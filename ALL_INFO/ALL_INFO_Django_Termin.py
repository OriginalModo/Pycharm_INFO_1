"""

 Самое Важное!!!
 Всегда ДУМАТЬ! перед тем, как что-либо сделать, необходимо всё тщательно обдумать

 Радоваться Жизни  Радоваться разным мелочам

 Ценить:         Ценить то что есть и стремиться к лучшему, Ценить сегодняшний день и брать МАКСИМУМ
 Быть проще:     Ко всему относиться Проще и Спокойнее без Волнения
 Слушать Других: Прислушиваться к мнению других людей они могут быть правы  И делать выводы
 Время:          Тайм-менеджмент   Грамотное распределение времени, Контроль Времени, Правильно раставлять Приоритеты
 Уверенность:    Быть уверенным в себе НО Оценивать свои силы!
 Развития:       Развиваться, Учиться, учиться и ещё раз - учиться, Саморазвитие
 Не Надеяться:   Надеяться только на себя
 Контроль:       Быть менее Эмоциональным, Совладать с Эмоциями, Контролировать свои эмоции в любой ситуации
 Внимательность: Быть Внимательным
 Спокойствие:    Быть Спокойнее, Перестать Нервничать , Быть Расслабленным, Не Злиться на себя и на других
 Режим:          Правильный Сон, Пить Воду
 Зарядка:        Бег, Тренировки, Стойка на Голове
 Тельце в тепле: НЕ переохлаждаться

 Молчание золото:  Лучше промолчать, чем сказать и потом жалеть о том, что сказал
 Соломон:          Все пройдёт, и это тоже пройдёт
 Вообще это замечательный подход: осознать, что проблема не такая уж и проблема, и вполне решаема.
 Кто ищет-тот всегда найдет!
 Искать Другие способы
 Не спеши, а то успеешь...   Успеешь, но не туда куда хотел...
 Подумай, нужно ли тебе ЭТО и для Чего
 Надо принимать вещи такими, как они есть, и пользоваться ими с наибольшей для себя выгодой.
 Если научиться принимать вещи как они есть, страдание исчезнет.
________________________________________________________________________________________________________________________

 -- raw запросы --
 people = Person.objects.raw("SELECT id, name FROM hello_person")

 Пример raw запроса:

 class Person(models.Model):
     first_name = models.CharField(...)
     last_name = models.CharField(...)
     birth_date = models.DateField(...)
 You could then execute custom SQL like so:

 for p in Person.objects.raw("SELECT * FROM myapp_person"):
     print(p)

 # John Smith
 # Jane Jones

 # Сопоставление полей запроса с полями модели
 name_map = {"first": "first_name", "last": "last_name", "bd": "birth_date", "pk": "id"}
 Person.objects.raw("SELECT * FROM some_other_table", translations=name_map)


 Django использует метаклассы для создания моделей базы данных

 Django во многом работает через метаклассы.
 Поэтому когда Django конструирует ваш класс, она делает это с помощью своего метакласса.
 Чтобы при конструировании ей знать какие-то параметры вашего класса, ну, например модель или поля в вашем случае,
 она ищет в вашем классе класс с названием Meta.

 папка migrations: предназначена для хранения миграций - скриптов,
 которые позволяют синхронизировать структуру базы данных с определением моделей


 # **Прямое выполнение миграций через код**
 Если вам нужно выполнить миграции программно, вы можете использовать следующий код в Python

 from django.core.management import call_command

 call_command('migrate', 'app_name')  #  Замените `'app_name'` на имя вашего приложения

 Имейте в виду, что `migrate` остается основным способом применения миграций и рекомендуется использовать его для
 адекватного управления базой данных.

 - Создайте каталог `management/commands` внутри приложения, если его еще нет.
 - Создайте файл, например, `run_migrations.py`:

 python
      # myapp/management/commands/run_migrations.py

      from django.core.management import BaseCommand, call_command

      class Command(BaseCommand):
          help = 'Выполнить миграции для приложения'

          def handle(self, *args, **kwargs):
              call_command('migrate', 'app_name')  # Замените 'app_name' на имя вашего приложения

  Запускайте команду в терминале:
  python manage.py run_migrations

 Не забывайте, что выполнять миграции программно — это менее распространенная практика, и делайте это осознанно,
 чтобы избежать непредвиденных проблем с базой данных.


 -- Создание миграции вручную --

 Чтобы создать миграции вручную через файл миграции `initial` в Django, выполните следующие шаги:

 1. **Создайте файл миграции вручную**:
 - В каталоге вашей модели приложения создайте директорию `migrations`, если она еще не существует.
 - Создайте файл миграции, назовите его, например, `0001_initial.py`.

 2. **Напишите код миграции**:
 - Откройте созданный файл и добавьте следующий код:


    from django.db import migrations, models

    class Migration(migrations.Migration):

        initial = True

        operations = [
            migrations.CreateModel(
                name='YourModelName',
                fields=[
                    ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                    ('field_name', models.CharField(max_length=100)),
                    # добавьте другие поля вашего модели
                ],
            ),
        ]

 - Замените `YourModelName` на название вашей модели и добавьте нужные поля.

 3. **Примените миграцию**:
 - Запустите команду, чтобы применить миграцию:

 bash
    python manage.py migrate

 Это создаст соответствующую таблицу в базе данных на основе вашей модели.

 ### Примечания:
 - Убедитесь, что вы правильно указали все поля и их типы в файле миграции.
 - Файл миграций должен иметь уникальный номер (например, `0001`, `0002` и т.д.) для правильного управления миграциями.


  -- Таблицы при ПЕРВОЙ МИРГРАЦИЯ --

 При первой миграции в Django создаются несколько таблиц по умолчанию, в зависимости от установленных приложений.
 Если вы используете стандартные приложения, такие как auth, contenttypes, sessions и admin, то будут созданы следующие таблицы:

 auth_user: Таблица для хранения пользователей, содержащая поля, такие как id, username, password, email, first_name,
 last_name, is_active, is_staff, is_superuser, last_login, date_joined.

 auth_group: Таблица для хранения групп пользователей, которая позволяет объединять пользователей в группы с определенными правами.

 auth_permission: Таблица для хранения прав доступа, которые могут быть назначены пользователям и группам.

 django_content_type: Таблица, которая хранит информацию о всех моделях, зарегистрированных в приложении, и используется
                      для реализации системы прав доступа.

 django_session: Таблица для хранения сессий пользователей, которая позволяет отслеживать состояние пользователей между запросами.

 django_migrations: Таблица, которая хранит информацию о примененных миграциях, что позволяет Django отслеживать,
                    какие миграции были выполнены.

 admin_log: Таблица для хранения логов действий в административной панели.

 Эти таблицы создаются автоматически при выполнении команды python manage.py migrate после создания проекта и настройки приложений.
 Если вы добавляете свои собственные модели, то для каждой из них также будет создана соответствующая таблица в базе данных.



 __init__.py: указывает интерпретатору python, что текущий каталог будет рассматриваться в качестве пакета

 admin.py: предназначен для административных функций, в частности, здесь производится регистрация моделей,
  которые используются в интерфейсе администратора

 apps.py: определяет конфигурацию приложения

 models.py: хранит определение моделей, которые описывают используемые в приложении данные

 tests.py: хранит тесты приложения

 views.py: определяет функции, Классы которые получают запросы пользователей, обрабатывают их и возвращают ответ
  manage.py

  manage.py используется для создания приложений, работы с базами данных и для запуска отладочного сервера


  # Или добавляем в начало python в командной строке:  python manage.py

  Чтобы выбрать без python manage.py Идем в Edit Configurations...  Parameters и прописываем   manage.py

  Все команды:    python manage.py --help    или просто  python manage.py
                  django-admin --help        или просто  django-admin

  python manage.py collectstatic -   Проверка статики
  python manage.py makemigrations - Проверка миграции
  python manage.py migrate - Применить миграции
  django-admin startproject - Создание проекта
  python manage.py startapp - Создание приложения               django-admin startapp menu  - так тоже можно
  python manage.py runserver - Запуск сервера для разработки
  python manage.py createsuperuser - Создать аккаунт администратора

  python manage.py test название_приложения  - Запускать тесты


  WSGI - стандартизированный способ передачи запросов
  ASGI - асинхронный интерфейс серверного шлюза

  asgi.py - нужен для Асинхронных веб-серверов и приложений
  ASGI является духовным наследником WSGI, давнего стандарта Python для совместимости между веб-серверами, фреймворками и приложениями.

  wsgi.py - нужен для синхронных веб-серверов и приложений

  WSGI удалось предоставить гораздо больше свободы и инноваций в веб-пространстве Python,
  и цель ASGI - продолжить эту работу асинхронным Python.

  wsgi.py, который будет отвечать за обработку веб-сервером запросов к Django

  urls.py - главный файл для наших URL проектов куда мы подключаем URL наших приложений
  path('password-change/done/', PasswordChangeDoneView.as_view(template_name='users/password_change_done.html'), name='password_change_done'),
  name - имя маршрута, для использования в html

 --- settings.py ---
  settings.py - файл со всеми настройками проекта

  BASE_DIR - построение пути к корню нашего проекта

  DEBUG - включает отключает режим отладки проекта
  DEBUG = True - Django будет отображать подробные страницы с ошибками при выбрасывании исключений приложений
  DEBUG = False - Если разворачиваем на боевом сервере устанавливаем настройку False
  никогда не публикуем проект с DEBUG = True, так как пользователю станут доступны секретные данные конфигурации приложения

  ALLOWED_HOSTS = [] - не используется при включенной отладке и запуске тестов но как только мы развернем приложение
  и установим DEBUG = False необходимо добавить домен сайта в эту настройку для того чтобы Django мог с ним работать

  INSTALLED_APPS = [] - настройка которая указывает Django какие приложения активны в нашем проекте
  по умолчанию Django подключает следующие приложения:

  INSTALLED_APPS = [
    'django.contrib.admin',         - Администрирование
    'django.contrib.auth',          - Подсистема  аутификации
    'django.contrib.contenttypes',  - Подсистема  для работы с типами обьектов
    'django.contrib.sessions',      - Подсистема  сессий
    'django.contrib.messages',      - Подсистема  сообщений
    'django.contrib.staticfiles',   - Подсистема  для управления статическим содержимым сайта
 --- End settings.py ---

 MIDDLEWARE = [] - список подлюченных промежуточных слоёв
 MIDDLEWARE - это промежуточный слой между запросом и ответом в Django
 Django Middleware - это механизм обработки запросов и ответов в Django
 Каждый компонент промежуточного программного обеспечения(СЛОЯ) отвечает за выполнение определенной функции
 Middleware может поддерживать любую комбинацию синхронных и асинхронных запросов
 Основные MIDDLEWARE:
 SessionMiddleware – поддержка сессий. Добавляет в запрос объект session
 CsrfViewMiddleware – проверяет, что POST-запросы отправлены с текущего домена
 AuthenticationMiddleware – авторизует пользователя. Добавляет в запрос поле user
 MessageMiddleware – передает пользователю короткие сообщения

 ROOT_URLCONF - указывает на Python модуль который содержит корневые шаблоны urls.py

 DATABASES - словарь содержащий настройки для всех баз данных проекта

 LANGUAGE_CODE = 'ru-ru' - Определяет код языка для Django сайта

 USE_TZ = True - указывает Django необходимость поддержки временных зон

 select_related(key) - 'ЖАДНАЯ' загрузка связанных данных по внешнему ключу key, который имеет тип ForeignKey, OneToOneField
 уменьшение количество запросов к базе данных

 'ЖАДНАЯ' загрузка - загрузка сразу всех данных
 'ЛЕНИВАЯ' загрузка - происходит в момент обращения к тому или иному атрибуту

 prefetch_related(key) - 'ЖАДНАЯ' загрузка связанных данных по внешнему ключу key, который имеет тип ManyToManyField
 уменьшение количество запросов к базе данных


  -- Транзакции/transaction в django --

 Поведение транзакции по умолчанию в Django

 По умолчанию Django работает в режиме автоматической фиксации. Каждый запрос немедленно фиксируется в базе данных,
  если транзакция не активна.

 Django автоматически использует транзакции или точки сохранения, чтобы гарантировать целостность операций ORM,
  которые требуют нескольких запросов, особенно запросов delete () и update () .

 TestCase Класс Django также включает каждый тест в транзакцию из соображений производительности.


 -- Привязка транзакций к HTTP-запросам --

 Распространенный способ обработки транзакций в Интернете - заключить каждый запрос в транзакцию. Установите
  ATOMIC_REQUESTS значение True в конфигурации каждой базы данных, для которой вы хотите включить это поведение.

 Это работает вот так. Перед вызовом функции просмотра Django запускает транзакцию. Если ответ получен без проблем,
 Django фиксирует транзакцию. Если представление вызывает исключение, Django откатывает транзакцию.

 Вы можете выполнять частичные транзакции, используя точки сохранения в коде представления, обычно с помощью atomic()
 диспетчера контекста. Однако в конце просмотра все изменения или ни одно из них не будут зафиксированы.

 Когда ATOMIC_REQUESTS он включен, по-прежнему можно запретить выполнение представлений в транзакции.

 non_atomic_requests(using=None)
 Этот декоратор нейтрализует эффект ATOMIC_REQUESTS для данного вида:

 from django.db import transaction

 @transaction.non_atomic_requests
 def my_view(request):
     do_stuff()

 @transaction.non_atomic_requests(using='other')
 def my_other_view(request):
     do_stuff_on_the_other_database()

 Он работает только в том случае, если он применяется к самому представлению.


 -- Явное управление транзакциями --

 atomic(using=None, savepoint=True, durable=False)

 Атомарность - определяющее свойство транзакций базы данных. atomic позволяет нам создать блок кода, в котором
 гарантируется атомарность базы данных. Если блок кода успешно завершен, изменения фиксируются в базе данных.
 Если есть исключение, изменения отменяются.

 atomic блоки могут быть вложенными. В этом случае, когда внутренний блок завершается успешно, его эффекты все еще могут
 быть отменены, если во внешнем блоке позже возникнет исключение.

 Иногда полезно убедиться, что atomic блок всегда является самым внешним atomic блоком, гарантируя, что любые изменения
 базы данных будут зафиксированы при выходе из блока без ошибок. Это называется долговечностью и достигается за счет
 схватывания durable=True. Если atomic блок вложен в другой, возникает ошибка RuntimeError.


 atomic можно использовать как декоратор :

 from django.db import transaction

 @transaction.atomic
 def viewfunc(request):
     # This code executes inside a transaction.
     do_stuff()

 и как менеджер контекста :

 from django.db import transaction

 def viewfunc(request):
     # This code executes in autocommit mode (Django's default).
     do_stuff()

     with transaction.atomic():
         # This code executes inside a transaction.
         do_more_stuff()

 Заключение atomic в блок try / except позволяет естественным образом обрабатывать ошибки целостности:

 from django.db import IntegrityError, transaction

 @transaction.atomic
 def viewfunc(request):
     create_parent()

     try:
         with transaction.atomic():
             generate_relationships()
     except IntegrityError:
         handle_exception()

     add_children()


 -- Автокоммит --

 Почему Django использует автокоммит?

 В стандартах SQL каждый запрос SQL запускает транзакцию, если она еще не активна. Затем такие транзакции должны быть
 явно зафиксированы или отменены.

 Это не всегда удобно для разработчиков приложений. Чтобы решить эту проблему, в большинстве баз данных предусмотрен
 режим автоматической фиксации. Когда автоматическая фиксация включена и транзакция не активна, каждый запрос SQL
 помещается в свою собственную транзакцию. Другими словами, каждый такой запрос не только запускает транзакцию,
 но транзакция также автоматически фиксируется или откатывается, в зависимости от того, был ли запрос успешным.

 PEP 249 , спецификация API базы данных Python v2.0, требует, чтобы функция автоматической фиксации была изначально
 отключена. Django отменяет это значение по умолчанию и включает автоматическую фиксацию.

 Чтобы этого избежать, вы можете отключить управление транзакциями , но это НЕ рекомендуется.    <-----

 Django предоставляет API в django.db.transaction модуле для управления состоянием автоматической фиксации каждого
 соединения с базой данных.

 get_autocommit(using=None)
 set_autocommit(autocommit, using=None)
 Эти функции принимают using аргумент, который должен быть именем базы данных. Если он не указан, Django использует
 "default" базу данных.

 Автокоммит изначально включен. Если вы выключите его, вы обязаны восстановить его.

 Вы должны убедиться, что ни одна транзакция не активна, обычно с помощью символа a commit() или a rollback(),
 прежде чем снова включить автоматическую фиксацию.

 Django откажется выключать автоматическую фиксацию, когда atomic() блок активен, потому что это нарушит атомарность.


 -- Отключение управления транзакциями --
 Вы можете управление транзакциями полностью отключить Джанго для данной базы данных, установив AUTOCOMMIT для False
 в его конфигурации. Если вы это сделаете, Django не включит автокоммит и не будет выполнять никаких коммитов.
 Вы получите обычное поведение базовой библиотеки базы данных.


 -- Выполнение действий после коммита --

 Иногда вам нужно выполнить действие, связанное с текущей транзакцией базы данных, но только в том случае, если транзакция
 успешно зафиксирована. Примеры могут включать задачу Celery , уведомление по электронной почте или аннулирование кеша.

 Django предоставляет on_commit() функцию для регистрации функций обратного вызова, которые должны выполняться после
 успешной фиксации транзакции:

 on_commit(func, using=None, robust=False)
 Передайте любую функцию (не принимающую аргументов) в on_commit():

 from django.db import transaction

 def do_something():
     pass  # send a mail, invalidate a cache, fire off a Celery task, etc.

 transaction.on_commit(do_something)
 Вы также можете заключить свою функцию в лямбду:

 transaction.on_commit(lambda: some_celery_task.delay('arg1'))

 Обратным вызовам не будут переданы никакие аргументы, но вы можете связать их с помощью functools.partial():

 from functools import partial

 for user in users:
     transaction.on_commit(partial(send_invite_email, user=user))


 -- Транзакции --
 Транзакция - это атомарный набор запросов к базе данных. Даже если ваша программа выйдет из строя, база данных
 гарантирует, что будут применены либо все изменения, либо ни одно из них.

 Django не предоставляет API для запуска транзакции. Ожидаемый способ начать транзакцию - отключить автоматическую
 фиксацию с помощью set_autocommit().

 После того, как вы участвуете в транзакции, вы можете либо применить изменения, которые вы выполняли до этого момента
 commit(), либо отменить их с помощью rollback(). Эти функции определены в django.db.transaction.

 commit(using=None)
 rollback(using=None)

 Эти функции принимают using аргумент, который должен быть именем базы данных. Если он не указан, Django использует
 "default" базу данных.

 Django откажется выполнять фиксацию или откат, когда atomic() блок активен, потому что это нарушит атомарность.


 -- Точки сохранения --

 Точка сохранения - это маркер внутри транзакции, который позволяет вам откатить часть транзакции, а не полную транзакцию.

 Точки сохранения управляются тремя функциями в django.db.transaction:

 savepoint(using=None)
 Создает новую точку сохранения. Это отмечает точку транзакции, которая, как известно, находится в «хорошем» состоянии.
 Возвращает идентификатор точки сохранения ( sid).

 savepoint_commit(sid, using=None)
 Освобождает точку сохранения sid. Изменения, внесенные с момента создания точки сохранения, становятся частью транзакции.

 savepoint_rollback(sid, using=None)
 Откатывает транзакцию до точки сохранения sid.

 Эти функции ничего не делают, если точки сохранения не поддерживаются или если база данных находится в режиме автоматической фиксации.


 Кроме того, есть служебная функция:

 clean_savepoints(using=None)
 Сбрасывает счетчик, используемый для генерации уникальных идентификаторов точек сохранения.

 -- END Транзакции/transaction в django --


 request - обьект запроса
 response - ответ
 redirect - перенаправление

 URL обозначает Uniform Resource Locator. URL это лишь адрес, который выдан уникальному ресурсу в интернете.
  В теории, каждый корректный URL ведёт на уникальный ресурс

 Каждый URL может быть напечатан напрямую в адресной строке браузера, чтобы сразу получить запрошенный ресурс

 если с Формы нужно передать ФАЙЛЫ нужно указать атрибут - enctype="multipart/form-data"

 Slug — это короткая метка, которая содержит только буквы, цифры, подчеркивания или дефисы. Обычно они используются в URL.

 --- Slug ---
 prepopulated_fields = {'slug': ('title',)} # Автозаполнение полей прописывается в Admin.py

 CSRF токен — это случайное значение, генерируемое веб-приложением и связываемое с текущей сессией пользователя
 CSRF токен - нужен для защиты межсайтовых атак
 Django требует CSRF токен при всех POST - запросах

 CSRF-токен помогает удостовериться, что запрос исходит от законного пользователя.
 CSRF-токен (Cross-Site Request Forgery) используется для защиты веб-приложений от атак

 Django Debug Toolbar - Помогает оптимизировать проект

 Виртуальное окружение(venv) (virtual environment) - позволяет создавать изолированные среды для каждого проекта,
 в которых можно устанавливать и управлять зависимостями и пакетами, не вмешиваясь в другие проекты или системные установки Python.

 Активировать venv  (Виртуальное окружение)        .\venv\Scripts\activate
 ДЕ-Активировать venv  (Виртуальное окружение)     .\venv\Scripts\deactivate
 Чтобы деактивировать активное виртуальное окружение, просто введите команду deactivate в командной строке.   <-----


 Postman – это программа, которая предоставляет вам все необходимые инструменты для тестирования API:
 возможность посылать запросы, писать документацию к API, запускать автотесты, составлять иерархию тестов,
 проводить версионирование и так далее.

 OpenAPI - это спецификация для описания API.

 Swagger использует спецификацию OpenAPI для описания и документирования API, а инструменты Swagger позволяют
 использовать эту спецификацию для создания и тестирования API, а также для генерации клиентского кода.

 Swagger простыми словами — инструмент для подготовки документации к API и проведения тестов API(Публичный интерфейс).

 Swagger - Использует CURL  <-----                                                                           <-----

 ОСНОВНОЕ ОТЛИЧИЕ между Swagger и Postman заключается в том, что Swagger сконцентрирован на проектировании
 и документировании API, в то время как Postman — на тестировании и создании запросов.


 Чем отличаются HTTP и HTTPS?
 HTTP — прикладной протокол передачи данный, используемый для получения информации с веб-сайтов.
 HTTPS — расширение протокола HTTP, поддерживающее шифрование по протоколам SSL и TLS.


 --- HTTP ---
 HTTP сообщения - это обмен данными между сервером и клиентом
 Http запрос, Http ответ между Клиентом и Сервером

 Полный цикл HTTP-запроса включает следующие шаги:

 1. Клиент (обычно браузер) формирует HTTP-запрос.
 2. Запрос отправляется на сервер через Интернет.
 3. Сервер принимает запрос и обрабатывает его, выполняя необходимые операции (например, извлечение данных из базы).
 4. Сервер формирует ответ в формате HTTP, включая статус (успешно, ошибка и т.д.) и, при необходимости, данные
   (например, HTML-страницу).
 5. Ответ отправляется обратно клиенту по тому же соединению.
 6. Клиент получает ответ и обрабатывает его (например, отображает страницу).

 Этот цикл обеспечивает взаимодействие между клиентом и сервером для передачи данных в веб-приложениях.


 СТАТУСЫ HTTP запросов:

 100-199: ИНФОРМАЦИОННЫЕ ответы.
 200-299: УСПЕШНАЯ обработка запроса.
 300-399: ПЕРЕНАПРАВЛЕНИЕ запроса.
 400-499: ОШИБКИ КЛИЕНТА.
 500-599: ОШИБКИ СЕРВЕРА.

 МЕТОДЫ HTTP запросов:

 Метод запроса является идемпотентным , если его можно успешно обработать несколько раз, не изменив результат.
 Метод запроса кэшируется , если соответствующий ответ может храниться для повторного использования.
 Метод запроса считается безопасным, если он не изменяет состояние ресурса

 Кэш — это память программы или устройства, которая сохраняет временные или часто используемые файлы для быстрого
 доступа к ним. Это увеличивает скорость работы приложений и операционной системы. Процесс сохранения таких файлов
 в специальном месте называется кэшированием.


 Файлы cookie — это небольшие текстовые файлы, которые веб-сайты сохраняют на вашем устройстве при посещении. Они нужны для:

 1. **Хранения пользовательских настроек** — запоминают предпочтения пользователя, такие как язык или настройки оформления.
 2. **Аутентификации** — помогают идентифицировать пользователей и сохранять сессии входа.
 3. **Аналитики** — собирают информацию о том, как пользователи взаимодействуют с сайтом, что помогает улучшить его.
 4. **Персонализации контента** — позволяют предлагать пользователям релевантные рекомендации и рекламу.

 В целом, файлы cookie делают веб-серфинг более удобным и персонализированным.


 БЕЗОПАСНЫЕ (GET, HEAD, OPTIONS) — не изменяют данные, их можно выполнять в любой последовательности
 Безопасные методы - это методы, которые не изменяют состояние в базе данных (read only методы).
 Примечательно, что все безопасные методы также являются идемпотентными. Безопасными методами являются: GET, HEAD и OPTIONS.

 Отличие идемпотентных методов от безопасных заключается в том, что безопасные методы не меняют состояние базы данных,
 в то время как идемпотентные методы могут внести изменения при первом запросе,
 но последующие идентичные запросы уже не будут менять состояние в базе данных.

 Несколько следующих методов HTTP безопасные: GET, HEAD или OPTIONS.
 Все безопасные методы являются также идемпотентными, как и некоторые другие, но при этом небезопасные, такие как PUT или DELETE.

 ИДЕМПОТЕНТНЫЕ (GET, HEAD, PUT, DELETE, OPTIONS, TRACE) — при повторном выполнении результаты будут ожидаемо ОДИНАКОВЫМИ
 Идемпотентные методы - это методы, которые либо не изменяют состояние в базе данных,
 либо изменяют состояние только при первом запросе. В случае повторной отправки идентичного запроса,
 состояние в базе данных не изменяется. Идемпотентными методами являются: GET, PUT, DELETE, HEAD и OPTIONS.

 Метод HTTP является идемпотентным, если повторный идентичный запрос, сделанный один или несколько раз подряд,
 имеет один и тот же эффект, не изменяющий состояние сервера. Другими словами, идемпотентный метод не должен иметь
 никаких побочных эффектов (side-effects), кроме сбора статистики или подобных операций.

 НЕИДЕМПОТЕНТНЫЕ (POST, PATCH) — при повторном выполнении результаты будут РАЗНЫМИ, если, например,
 отправить POST-запрос на создание элемента несколько раз подряд, то он может создать несколько элементов с одинаковыми данными

 Таким образом, ИДЕМПОТЕНТНЫЕ запросы приводят к одному и тому же состоянию системы НЕЗАВИСИМО от количества вызовов,
 а НЕИДЕМПОТЕНТНЫЕ могут изменять состояние при каждом вызове.

 GET – получить объект или список объектов
 POST – создать объект
 PUT – обновить существующий объект
 PATCH – частично обновить существующий объект
 DELETE – удалить объект
 HEAD – получить метаданные объекта

 Метаданные — это субканальная информация об используемых данных.     информация о другой информации
 Метаданные — информация о другой информации, или данные, относящиеся к дополнительной информации о содержимом или объекте.
 субканальная информация -  (данные о данных)
 Какие бывают метаданные:
 - Структурные:
 Они содержат информацию о том, как именно хранятся какие-либо данные. Структурные метаданные можно легко обнаружить,
 просто взглянув на тот или иной файл. Так, для телефонного разговора эти данные будут содержат
 длительность и время беседы; для цифровой фотографии ─ размер и формат файла.

 - Описательные:
 Описательные. Это разнообразная дополнительная информация, которая упрощает изучение содержимого книг и файлов.
 Если речь идёт о книге, то описательные метаданные сообщат нам её название, автора, издание, краткую аннотацию и номер ISBN.

 Примеры метаданных:  Email, Телефон, Социальные сети, Веб-страницы, Цифровые медиа-библиотеки - аккаунты.


  Пинг может влиять на скорость запроса   <-----


 Метод GET - используется для получения информации о ресурсе.
 Метод GET - запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные
 Метод HEAD - запрашивает ресурс так же, как и метод GET, но без тела ответа.
 Метод POST - предназначен для создания новых ресурсов и передачи данных
 Метод POST - используется для отправки сущностей к определённому ресурсу.
 Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.
 Метод PUT - обновляет ресурс полностью
 Метод PUT - заменяет все текущие представления ресурса данными запроса.
 Метод PATCH - вносит частичные изменения в существующем ресурсе
 Метод PATCH - используется для частичного изменения ресурса
 Метод DELETE - для удаления ресурса, который указывается с помощью его URI
 Метод CONNECT - устанавливает "туннель" к серверу, определённому по ресурсу
 Метод OPTIONS - используется для описания параметров соединения с ресурсом
 Метод TRACE - выполняет вызов возвращаемого тестового сообщения с ресурса
 Метод TRACE - выполняет проверку обратной связи по пути к целевому ресурсу, предоставляя полезный механизм отладки.

 Фреймворк Django реализует АРХИТЕКТУРНЫЙ паттерн Model-View-Template или сокращенно MVT,
 который по факту является модификацией распростаненного в веб-программировании паттерна MVC (Model-View-Controller).

 Model View Template(MVT) (MVT – модель, представление и шаблон) - АРХИТЕКТУРНЫЙ ПАТТЕРН

 Основные элементы паттерна:
 URL dispatcher: при получение запроса на основании запрошенного адреса URL определяет, какой ресурс должен обрабатывать данный запрос

 View: получает запрос, обрабатывает его и отправляет в ответ пользователю некоторый ответ.
 Если для обработки запроса необходимо обращение к модели и базе данных, то View взаимодействует с ними.
 Для создания ответа может применять Template или шаблоны. В архитектуре MVC этому компоненту соответствуют контроллеры (но не представления).

 Model: описывает данные, используемые в приложении. Отдельные классы, как правило, соответствуют таблицам в базе данных.

 Template: представляет логику представления в виде сгенерированной разметки html.
 В MVC этому компоненту соответствует View, то есть представления.

 QuerySet, по сути, — список объектов заданной модели. QuerySet позволяет читать данные из базы данных,
 фильтровать и изменять их порядок

 ORM Django позволяет разработчикам взаимодействовать с базами данных с помощью кода Python


 Что такое ОРМ?
 Прежде всего, давайте заложим основу. Объектно-реляционные отображения (ORM) — это уровень абстракции,
 который позволяет разработчикам взаимодействовать с базами данных с помощью объектов Python вместо написания сырых SQL-запросов

  -- SQLAlchemy vs Django ORM --
 Django ORM обладает теми же свойствами: более-менее типичные запросы на ней можно сделать очень легко.
 А вот со сложными запросами Django ORM не справится.

 SQLAlchemy наоборот: позволяет создавать очень сложные запросы, но в среднем формирование запроса будет сложнее.


 необходимо Django ORM, если:
 Вы создаете новое веб-приложение с помощью Django.
 Вы отдаете предпочтение быстрой разработке и читаемости кода.
 У вас нет требований к базе данных.

 понадобится SQLAlchemy, если:
 Вам нужна максимальная гибкость для сложного взаимодействия с базами данных.
 Вы работаете со схемой базы данных.
 Вам требуется детальная оптимизация производительности.
 Вы используете веб-фреймворк, отличный от Django, или создаете отдельный проект.

 -- END SQLAlchemy vs Django ORM --


 ORM (Object-Relation Mapping) – общее название для фреймворков или библиотек,
 позволяющих автоматически связать базу данных с кодом

 Запросы в Django ORM ЛЕНИВЫЕ и они не отправляются до тех пор,
 пока их не запустят (в англоязычных текстах это называют evaluate)

  В Django ORM запросы по умолчанию ЛЕНИВЫЕ. Это означает, что они не выполняются до тех пор, пока не потребуется
 получение данных. Чтобы применить запрос и получить данные, вы можете использовать следующие методы:

 **Конвертация в другие структуры данных**:
 **`list()`**: Преобразует `QuerySet` в список и выполняет запрос.   ** list() или tuple() или dict() или другие **:
 results = list(MyModel.objects.all())


 **Использование `next()` или `list()`**: Если вам нужно только одно значение, вы можете использовать `next()`:
 queryset = MyModel.objects.all()
 first_item = next(iter(queryset))  # Возвращает первый элемент, выполняя запрос


 **`len()`**: Получает количество объектов в `QuerySet` и выполняет запрос.
 count = len(MyModel.objects.all())


 **`for` циклы**: Итерирование по `QuerySet` также выполняет запрос.
 for obj in MyModel.objects.all():
        print(obj)


 **`get()`**: Получает единственный объект и выполняет запрос.
 obj = MyModel.objects.get(id=1)


 **Методы `get()` и `filter()`**:
- Вызов `get()` возвращает конкретный объект, тогда как `filter()` возвращает QuerySet, который будет выполнен позже.

 single_object = MyModel.objects.get(id=1)                  # Выполняет SQL-запрос
 filtered_objects = MyModel.objects.filter(name='example')  # Запрос выполняется при дальнейшей обработке


 **`first()` и `last()`**: Получает первый или последний объект и выполняет запрос.
 first_obj = MyModel.objects.first()
 last_obj = MyModel.objects.last()


 **`exists()`**: Проверяет наличие объектов и выполняет запрос.
 exists = MyModel.objects.filter(condition).exists()


 **`count()`**: Возвращает количество объектов в `QuerySet` и выполняет запрос.
 count = MyModel.objects.all().count()


 **`aggregate()` и `annotate()`**: Эти методы возвращают агрегированные данные и также выполняют запрос.
 from django.db.models import Count

 result = MyModel.objects.aggregate(Count('field_name'))

# Подсчитываем общее количество объектов модели MyModel
 result = MyModel.objects.aggregate(total_count=Count('field_name'))

 print(result)  # Вывод: {'total_count': 42} (пример результата)


 from django.db.models import Count
 from myapp.models import MyModel, RelatedModel

 Получаем все объекты MyModel с подсчитанным количеством связанных объектов из RelatedModel
 result = MyModel.objects.annotate(related_count=Count('relatedmodel'))

 for obj in result:
     print(f'{obj.pk}: {obj.related_count}')  # Выводит идентификатор объекта и количество связанных объектов

 # Получаем общее количество объектов модели и аннотируем каждую запись с суммой значений определенного поля
 result_aggregate = MyModel.objects.aggregate(total_count=Count('id'), total_sum=Sum('field_name'))
 result_annotate = MyModel.objects.annotate(field_name_sum=Sum('field_name'))

 print(result_aggregate)  # Выводит агрегированные результаты, например: {'total_count': 42, 'total_sum': 1000}
 for obj in result_annotate:
     print(f'{obj.pk}: {obj.field_name_sum}')

 - `aggregate()` возвращает итоговые значения по всему набору данных,
 - `annotate()` добавляет агрегированные значения к каждому объекту в queryset.


 **`values()` и `values_list()`**: Эти методы возвращают список словарей или кортежей соответственно, выполняя запрос.
 queryset = MyModel.objects.values('id', 'name')           # Выполняет запрос и возвращает словари с указанными полями
 queryset = MyModel.objects.values_list('id', 'name')      # Возвращает список кортежей
 queryset = MyModel.objects.values_list('name', flat=True) # результаты в виде списков   flat=True


 **Срезы [ ]**: Использование срезов для получения определенного количества объектов.
 first_five = queryset[:5]  # Выполняет запрос и возвращает первые пять объектов

 Использование одного из этих методов заставит Django выполнить запрос к базе данных и вернуть результаты.


 CRUD - Create(создание), Read(чтение), Update(обновление), Delete(удаление)


 __Class__ = имя класса в модели
 __Class__.objects.all()
 __Class__.objects.create(title='')
 __Class__.objects.filter(title='Best')
 __Class__.objects.filter(pk__gte=2) # __gt, __lt, __lte, __contains   <--- Lookup
 __Class__.objects.get(id=1) # получить строго одну запись
 __Class__.objects.order_by("blog__name") # сортировка по выбранному полю
 __Class__.objects.order_by("-blog__name") # обратная сортировка
 __Class__.objects.order_by("blog__name").desc()) # обратная сортировка
 __Class__.objects.filter(pk__lte=4).update('') # update - применяется к QuerySet, не работает с одной записью
 __Class__.objects.filter(cat_id=1).count() # количество записей
 __Class__.objects.get(pk=3).posts.exists() # существуют записи или нет # posts = 'название модели'_set



 ORM-команды ForeignKey   many-to-one
 RelatedManager
 <вторичная модель>_set.all() # получить всё связанное с категорией
 __Class__.women_set.all()
 cat = models.ForeignKey('Category', on_delete=models.CASCADE, related_name='posts') # related_name
 __Class__.posts.all() # related_name='posts'
 __Class__.objects.filter(cat__slug='aktrisy') # cat = models.ForeignKey(Category, on_delete=models.PROTECT)


 Фреймворк Djnago имеет три специальных класса для организации связей:

 ForeignKey – для связей Many to One (Один ко многим) (поля отношений)
 ManyToManyField – для связей Many to Many (Многие ко многим)
 OneToOneField – для связей One to One (Один к одному)

 # Если модель в кавычках 'имя_модели' то её можно опеределять даже выше (python найдет её)
 cat = models.ForeignKey('Category', on_delete=models.PROTECT) # функция(PROTECT) не удаляет все связанные записи с Category
 cat = models.ForeignKey('Category', on_delete=models.CASCADE) # функция(CASCADE) удаляет все связанные записи с Category

 ManyToManyField - связь с помощью промежуточной таблицы
 tag = models.ManyToManyField('TagPost', blank=True, related_name='tags')

 OneToOneField - один к одному
 husband = models.OneToOneField('Husband', on_delete=models.SET_NULL,
                                   null=True, blank=True, related_name='wuman')

 django-taggit - уже реализованный функционал,  можно без труда добавлять теги к моделям. Вывод тегов в шаблон

 QuerySet: QuerySet Method reference # Documentation

 Class Q   -  and, or, not
 Q() objects
 Приоритеты:
 1) самый низкий OR:  |
 2) средний AND: &
 3) самый высокий NOT: ~

 from django.db.models import Q
 Women.objects.filter(Q(pk__lt=5) | Q(cat_id=2)) # | == OR  # |  = Вертикальная черта
 Women.objects.filter(Q(pk__lt=5) & Q(cat_id=2)) # & == AND # & = Амперсанд
 Women.objects.filter(~Q(pk__lt=5) & Q(cat_id=2)) # ~ == NOT # ~ = Тильда
 Women.objects.filter(~Q(pk__in=[1,2,5]) | Q(cat_id=2), title__icontains='pa')


 Women.objects.order_by('pk') # сортировка
 Women.objects.order_by('-pk') # обратная сортировка

 Class F
 from django.db.models import F
 Women.objects.filter(pk__gt=F('cat_id'))
 Объект F() представляет значение поля модели, преобразованное значение поля модели или аннотированный столбец.
 Он позволяет ссылаться на значения полей модели и выполнять операции с базой данных, используя их без необходимости
 извлекать их из базы данных в память Python

 Class Value
 from django.db.models import Value
 Объект Value() представляет наименьший возможный компонент выражения: простое значение. Когда вам нужно представить
 значение целого числа, булевой или строки в выражении, вы можете обернуть это значение в объект Value()

 Процесс, при котором к каждому объекту из выборки применяется агрегирующая функция, назвается аннотированием.


 -- Агрегация и агрегирующие функции --

 Для того чтобы получить уже агрегированные данные, нужно воспользоваться методом .aggregate(), вызвав его у имеющегося
 менеджера или QuerySet. Этот метод принимает в качестве параметров так называемые агрегирующие функции. Функций этих
 достаточно много, но все они используются примерно одинаково, поэтому рассмотрим для примера функцию Avg:

 from django.db.models import Avg

 # Получение средней цены среди всех книг магазина
 Book.objects.aggregate(Avg('price'))
 # {'price__avg': 34.35}

 # Можно задать имя ключа результирующего словаря явно
 Book.objects.aggregate(average_price=Avg('price'))
 # {'average_price': 34.35}

 Если аргументы указываются как позиционные, то имена для ключей генерирует Django ORM на основе имени поля и имени
 агрегирующей функции. Аргументов можно указать сразу несколько и генерируемые имена не дадут запутаться:

 from django.db.models import Avg, Max, Min

 Book.objects.aggregate(Avg('price'), Max('price'), Min('price'))
 # {'price__avg': 34.35, 'price__max': Decimal('81.20'), 'price__min': Decimal('12.99')}

 Как можно заметить, каждый запрос на агрегацию возвращает не сами книги, а только итоговый результат. Таким образом со
 стороны Python никаких промежуточных объектов создавать не приходится!

 Вернёмся к учебному проекту, который моделирует платформу для ведения блогов. Никаких "цен" в этом проекте нет,
 но задачи для анализа найдутся. Предположим, что нужно для каждой записи в блоге некоторого автора узнать количество
 комментариев. Агрегация на первый взгляд не подходит: сами посты тоже нужны. Можно решить задачу "в лоб", написав:

 author = User.objects.get(id=1)
 posts = [(p, p.postcomment_set.count()) for p in author.post_set.all()]

 Такое решение имеет своё собственное название – "N+1 запросов" – поскольку будет выполнен один запрос N постов,
 а затем N запросов комментариев к каждому. Легко представить, насколько это неэффективно.

 Для того чтобы для каждой возвращаемой сущности вычислить некоторое значение в рамках одного запроса, Django ORM
 предоставляет механизм аннотирования.


 Процесс, при котором к каждому объекту из выборки применяется агрегирующая функция, назвается аннотированием.


  -- Аннотирование и дубликаты в выдаче --

 Например, .aggregate(Count('postcomment')) подсчитает количество всех комментариев, а .annotate(Count('postcomment'))
 даст количество комментариев к каждому посту. Так выглядит подсчёт количества тегов, которыми помечен каждый пост:

 posts = Post.objects.annotate(Count('tags'))
 posts[0].tags__count  # только тут финализируется запрос!
 # SELECT "blog_post"."id",
 #        ...
 #        COUNT("blog_post_tags"."tag_id") AS "tags__count"
 #   FROM "blog_post"
 #   LEFT OUTER JOIN "blog_post_tags"
 #     ON ("blog_post"."id" = "blog_post_tags"."post_id")
 #  GROUP BY ...
 #  LIMIT 1

 # Execution time: 0.000563s [Database: default]

 # => 2

 Здесь новый атрибут получил имя "tags__count", но имя можно было указать вручную, как и в случае обычной агрегации.


 Если вы уже имеете некоторый опыт в SQL, вы можете задаться вопросом: а не добавляет ли OUTER JOIN, который можно
 заметить в примере выше, в выборку дублирующиеся элементы, если присовокупляемые сущности соотносятся с текущей как
 "многие к одному"? Добавляет! Более того, агрегация в таких случаях даёт неверные результаты, так как учитывает и
 повторяющиеся строки. И тем больше дублей вы увидите, чем больше разных связей "многие к одному" задействуете
 (и даже одну и ту же, но несколько раз).

 Увы, в общем виде эту проблему не решить. Но конкретно агрегирующая функция Count имеет опцию distinct=True,
 которая убирает дублирование, пока вы используете только этот вид аннотаций и каждый Count используете с distinct=True.


 -- Агрегация аннотированных значений --
 Аннотирование позволяет добавить вычислимые данные к каждому элементу запроса, а это значит, что можно выполнить
 итоговую агрегацию с использованием этих значений! Получение среднего количества тегов среди всех постов будет выглядеть так:

 Post.objects.annotate(Count('tags')).aggregate(Avg('tags__count'))
 # SELECT AVG("tags__count")
 #   FROM (
 #         SELECT COUNT("blog_post_tags"."tag_id") AS "tags__count"
 #           FROM "blog_post"
 #           LEFT OUTER JOIN "blog_post_tags"
 #             ON ("blog_post"."id" = "blog_post_tags"."post_id")
 #          GROUP BY "blog_post"."id"
 #        ) subquery

 # Execution time: 0.000361s [Database: default]

 # => {'tags__count__avg': 1.5}


 Функция annotate() в Django — это мощный инструмент, который позволяет разработчикам добавлять дополнительные данные
 в свои наборы запросов, не прибегая к использованию чистого SQL


 annotate() - метод позволяет создавать новые вычисляемые поля для нашей выборки
 lst = Husband.objects.all().annotate(is_married=Value(True))

 annotate() - Позволяет Создавать дополнительное поле в Запросе к примеру в SQL. Новые поля на основе Имеющихся.
 Нужно использовать класс F            Пример выше.    annotate() - Позволяет Создавать Новые дополнительные вычисляемые поля


 Aggregation - обрабатывает все результаты запроса (queryset).
 Annotation - обрабатывает значение каждого значения (item) в запросе (queryset) отдельно

 Для того чтобы получить уже агрегированные данные, нужно воспользоваться методом .aggregate()
 Агрегирующие функции: Count, Sum, Avg, Max, Min. Метод values()
 from django.db.models import Count, Sum, Avg, Max, Min

 Husband.objects.aggregate(Min('age'), Max('age'))
 Husband.objects.aggregate(res = Min('age') -  Max('age')) # если res нет TypeError: Complex aggregates require an alias
 Women.objects.filter(pk__gt=2).aggregate(res = Count('cat_id'))
 Women.objects.values('title', 'cat_id')

 Database Functions on documentations
 from django.db.models.functions import Length



  --- Field types Типы полей models ---
 classes:

 BooleanField  - Поле истина/ложь. Значение по умолчанию BooleanField равно None
 CharField     - Строковое поле, для строк малого и большого размера.
 TextField     - Большое текстовое поле.
 DateField     - Дата, представленная в Python экземпляром datetime.date
 DateTimeField - Дата и время, представленные в Python экземпляром datetime.datetime.
 TimeField     - Время, представленное в Python экземпляром datetime.time.
 EmailField    - Проверяет является ли значение действительным адресом электронной почты, используя EmailValidator
 FileField     - Поле для загрузки файла.
 ImageField    - Наследуется от FileField, но также проверяет, что загруженный объект является допустимым изображением.
 JSONField     - Поле для хранения данных в кодировке JSON.
 SlugField     - Slug - газетный термин. Слаг - это короткая метка для чего-либо, содержащая только буквы, цифры,
                 подчеркивания или дефисы. Они обычно используются в URL.
 URLField      - CharField для URL, проверяется валидатором URLValidator.
 IntegerField  - Целое число. Значения от -2147483648 до 2147483647  использует MinValueValidator и MaxValueValidator
 PositiveBigIntegerField, PositiveIntegerField, PositiveSmallIntegerField, SmallIntegerField - Классы чисел


  -- Поля моделей в Django являются ДЕСКРИПТОРАМИ --

 Поля моделей в Django являются дескрипторами. Они определяют, как данные хранятся и обрабатываются в базе данных. <----

 from django.db import models

 class Book(models.Model):
     title = models.CharField(max_length=100)    # Дескриптор для поля строкового типа      <----
     published_date = models.DateField()         # Дескриптор для поля даты                 <----



 --- ПРОБЛЕМА N+1 запроса ---      Решение - select_related, prefetch_related, annotate и подзапросы

 ПРОБЛЕМА N+1 запроса — это НЕ эффективный способ обращения к базе данных, когда приложение генерирует запрос на каждый вызов объекта.
 Эта проблема обычно возникает, когда мы получаем список данных из базы данных без использования ленивой или
 жадной загрузки (lazy load, eager load)

 ПРОБЛЕМА N+1 запросов, когда каждая возвращенная строка из сотен строк вызывает дополнительный запрос.
 Проблема N + 1 возникает, когда фреймворк доступа к данным выполняет N дополнительных SQL‑запросов для получения
 тех же данных, которые можно получить при выполнении одного SQL‑запроса.

 Чтобы РЕШИТЬ ПРОБЛЕМА N+1 запросов:  select_related, prefetch_related, annotate и подзапросы   <-----

 select_related(key) - 'ЖАДНАЯ' загрузка связанных данных по внешнему ключу key, который имеет тип ForeignKey, OneToOneField
 уменьшение количество запросов к базе данных

 prefetch_related(key) - 'ЖАДНАЯ' загрузка связанных данных по внешнему ключу key, который имеет тип ManyToManyField
 уменьшение количество запросов к базе данных

 Запросы N+1 происходят из-за способа, которым ORM Django обрабатывает связанные объекты по умолчанию.



 # Задача на ORM
 class City(models.Model):
    name = models.CharField()


 class Person(models.Model):
     name = models.CharField()
     city = models.ForeignKey(City)

 Вывести список людей и городов где они живут?
 Вывести всех людей, живущих в городе N
 Вывести 5 городов с наибольшим населением, упорядочив по убыванию.

 # Ответ:
 Вот пример определения моделей с учетом этих деталей:
 from django.db import models

 class City(models.Model):
     name = models.CharField(max_length=255)

     def __str__(self):
         return self.name


 class Person(models.Model):
     name = models.CharField(max_length=255)
     city = models.ForeignKey(City, on_delete=models.CASCADE, related_name='people')

     def __str__(self):
         return self.name

 # Теперь перейдем к выполнению задач:
 1. Вывести список людей и городов, где они живут:

 people_with_cities = Person.objects.select_related('city').values('name', 'city__name')
 for person in people_with_cities:
     print(f'Человек: {person["name"]}, Город: {person["city__name"]}')


 2. Вывести всех людей, живущих в городе N:
 city_name = 'N'  # укажите название города
 people_in_city_n = Person.objects.filter(city__name=city_name)

 for person in people_in_city_n:
     print(f'Человек: {person.name}')

 3. Вывести 5 городов с наибольшим населением, упорядочив по убыванию.
 Для этого нам нужно будет добавить поле для хранения количества людей в каждом городе. Однако, чтобы подсчитать
 это количество динамически, мы можем использовать аннотирование с `Count`.

 from django.db.models import Count

 top_cities = City.objects.annotate(population=Count('people')).order_by('-population')[:5]

 for city in top_cities:
     print(f'Город: {city.name}, Население: {city.population}')



 Django Debug Toolbar — это мощный инструмент для отладки Django-кода.
 Он предоставляет подробную информацию о процессе выполнения запросов, использовании базы данных,
 настройках и многих других аспектах работы Django

 --- Adminka ---
 Можно решать все типовые задачи:
 создание пользователя с разными полномочиями
 отображение всех наших приложений
 добавление/изменения/удаление записи

 @admin.register(Women)
 class WomenAdmin(admin.ModelAdmin):
     list_display = ('id', 'title', 'time_create', 'is_published')

 --- CBV  -  Class-Based Views ---
 CBV могут наследоваться от множества классов и миксинов,
 но все CBV берут начало от класса View.
 Функции/Классы пишутся в файле views.py

 Базовые виды  base.generic : View, TemplateView, RedirectView
 Общие виды отображения - generic: DetailView, ListView
 Общие представления редактирования - generic: FormView, CreateView, UpdateView, DeleteView

 --- View ---
 View - базовый класс представлений
 Базовый класс представления. Все остальные представления на основе классов наследуются от этого базового класса
 from django.views import View

 __Class__.as_view() нужно прописать в urls.py приложения
 __Class__.as_view(template_name='users/password_change_done.html') # template_name=указать шаблон html

 extra_context - только для статических данных

 get_context_data - если нужно обрабатывать еще и динамические данные

 --- TemplateView ---
 TemplateView - он служит для обработки шаблонов и отправки результата пользователю
 Отображает заданный шаблон с контекстом, содержащим параметры, зафиксированные в URL-адресе.
 from django.views.generic import TemplateView
 template_name = 'women/index.html' # служит для указания шаблона(html)
 get_context_data - возвращает контекст для использования в шаблоне
 def get_context_data(self, **kwargs):
     context = super().get_context_data(**kwargs)
     return context

 DetailView, ListView представления на основе классов предназначены для отображения данных.
 Во многих проектах они обычно являются наиболее часто используемыми представлениями.

 --- ListView ---
 ListView - Страница, представляющая список объектов
 from django.views.generic import ListView
 model = для выбора модели
 для templates формирует перменную object_list
 template_name - 'women/index.html' # служит для указания шаблона(html)
 по умолчанию шаблон ищется:
 имя приложения / имя модели_list.html
 'women/women_list.html'
 context_object_name = 'posts' # для изменения   object_list
 def get_queryset(self): - то что будет отображатся в качестве списка
     Women.objects.all().select_related('cat')
 allow_empty = False - при пустом списке будет генерироватся исключение 404

 --- DetailView ---
 from django.views.generic import DetailView
 Во время выполнения этого представления self.object будет содержать объект, над которым работает представление.
 DetailView - Базовое представление для отображения одного объекта.
 Оно не предназначено для непосредственного использования, а скорее как родительский класс
 для templates формирует перменную object
 по умолчанию шаблон ищется:
 имя приложения / имя модели_detail.html
 'women/women_detail.html'
 model = для выбора модели
 slug_url_kwarg - если ищем по слагу
 pk_url_kwarg - если ищем по id  pk - primary key (первичный ключ)

 --- FormView ---
 from django.views.generic.edit import FormView # можно импортировать так
 from django.views.generic import FormView # можно импортировать так тоже

 Класс для автоматизации отображения и обработки html-форм
 Представление, отображающее форму. В случае ошибки повторно отображает форму с ошибками проверки;
  в случае успеха перенаправляется на новый URL

 Базовое представление для отображения формы. Он не предназначен для прямого использования,
 а скорее как родительский класс для того django.views.generic.edit.FormView или иного представления, отображающего форму

 form_class = AddPostForm (ссылка на сам класс без вызова () ) # ссылается на класс Формы form.py
 success_url = reverse_lazy('home') # определяет на какой URL адрес мы должны перенаправится после успешной отправки формы

 reverse_lazy - маршрут выстраивается не сразу а лишь в момент когда он необходим

 def form_valid(self, form): # для сохранения новой записи в БД
    form.save()
    return super().form_valid(form)

 в шаблон форма будет передаватся через переменую    form

 --- CreateView ---
 Служит для добавления новых записей в БД через форму

 from django.views.generic.edit import CreateView # можно импортировать так
 from django.views.generic import CreateView # можно импортировать так тоже

 Представление, отображающее форму для создания объекта,
 повторное отображение формы с ошибками проверки (если они есть) и сохранение объекта.

 При использовании CreateView у вас есть доступ к self.object создаваемому объекту.
 Если объект еще не создан, значение будет None.

 Метод уже реализован в CreateView
 def form_valid(self, form): # для сохранения новой записи в БД
    form.save()
    return super().form_valid(form)

 success_url = reverse_lazy('home')  если убрать то перенаправление будет через:
     def get_absolute_url(self):
        return reverse('post', kwargs={'post_slug': self.slug})

 get_absolute_url - Абсолютный путь URL

 который определен в модели, форма связана с моделью
 1) вариант
 class AddPage(CreateView):
    form_class = AddPostForm
    template_name = 'women/about.html'
    success_url = reverse_lazy('home')
    extra_context = {}

 2) вариант
 class AddPage(CreateView):
    model = Women
    fields = '__all__'
    template_name = 'women/about.html'
    extra_context = {}


 --- UpdateView ---
 Служит для изменения существующих записей в БД через форму

 from django.views.generic.edit import UpdateView # можно импортировать так
 from django.views.generic import UpdateView # можно импортировать так тоже

 При использовании UpdateView у вас есть доступ к self.object обновляемому объекту.

 Представление, отображающее форму редактирования существующего объекта,
 повторное отображение формы с ошибками проверки (если они есть) и сохранение изменений в объекте.
 При этом используется форма, автоматически сгенерированная из класса модели объекта (если класс формы не указан вручную).


 --- DeleteView ---
 Служит для удаления существующих записей в БД через форму

 from django.views.generic.edit import DeleteView # можно импортировать так
 from django.views.generic import DeleteView # можно импортировать так тоже

 Представление, отображающее страницу подтверждения и удаляющее существующий объект.
 Данный объект будет удален только в том случае, если метод запроса равен POST.
 Если это представление получено через GET, оно отобразит страницу подтверждения, которая должна содержать форму,
 которая отправляет POST на тот же URL-адрес.


 --- LoginView ---
 класс представления для авторизации пользователей
 from django.contrib.auth.views import LoginView

 --- LogoutView  ---
 класс представления для выхода пользователя из системы

 --- AuthenticationForm ---
 класс формы обработки аутентификации пользователя

 --- в settings.py можно прописать такие константы ---
 LOGIN_REDIRECT_URL - задает URL-адрес, на который следует перенаправлять пользователя после успешной авторизации

 LOGIN_URL - определяет URL-адрес, на который следует перенаправить неавторизованного пользователя при попытке посетить
 закрытую страницу сайта

 LOGOUT_REDIRECT_URL  - задает URL-адрес, на который перенапраляется пользователь после выхода

 --- Приоритеты ---
 get_user_model() - Этот метод вернет текущую активную модель пользователя - приоритет самый высокий

 <input type="hidden" name="next" value="{{ next }}" /> - средний приоритет
 в интеренет магазинах когда помещаем товар в корзину потом требуется авторизация,
  после авторизации перенаправляемся именно в корзину, не строго какая-то страница а та на которой пользователь был в последний момент

 LOGIN_REDIRECT_URL - самый низкий приоритет

 @login_required  - для функций представлений
 @login_required(login_url='/admin/') - приоритет выше чем LOGIN_URL в settings.py
 Ограничение доступа к страницам сайта с помощью декоратора
 @login_required - страница доступна только для авторизованных пользователей
 LOGIN_URL - перенаправление на выбранный адрес # в settings.py прописывается

 --- LoginRequiredMixin ---
 Миксин для проверки аутентификации пользователя, требует, чтобы пользователь был авторизован.
 from django.contrib.auth.mixins import LoginRequiredMixin
 login_url = '/admin/' - атрибут для перенаправления на выбранный URL адресс

 --- UserCreationForm ---
 Класс для регистрации пользователей
 from django.contrib.auth.forms import UserCreationForm

 --- PasswordChangeView ---
 для обработки формы изменения пароля

 --- PasswordChangeDoneView ---
 для отображения результата успешного изменения

 --- PasswordResetView ---
 Позволяет пользователю сбросить свой пароль, создав одноразовую ссылку, которую можно использовать для сброса пароля,
  и отправив эту ссылку на зарегистрированный адрес электронной почты пользователя.

 --- PasswordResetDoneView ---
 Страница, отображаемая после того, как пользователю была отправлена по электронной почте ссылка для сброса пароля

 --- PasswordResetConfirmView ---
 Представлена форма для ввода нового пароля.

 --- PasswordResetCompleteView ---
 Представляет представление, которое информирует пользователя об успешном изменении пароля

 --- PermissionRequiredMixin ---
 Этот миксин, как и permission_required декоратор, проверяет, имеет ли пользователь, обращающийся к представлению,
  все заданные разрешения. Вы должны указать разрешение (или итерацию разрешений), используя permission_required параметр

  permission_required

 --- Paginator ---
  from django.core.paginator import Paginator
 Django предоставляет высокоуровневые и низкоуровневые способы управления данными, разбитыми на страницы,
  то есть данными, разделенными на несколько страниц со ссылками «Предыдущий/Следующий

 Под капотом все методы нумерации страниц используют этот Paginator класс.
 Он выполняет всю тяжелую работу по фактическому разбиению объекта QuerySet на Page объекты

  Отправка писем в консоль(console)
  EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend" # прописываем в settings.py

 CRM-система – это сервис для автоматизации бизнес-процессов

 Flask - предоставляет простоту, гибкость и аккуратность в работе, позволяя пользователю самому выбирать,
  как реализовать те или иные вещи. Больше подойдет для создания микросервисов или приложений
 Django - предоставляет пакет «все включено»: у вас есть панель админа, интерфейсы баз данных,
  ORM, и структура каталогов для ваших приложений и проектов.
  Django хорошо подойдет для новостных сайтов, блогов и тд, благодаря тому что у него уже из коробки есть многое
   (в том числе админка), да и создавался он именно под такой тип сайтов

 фласк крут, потому что он простой, всё что надо ставишь сам, а чего не надо там и так нет, но как по мне, всё равно потом получается django.

 WebSocket (веб-сокеты) — независимый веб-протокол, который позволяет создавать
 интерактивное соединение между сервером и клиентом (браузером) и обмениваться сообщениями в реальном времени

 **Django** не поддерживает WebSocket "из коробки", но есть способы реализации этого протокола с помощью дополнительной
 библиотеки **Django Channels**.

 Сокеты являются основой для работы с сетью в Python, и они предоставляют возможность обмениваться данными между
 двумя программами через сеть.

 Для работы с сокетами в Python используется модуль socket

 Сокет — это абстракция, представляющая собой конечную точку сетевого соединения. Вам потребуется создать два сокета для
 обмена данными: один на стороне клиента и один на стороне сервера. Клиент и сервер могут обмениваться данными,
 используя эти сокеты.

 Сокет — это виртуальная конструкция из IP-адреса и номера порта. Её придумали для того, чтобы разработчикам было проще
 писать код, а программы могли передавать данные друг другу даже в пределах одного компьютера.

 Сокет - низкоуровневая обстракция отправки и получения данных по сети. Именно с помощью ее производится обмен данными
 между клиектами и серверами. Сокеты поддерживают две основные операции: отправку и получение байтов.

 --Сокеты используют для двух вещей:
 - для передачи данных по сети.
 - и для связи между приложениями.

 Существует два основных типа сокетов:
 -- TCP-сокеты (Transmission Control Protocol) — обеспечивают надежное соединение между двумя устройствами. Они обычно
 используются в веб-серверах и клиентах, почтовых серверах и других приложениях, где требуется надежность и порядок доставки данных.

 -- UDP-сокеты (User Datagram Protocol) — обеспечивают передачу данных без установления соединения. Они обычно
 используются в видео и аудио потоковых приложениях, играх и других приложениях, где скорость важнее, чем надежность.


 Вот краткое описание ключевых интернет-архитектур, технологий, протоколов и форматов:

 1. **TCP/IP**: Протоколы, обеспечивающие передачу данных по сети. TCP (Transmission Control Protocol)
  отвечает за надежную доставку, а IP (Internet Protocol) — за маршрутизацию данных.

 2. **HTTP**: Протокол передачи данных, используемый для обмена информацией между веб-серверами и клиентами (браузерами).
  Он лежит в основе работы Всемирной паутины.

 3. **AJAX**: Технология для асинхронной загрузки данных на веб-страницах, позволяющая обновлять интерфейс без перезагрузки страницы.

 4. **HTML**: Язык разметки для создания и структурирования веб-страниц, который описывает содержимое и структуру документов.

 5. **CSS**: Язык стилей, используемый для оформления HTML-документов. Он управляет внешним видом элементов веб-страниц,
  включая цвета, шрифты и макеты.

 6. **XML**: Язык разметки, используемый для структурированного хранения и передачи данных с возможностью определения
  собственных тегов.

 7. **JSON**: Формат обмена данными, основанный на JavaScript, который является более легковесной альтернативой
  XML для передачи структурированных данных.

 8. **WSDL**: Язык описания веб-служб, который определяет интерфейс и методы, доступные в веб-службах, позволяя
  программам взаимодействовать друг с другом.

 9. **REST**: Архитектурный стиль для разработки веб-сервисов, использующий стандартные HTTP-методы
  (GET, POST, PUT, DELETE) для взаимодействия с ресурсами, которые представляются в виде URL.

 Эти технологии и протоколы создают основу для работы интернета и веб-приложений.


  -- Базовые атаки --

 DoS/DDoS атаки - цель состоит в том, чтобы перегрузить сервер. Часто путем отправки большого количества запросов.

 SQL-инъекции — это один из самых распространенных методов атак на базы данных.
 SQL-инъекция (SQLi) - это уязвимость веб-безопасности, которая позволяет злоумышленнику вмешиваться в запросы,
 которое приложение делает к своей базе данных. Как правило, это позволяет просматривать данные,
 которые он обычно не может получить

 Способы избежать SQL-инъекция (SQLi):

 - Проверка пользовательского ввода
  Всегда проверяйте и фильтруйте пользовательский ввод, включая символы, которые могут быть потенциально опасными
 (например, кавычки, точки с запятой и т. д.).

 - Ограничение прав доступа
   НЕ давайте учетной записи, используемой веб-приложением, права на изменение структуры базы данных.

 - Логи и Мониторинг
   Ведите логи всех запросов к вашей базе данных и следите за необычной активностью, что позволит быстро обнаружить потенциальные атаки.

 - Использование ORM (Object-Relational Mapping)
   SQLAlchemy (Python), автоматически генерируют SQL-запросы и уменьшают риск инъекций.
   Предотвращение SQLi в Django

  Django ORM повсеместно использует параметризованные операторы, поэтому он очень устойчив к SQLi. Таким образом,
  если вы используете ORM для выполнения запросов к базе данных, вы можете быть уверены, что ваше приложение в безопасности.

 - Экранирование данных — это процесс обработки пользовательского ввода в таком виде, чтобы вредоносные символы НЕ
  интерпретировались как части SQL-команды. Это обеспечивает безопасность, предотвращая возможность SQL-инъекций.

  Пример:
  import sqlite3
  connection = sqlite3.connect('example.db')
  cursor = connection.cursor()
  input_data = "O'Reilly"  # Пользовательский ввод
  escaped_input = input_data.replace("'", "''")  # Экранирование
  query = f"SELECT * FROM authors WHERE name = '{escaped_input}'"

 - Подготовленные запросы SQL (prepared statements) — это механизм работы с базами данных, который позволяет заранее
  компилировать SQL-запросы с параметрами.
  В Python: Используйте библиотеки, такие как `sqlite3` или `SQLAlchemy`, которые поддерживают подготавливаемые запросы.

 Django был разработан таким образом, чтобы быть устойчивым к SQL-инъекциям (и другим распространенным веб-уязвимостям).
 Большинство распространенных вариантов использования Django будут автоматически защищены, поэтому уязвимости SQLi
 в реальных приложениях Django, к счастью, встречаются редко.

 Bento автоматически проверяет код Django на наличие шаблонов SQL-инъекций.   <-----


 Лог (log) — это текстовый файл, куда автоматически записывается важная информация о работе системы или программы.
 Чаще всего говорят о логах сервера. Их записывает программное обеспечение, которое управляет внутренней частью сайта
 или онлайн-системы. Лог-файл — своеобразный журнал событий.
 Логированием называют запись логов. Оно позволяет ответить на вопросы, что происходило, когда и при каких обстоятельствах.
 Без логов сложно понять, из-за чего появляется ошибка, если она возникает периодически и только при определенных условиях.
 Лог-файл (log file) содержит в себе информацию в сокращенном формате.
 Логи хранятся в файлах с расширением .log. Их можно открыть как обычные текстовые файлы и просмотреть содержимое.
 Как правильно читать лог? 1) Вручную. 2) Cпециальной программой-анализатором.

 Для чего нужны логи:
 Устранение неполадок:
 - По логам можно понять, когда и из-за чего в работе системы возник сбой.
 Контроль работы:
 - Логи позволяют лучше отслеживать процессы, делать прогнозы на будущее и в целом контролировать работу сервера.
 Проверка стабильности:
 - Даже если с системой все хорошо, рекомендуется периодически проверять ее логи.
 Выявление злоумышленников:
 - Вирус или взлом можно обнаружить по логам.
 Маркетинг:
 - Логи — источник ценной информации для развития сайта. Они позволяют собрать статистику по посещаемости с
 «сырыми» техническими данными. Например, понять, откуда приходят пользователи, где они находятся и какими устройствами
 пользуются для визита.

 Какими бывают логи?
 - основной рассказывает о главных событиях, которые произошли непосредственно с серверным ПО;
 - журнал доступа содержит сведения о посетителях сайта;
 - лог ошибок сообщает обо всех сбоях, которые произошли во время работы ПО;
 - лог веб-сервера рассказывает об обращениях к серверу и о возможных ошибках;
 - лог баз данных записывает сведения о действиях с БД, запросах и ошибках;
 - лог почтового сервера содержит информацию об отправленных и полученных письмах и так далее.

 Наиболее важными считаются логи сервера, доступа и ошибок, но проверять советуют не только их.

 Elasticsearch (ES) – масштабируемая утилита полнотекстового поиска и аналитики, которая позволяет быстро в режиме
 реального времени хранить, искать и анализировать большие объемы данных.
 ES (Elasticsearch) - позволяет производить поиск по документам в режиме реального времени
 Elasticsearch это документо-ориентированная база данных
 Elasticsearch – это распределенный поисковый и аналитический движок на базе Apache Lucene.
 В Elasticsearch отправляются данные в виде документов JSON с помощью API или такого инструмента, как Logstash

 Django Channels расширяет встроенные возможности Django за пределы только HTTP,
 используя преимущества "духовного наследника"
 WSGI (Web Server Gateway Interface), ASGI (Asynchronous Server Gateway Interface).
 Если WSGI предоставлял синхронный стандарт для веб-приложений Python,
 то ASGI предоставляет как синхронные, так и асинхронные стандарты.

 WebSocket — это протокол связи, который обеспечивает ПОСТОЯННОЕ соединение между клиентом и сервером для обмена данными
 в реальном времени. Он позволяет отправлять и получать сообщения в обоих направлениях с низкой задержкой, что удобно
 для приложений, требующих мгновенной передачи данных, таких как чаты, онлайн-игры и финансовые приложения.

 WebSocket работает по следующему принципу:

 1. Установление соединения: Клиент (например, веб-браузер) инициирует подключение к серверу WebSocket путем отправки
  HTTP-запроса с заголовком Upgrade. Это запрос сообщает серверу, что клиент хочет переключиться на протокол WebSocket.

 2. Подтверждение соединения: Сервер, приняв запрос, отвечает с кодом 101 (Switching Protocols), что означает успешное
  переключение на протокол WebSocket. После этого устанавливается постоянное соединение.

 3. Двусторонняя связь: В отличие от традиционных HTTP-запросов, где связь осуществляется только от клиента к серверу,
  WebSocket позволяет обмениваться данными в обоих направлениях одновременно. Это означает, что сервер может отправлять
  сообщения клиенту без предварительного запроса.

 4. Закрытие соединения: Когда соединение больше не требуется, оно может быть закрыто одной из сторон
  (клиентом или сервером), что освобождает ресурсы.

 Этот процесс обеспечивает эффективный обмен данными в реальном времени с минимальной задержкой.


 WebSocket — это протокол связи, который позволяет устанавливать двунаправленное взаимодействие между клиентом и
 сервером через одно соединение. В отличие от HTTP, который является однонаправленным, WebSocket позволяет обмениваться
 данными в режиме реального времени.

 Создать файл  consumers.py

 Пример:
 from channels.generic.websocket import AsyncWebsocketConsumer
 import json

 class MyConsumer(AsyncWebsocketConsumer):
     async def connect(self):
         await self.accept()

     async def disconnect(self, close_code):
         pass

     async def receive(self, text_data):
         data = json.loads(text_data)
         await self.send(text_data=json.dumps({
             'message': data['message']
         }))



 Что такое сигналы? Зачем нужны? Назовите основные
 Сигналы – это события в экосистеме Джанго. С помощью сигналов подсистемы оповещают приложение о том, что случилось.
 Чтобы читать сигналы, программист регистрирет обработчики сигналов. Сигналы распространяются синхронно. Это значит,
 подписав на один сигнал сотню обработчиков, мы увеличим время, необходимое на отдачу ответа.

 Основные сигналы это начало запроса и его окончание, перед сохранением модели и после, обращение к базе данных. <-----

 Django Signals - Чтобы принять сигнал, зарегистрируйте функцию приемник с помощью метода Signal.connect().
 Функция-приемник вызывается при отправке сигнала. Все функции-приемники сигнала вызываются по очереди,
 в том порядке, в котором они были зарегистрированы
 Сигналы распространяются синхронно.

 В Django built-in signals позволяет пользовательскому коду получать уведомления об определенных действиях.

 В Django сигналы позволяют вам связывать определенные действия с событиями, происходящими в модели, например,
 сохранением или удалением объектов. Это полезно для выполнения дополнительных задач, таких как отправка уведомлений
 или обновление связанных данных.

 ### Как использовать сигналы:
 1. **Импортируйте необходимые модули:** Вам нужно импортировать `signals` и `receiver` из `django.db.models.signals`.

 2. **Создайте обработчик сигнала:** Напишите функцию, которая будет выполнена при срабатывании сигнала.

 3. **Подпишитесь на сигнал:** Используйте декоратор `@receiver` для связывания сигнала с обработчиком.

 ### Пример

 Допустим, у вас есть модель `MyModel`, и вы хотите выполнить действие при ее сохранении.

 from django.db import models
 from django.db.models.signals import post_save
 from django.dispatch import receiver

 class MyModel(models.Model):
     name = models.CharField(max_length=100)

 @receiver(post_save, sender=MyModel)
 def mymodel_saved(sender, instance, created, **kwargs):
     if created:
         print(f'Объект {instance.name} был создан!')
     else:
         print(f'Объект {instance.name} был обновлён!')

 # Пример использования:
 # Создание нового объекта:
 new_object = MyModel.objects.create(name='Пример')

 # Обновление существующего объекта:
 new_object.name = 'Обновлённый пример'
 new_object.save()

 - **Сигналы** позволяют автоматически выполнять действия при возникновении событий в моделях.
 - **Пример** показывает, как обрабатывать сигналы `post_save` для создания и обновления объектов.


 Django-allauth — Библиотека авторизации:
 помогает реализовать функции регистрации, авторизации и управления учётными записями

 ipython  - для удобства в терминале
 django-extensions - набор инструментов, которые помогут вам в вашей повседневной работе. manage.py shell_plus --print-sql

 django-ckeditor - Для редактирования в Админке

 pillow - Для работы с изображениями

 Crispi-forms - для работы с формами. Позволят вам управлять поведением рендеринга ваших форм

 Celery - это асинхронная очередь задач, используемая для распределенной обработки сообщений.
 Он позволяет выполнять задачи в фоновом режиме, не загружая основной поток выполнения

 Celery — это программа, которая отслеживает задачи (tasks), которые необходимо выполнить,
 и в которой есть набор обработчиков (workers), которые будут выполнять эти задачи.
 Основной смысл в том, что она (программа) может выполнять несколько задач параллельно
 и что она не блокирует поставщиков (producers) этих самых задач.

 Celery на самом деле не хранит все эти задачи в памяти, брокер сообщений хранит задачи.


 Django предназначен для создания полнофункциональных веб-приложений,
 в то время как DRF специализируется на создании RESTful API.


 -- Что такое REST --
 в веб-программировании — это архитектурный стиль, который используется для создания веб-сервисов.

 **REST (Representational State Transfer)**:
 - Это архитектурный стиль для проектирования сетевых приложений. REST использует стандартные HTTP-методы
  (GET, POST, PUT, DELETE и т.д.) для взаимодействия между клиентом и сервером.
 - RESTful API (интерфейсы программирования приложений) соответствуют принципам REST и обычно обмениваются данными в
  формате JSON или XML.
 - Основные принципы REST:
 - **Статус представление**: Клиент и сервер взаимодействуют путем обмена состояниями ресурса (например, данные о пользователе).
 - **Безсостояние**: Каждый запрос от клиента к серверу должен содержать всю информацию, необходимую для его обработки,
   и сервер не хранит состояние клиента.
 - **Кешируемость**: Ответы должны указывать, могут ли они быть закешированы для повышения производительности.
 - **Уровень абстракции**: Каждый ресурс в REST может быть доступен по уникальному URI (Uniform Resource Identifier).


 -- Что в rest значить Path и Query? --
 В REST (Representational State Transfer) API, `path` и `query` являются частями URL, которые используются для
 определения ресурсов и параметров запроса. Давайте подробнее рассмотрим каждую из них.

 1) Path (путь)
 `path` — это то, что идет после доменного имени и определяет конкретный ресурс или коллекцию ресурсов. Обычно он
 используется для идентификации ресурса, с которым вы взаимодействуете.

 Пример URL:
 https://api.example.com/users/123
 В этом URL `users/123` — это Path (путь). Он обозначает, что вы хотите получить информацию о пользователе с ID 123.

 2) Query (параметры запроса)
 query` — это часть URL, которая начинается со знака вопроса `?` и используется для передачи дополнительных параметров,
 которые могут уточнить или изменить запрос. Параметры в запросе могут быть ключами и значениями, разделенными знаком `&`.

 Пример URL:
 https://api.example.com/users?age=25&active=true

 В этом URL `age=25&active=true` — это параметры запроса. Они могут использоваться для фильтрации или настройки данных,
 которые вы хотите получить. В данном случае, это запрос списка пользователей, которые активны и имеют возраст 25 лет.

 ### Примеры использования

 **Path без query**:
 Это запрос на получение информации о продукте с ID 456.
 GET https://api.example.com/products/456


 **Path с query**:
 Это запрос на получение списка продуктов в категории "электроника", отсортированных по цене.
 GET https://api.example.com/products?category=electronics&sort=price

 Таким образом, `path` используется для навигации к определенному ресурсу, а `query` для передачи параметров, которые
 могут изменить или уточнить запрос.



 --- DRF  Django REST Framework ---
 Фреймворк, работающий со стандартными моделями Django для создания гибкого и мощного API для проекта.

 Установка  pip install djangorestframework

 DRF облегчает взаимодействие между сервером и клиентами, позволяя передавать данные в формате JSON
 и выполнять различные операции, такие как чтение, запись и удаление данных. Он также обеспечивает безопасность,
 авторизацию и управление правами доступа.

 Архитектура DRF:

 Сериализатор (Serializer): преобразует информацию, хранящуюся в базе данных и определенную с помощью моделей Django,
 в формат JSON, который легко и эффективно передаётся через API.

 Представление (View, ViewSet): определяет функции (чтение, создание, обновление, удаление), которые будут доступны через API.

 Маршрутизатор (Router): определяет URL-адреса, которые будут предоставлять доступ к каждому представлению.


 Как работает Serializer в Django REST Framework?
 Serializer преобразует информацию, хранящуюся в базе данных и определенную с помощью моделей Django, в формат,
  который легко и эффективно передается через API - JSON.

 Наиболее распространенной формой, которую принимает сериализатор DRF, является тот, который привязан непосредственно к модели Django:

 class ThingSerializer(serializers.ModelSerializer):
  class Meta:
    model = Thing
    fields = (‘name’, )

 Если взять за пример Serializer, то можно посмотреть на код джанги:

@six.add_metaclass(SerializerMetaclass)
class Serializer(BaseSerializer):
  ...
SerializerMetaclass - это тот самый метакласс, который конструирует класс ModelForm.


 За что отвечает Meta в сериализаторе?
 В классе Meta сериализатора можно задать модель по которой будет создан сериализатор, поля, которые будут включены
 (или exclude для исключения), list_serializer_class, например для того чтобы задать специфическую валидацию списков и тд.


 Throttling в Django REST Framework (DRF) — это механизм, который ограничивает количество запросов, которые клиент
 может сделать к API в заданный период времени. Это помогает предотвратить злоупотребления, защитить сервер от
 перегрузок и обеспечить справедливое распределение ресурсов между пользователями.

 В DRF есть несколько встроенных классов для реализации throttling, таких как:

 1. **AnonRateThrottle** — ограничивает анонимных пользователей.
 2. **UserRateThrottle** — ограничивает зарегистрированных пользователей.
 3. **ScopedRateThrottle** — позволяет устанавливать разные лимиты для различных частей API.

 Настройки throttling можно задать в файле конфигурации Django или в представлениях (views). Это делает его гибким и
 настраиваемым под нужды вашего приложения.


 Какая разница между аутентификацией и авторизацией?
 - Сначала определяют имя (логин или номер) – идентификация
 - Затем проверяют пароль (ключ или отпечаток пальца) – аутентификация
 - И в конце предоставляют доступ – авторизаци

 -- nginx --
 Nginx – это веб сервер. Он хранит файлы сайта и направляет их по запросу на компьютер или мобильное устройство.
 То есть он нужен для быстрого отображения интернет-страничек.
 Его основная задача заключается в обработке статичного контента.
 Сервер Nginx выполняет две функции:
 - Принимает, обрабатывает и отправляет запросы клиентам
 - Играет роль прокси-сервера

 Сайты в интернете работают на веб-серверах, которые обрабатывают запросы пользователей и отвечают на них.
 Сегодня один из самых популярных веб-серверов — Nginx
 NGINX (Engine X, или «Энджин-икс») — это программное обеспечение с открытым исходным кодом для создания веб-серверов.
 Оно принимает запрос клиента, например браузера, обрабатывает его и возвращает ответ.

 --- Типа Советы ---

 -- Рефакторить и замерять скорость при помощи  @funcy.log_durations. - там на сайте еще много чего

 Ну, например, select_related на самом деле делает JOIN. А prefetch_related не делает. Не всегда синтаксис django ORM
 выдерживает реальности SQL, и появляются всякие странные вещи типа OuterRef, F, Q, и иже с ними. GROUP BY вообще замаскирован.

 Если вы хотите выполнить агрегацию, вы можете использовать функции агрегации ORM :

 from django.db.models import Count
 result = (Members.objects
     .values('designation')
     .annotate(dcount=Count('designation'))
     .order_by()
)




"""