"""

 Самое Важное!!!
 Всегда ДУМАТЬ! перед тем, как что-либо сделать, необходимо всё тщательно обдумать

 Радоваться Жизни  Радоваться разным мелочам

 Ценить:         Ценить то что есть и стремиться к лучшему, Ценить сегодняшний день и брать МАКСИМУМ
 Быть проще:     Ко всему относиться Проще и Спокойнее без Волнения
 Слушать Других: Прислушиваться к мнению других людей они могут быть правы  И делать выводы
 Время:          Тайм-менеджмент   Грамотное распределение времени, Контроль Времени, Правильно раставлять Приоритеты
 Уверенность:    Быть уверенным в себе НО Оценивать свои силы!
 Развития:       Развиваться, Учиться, учиться и ещё раз - учиться, Саморазвитие
 Не Надеяться:   Надеяться только на себя
 Контроль:       Быть менее Эмоциональным, Совладать с Эмоциями, Контролировать свои эмоции в любой ситуации
 Внимательность: Быть Внимательным
 Спокойствие:    Быть Спокойнее, Перестать Нервничать , Быть Расслабленным, Не Злиться на себя и на других
 Режим:          Правильный Сон, Пить Воду
 Зарядка:        Бег, Тренировки, Стойка на Голове
 Тельце в тепле: НЕ переохлаждаться

 Молчание золото:  Лучше промолчать, чем сказать и потом жалеть о том, что сказал
 Соломон:          Все пройдёт, и это тоже пройдёт
 Вообще это замечательный подход: осознать, что проблема не такая уж и проблема, и вполне решаема.
 Кто ищет-тот всегда найдет!
 Искать Другие способы
 Не спеши, а то успеешь...   Успеешь, но не туда куда хотел...
 Подумай, нужно ли тебе ЭТО и для Чего
 Надо принимать вещи такими, как они есть, и пользоваться ими с наибольшей для себя выгодой.
 Если научиться принимать вещи как они есть, страдание исчезнет.
________________________________________________________________________________________________________________________


--- Модуль operator в Python  Функциональный интерфейс для встроенных операторов ---



________________________________________________________________________________________________________________________
 - Общий интерфейс поиска атрибутов и элементов модуля operator в Python -

 - Поиск атрибутов или элементов последовательностей/итераций -

 Одной из самых необычных особенностей модуля operator является концепция геттеров. Это вызываемые объекты, созданные
 во время выполнения для извлечения атрибутов объектов или содержимого из последовательностей.

 Геттеры особенно полезны при работе с итераторами или последовательностями генераторов, где они предназначены для
 быстрого извлечения полей аргументов из функций для map(), sorted(), itertools.groupby() или других функций, которые
 ожидают аргумент переданной функции.

________________________________________________________________________________________________________________________
 --- Полезный пример ---
 from operator import attrgetter, itemgetter

 class Cat:
     def __init__(self, name, age):
         self.name = name
         self.age = age

     def __repr__(self):
         return f'Cat {self.name}, age is {self.age}'

 if __name__ == '__main__':
     ints = list(range(20))
     print(list(map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, ints))))
     print([i**2 for i in range(20) if i % 2 == 0])
     a_dict = {'a': 3, 'b': 2, 'd': 1, 'c': 4}
     print(sorted(a_dict.items(), key=lambda x: x[0]))
     print(sorted(a_dict.items(), key=itemgetter(1)))
     cats = [Cat('Tom', 3), Cat('Angela', 4)]
     print(sorted(cats, key=lambda x: x.age))
     print(sorted(cats, key=attrgetter('age')))
     print(sorted(cats, key=attrgetter('name')))



________________________________________________________________________________________________________________________
 operator.attrgetter(attr), operator.attrgetter(*attrs) - возвращает вызываемый объект, который получает attr из своего
 операнда. Если запрашивается более одного атрибута, возвращает набор атрибутов. Имена атрибутов также могут содержать точки.


 Эквивалентно:
 def attrgetter(*items):
    if any(not isinstance(item, str) for item in items):
        raise TypeError('attribute name must be a string')
    if len(items) == 1:
        attr = items[0]
        def g(obj):
            return resolve_attr(obj, attr)
    else:
        def g(obj):
            return tuple(resolve_attr(obj, attr) for attr in items)
    return g

 def resolve_attr(obj, attr):
     for name in attr.split("."):
         obj = getattr(obj, name)
     return obj

 from operator import attrgetter


 class MyObj:

     def __init__(self, arg):
         super().__init__()
         self.arg = arg

     def __repr__(self):
         return f'MyObj({self.arg})'


 l = [MyObj(i) for i in range(5)]
 print(l)
 # [MyObj(0), MyObj(1), MyObj(2), MyObj(3), MyObj(4)]

 # Извлечем значение 'arg' из каждого объекта
 g = attrgetter('arg')
 print([g(i) for i in l])
 # [0, 1, 2, 3, 4]

 # теперь отсортируем, используя 'arg'
 l.reverse()
 print(l)
 # [MyObj(4), MyObj(3), MyObj(2), MyObj(1), MyObj(0)]

 print(sorted(l, key=g))
 print(sorted(l, key=attrgetter('arg')))
 # [MyObj(0), MyObj(1), MyObj(2), MyObj(3), MyObj(4)]
________________________________________________________________________________________________________________________
 operator.itemgetter(item), operator.itemgetter(*items) - возвращает вызываемый объект, который выбирает элемент из
 своего операнда, используя метод операнда __getitem__(). Если указано несколько элементов, возвращает кортеж значений:

 Элементы могут быть любого типа, принятого методом операнда __getitem__(). Словари принимают любое хешируемое значение.
 Списки, кортежи и строки принимают индекс или срез.

 Функция эквивалентна следующему коду:
 def itemgetter(*items):
    if len(items) == 1:
        item = items[0]
        def g(obj):
            return obj[item]
    else:
        def g(obj):
            return tuple(obj[item] for item in items)
    return g

 from operator import itemgetter

 Пример 1:
 import operator
 print(operator.itemgetter('name')({'name': 'tu', 'age': 18}))
 # 'tu'
 print(operator.itemgetter(1)('ABCDEFG'))
 # 'B'
 print(operator.itemgetter(1,3,5)('ABCDEFG'))
 # ('B', 'D', 'F')
 print(operator.itemgetter(slice(2,None))('ABCDEFG'))
 # 'CDEFG'
 soldier = dict(rank='captain', name='dotterbart')
 print(operator.itemgetter('rank')(soldier))
 # 'captain'

 Пример 2:
 import operator
 inventory = [('apple', 3), ('banana', 2), ('pear', 5), ('orange', 1)]
 getcount = operator.itemgetter(1)
 print(list(map(getcount, inventory)))
 # [3, 2, 5, 1]
 print(sorted(inventory, key=getcount))
 # [('orange', 1), ('banana', 2), ('apple', 3), ('pear', 5)]
 print(sorted(inventory, key=operator.itemgetter(0)))
 # [('apple', 3), ('banana', 2), ('orange', 1), ('pear', 5)]

 Пример 3:
 # Для словарей
 l = [dict(val=-1 * i) for i in range(4)]
 print(l)
 # [{'val': 0}, {'val': -1}, {'val': -2}, {'val': -3}]
 g = itemgetter('val')
 print([g(i) for i in l])
 # [0, -1, -2, -3]
 print(sorted(l, key=g))
 print(sorted(l, key=itemgetter('val')))
 # [{'val': -3}, {'val': -2}, {'val': -1}, {'val': 0}]

 # Для кортежей
 l = [(i, i * -2) for i in range(4)]
 print(l)
 # [(0, 0), (1, -2), (2, -4), (3, -6)]
 g = itemgetter(1)
 print([g(i) for i in l])
 # [0, -2, -4, -6]
 print(sorted(l, key=g))
 # [(3, -6), (2, -4), (1, -2), (0, 0)]
 print(sorted(l, key=itemgetter(0)))
 # [(0, 0), (1, -2), (2, -4), (3, -6)]

________________________________________________________________________________________________________________________
 operator.methodcaller(name, /, *args, **kwargs) - это функция, которая позволяет создавать вызываемый объект (callable)
 для вызова метода у объекта. Этот метод принимает имя метода как строку и возвращает функцию, которая может быть
 вызвана на любом объекте.

 Пример 1:
 import operator

 # Создаем метод для вызова метода str.upper
 upper = operator.methodcaller('upper')
 my_replace = operator.methodcaller('replace', 'hello', 'OOO')

 # Применяем его к строке
 result = upper('hello')    # вернет 'HELLO'
 res = my_replace('hello')  # вернет 'OOO'

 print(result)  # -> HELLO
 print(res)     # -> OOO


 Пример 2:

 data = [[1, 2, 3], (2, 2)]
 # Создаем метод для вызова метода   __len__
 length = operator.methodcaller('__len__')

 # Применяем его к элементам списка
 lengths = list(map(length, data))  # вернет [3, 2]

 print(lengths)  # -> [3, 2]


 Пример 3:
 class MyClass:
     def greet(self, name, age=None):
         return f"Hello, {name}! Age: {age}"

 obj = MyClass()

 # Создаем метод вызова метода greet с аргументами
 greet_method = operator.methodcaller('greet', 'Alice', age=30)

 # Вызываем метод
 result = greet_method(obj)
 print(result)  # -> Hello, Alice! Age: 30
________________________________________________________________________________________________________________________


________________________________________________________________________________________________________________________


________________________________________________________________________________________________________________________


________________________________________________________________________________________________________________________


________________________________________________________________________________________________________________________


________________________________________________________________________________________________________________________


________________________________________________________________________________________________________________________


________________________________________________________________________________________________________________________


________________________________________________________________________________________________________________________


________________________________________________________________________________________________________________________


________________________________________________________________________________________________________________________









"""