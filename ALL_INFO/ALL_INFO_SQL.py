"""

 Structured Query Language (SQL) — декларативный язык программирования, применяемый для создания, модификации и управления
 данными в реляционной базе данных, управляемой соответствующей системой управления базами данных.

 Таблицы — это основа хранения данных в SQL, а представления — инструмент для извлечения конкретной информации.

 В SQL представление(VIEW) — это виртуальная таблица, основанная на SELECT операторе. CREATE VIEW НАЗВАНИЕ AS SELECT ...

 Примеры:
 CREATE VIEW top_rated_movies           CREATE VIEW NamesView
 AS                                     AS
 SELECT id,                             SELECT pl.vcName, count(*)
       title,                           FROM tbPeoples pl
       release_year,                    GROUP BY vcName
       genre,
       rating
 FROM movies
 WHERE rating = 9;


 Напишите запрос, который выводит информацию о версии MySQL сервера.
 SELECT VERSION();

 Напишите запрос, который выводит список баз данных на сервере
 SHOW DATABASES;

 Какие таблицы есть в  БД.
 SHOW TABLES;

 Выведите информацию о структуре таблицы statistics.
 USE information_schema;
 SHOW COLUMNS FROM statistics;

 - **DATABASE** — это более широкий контейнер с данными.
 - **SCHEMA** — это способ организации данных внутри базы данных.


 -- Что такое ИНДЕКСЫ в SQL и как их использовать --

 По сути, индекс — это сбалансированное двоичное дерево поиска. Каждая строка в таблице соответствует узлу в дереве.

 Производительность: Проблема в том, что, когда новая запись вставляется в таблицу или удаляется из нее, приходится
 обновлять все индексы, чтобы отразить это изменение. Если индексов много, то обновление, вставка или удаление строк
 могут стать в вычислительном плане дорогостоящими операциями (ВСПОМНИМ ПРО БАЛАНСИРОВКУ ДЕРЕВА).

 Более того, индексы занимают ограниченное дисковое пространство.

 - Ответ 1:

 Если в кратце, то индекс, это поле по которому оптимизирован(ускорен) поиск.                            <-----

 Поскольку индекс занимает место, то индексировать нужно только те поля, по которым происходит выборка.  <-----

 Допустим есть таблица.

 CREATE TABLE MyGuests (
     id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
     firstname VARCHAR(30) NOT NULL,
     lastname VARCHAR(30) NOT NULL,
     email VARCHAR(50),
     reg_date TIMESTAMP
 )

 id - уже индекс

 Допустим вам нужен поиск по имени (firstname).

 SELECT * FROM MyGuests WHERE firstname = "Вася"

 тогда есть смысл добавить индекс по данному полю.

 CREATE INDEX firstname_index ON MyGuests (firstname) USING BTREE;    # Создание Индекса

 Будет созданна "карта" которая позволет легко находить записи в оригинальном списке.


 - Ответ 2:

 Вкратце, индексы создаются для повышения производительности поиска данных. Таблицы могут иметь огромное количество строк,
 которые хранятся в произвольном порядке. Без индекса поиск нужных строк идёт по порядку (последовательно), что на
 больших объемах данных отнимает много времени.

 Индекс - обычно один или несколько столбцов таблицы и указателей на соответствующие строки таблицы, позволяет искать
 строки, удовлетворяющие критерию поиска. Ускорение работы с использованием индексов достигается в первую очередь за
 счёт того, что индекс имеет структуру, оптимизированную под поиск — например, в MySQL b-дерева. Индекс лучше
 использовать на тех столбцах таблицы, на которые вы чаще всего будете накладывать условия через where column_name = ...

 Индекс создаётся по правилу:

 create index название_индекса
 on название_таблицы (название_столбца)

 Например, у вас таблица называется test, где хранятся данные по городам России с улицами вида Город, Улица, Дом.Понятно,
 что строк в таблице при таком раскладе будет много. Если вы часто делаете выборку по определенному городу, например:

 select *
 from test
 where city = 'Омск'

 то, чтобы этот запрос отработал быстрее обычного, следует добавить индекс по вышеуказанному правилу:

 create index city_index
 on test (city)

 Тогда тот же самый запрос

 select *
 from test
 where city = 'Омск'

 отработает гораздо быстрее, если столбец city будет проиндексирован.


 Внешний ключ - это столбец для соединения с другими таблицами.
 Индекс - столбец, по которому можно задать условие и тогда запрос отработает гораздо быстрее.


 -- Ответ 3:
 На пальцах можно объяснить так:

 Когда Вы создаёте таблицу, добавляете в неё данные, то таблица разрастается и она выглядит как просто последовательный
 список, упорядоченный по тому как в неё данные добавлялись.

 Когда данных мало, список маленький и все запросы к ней выполняются, почти, незаметно. Но когда количество записей в
 таблице начинает переваливать за миллион (в разных случаях по разному, но как пример миллион), то у Вас поиск уже идёт
 не так быстро и с добавлением всё новых и новых записей - ещё медленнее.

 Это связано с тем, что когда Вы ищите какую-то запись, то просматриваются все записи, пока не дойдут до нужной.

 Когда Вам это окончательно надоедает и Вы хотите что-нибудь сделать, то к Вам на помощь приходят индексы.

 Индекс создаётся по какому-то определённому полю (можно по нескольким) по которому, обычно, выполняется поиск.
 Когда Вы создаёте индекс, то MySql (и любая другая БД) обходит все записи в таблице и строит дерево
 (скорее всего B-дерево или разновидность), в котором ключами выступает выбранное поле, а содержимым ссылки на записи в таблице.

 И когда Вы делаете очередной свой select запрос по таблице, по полю для которого создали индекс MySql
 (и любая другая БД) знает что у неё есть индекс, по которому пройтись будет быстрее, нежели перебирать все записи и
 Ваш запрос будет направлен этому индексу и записи, удовлетворяющие условию, будут найдены гораздо быстрее, так как
 поиск по построенному дереву будет гораздо быстрее, нежели простой перебор всех записей.

 B-Tree индекс дает скорость выборки порядка O(log n): Логарифмическая сложность
 hash в среднем обеспечивают скорость выборки O(1):  Константная сложность.   если происходит множество коллизий  линейную O(n).

 Таким образом:
- B-Tree обеспечивает логарифмическую сложность O(log n) при поиске.
- Хэш-индексы в среднем обеспечивают постоянную сложность O(1) для поиска, но могут достигать до O(n) в худшем случае при наличии коллизий.

 Важно также отметить, что хэш-индексы НЕ поддерживают диапазонный поиск, в отличие от B-Tree.

 В реальной жизни hash и B-Tree применяются совместно, то есть для вычисления значений B-Tree индекса все равно применяются хэши.

 ### Сравнение   B-Tree vs Hash:

 - **Производительность**:
  B-Tree лучше для операций, требующих диапазонного поиска, тогда как
  хэш-индексы оптимальны для точных совпадений.

 - **Структурные особенности**:
  B-Tree — это сбалансированная структура, которая остается упорядоченной, в то время как хэш-индексы НЕ упорядочены.

 - **Гибкость**:
  B-Tree более универсален и подходит для разнообразных типов запросов, в то время как хэш-индексы более узкоспециализированы.

 В зависимости от конкретных задач и типов запросов, СУБД может использовать один или оба типа индексов.

  -- Кластерные индексы vs Обычные индексы --

 - Кластерные индексы лучше подходят — для операций с диапазонами
 - НЕкластерные индексы              — для выборок по конкретным значениям.


 | Аспект                 | Кластерные индексы                           | Некластерные индексы
 |------------------------|----------------------------------------------|------------------------------------------------
 | **Структура**          | Определяет физический порядок хранения строк.| Создает отдельную структуру с указателями на строки.
 | **Количество**         | Только один на таблицу.                      | Много на таблицу.
 | **Производительность** | Быстрый для диапазонных запросов.            | Быстрый для точных запросов.
 | **Обновления**         | Более затратные при изменениях данных.       | Менее затратные операции при изменениях.

  Кластерные индексы играют важную роль в оптимизации производительности базы данных за счет упорядочивания данных.

 -- END Что такое ИНДЕКСЫ в SQL и как их использовать --


 -- Что такое Транзакции в SQL Атомарное действие --

 Транзакция, если по-простому - это совокупность неких действий, причем такая, что либо все эти действия
 выполняются успешно, либо ни одно не выполняется вообще.

 Соответственно, транзакция в sql - это последовательность операторов, которая либо выполняется целиком, либо целиком
 же откатывается. (почитайте про ключевые слова TRANSACTION, COMMIT, ROLLBACK)

 TCL (Transaction Control Language)
 BEGIN TRANSACTION    — начало транзакции.
 COMMIT TRANSACTION   — изменение команд транзакции.
 ROLLBACK TRANSACTION — отказ в транзакции.
 SAVE TRANSACTION     — формирование промежуточной точки сохранения внутри

 Транзакции в SQL — это набор операций, которые выполняются как единое целое. Они обеспечивают атомарность,
 консистентность, изолированность и долговечность (ACID-принципы). Это значит, что либо все операции в транзакции
 выполняются успешно, либо, в случае ошибки, все изменения отменяются.

 -- ACID-принципы --
 ACID — это набор свойств, которые гарантируют надежность транзакций в системах управления базами данных (СУБД).

 ACID расшифровывается как:

 1. **Atomicity (Атомарность)**: Транзакция выполняется полностью или не выполняется вообще. Частичные изменения не допустимы.

 2. **Consistency (Согласованность)**: Транзакция переводит базу данных из одного согласованного состояния в другое.
    Это означает, что все бизнес-правила и ограничения базы данных должны соблюдаться.

 3. **Isolation (Изолированность)**: Одновременно выполняющиеся транзакции не влияют друг на друга.
    Результаты транзакции не доступны другим до её завершения.

 4. **Durability (Надежность)**: После завершения транзакции её изменения сохраняются в базе данных, даже в случае сбоя системы.

 Эти свойства помогают обеспечить надежность и целостность данных в реляционных базах данных.


  -- CAP теорема --
 CAP теорема (или теорема CAP) — это концепция, которая описывает баланс между тремя важными свойствами распределённых
  вычислений в системах хранения данных:

 1. **Consistency (Согласованность)**: Все узлы системы видят одни и те же данные в одно и то же время. Это значит,
  что после успешного завершения операции все пользователи будут видеть обновленные данные.

 2. **Availability (Доступность)**: Каждый запрос к системе получает ответ, даже если некоторые узлы недоступны.
  Система всегда отвечает, но не обязательно корректно.

 3. **Partition Tolerance (Устойчивость к разделению)**: Система продолжает функционировать даже в случае сетевых
  разделений, когда узлы не могут обмениваться данными.

 Согласно теореме CAP, в любой распределенной системе можно одновременно гарантировать только два из трёх свойств:

 - Если вы стремитесь к **согласованности** и **доступности**, у вас может возникнуть проблема при сетевом разделении (Partition).
 - Если вы стремитесь к **доступности** и **устойчивости к разделению**, вы можете потерять **согласованность**.
 - Если вы пытаетесь обеспечить **согласованность** и **устойчивость к разделению**, вы можете столкнуться с проблемами
   в **доступности**.

 Таким образом, теорема CAP помогает разработчикам и архитекторам систем понимать компромиссы, которые необходимо
 учитывать при проектировании распределенных систем.


 ### Пример транзакции:

 Предположим, у нас есть две таблицы: `Accounts` (для учета балансов пользователей) и `Transactions` (для учета сделанных транзакций).

 #### 1. Создание таблиц

 sql
 CREATE TABLE Accounts (
     AccountID INT PRIMARY KEY,
     Balance DECIMAL(10, 2)
 );

 CREATE TABLE Transactions (
     TransactionID INT PRIMARY KEY AUTO_INCREMENT,
     FromAccount INT,
     ToAccount INT,
     Amount DECIMAL(10, 2),
     TransactionDate DATETIME DEFAULT CURRENT_TIMESTAMP
 );


 #### 2. Пример транзакции

 Предположим, мы хотим перевести 100 единиц денег от одного аккаунта к другому:

 sql
 BEGIN;

 UPDATE Accounts
 SET Balance = Balance - 100
 WHERE AccountID = 1;

 UPDATE Accounts
 SET Balance = Balance + 100
 WHERE AccountID = 2;

 INSERT INTO Transactions (FromAccount, ToAccount, Amount)
 VALUES (1, 2, 100);

 COMMIT;


 ### Объяснение:

 1. **BEGIN**  - Начинает транзакцию.
 2. **UPDATE** - Первое обновление уменьшает баланс первого аккаунта.
 3. **UPDATE** - Второе обновление увеличивает баланс второго аккаунта.
 4. **INSERT** - Записывает информацию о транзакции в таблицу `Transactions`.
 5. **COMMIT** - Подтверждает все изменения, сделанные в рамках транзакции.

 Если на каком-то этапе возникает ошибка (например, недостаточно средств на первом аккаунте), можно выполнить `ROLLBACK`,
 чтобы отменить все изменения, сделанные в транзакции.

 -- END Что такое Транзакции в SQL Атомарное действие --


 -- COALESCE    COALESCE(value1, value2, ..., valueN) --

 COALESCE — это функция в SQL, которая возвращает первый ненулевой аргумент из списка.
 Если все аргументы равны NULL, функция вернет NULL.

 # Пример
 Предположим, у нас есть таблица `employees`:

 | id | name    | bonus  |
 |----|---------|--------|
 | 1  | Alice   | NULL   |
 | 2  | Bob     | 500    |
 | 3  | Charlie | NULL   |

 **Запрос с использованием `COALESCE`:**
 SELECT name, COALESCE(bonus, 1000) AS effective_bonus
 FROM employees;

 **Результат

 | name    | effective_bonus  |
 |---------|------------------|
 | Alice   | 1000             |
 | Bob     | 500              |
 | Charlie | 1000             |

 ### Объяснение:
 В этом примере `COALESCE(bonus, 1000)` возвращает значение `bonus`, если оно ненулевое; если `bonus` — это `NULL`, то
 возвращается значение `1000`. Таким образом, `effective_bonus` для `Alice` и `Charlie` будет `1000`, а для `Bob` — `500`



 Виртуальная таблица(Вьюха) - не имеет физического табличного представления в базе данных. Ее данные формируются в момент
 выполнения запроса на основе других реальных таблиц базы данных.

 Виртуальная таблица - Таблица созданная на основе источника посредством выполнения запроса.
 Итак, вьюшка – это просто запрос на языке SQL, который выбирает данные, а в базе данных она выглядит как таблица
 и работа с ней происходит также.

 Чем View отличается от таблицы?
 View — виртуальная (логическая) таблица, представляющая собой поименованный запрос (синоним к запросу), который будет
 подставлен как подзапрос при использовании представления. В отличие от обычных таблиц реляционных баз данных,
 представление не является самостоятельной частью набора данных, хранящегося в базе.

 Таблица содержит данные, Представление(View) — это просто оператор SELECT, который был сохранен в базе данных

 Таблица — это сущность базы данных, которая хранит данные в виде строк и столбцов.
 Представление — это виртуальная таблица, используемая для просмотра или манипулирования некоторыми частями таблицы .

 Представление(View) является результатом SQL-запроса и представляет собой виртуальную таблицу, тогда как таблица состоит из
 строк и столбцов, которые хранят информацию о любом объекте и используются для извлечения этих данных по мере необходимости.



 --- Разница между Joins Сравнение Joins ---

 В SQL существует несколько типов соединений (joins), которые позволяют объединять данные из разных таблиц.
 Вот краткое описание основных типов соединений и их разница:

 1. **INNER JOIN**:
 - Возвращает только те строки, которые имеют совпадения в обеих таблицах.
 - Например, если в таблицах A и B есть совпадающие значения, то только они будут включены в результат.

 2. **LEFT JOIN (или LEFT OUTER JOIN)**:
 - Возвращает все строки из левой таблицы и совпадающие строки из правой таблицы.
 - Если совпадений нет, в результатах будут NULL-значения для правой таблицы.

 3. **RIGHT JOIN (или RIGHT OUTER JOIN)**:
 - Возвращает все строки из правой таблицы и совпадающие строки из левой таблицы.
 - Если совпадений нет, в результатах будут NULL-значения для левой таблицы.

 4. **FULL JOIN (или FULL OUTER JOIN)**:
 - Возвращает все строки из обеих таблиц.
 - Если для какой-то строки нет совпадений, в соответствующих местах будут NULL-значения.

 5. **CROSS JOIN**:
 - Возвращает декартово произведение строк двух таблиц, т.е. все возможные сочетания строк из обеих таблиц.

 6. **SELF JOIN**:
 - Это соединение таблицы самой с собой. Используется для сравнения строк в одной таблице.



 Оконные функции SQL:
 Оконная функция вычисляет значение по набору данных, связанных с текущей строкой, то есть данные из одной группы,
 если используется Partition by.


 `PARTITION BY` в SQL — это предложение, используемое в оконных функциях для разделения набора строк на более мелкие
 подгруппы (партиции) перед применением функции.

 Оконные функции в SQL — это функции, которые позволяют выполнять вычисления по наборам строк, связанным с текущей
 строкой, не сводя их в одну строку, как это делает, например, агрегатная функция. Они "окружают" строки и позволяют
 выполнять аналитику, сохраняя при этом все строки в результирующем наборе. Оконные функции особенно полезны для
 вычисления скользящих средних, рангов, сумм и т.д.


 Пример:
 SELECT
     id,
     amount,
     sale_date,
     SUM(amount) OVER (ORDER BY sale_date) AS cumulative_sum
 FROM
     sales;

 ### Объяснение:

 - `SUM(amount)`: Это оконная функция, которая вычисляет сумму по столбцу `amount`.
 - `OVER (ORDER BY sale_date)`: Это определяет "окно" для функции, указывая, что суммы должны быть рассчитаны в порядке дат.


 DDL (Data Definition Language)
 CREATE  — создание нового объекта в существующей базе.
 ALTER   — изменение существующего объекта.
 DROP    — удаление объекта из базы.

 DML (Data Manipulation Language)
 SELECT — позволяет выбрать данные в соответствии с необходимым условием.
 INSERT — осуществляют добавление новых данных.
 UPDATE — производит замену существующих данных.
 DELETE — удаление информации.

 DCL (Data Control Language)
 GRANT  — предоставляет доступ к объекту.
 REVOKE — аннулирует выданное ранее разрешение на доступ.
 DENY   — запрет, который прекращает действие разрешения.

 TCL (Transaction Control Language)
 BEGIN TRANSACTION    — начало транзакции.
 COMMIT TRANSACTION   — изменение команд транзакции.
 ROLLBACK TRANSACTION — отказ в транзакции.
 SAVE TRANSACTION     — формирование промежуточной точки сохранения внутри

 Операторы сравнения SQL:    = , != <>, >, <, >=, <=, !<, !>

 Логические операторы:
 ALL	    TRUE, если все сравнения в наборе равны TRUE.
 ANY	    TRUE, если любое из сравнений в наборе равно TRUE.
 AND	    TRUE, если оба выражения типа Boolean равны TRUE.
 BETWEEN	TRUE, если операнд принадлежит указанному диапазону.
 EXISTS	    TRUE, если вложенный запрос возвращает как минимум одну строку.
 IN	        TRUE, если операнд содержится в заданном списке выражений.
 LIKE	    TRUE, если оператор удовлетворяет шаблону.
 NOT    	Меняет значение оператора типа Boolean на противоположное.
 OR	        TRUE, если одно из выражений типа Boolean равно TRUE.
 IS NULL    позволяет проверить значение поля на NULL.
 UNIQUE     позволяет проверить уникальность каждой строки.

 SOME	    TRUE, если некоторые из сравнений в наборе равны TRUE.   Ключевые слова SOME и ANY эквивалентны.


 # Как начать работу с SQL
 SELECT    — выбор данных.
 FROM      — источник информации, откуда брать данные.
 JOIN      — добавление таблиц.
 WHERE     — при каком условии.
 GROUP BY  — сформируй группу данных по заданному признаку.
 ORDER BY  — сортировка данных по нужному признаку.
 LIMIT     — количество результатов.
 ;         — конец предложения


 Чтобы в Pycharm Создать SQL file: Создает текстовый файл с расширением .sql или .SQL

 Как закомментировать код в SQL?  Ставим -- перед
 select * from book
 -- where amount = 3 and price >= 500

 Как в СЕРЕДИНЕ закомментировать код в SQL?  Оборачиваем в /* */
 select * from book
 where amount = 3 /* and price >= 500 */


 Проверка на bool   Как в Python  print('1' if True else '0')  # -> 1

 # Тоже самое
 SELECT * FROM students WHERE IsActive;
 SELECT * FROM students WHERE isActive = 1;
 SELECT * FROM students WHERE not not IsActive;
 select * from students where students.isActive = 1
 Select * FROM students WHERE IsActive == 1;
 Select * FROM students WHERE isActive <> 0;

 WITH позволяет дать блоку подзапроса имя/псевдоним, на которое можно ссылаться в нескольких местах основного SQL-запроса.
 Имя, присвоенное подзапросу, обрабатывается так, как если бы оно было встроенным представлением или таблицей.
 SQL оператор WITH по сути является заменой обычному подзапросу.

 Cинтаксис Oracle PL/SQL WITH с одним подзапросом:
 WITH query_name AS (SELECT expressions FROM table_A)

 SELECT column_list

   FROM query_name [,table_name]

 [WHERE conditions]


 Что такое обобщенное табличное выражение?
 это простой способ разбить сложный запрос T-SQL на несколько запросов, что придаёт больше гибкости и управляемости.
 CTE во многом очень похожи на представления.

 CTE (Common Table Expression) в SQL — это временный результат, который можно использовать внутри оператора
 `SELECT`, `INSERT`, `UPDATE` или `DELETE`. CTE позволяет структурировать сложные запросы и повышать их читаемость.
 CTE объявляется с помощью оператора `WITH`, за которым следует определение имени CTE и его запроса.

 Пример использования CTE:

 WITH SalesCTE AS (
     SELECT ProductID, SUM(Quantity) AS TotalSales
     FROM Sales
     GROUP BY ProductID
 )
 SELECT *
 FROM SalesCTE
 WHERE TotalSales > 100;

 В этом примере CTE `SalesCTE` вычисляет общие продажи по продуктам, которые затем могут быть использованы в основном запросе.


 # Регулярки в SQL

 SELECT ... WHERE title REGEXP BINARY '^(An?|The) +'; -- MySQL

 SELECT ... WHERE REGEXP_LIKE(title, '^(An?|The) +', 'c'); -- Oracle

 SELECT ... WHERE title ~ '^(An?|The) +'; -- PostgreSQL

 SELECT ... WHERE title REGEXP '^(An?|The) +'; -- SQLite


 Создание таблицы book со столбцами определенного типа данных

 CREATE TABLE book(
    book_id INT PRIMARY KEY AUTO_INCREMENT,    # id  pk primary key
    title VARCHAR(50),                         # str
    author VARCHAR(30),                        # str
    price DECIMAL(8, 2),                       # decimal
    amount INT                                 # int
);

 # Вставка записи в таблицу
 INSERT INTO book (book_id,	title,	author,	price,	amount)             # Столбцы
 VALUES
    ('1', 'Мастер и Маргарита','Булгаков М.А.','670.99', '3');          # Значения

 +---------+--------------------+---------------+--------+--------+
 | book_id | title              | author        | price  | amount |
 +---------+--------------------+---------------+--------+--------+
 | 1       | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3      |
 +---------+--------------------+---------------+--------+--------+


 # Занесите три последние записи в таблицу book,  первая запись уже добавлена на предыдущем шаге:

 INSERT INTO book (title, author, price, amount)
 VALUES
     ('Белая гвардия', 'Булгаков М.А.', 540.50 , 5),
     ('Идиот', 'Достоевский Ф.М.', 460, 10),
     ('Братья Карамазовы', 'Достоевский Ф.М.', 799.01, 2),
     ('Стихотворения и поэмы', 'Есенин С.А.', 650.00, 15);


 # Исходная таблица
 +---------+-----------------------+------------------+--------+--------+
 | book_id | title                 | author           | price  | amount |
 +---------+-----------------------+------------------+--------+--------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
 | 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
 +---------+-----------------------+------------------+--------+--------+


 # Мы выбираем столбцы title, author, amount из Таблицы book
 SELECT title, author, amount  FROM book

 # Тоже самое
 SELECT (title), (author), (amount)  FROM book

 # Выбрать все поля из Таблицы book
 SELECT * FROM book

 +-----------------------+------------------+--------+
 | title                 | author           | amount |
 +-----------------------+------------------+--------+
 | Мастер и Маргарита    | Булгаков М.А.    | 3      |
 | Белая гвардия         | Булгаков М.А.    | 5      |
 | Идиот                 | Достоевский Ф.М. | 10     |
 | Братья Карамазовы     | Достоевский Ф.М. | 2      |
 | Стихотворения и поэмы | Есенин С.А.      | 15     |
 +-----------------------+------------------+--------+

 # Оператор WITH - Псевдоним
 WITH NEW_NAME AS (SELECT author , title, price FROM book)
    SELECT * from NEW_NAME

 +------------------+-----------------------+--------+
 | author           | title                 | price  |
 +------------------+-----------------------+--------+
 | Булгаков М.А.    | Мастер и Маргарита    | 670.99 |
 | Булгаков М.А.    | Белая гвардия         | 540.50 |
 | Достоевский Ф.М. | Идиот                 | 460.00 |
 | Достоевский Ф.М. | Братья Карамазовы     | 799.01 |
 | Есенин С.А.      | Стихотворения и поэмы | 650.00 |
 +------------------+-----------------------+--------+


 # Просто дать любое название
 SELECT 'Привет, мир!' AS result, title from book

 +--------------+-----------------------+
 | result       | title                 |
 +--------------+-----------------------+
 | Привет, мир! | Мастер и Маргарита    |
 | Привет, мир! | Белая гвардия         |
 | Привет, мир! | Идиот                 |
 | Привет, мир! | Братья Карамазовы     |
 | Привет, мир! | Игрок                 |
 | Привет, мир! | Стихотворения и поэмы |
 +--------------+-----------------------+



 # AS дать название
 # if author=='Булгаков М.А.' то выводим 100 if author=='Есенин С.А.' то выводим 200 else price
 SELECT author, title,
      IF(author='Булгаков М.А.', 100, IF(author='Есенин С.А.', 200, price)) AS new_price  FROM book

 +------------------+-----------------------+-----------+
 | author           | title                 | new_price |
 +------------------+-----------------------+-----------+
 | Булгаков М.А.    | Мастер и Маргарита    | 100       |
 | Булгаков М.А.    | Белая гвардия         | 100       |
 | Достоевский Ф.М. | Идиот                 | 460.00    |
 | Достоевский Ф.М. | Братья Карамазовы     | 799.01    |
 | Есенин С.А.      | Стихотворения и поэмы | 200       |
 +------------------+-----------------------+-----------+


 # Округление с условиями
 SELECT author, title,
     ROUND(IF(author='Булгаков М.А.', price+price*0.10, IF(author='Есенин С.А.', price+price*0.05, price)), 2)
      AS new_price  FROM book

 # Тоже самое
 select author, title,
 round(case author
     when "Булгаков М.А." then price * 1.1
     when "Есенин С.А." then price * 1.05
     else price end, 2) as new_price
 from book

 +------------------+-----------------------+-----------+
 | author           | title                 | new_price |
 +------------------+-----------------------+-----------+
 | Булгаков М.А.    | Мастер и Маргарита    | 738.09    |
 | Булгаков М.А.    | Белая гвардия         | 594.55    |
 | Достоевский Ф.М. | Идиот                 | 460.00    |
 | Достоевский Ф.М. | Братья Карамазовы     | 799.01    |
 | Есенин С.А.      | Стихотворения и поэмы | 682.50    |
 +------------------+-----------------------+-----------+


 # Вывести автора, название  и цены тех книг, количество которых меньше 10.
 SELECT author, title, price FROM book
     where amount < 10

 +------------------+--------------------+--------+
 | author           | title              | price  |
 +------------------+--------------------+--------+
 | Булгаков М.А.    | Мастер и Маргарита | 670.99 |
 | Булгаков М.А.    | Белая гвардия      | 540.50 |
 | Достоевский Ф.М. | Братья Карамазовы  | 799.01 |
 +------------------+--------------------+--------+


 # Вывести название, автора,  цену  и количество всех книг, цена которых меньше 500 или больше 600, а стоимость всех
 экземпляров этих книг больше или равна 5000.
 select title, author, price, amount from book
     where (author < 500 or author > 600) and price * amount >= 5000

 # Тоже самое
 select title, author, price, amount from book
     where (author < 500 || author > 600) && price * amount >= 5000

 +-----------------------+-------------+--------+--------+
 | title                 | author      | price  | amount |
 +-----------------------+-------------+--------+--------+
 | Стихотворения и поэмы | Есенин С.А. | 650.00 | 15     |
 +-----------------------+-------------+--------+--------+


 # Выбрать названия и количества тех книг, количество которых от 5 до 14 включительно.

 # Тоже самое                           # Тоже самое
 SELECT title, amount                   SELECT title, amount
 FROM book                              FROM book
 WHERE amount BETWEEN 5 AND 14;         WHERE amount >= 5 AND amount <=14;

 +---------------+--------+
 | title         | amount |
 +---------------+--------+
 | Белая гвардия | 5      |
 | Идиот         | 10     |
 +---------------+--------+


 # Вывести название и авторов тех книг, цены которых принадлежат интервалу от 540.50 до 800 (включая границы),
 а количество или 2, или 3, или 5, или 7 .

 # BETWEEN в диапазоне аналог range включая его границы
 select title, author from book
     where price between 540.50 and 800 and amount in (2, 3, 5, 7)

  # IN и BETWEEN выполняются раньше and, поэтому скобки писать не обязательно
 select title, author from book
    where price (between 540.50 and 800) and (amount in (2, 3, 5, 7));

 +--------------------+------------------+
 | title              | author           |
 +--------------------+------------------+
 | Мастер и Маргарита | Булгаков М.А.    |
 | Белая гвардия      | Булгаков М.А.    |
 | Братья Карамазовы  | Достоевский Ф.М. |
 +--------------------+------------------+


 # Вывести  автора и название  книг, количество которых принадлежит интервалу от 2 до 14 (включая границы). Информацию
 отсортировать сначала по авторам (в обратном алфавитном порядке), а затем по названиям книг (по алфавиту).

 # ASC - (по возрастанию),  DESC - (по убыванию)
 select author, title from book
    where amount between 2 and 14
    ORDER BY author DESC, title asc;

 +------------------+--------------------+
 | author           | title              |
 +------------------+--------------------+
 | Достоевский Ф.М. | Братья Карамазовы  |
 | Достоевский Ф.М. | Идиот              |
 | Булгаков М.А.    | Белая гвардия      |
 | Булгаков М.А.    | Мастер и Маргарита |
 +------------------+--------------------+
________________________________________________________________________________________________________________________


 # Исходная таблица
 +---------+-----------------------+------------------+--------+--------+
 | book_id | title                 | author           | price  | amount |
 +---------+-----------------------+------------------+--------+--------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
 | 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
 | 6       |                       | Иванов С.С.      | 50.00  | 10     |
 | 7       | Дети полуночи         | Рушди Салман     | 950.00 | 5      |
 | 8       | Лирика                | Гумилев Н.С.     | 460.00 | 10     |
 | 9       | Поэмы                 | Бехтерев С.С.    | 460.00 | 10     |
 | 10      | Капитанская дочка     | Пушкин А.С.      | 520.50 | 7      |
 +---------+-----------------------+------------------+--------+--------+


 # Вывести название и автора тех книг, название которых состоит из двух и более слов, а инициалы автора содержат букву
 «С». Считать, что в названии слова отделяются друг от друга пробелами и не содержат знаков препинания, между фамилией
 автора и инициалами обязателен пробел, инициалы записываются без пробела в формате: буква, точка, буква, точка.
 Информацию отсортировать по названию книги в алфавитном порядке.

 LIKE 'a%'     Находит любые значения, которые начинаются с "a"
 LIKE '%a'     Находит любые значения, которые заканчиваются на "a"
 LIKE '%or%'   Находит любые значения, которые имеют "or" в любой позиции
 LIKE '_r%'    Находит любые значения, имеющие букву "r" во второй позиции
 LIKE 'a__%'   Находит любые значения, начинающиеся с буквы "a" и имеющие длину не менее 3 символов
 LIKE 'a%o'    Находит любые значения, которые начинаются с "a" и заканчиваются "о"


 select title, author from book
   WHERE title like '% %' and title not like ' %' and (author like '%______ С___' or author like '%______ __С_')
   # Тоже самое но с REGEXP
   WHERE title REGEXP '(.+ .+)+' and  author REGEXP '(.+ С.А.)|(.+ А.С.)'


 # _ В like значит 1 любой символ

 +-----------------------+-------------+
 | title                 | author      |
 +-----------------------+-------------+
 | Капитанская дочка     | Пушкин А.С. |
 | Стихотворения и поэмы | Есенин С.А. |
 +-----------------------+-------------+
________________________________________________________________________________________________________________________


 # Исходная таблица
 +---------+-----------------------+------------------+--------+--------+
 | book_id | title                 | author           | price  | amount |
 +---------+-----------------------+------------------+--------+--------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 3      |
 | 5       | Игрок                 | Достоевский Ф.М. | 480.50 | 10     |
 | 6       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
 +---------+-----------------------+------------------+--------+--------+


 # Выбор уникальных элементов столбца  DISTINCT                                                                 <-----
 На самом деле это тяжёлая операция - группировка и сортировку в себя включает, на маленьких объёмах это незаметно,
 а вот на больших его лучше не использовать

 # Отобрать различные (уникальные) элементы столбца amount таблицы book.

 select distinct amount from book
 select distinct(amount) from book   # Обернуть в скобки тоже можно

 +--------+
 | amount |
 +--------+
 | 3      |
 | 5      |
 | 10     |
 | 15     |
 +--------+


 # Тоже самое но установить LIMIT

 select distinct amount from book
 limit 1

 +--------+
 | amount |
 +--------+
 | 3      |
 +--------+


 # Выборка данных, групповые функции SUM и COUNT   в GROUP BY попадает столбец без функции
 Важно! В разделе GROUP BY нужно перечислять все НЕАГРЕГИРОВАННЫЕ столбцы (к которым не применяются групповые функции) из SELECT.

 SELECT author, sum(amount), count(amount)
 FROM book
 GROUP BY author;

 +------------------+-------------+---------------+
 | author           | sum(amount) | count(amount) |
 +------------------+-------------+---------------+
 | Булгаков М.А.    | 8           | 2             |
 | Достоевский Ф.М. | 23          | 3             |
 | Есенин С.А.      | 15          | 1             |
 +------------------+-------------+---------------+


 select author as Автор, count(author) as Различных_книг, sum(amount) as Количество_экземпляров from book
     GROUP BY Автор

 +------------------+----------------+------------------------+
 | Автор            | Различных_книг | Количество_экземпляров |
 +------------------+----------------+------------------------+
 | Булгаков М.А.    | 2              | 8                      |
 | Достоевский Ф.М. | 3              | 23                     |
 | Есенин С.А.      | 1              | 15                     |
 +------------------+----------------+------------------------+


 # посчитать уникальные наименования
 SELECT
     author,
     COUNT(DISTINCT title)
 FROM book
 GROUP BY author;

 +------------------+-----------------------+
 | author           | COUNT(DISTINCT title) |
 +------------------+-----------------------+
 | Булгаков М.А.    | 2                     |
 | Достоевский Ф.М. | 3                     |
 | Есенин С.А.      | 1                     |
 +------------------+-----------------------+


 # Выборка данных, групповые функции MIN, MAX и AVG

 SELECT author, MIN(price) AS Минимальная_цена, MAX(price) AS Максимальная_цена, AVG(price) AS Средняя_цена
 FROM book
 GROUP BY author;

 +------------------+------------------+-------------------+--------------+
 | author           | Минимальная_цена | Максимальная_цена | Средняя_цена |
 +------------------+------------------+-------------------+--------------+
 | Булгаков М.А.    | 540.50           | 670.99            | 605.745000   |
 | Достоевский Ф.М. | 460.00           | 799.01            | 579.836667   |
 | Есенин С.А.      | 650.00           | 650.00            | 650.000000   |
 +------------------+------------------+-------------------+--------------+


 # Выборка данных c вычислением, групповые функции
 SELECT MIN(price) AS Минимальная_цена, MAX(price) AS Максимальная_цена, ROUND(AVG(price), 2) AS Средняя_цена
 FROM book

 +------------------+-------------------+--------------+
 | Минимальная_цена | Максимальная_цена | Средняя_цена |
 +------------------+-------------------+--------------+
 | 460.00           | 799.01            | 600.17       |
 +------------------+-------------------+--------------+


 # Вычислить среднюю цену и суммарную стоимость тех книг, количество экземпляров которых принадлежит интервалу
 от 5 до 14, включительно. Столбцы назвать Средняя_цена и Стоимость, значения округлить до 2-х знаков после запятой.

 SELECT
     ROUND(AVG(price), 2) as Средняя_цена,
     ROUND(SUM(price * amount), 2) as Стоимость     # Внимание на запятую она тут не нужна
 FROM book
 where amount BETWEEN 5 AND 14

 +--------------+-----------+
 | Средняя_цена | Стоимость |
 +--------------+-----------+
 | 493.67       | 12107.50  |
 +--------------+-----------+


 # Пример
 SELECT author,
     MIN(price) AS Минимальная_цена,
     MAX(price) AS Максимальная_цена               # Внимание на запятую она тут не нужна
 FROM book
 GROUP BY author
 HAVING SUM(price * amount) > 5000;

 +------------------+------------------+-------------------+
 | author           | Минимальная_цена | Максимальная_цена |
 +------------------+------------------+-------------------+
 | Достоевский Ф.М. | 460.00           | 799.01            |
 | Есенин С.А.      | 650.00           | 650.00            |
 +------------------+------------------+-------------------+


 # Посчитать стоимость всех экземпляров каждого автора без учета книг «Идиот» и «Белая гвардия».
 В результат включить только тех авторов, у которых суммарная стоимость книг (без учета книг «Идиот» и «Белая гвардия»)
 более 5000 руб. Вычисляемый столбец назвать Стоимость. Результат отсортировать по убыванию стоимости.

 <>  то же самое что и !=

 # Тоже самое                                              # Тоже самое
 SELECT author,                                            SELECT author,
     SUM(price*amount) AS Стоимость                            SUM(price*amount) AS Стоимость
 FROM book                                                 FROM book
 WHERE title != 'Идиот' and title != 'Белая гвардия'       WHERE title <> 'Идиот' and title <> 'Белая гвардия'
 GROUP BY author                                           GROUP BY author
 HAVING SUM(price*amount) > 5000                           HAVING Стоимость > 5000
 order by Стоимость desc                                   order by Стоимость desc

 # Тоже самое Но лучше конечно not in
 select author, sum(price*amount) as Стоимость
 from book
 where title not in ('Идиот', 'Белая гвардия')
 group by author
 having Стоимость > 5000
 order by Стоимость desc

 +------------------+-----------+
 | author           | Стоимость |
 +------------------+-----------+
 | Есенин С.А.      | 9750.00   |
 | Достоевский Ф.М. | 7202.03   |
 +------------------+-----------+


 # Вложенный запрос, возвращающий одно значение

 SELECT title, author, price, amount
 FROM book
 WHERE price = (
          SELECT MIN(price)
          FROM book
       );                                               # ; Означает конец выражения

 +-------+------------------+--------+--------+
 | title | author           | price  | amount |
 +-------+------------------+--------+--------+
 | Идиот | Достоевский Ф.М. | 460.00 | 10     |
 +-------+------------------+--------+--------+


 # Вывести информацию (автора, название и цену) о  книгах, цены которых меньше или равны средней цене книг на складе.
 Информацию вывести в отсортированном по убыванию цены виде. Среднее вычислить как среднее по цене книги.

 SELECT author, title, price
 FROM book
 WHERE price <= (
          SELECT avg(price)
          FROM book
       )
 order by price desc

 +------------------+---------------+--------+
 | author           | title         | price  |
 +------------------+---------------+--------+
 | Булгаков М.А.    | Белая гвардия | 540.50 |
 | Достоевский Ф.М. | Игрок         | 480.50 |
 | Достоевский Ф.М. | Идиот         | 460.00 |
 +------------------+---------------+--------+


 # Использование вложенного запроса в выражении

 # То есть нужно вывести и те книги, количество экземпляров которых меньше среднего на 3, или больше среднего на 3.
 SELECT title, author, amount
 FROM book
 WHERE ABS(amount - (SELECT AVG(amount) FROM book)) > 3;

 +-----------------------+------------------+--------+
 | title                 | author           | amount |
 +-----------------------+------------------+--------+
 | Мастер и Маргарита    | Булгаков М.А.    | 3      |
 | Братья Карамазовы     | Достоевский Ф.М. | 3      |
 | Стихотворения и поэмы | Есенин С.А.      | 15     |
 +-----------------------+------------------+--------+


 # Вывести информацию (автора, название и цену) о тех книгах, цены которых превышают минимальную цену книги на складе
 не более чем на 150 рублей в отсортированном по возрастанию цены виде.

 SELECT author, title, price
 FROM book
 WHERE (price - (SELECT min(price) FROM book)) <= 150
 order by price

 +------------------+----------------+--------+
 | author           | title          | price  |
 +------------------+----------------+--------+
 | Достоевский Ф.М. | Идиот          | 460.00 |
 | Достоевский Ф.М. | Игрок          | 480.50 |
 | Булгаков М.А.    | Белая гвардия  | 540.50 |
 | Пушкин А.С.      | Евгений Онегин | 610.00 |
 +------------------+----------------+--------+


 # Вывести информацию (автора, книгу и количество) о тех книгах, количество экземпляров которых в таблице book не дублируется.
 SELECT author, title, amount
 FROM book
 WHERE amount NOT IN (
         SELECT amount
         FROM book
         GROUP BY amount
         HAVING COUNT(amount) != 1
       )

 +---------------+-----------------------+--------+
 | author        | title                 | amount |
 +---------------+-----------------------+--------+
 | Булгаков М.А. | Белая гвардия         | 5      |
 | Есенин С.А.   | Стихотворения и поэмы | 15     |
 +---------------+-----------------------+--------+


 # Вложенный запрос, операторы ANY и ALL

 SELECT title, author, amount, price
 FROM book
 WHERE amount < ALL (
         SELECT AVG(amount)
         FROM book
         GROUP BY author
       );

 +--------------------+------------------+--------+--------+
 | title              | author           | amount | price  |
 +--------------------+------------------+--------+--------+
 | Мастер и Маргарита | Булгаков М.А.    | 3      | 670.99 |
 | Братья Карамазовы  | Достоевский Ф.М. | 3      | 799.01 |
 +--------------------+------------------+--------+--------+
________________________________________________________________________________________________________________________

 # Таблица book
 +---------+-----------------------+------------------+--------+--------+
 | book_id | title                 | author           | price  | amount |
 +---------+-----------------------+------------------+--------+--------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
 | 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
 +---------+-----------------------+------------------+--------+--------+

  # Таблица supply
 +-----------+----------------+------------------+--------+--------+
 | supply_id | title          | author           | price  | amount |
 +-----------+----------------+------------------+--------+--------+
 | 1         | Лирика         | Пастернак Б.Л.   | 518.99 | 2      |
 | 2         | Черный человек | Есенин С.А.      | 570.20 | 6      |
 | 3         | Белая гвардия  | Булгаков М.А.    | 540.50 | 7      |
 | 4         | Идиот          | Достоевский Ф.М. | 360.80 | 3      |
 +-----------+----------------+------------------+--------+--------+

 # Занести из таблицы supply в таблицу book только те книги, авторов которых нет в  book.


 INSERT INTO book (title, author, price, amount)
 SELECT title, author, price, amount
 FROM supply
 WHERE author NOT IN (SELECT DISTINCT author
         FROM book);

 SELECT * FROM book;

 +---------+-----------------------+------------------+--------+--------+
 | book_id | title                 | author           | price  | amount |
 +---------+-----------------------+------------------+--------+--------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
 | 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
 | 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
 +---------+-----------------------+------------------+--------+--------+


 # Обновить Таблицу Заменить значения одного столбца
 UPDATE book
 SET amount = 19;

 select * from book

 +---------+-----------------------+------------------+--------+--------+
 | book_id | title                 | author           | price  | amount |
 +---------+-----------------------+------------------+--------+--------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 19     |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 19     |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 19     |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 19     |
 | 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 19     |
 +---------+-----------------------+------------------+--------+--------+


 # Добавить КОЛОНКУ в запросе SQL   ALTER - Может много чего
 ALTER TABLE book
 ADD Address VARCHAR(50) NOT NULL DEFAULT 'Неизвестно';

 SELECT * FROM book;

 +---------+-----------------------+------------------+--------+--------+------------+
 | book_id | title                 | author           | price  | amount | Address    |
 +---------+-----------------------+------------------+--------+--------+------------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      | Неизвестно |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      | Неизвестно |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     | Неизвестно |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      | Неизвестно |
 | 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     | Неизвестно |
 +---------+-----------------------+------------------+--------+--------+------------+


 # Обновить Таблицу
 UPDATE fine tv
 SET tv.sum_fine = (
     SELECT v.sum_fine
     FROM traffic_violation v
     WHERE v.violation = tv.violation
 )
 WHERE tv.sum_fine IS NULL;



 С помощью выражения ON DELETE можно установить действия, которые выполняются для записей подчиненной таблицы
 при удалении связанной строки из главной таблицы. При удалении можно установить следующие опции:

 - CASCADE: автоматически удаляет строки из зависимой таблицы при удалении  связанных строк в главной таблице.
 - SET NULL: при удалении  связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL.
 (В этом случае столбец внешнего ключа должен поддерживать установку NULL).
 - SET DEFAULT похоже на SET NULL за тем исключением, что значение  внешнего ключа устанавливается не в NULL,
 а в значение по умолчанию для данного столбца.
 - RESTRICT: отклоняет удаление строк в главной таблице при наличии связанных строк в зависимой таблице.

 Важно! Если для столбца установлена опция SET NULL, то при его описании нельзя задать ограничение на пустое значение.

 # Создание таблицы с внешними ключами  FOREIGN KEY
 CREATE TABLE book (
     book_id INT PRIMARY KEY AUTO_INCREMENT,
     title VARCHAR(50),
     author_id INT NOT NULL,
     genre_id INT,
     price DECIMAL(8,2),
     amount INT,
     FOREIGN KEY (author_id)  REFERENCES author (author_id) ON DELETE CASCADE,
     FOREIGN KEY (genre_id) REFERENCES genre (genre_id) ON DELETE SET NULL
     );





 --- JOINS ---
 В pandas это - pandas.DataFrame.join   pandas.DataFrame.merge

 <join_type> ::=
    [ { INNER | { { LEFT | RIGHT | FULL } [ OUTER ] } } [ <join_hint> ] ]       # [] - НЕобязательное
    JOIN

 Ключевое слово OUTER отмечено как необязательное (заключено в квадратные скобки). В этом конкретном случае OUTER
 не имеет значения, указываете вы его или нет. Обратите внимание, что хотя другие элементы предложения join также
 отмечены как необязательные, их исключение будет иметь значение.

 Например, вся часть type в JOIN предложении является необязательной, в этом случае по умолчанию будет, INNER
 если вы просто укажете JOIN. Другими словами, это допустимо:

 SELECT *
 FROM A JOIN B ON A.X = B.Y

 Вот список эквивалентных синтаксисов:
 A LEFT JOIN B            A LEFT OUTER JOIN B
 A RIGHT JOIN B           A RIGHT OUTER JOIN B
 A FULL JOIN B            A FULL OUTER JOIN B
 A INNER JOIN B           A JOIN B


 На верхнем уровне в основном существуют 3 типа соединений:

 1.INNER JOIN извлекает данные, если они присутствуют в обеих таблицах.

 2.OUTER JOINs бывают 3 типов:
    1.LEFT OUTER JOIN  - извлекает данные, если они присутствуют в левой таблице.
    2.RIGHT OUTER JOIN - извлекает данные, если они присутствуют в нужной таблице.
    3.FULL OUTER JOIN  - извлекает данные, если они присутствуют в любой из двух таблиц.
 3. CROSS JOIN, как следует из названия, делает n раз m пар, которые соединяют все со всем. Это похоже на то, как мы
 просто перечисляем таблицы для соединения (в предложении FROM оператора SELECT), используя запятые для их разделения.

 Следует отметить следующее:
 - Если вы просто упомянули JOIN, то по умолчанию это INNER JOIN.
 - Соединение OUTER должно быть LEFT| RIGHT| FULL; вы не можете просто сказать OUTER JOIN.
 - Вы можете опустить OUTER ключевое слово и просто сказать LEFT JOIN или RIGHT JOIN или FULL JOIN.  <-----



  --- Pandas vs SQL ---

 -- INNER JOIN --

 SELECT *                     # Pandas
 FROM df1                     pd.merge(df1, df2, on="key")
 INNER JOIN df2
   ON df1.key = df2.key;


 merge() также предлагает параметры для случаев, когда вы хотите объединить столбец одного DataFrame с индексом другого DataFrame.
 indexed_df2 = df2.set_index("key")
 pd.merge(df1, indexed_df2, left_on="key", right_index=True)


 -- LEFT OUTER JOIN --

 SELECT *                      # Pandas
 FROM df1                      pd.merge(df1, df2, on="key", how="left")
 LEFT OUTER JOIN df2
   ON df1.key = df2.key;


 -- RIGHT JOIN --

 SELECT *                      # Pandas
 FROM df1                      pd.merge(df1, df2, on="key", how="right")
 RIGHT OUTER JOIN df2
   ON df1.key = df2.key;


 -- FULL JOIN --

 SELECT *                       # Pandas
 FROM df1                       pd.merge(df1, df2, on="key", how="outer")
 FULL OUTER JOIN df2
   ON df1.key = df2.key;





 # Соединение INNER JOIN  можно использовать просто JOIN   разницы никакой!!!
 Оператор внутреннего соединения INNER JOIN соединяет две таблицы. Порядок таблиц для оператора неважен,
 поскольку оператор является симметричным.


 # Исходные таблицы
 Таблица genre:
 +----------+-------------+
 | genre_id | name_genre  |
 +----------+-------------+
 | 1        | Роман       |
 | 2        | Поэзия      |
 | 3        | Приключения |
 +----------+-------------+

 Таблица author:
 +-----------+------------------+
 | author_id | name_author      |
 +-----------+------------------+
 | 1         | Булгаков М.А.    |
 | 2         | Достоевский Ф.М. |
 | 3         | Есенин С.А.      |
 | 4         | Пастернак Б.Л.   |
 | 5         | Лермонтов М.Ю.   |
 +-----------+------------------+

 Таблица book:
 +---------+-----------------------+-----------+----------+--------+--------+
 | book_id | title                 | author_id | genre_id | price  | amount |
 +---------+-----------------------+-----------+----------+--------+--------+
 | 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
 | 2       | Белая гвардия         | 1         | 1        | 540.50 | 5      |
 | 3       | Идиот                 | 2         | 1        | 460.00 | 10     |
 | 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
 | 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
 | 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
 | 7       | Черный человек        | 3         | 2        | 570.20 | 6      |
 | 8       | Лирика                | 4         | 2        | 518.99 | 2      |
 +---------+-----------------------+-----------+----------+--------+--------+

 # Вывести название, жанр и цену тех книг, количество которых больше 8, в отсортированном по убыванию цены виде.


 SELECT title, name_genre, price             SELECT title, name_genre, price
 FROM genre INNER JOIN book                  FROM genre g JOIN book b
      ON genre.genre_id = book.genre_id      ON g.genre_id = b.genre_id AND b.amount > 8
 WHERE amount > 8                            ORDER BY price DESC;
 ORDER BY price DESC;


 # Можно использовать  USING    book.genre_id = genre.genre_id на USING(genre_id) - записи эквивалентны

 SELECT title, name_genre, price from book
 JOIN genre USING(genre_id)
 WHERE amount > 8
 ORDER BY price DESC;

 # Моё решение
 select title, name_genre, price from book
 join genre on book.genre_id = genre.genre_id
 where amount > 8
 order by price desc



 # Внешнее соединение LEFT и RIGHT OUTER JOIN
 Оператор внешнего соединения LEFT OUTER JOIN  (можно использовать LEFT JOIN) соединяет две таблицы.
 Порядок таблиц для оператора важен, поскольку оператор не является симметричным.


 # Вывести все жанры, которые не представлены в книгах на складе.

 SELECT DISTINCT name_genre
 FROM genre LEFT JOIN book
      on genre.genre_id = book.genre_id
 WHERE title is NUll;


 # Вывести (жанр, книга, автор), относящихся к жанру, включающему слово «роман» в отсортированном по названиям книг виде.

 select name_genre, title, name_author from book      select name_genre, title, name_author from book
 JOIN genre ON book.genre_id = genre.genre_id         JOIN genre ON book.genre_id = genre.genre_id
 JOIN author ON book.author_id = author.author_id     JOIN author ON book.author_id = author.author_id
 where name_genre like '%Роман%'                      WHERE book.genre_id=1
 order by title                                       order by title


 # Лучше решения!!!
                                               # LIKE регистроНЕзависимый, всю эту конструкцию можно заменить одним WHERE LIKE '%роман%'
 SELECT name_genre, title, name_author         SELECT name_genre, title, name_author
  FROM genre g                                 FROM genre g
       INNER JOIN book b                           INNER JOIN book b ON g.genre_id=b.genre_id
       ON g.genre_id = b.genre_id                  INNER JOIN author a ON a.author_id=b.author_id
          AND g.name_genre LIKE '%_оман%'      WHERE LOWER(name_genre) RLIKE '[[:<:]]роман[[:>:]]'
       INNER JOIN author USING(author_id)      ORDER BY title
 ORDER BY title;



 # Выберите из таблицы game_events только те события, которые произошли 15 января 2021 года или позднее.
 # В выводе получите только один столбец - уникальные названия этих событий.

 select distinct event_name from game_events
 where event_date >= '2021-01-15'


 # *Агрегирующие функции (иногда их ещё называют агрегатными) обрабатывают набор строк для подсчета и возвращают одно
 # обобщенное значение: SUM, MAX, MIN, COUNT, AVG

 COUNT(*) —  подсчитывает  все записи, относящиеся к группе, в том числе и со значением NULL;
 COUNT(имя_столбца) — возвращает количество записей конкретного столбца (только NOT NULL), относящихся к группе.

 # Такой запрос всегда вернет только одно значение – количество строк в таблице, которая указана во FROM.

 SELECT COUNT(*)
 FROM game_events


 # как посчитать количество уникальных пользователей за каждый день.

 SELECT event_date, COUNT(DISTINCT user_id)
 FROM game_events
 GROUP BY event_date


 # Найти дату первого и последнего игрового события для каждого игрока.

 select user_id, min(event_date), max(event_date) from game_events
 group by user_id









 # Пример!!!
 # Исходная таблица
 +---------+-----------------------+------------------+--------+--------+
 | book_id | title                 | author           | price  | amount |
 +---------+-----------------------+------------------+--------+--------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 3      |
 | 5       | Игрок                 | Достоевский Ф.М. | 480.50 | 10     |
 | 6       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
 +---------+-----------------------+------------------+--------+--------+

 # В GROUP BY можно использовать без функций
 SELECT author
 FROM book
 GROUP BY author;

 +------------------+
 | author           |
 +------------------+
 | Булгаков М.А.    |
 | Достоевский Ф.М. |
 | Есенин С.А.      |
 +------------------+


 # Разные способы !!!                                       # Тоже самое В GROUP BY можно использовать все столбцы
 SELECT author, title, count(price), max(amount) as maxx    SELECT author, title, count(price), max(amount) as maxx
 FROM book                                                  FROM book
 GROUP BY author, title;                                    GROUP BY author, title, price, amount;

 +------------------+-----------------------+--------------+------+
 | author           | title                 | count(price) | maxx |
 +------------------+-----------------------+--------------+------+
 | Булгаков М.А.    | Мастер и Маргарита    | 1            | 3    |
 | Булгаков М.А.    | Белая гвардия         | 1            | 5    |
 | Достоевский Ф.М. | Идиот                 | 1            | 10   |
 | Достоевский Ф.М. | Братья Карамазовы     | 1            | 3    |
 | Достоевский Ф.М. | Игрок                 | 1            | 10   |
 | Есенин С.А.      | Стихотворения и поэмы | 1            | 15   |
 +------------------+-----------------------+--------------+------+


 # Вернуть чётное число в таблице или нет!     PostgreSQL 13.0
 SELECT number,
 CASE WHEN (number % 2) = 0 THEN 'Even'
 ELSE 'Odd' END AS is_even
 FROM numbers;

 # Выбор всех студентов у которых tuition_received==False      # В SQL так же работает оператор not как и в Python
 select * from students
 where not tuition_received















































































































































































































































































































































































"""