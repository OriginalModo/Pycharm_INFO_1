"""
 Порождающие паттерны:
      --- Абстрактная фабрика (Abstract Factory)
      --- Строитель (Builder)
      --- Фабричный метод (Factory Method)
      --- Прототип (Prototype)
      --- Одиночка (Singleton)


 Структурные паттерны:
      --- Адаптер (Adapter)
      --- Мост (Bridge)
      --- Компоновщик (Composite)
      --- Декоратор (Decorator)
      --- Фасад (Facade)
      --- Приспособленец (Flyweigth)
      --- Заместитель (Proxy)


 Поведенческие Паттерны :
      --- Цепочка обязанностей (Chain of Responsibility)
      --- Команда (Command)
      --- Интерпретатор (Interpreter)
      --- Итератор (Iterator)
      --- Посредник (Mediator)
      --- Хранитель (Memento)
      --- Наблюдатель (Observer)
      --- Состояние (State)
      --- Стратегия (Strategy)
      --- Шаблонный метод (Template method)
      --- Посетитель (Visitor)

 Паттерны или шаблоны разработки - это общие способы решения частых задач и проблем
 Паттерны — это типовые решение для типовых задач.
 Существует три основные разновидности паттернов:
 1) архитектурные паттерны, 2) паттерны проектирования, 3) идиомы
 ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ:
 1) Порождающие паттерны — отвечают за процесс создания объектов.
 2) Структурные паттерны — определяют отношения между объектами, облегчая их взаимодействие
 3) Поведенческие паттерны — определяют способы коммуникации между объектами

Порождающие паттерны:

 1)  Абстрактная фабрика (Abstract factory):
 создает семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

 создать сложный объект, состоящий из других объектов, причем все составляющие объекты принадлежат одному "семейству"
 абстрактная фабрика возвращает объект немедленно

 Классы абстрактной фабрики часто реализуются фабричными методами, но могут быть реализованы и с помощью паттерна прототип.

 # Предоставляет способ инкапсуляции группы отдельных фабрик.

 2)  Строитель (Builder):
 От абстрактной фабрики отличается тем, что делает акцент на пошаговом конструировании объекта.
 Строитель возвращает объект на последнем шаге, тогда как абстрактная фабрика возвращает объект немедленно.

 Строитель часто используется для создания паттерна компоновщик.

 # Разделяет создание сложного объекта и его представление.

 3)  Фабричный метод (Factory method):
 Создает объекты без указания точного класса, но оставляет подклассам решение о том, какой класс инстанцировать.

 Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанцировать.
 Позволяет делегировать инстанцирование подклассам.
 Фабричный метод - можно увидеть в Django:Например в контактной форме на веб-странице тема и сообщение
  поля создаются с использованием одной и той же фабрики форм (CharField())

 Инстанцирование — создание экземпляра класса
 В Python инстанцирование фактически и является вызовом некоторой функции, которая возвращает новый экземпляр класса.

  # Создает объекты без указания точного класса.

 4) Прототип (Prototype):
 Создает новые экземпляры объекта путем клонирования прототипа: Пример Модуль copy

 позволяет копировать объекты любой сложности без привязки к их конкретным классам : Пример - Модуль copy

 # Создает новые экземпляры объекта путем клонирования прототипа.

 5) Одиночка (Singleton):
 У класса есть только один экземпляр : Пример Модуль — это файл с расширением .py

 С помощью паттерна одиночка могут быть реализованы многие паттерны (АБСТРАКТНАЯ ФАБРИКА, СТРОИТЕЛЬ, ПРОТОТИП).


Структурные паттерны:

 1) Адаптер (Adapter):
  позволяет объектам с несовместимыми интерфейсами работать вместе

  Итог: упрощает повторное использование классов в новых контекстах

  # Позволяет использовать интерфейс существующего класса в качестве другого интерфейса.

 2) Мост (Bridge):
  Отделяет абстракцию от ее реализации так, чтобы и то и другое можно было изменять независимо.

  Основная задача - отделить абстракцию от её реализации так, чтобы и то и другое можно было изменять независимо.

  Более сильная форма инкапсуляции

  # Отделяет абстракцию от ее реализации.

  Итог: дает возможность внедрить сложную функциональность одного класса в другой

 3) Компоновщик (Composite):
  упрощает создание иерархий объектов:  Python это не особенно нужно, так как для этой цели хватает словарей

  # Описывает группу объектов, которая рассматривается как один экземпляр.

  Итог: упрощает создание иерархий объектов, хотя в Python это не особенно нужно, так как для этой цели хватает словарей

 4) Декоратор (Decorator):
 Добавляет дополниетльную функциональность, не изменяя класс.

 динамически добавляет объектам новую функциональность, оборачивая их в полезные «обёртки».

 # Добавляет поведение к объекту, не затрагивая его класс.

 Итог: настолько полезен, что в Python для него имеется прямая поддержка, причем идея декоратора распространена даже на классы

 5) Фасад (Facade):
 Фасад надстраивает простой интерфейс поверх сложного

 предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку

  Фасад надстраивает простой интерфейс поверх сложного,
  Адаптер надстраивает унифицированный интерфейс над каким-то другим (необязательно сложным).

  унифицировать - приведение к единообразию, к единому виду

  # Обеспечивает более простой унифицированный интерфейс для сложной системы.

 Итог: упрощает повторное использование классов в новых контекстах

 6) Приспособленец (Flyweight):
 для уменьшения затрат памяти при работе с большим количеством мелких объектов:  Пример - Менеджер памяти Python

 # Минимизирует использование памяти за счет совместного использования данных с другими подобными объектами.

 Итог: Использование ссылок на объекты означает что в сам язык встроена варианция на тему паттерна Приспособленец
 Менеджер памяти Python
 Менеджер небольших объектов Python редко возвращает память обратно в операционную систему

 7) Заместитель (Proxy, Surrogate)
 позволяет создать объект-замену для другого объекта: Пример - Mock(макет-пустышка)

 Mock(макет-пустышка) - пример реализации паттерна Заместитель

 Поведенческие Паттерны :

 1) Цепочка ответственности (Chain of responsobility):
  Цель Разрешить передачу запроса по цепочке получателей до тех пор, пока он не будет обработан.

  предназначен, для того чтобы разорвать связь между отправителем запроса и получателем, который этот запрос обрабатывает.

  # Разрешить передачу запроса по цепочке получателей до тех пор, пока он не будет обработан.

 2) Команда (Command):
  превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, Пример: Django HttpRequest (без метода выполнения)
  ставить запросы в очередь, логировать их, а также поддерживать отмену операций

  # Django HttpRequest (без метода выполнения):

 3) Интерпретатор (Interpreter):
 Для заданного языка определяет представление его грамматики,
 а также интерпретатор предложений этого языка.

 4) Итератор (Iterator):
 позволяет последовательно обойти элементы коллекции или агрегированного объекта, не раскрывая деталей их внутреннего устройства.

 позволяет обойти коллекцию, не раскрывая деталей реализации.

 5) Посредник (Mediator):
 Инкапсулирует взаимодействие набора объектов которые ничего не знают друг о друге
 инкапсулирует взаимодействия между другими объектами которые ничего не знают друг о друге

 # Инкапсулирует взаимодействие набора объектов.

 6) Хранитель (Memento):
 Предоставляет возможность восстановить объект в предыдущее состояние: Пример: модуль json, модуль pickle

 позволяет сохранять состояние (данные) объекта и восстанавливать это состояние при необходимости

 Пример: модуль json, модуль pickle мы можем сериализовать и десериализовать произвольные объекты Python
 (с некоторыми ограничениями, например, нельзя сериализовать файловый объект).

 # Предоставляет возможность восстановить объект в предыдущее состояние.

 7) Наблюдатель (Observer):
 Определяет зависимость типа "один ко многим" между объектами таким образом,
 что при изменении состояния одного объекта все зависящие от него оповещаются об этом
 и автоматически обновляются

 # Пример: Django Signals(Сигналы), Flask Signals(Сигналы)

 8) Состояние (State):
 создания объектов, поведение которых изменяется при изменении состояния

 # Реализует переходы состояний, вызывая методы из суперкласса шаблона.

 9) Стратегия (Strategy):
 Позволяет выбрать алгоритм во время выполнения.

 Стратегия позволяет изменять алгоритмы независимо от клиентов, которые ими пользуются.

 позволяет инкапсулировать набор взаимозаменяемых алгоритмов, из которых пользователь выбирает тот, что ему нужен.

 # Позволяет выбрать алгоритм во время выполнения.

 10) Шаблонный метод (Template method):
 позволяет определить шаги алгоритма, оставив реализацию некоторых шагов подклассам.

 Определяет основу алгоритма и позволяет подклассам переопределить некоторые шаги алгоритма,
 не изменяя его структуру в целом

 # --- CBV  -  Class-Based Views ---

 11) Посетитель (Visitor):
 когда нужно применить некую функцию к каждому элементу коллекции или объекту-агрегатору: Пример - функция map()

 Описывает операцию, выполняемую с каждым объектом из некоторой структуры
 позволяет определить новую операцию, не изменяя классы этих объектов.

 когда нужно применить некую функцию к каждому элементу коллекции или объекту-агрегатору. Пример - функция map()


"""










