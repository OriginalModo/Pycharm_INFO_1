"""

 Самое Важное!!!
 Всегда ДУМАТЬ! перед тем, как что-либо сделать, необходимо всё тщательно обдумать

 Радоваться Жизни  Радоваться разным мелочам

 Ценить:         Ценить то что есть и стремиться к лучшему, Ценить сегодняшний день и брать МАКСИМУМ
 Быть проще:     Ко всему относиться Проще и Спокойнее без Волнения
 Слушать Других: Прислушиваться к мнению других людей они могут быть правы  И делать выводы
 Время:          Тайм-менеджмент   Грамотное распределение времени, Контроль Времени, Правильно раставлять Приоритеты
 Уверенность:    Быть уверенным в себе НО Оценивать свои силы!
 Развития:       Развиваться, Учиться, учиться и ещё раз - учиться, Саморазвитие
 Не Надеяться:   Надеяться только на себя
 Контроль:       Быть менее Эмоциональным, Совладать с Эмоциями, Контролировать свои эмоции в любой ситуации
 Внимательность: Быть Внимательным
 Спокойствие:    Быть Спокойнее, Перестать Нервничать , Быть Расслабленным, Не Злиться на себя и на других
 Режим:          Правильный Сон, Пить Воду
 Зарядка:        Бег, Тренировки, Стойка на Голове
 Тельце в тепле: НЕ переохлаждаться

 Молчание золото:  Лучше промолчать, чем сказать и потом жалеть о том, что сказал
 Соломон:          Все пройдёт, и это тоже пройдёт
 Вообще это замечательный подход: осознать, что проблема не такая уж и проблема, и вполне решаема.
 Кто ищет-тот всегда найдет!
 Искать Другие способы
 Не спеши, а то успеешь...   Успеешь, но не туда куда хотел...
 Подумай, нужно ли тебе ЭТО и для Чего
 Надо принимать вещи такими, как они есть, и пользоваться ими с наибольшей для себя выгодой.
 Если научиться принимать вещи как они есть, страдание исчезнет.
________________________________________________________________________________________________________________________


 Поэтому, в общем-то, не важно, как вы пишете, важно, что вы пишете. Но если вы будете при этом писать чистый,
 легко читаемый код - это будет вишенка на торте.

--- Типа Советы ---

 Early quit:
 Когда мы только пишем/читаем код if a:, мы запоминаем, что где-то там, в конце, нам нужно рассмотреть else случай.
 Если код внутри if a большой, то else вообще будет "оторван" от контекста.

 самые частые паттерны  и надеюсь, что они помогут вам писать более чистый и эффективный питон-код:

 Лучше переписать так ----->        Мы могли бы поменять условия местами:
 def foo(a: bool):                  def foo(a: bool):

    if a:                               if not a:
        #                                   return False
        # ... 50 LOCs
        #                               else:
        return True                         #
                                            # ... 50 LOCs
    else:  # if not a                       #
        return False                        return True

 Это легче читается, так как случай not a мы уже рассмотрели и выкинули из головы в самом начале. Но если присмотреться,
 то else вообще не нужен:

 def foo(a: bool):

    if not a:
        return False

    # в этом месте мы уже отбросили случай "not a" и забыли про него

    #
    # ... 50 LOCs
    #
    return True

 В этом и вся фишка - когда пишем функцию, то стараемся как можно скорее из неё выйти при помощи отсечения каких-то
 плохих случаев. Эта методика прекрасна тем, что позволяет избавиться от уровней вложенности
 (то есть теперь никакого else), да ещё и память программиста разгружается, потому что нет ветвления логики.

 Вот синтетический пример для какого-то парсинга:

 import requests

 def scrape(url: str) -> dict:

     response = requests.get(url)

     if not response.ok:  # отсекаем плохие статус-коды
         return {}
     # начиная с этой строчки я уверен, что у ответа хороший статус код

     data = response.json()

     if 'error' in data:  # отсекаем случаи, когда в ответе есть ошибка
         raise ValueError(f'Bad response: {data["error"]}')
     # начиная с этой строчки я уверен, что нет ошибки

     if 'result' not in data:  # отсекаем случаи, когда ответ пуст
         return {}
     # начиная с этой строчки я уверен, что есть ответ

     # ... parse data['result'] ...

 Функция полностью "линейна", и в момент собственно парсинга данных я ничего не должен держать в голове и знаю
 наверняка, что всё хорошо, данные есть, ошибок нет.

 Работает так же для циклов, только вместо return будет break или continue.
------------------------------------------------------------------------------------------------------------------------

 -- One-line assignment
 Поговорим о присваивании переменных:

 Тут всё довольно очевидно - зачем лишние if-else, если можно сделать в одну строчку:

 Работает но лучше так ----->
 if a:                             v = 1 if a else 2
     v = 1
 else:
     v = 2

 А что если так:
                                хорошее решение!
 if a == 1:                     v = {
     v = 10                         1: 10,
 elif a == 0:                       0: 0,
     v = 0                          -1: -10,
 elif a == -1:                      -2: -20,
     v = -10                    }[a]
 elif a == -2:
     v = - 20

 Тут вы спросите, а что будет если a not in {0, 1, -1, -2}, и будете правы - v будет вообще не определена. Кроме того,
 если я захочу позже понять, откуда появилась v и что в ней записано, мне нужно будет посмотреть 4 случая, потому что v
 определена 4 раза. И это ужасно, потому что когда переменная определена много раз, то:

 1) не факт, что вы не забыли рассмотреть ещё какой-то случай

 2) можно опечататься и вместо v написать b, и питон это радостно съест,

 3) можно банально опечататься при копи-пасте (если вы копируете случаи и заменяете значения), и в разных случаях
 присвоить одно и то же значение

 Какой же выход? Старайтесь определять переменные один раз. В идеале любое объявление переменной должно выглядеть так:
 var = <some code>

 И не более того. Я намеренно пишу "в идеале", потому что не всегда это возможно сделать, а где-то от этого страдает
 читаемость кода, так что нужно делать с умом.
 В случае выше я бы заменил код на:
 v = {
     1: 10,
     0: 0,
     -1: -10,
     -2: -20,
 }[a]

 Тут v определена один раз, я чётко вижу какое a к какому v приводит, и если a не из допустимых значений, то всё упадёт,
 чему я и рад. Если вам нужно еще значения по умолчанию, то вместо [a] используйте .get(a, default_value).
------------------------------------------------------------------------------------------------------------------------

 -- Definition close to usage
 Ещё один способ разгрузить память программиста. Часто вижу такое:

 def foo(url: str):

    fields = ['a', 'b', 'c']

    response = requests.get(url)
    response.raise_for_status()
    data = response.json()
    if 'result' not in data:
        raise ValueError()

    for field in fields:
        print(data[field])

 Вообще нет ошибки, всё нормально - вот только когда я смотрю строчку for field in fields, я уже забыл, что там в fields,
 и меня ждёт увлекательное приключение в начало функции, чтобы найти там определение этой переменной.
 Да, в PyCharm это 2 шортката - один "jump to definition", другой "jump где я там был до этого", но было бы неплохо,
 чтобы вообще никуда прыгать не пришлось.

 С этой проблемой и борется этот паттерн: мы определяем переменные наиболее близко к тому месту, где мы их будем
 использовать. Как только вы хотите создать переменную, спросите себя: "нужна ли эта переменная в следующем
 сниппете кода"? Если нет, то, возможно, её следует определить позднее. Таким образом при анализе кода вы сможете
 бросить взгляд на соседние строчки кода и понять, откуда взялись эти переменные и что в них.

 Python Snippets (Сниппет) - это какой-то отрывок кода, который может быть использован повторно.

 В примере выше мы просто двигаем fields именно туда, где они используются, и даже можем заинлайнить их прям в for:
 for field in ['a', 'b', 'c']:
    print(data[field])
------------------------------------------------------------------------------------------------------------------------

 -- Too many indents
 Питон хорош тем, что в нём есть отступы. Отступы хороши тем, что они показывают вам уровень вложенности вашей логики.
 Чем больше отступов, тем сложнее логика, и, соответственно, голове сложнее парсить код и держать текущий стек условий.

 for x in range(10):
     result = foo(x)
     if result:
         second = bar(result)
         if second:
             print(second)
         else:
             # <<< HERE
             print('not second')
     else:
         print('not good')

 В данном примере в строчке <<< HERE нужно помнить, что у вас есть какой-то x от 0 до 9, result превращается в True,
 а second не превращается.

 Нет какой-то чёткой границы, типа если у вас N отступов, то всё плохо, а если меньше, то хорошо. Тем не менее,
 чем их меньше - тем лучше. Убирать отступы можно при помощи уже упомянутого "Early Quit", а также при помощи вынесения
 части кода в отдельную функцию.

 for x in range(10):
     result = foo(x)
     if not result:
         print('not good')
         continue

     second = bar(result)
     print_second(second)

 Частным случаем этого являются двойные, тройные и т.д. циклы, вроде:
 for x in range(100):
    for y in range(100):
        for z in range(100):
            if x % 10 == 0:
                if y % 10 == 0:
                    print('haha')

 Такие штуки часто можно упростить при помощи itertools и функций, например:

 from itertools import product

 def print_(x: int, y: int, z: int):
     if x % 10 == 0 and y % 10 == 0:
         print('haha')


 for x, y, z in product(range(100), range(100), range(100)):
     print_(x, y, z)
------------------------------------------------------------------------------------------------------------------------

 -- Dangerous loops
 Кстати о циклах! Идеальный вариант - это цикл с одним уровнем вложенности по какому-нибудь генератору:

 for i in range(100):
    print(i)

 В реальной жизни всё несколько сложнее, но есть два простых правила, которые помогают не стрелять себе в ноги.
 Первое - это цикл while True:

 a = 0
 while True:
     a += 1
     if a == 100:
         break

 Когда-нибудь вы поменяете a = 0 на a = 100, и оно будет работать бесконечно. Когда-нибудь вы просто забудете написать
 условие выхода, или напишете такое, что не будет выполняться, или будет выполняться, но не всегда. Поверьте,
 бесконечное выполнение программы - это последнее, что вам хочется, а while True - прямая дорожка к этому.

 Поэтому просто что-нибудь, что кончается:

 max_iterations = 100
 a = 0
 for i in range(max_iterations):
     a += 1
     if a == 100:
         break

 else:
     raise ValueError('max_iterations reached')

 Вторая категория опасных циклов - это вложенные циклы. Написать такие - раз плюнуть, но каждый вложенный цикл даёт вам
 ужасный прирост сложности. Цикл на 20 элементов, вложенный в цикл на 20 элементов, даёт вам 400 комбинаций - это число
 уже может стать боттлнеком вашей программы.

 Bottleneck - Узкое место программы

 for x in range(20):
    for y in range(20):
        fn(x, y)  # called 400 times

 Решается в каждом случае индивидуально, но можно, например, исключить какие-то случаи из обработки, где это применимо:

  for x, y in product(range(20), range(20)):
    if 10 < x < 20 and 10 < y < 20:
        fn(x, y)
------------------------------------------------------------------------------------------------------------------------

 -- Copy-paste more than twice
 Копи-паста - зло. Во-первых, тяжело читать - куча одинакового кода, занимает много места. Во-вторых, слишком просто ошибиться

 if v == 'a':
     self.value_a = 1
 elif v == 'b':
     self.value_b = 1
 elif v == 'c':
     self.value_c = 1

 Обычно копи-паста легко схлопывается в один сниппет кода, либо при помощи каких-то маппингов через словари,
 либо при помощи getattr / setattr, либо выделением копи-пастного кода в отдельную функцию и вызова её с параметрами.
 Иными словами, весь копи-пастный код проводится к общему виду и потом параметризуется.

 setattr(self, f'value_{v}', 1)
------------------------------------------------------------------------------------------------------------------------

 -- Interconnected lines of code
 Тут всё просто - бывают строчки кода, которые связаны, то есть когда вы меняете одну из них, должна поменяться и другая.
 Понятно, что однажды вы поменяете одну и забудете поменять другую. Именно поэтому от них нужно избавляться, как правило
 ссылаясь из одной строчки кода на другую:

 rows = [
    {'col 1': 'value 1', 'col 2': 'value 2'},
    {'col 1': 'value 3', 'col 2': 'value 4'},
 ]

 writer = csv.DictWriter(..., fieldnames=['col 1', 'col 2'])

 Теперь если вы решите добавить ещё одну колонку в rows, или переименовать существующую, то вам также нужно будет
 изменить fieldnames. Вместо этого мы заставим fieldnames "ссылаться" на нужные значения:

 rows = [
     {'col 1': 'value 1', 'col 2': 'value 2'},
     {'col 1': 'value 3', 'col 2': 'value 4'},
 ]

 writer = csv.DictWriter(..., fieldnames=rows[0].keys())
------------------------------------------------------------------------------------------------------------------------

 -- Type hints
 Тут всё просто: всегда используйте type hints. Когда вы пишете код, вам весело и приятно, но когда ваш код читают
 (а может это будете и вы сами через год), очень тяжело понять, что это за аргументы у функции и какого они типа.
 В этом плане type hints хотя бы немного помогут.

 def foo(processor):
    # wtf is processor? what is returned?
    ...

 def foo(processor: Processor) -> str:
  	# okay, now I can jump to definition of Processor and see what it is
    ...

 Я пишу "хотя бы", потому что type hint типа Tuple[int, str, datetime] никак не говорит вам, что это на самом деле
 возвращается (object_id, name, creation_datetime). Тут помогли бы namedtuple, но использовать их для возвращаемых
 значений кажется оверинжинирингом.
------------------------------------------------------------------------------------------------------------------------

  -- Quick "in" check
 Тут всё просто до безобразия: хотите проверить вхождение чего-то во что-то? Юзайте set (множество),
 ведь element in set выполняется за константное время. Как только вы делаете element in list, вы вызываете демона
 поэлементного сравнения, который рано или поздно укусит вас за зад при большом количестве элементов в списке.

 Не бро:                                           Бро:
 items = [instance1, instance2, instance3]         items = {instance1.id, instance2.id, instance3.id}
 if instance4 in items:                            if instance4.id in items:
     print('yes')                                      print('yes')
------------------------------------------------------------------------------------------------------------------------

 -- Bulk
 Вот это прям всем, всегда. Итак: всегда пишите код сразу для миллиона объектов, даже если у вас их сейчас два.

 Загружаете файлы в облачное хранилище? Делайте в несколько потоков, как будто вам надо загрузить миллион файлов.

 Пишете SQL запрос? Делайте джойны, как будто у вас миллион записей в каждой таблице.

 Пишете view для Джанго? Пишите его так, как будто его будут вызывать миллионы пользователей.

 Пишете код для загрузки данных? Пишите так, как будто будете загружать миллионы строк.

 На самом деле это просто, стоит только привыкнуть. Для SQL это какие-нибудь JOIN и INDEX, для Django это select_related,
 only, values_list, update и bulk_create, где-то ещё это ThreadPoolExecutor. Это сложнее, чем работать по-объектово,
 где-то придётся дробить входне данные на чанки, где-то отправлять параллельно, но зато ваш код будет работать и для
 одного объекта, и для миллиона. Может их и не станет миллион, но однажды их станет не два, а тысяча, а ваш код будет
 работать всё так же быстро.
------------------------------------------------------------------------------------------------------------------------

 -- Concurrency safety
 Однажды ваш код запустят не в вашем любимом терминале, а в потоках. Или в процессах. На разных машинах. Что случится,
 когда вы будете обрабатывать одновременно одни и те же данные? Делать одни и те же запросы к внешним API?
 Обращаться к одним и тем же файлам на диске?

 Возможно, ничего. Возможно, ничего хорошего.

 Представьте, что после каждой строчки кода выполнение вашей программы может быть прервано, и управление перейдёт
 другой программе - или точно такой же. Теперь пишите код с учётом этого.

 Подобные мысли приводят к появлению таких вещей, как, например, threading.Lock, @transaction.atomic,
 SELECT FOR UPDATE и иже с ними.
------------------------------------------------------------------------------------------------------------------------

 -- Asserts everywhere
 И последнее - немного про assert. Я считаю, что это замечательная вещь, потому что лучше "либо хорошо, либо никак",
 а assert как раз про это - у вас либо всё хорошо, либо всё падает, а третьего не дано.

 Ожидаете определённые данные с внешнего сервиса? Ставьте ассерт:

 result = get(service_url).json()
 assert result in {'ok', 'fine', 'good'}

 Ожидаете, что есть хотя бы один Item? Ставьте ассерт:

 items = Item.objects.all()
 assert len(items)
 print(items[0])

 Написали код, который сами не понимаете? Ставьте ассерт:

 result = foo(bar(baz(x)))
 assert result is not None

 Общее правило: если вы что-то ожидаете или в чём-то не уверены, то ставьте assert.

 Стоит, однако, помнить, что assert могут быть отключены при помощи заклинания -O, но если вы встретите тех, кто так
 делает, то передайте им от меня пламенный привет и немного новичка.

 -- К чему всё это
 Как видите, цель этих правил - улучшить читаемость кода, разгрузить память программиста и уменьшить число ошибок.

------------------------------------------------------------------------------------------------------------------------

 --- Что значит "упрощать" и "заботиться о пользователях"? ---
 Я понимаю это как написание кода, который:

 - ЛЕГКО ЧИТАТЬ
 - ЛЕГКО ИЗМЕНЯТЬ
 - ЛЕГКО ОТЛАЖИВАТЬ
 - ЛЕГКО ТЕСТИРОВАТЬ

 -- ЛЕГКО ЧИТАТЬ --
 - ЛЕГКО ЧИТАТЬ > Самодокументация > Типы:
 Это питонушка. Тут в переменной может быть всё что угодно, хотите int, хотите гетерогенный список объектов
 вперемежку со словарями и числами с плавающей точкой.

 Но мы имеем то, что имеем:

 def fn(items):
    # ...

 Проблема: а что можно подавать в items, и что возвращается из fn?

 - Решение 1: смотреть код.
 Топорное решение - посмотреть код и понять. И никто не гарантирует успех - может, вы поймёте, что items - это коллекция
 каких-то объектов, но вот чтобы понять, каких - нужно будет попрыгать по вызовам функции fn и посмотреть,
 что туда передаётся. Ну такое.

 - Решение 2: смотреть docstring.
 Пещерные люди жили в неведении, но потом открыли для себя докстринги, где можно писать, что делает функция,
 что получает и что возвращает.

 def fn(items):
    ```
    Sort items using mega-algo.

    Args:
        items: list - list of items
    Returns:
        list of sorted elements
    ```
    # ...

 Это почти нормально, если бы не:

 - разные стили: где-то google-style, где-то sphinx-style
 - много писать (но помогают плагины)
 - нужно всё время следить за актуальностью: убрали аргумент, добавили аргумент, поменяли название - будьте добры -
 обновить докстринг (я всё время забываю)

 - Решение 3: смотреть type hints
 Потом пещерные люди посмотрели на статически типизированные языки и внезапно увидели, что это удобно, и захотели так же.
 Ну хотя бы чтоб было похоже. Поэтому вот:

 from typing import List, Union, Optional

 def fn(items: List[Optional[Union[int, float]]]) -> list[Union[int, float]]:
     # ...

 Смешно, что, хотя для items объявлен тип, по факту вы можете передать туда что угодно. Поэтому всё равно нужно следить,
 что куда передаётся, но, по крайней мере, это проще, и всякие линтеры могут помогать.

 - Решение 4: использовать python >= 3.10 и не импортировать лишнего
 Наконец, пещерные люди посмотрели на List[Optional[Union[int, float]]], прифигели немного
 (это ведь только один аргумент!) и решили всё упростить:

 def fn(items: list[int | float | None]) -> list[int, float]:  # а ещё лучше TypeVar ;)
	# ...

 Согласитесь, эволюция налицо. Но проблемы всё равно есть:
 1) type hints могут быть слишком большими. Постоянная тема: dict[str, list[dict]] - это что вообще там? Если это тип
 для аргумента, то название аргумента подскажет, что имел в виду автор. А если это тип возвращаемого значения, то...
 2) return type hint никак не помогает!

 Вот посмотрите сами:
 def get_orientation(obj: Ufo) -> tuple[float, float, float]:  # WAT? это что такое?
     # ...
     return pitch, roll, yaw  # plot twist: я прочитал функцию до конца и узнал, что было в начале

 Решение тут пока - в использовании namedtuple или иных заранее определённых типов для возвращаемого значения,
 но как по мне - слишком много boilerplate кода:

 boilerplate - Шаблонный код, КОТОРЫЙ ДОЛЖЕН быть написан во многих местах практически без изменений.

 from collections import namedtuple

 Orientation = namedtuple('FunctionResult', ('pitch', 'roll', 'yaw'))

 def get_orientation(obj: Ufo) -> Orientation:
     # ...
     return Orientation(
         pitch=...,
         roll=...,
         yaw=...,
     )

 Выглядит ужасно. Да здравствует питон!

 Решение 5?
 И пока пещерные люди выходят на новый виток эволюции, большинство разработчиков вообще живут мимо эволюции и не
 используют type annotations - в 80% постов они отсутствуют.

 ВЫВОД!!!
 Поэтому я напишу это здесь ещё раз: пожалуйста, используйте type hints. Это не сложно                    <-----
 (кроме Generator[yield type, send type, return type], они реально бесят).
------------------------------------------------------------------------------------------------------------------------

 -- Легко читать > Самодокументация > НАЗВАНИЕ ФУНКЦИИ

 - Ладно, вот вам новая проблема: что делает функция?

 def fn(items: list[int | float | None]) -> list[int, float]:    Правильный ответ: а хрен её знает!

 - Решение 1: читать код:

 def fn(items: list[int]) -> list[int]:
    return sorted(items, key=math.sin)

 Сложность: O(n). Нет, пожалуйста.

 - Решение 2: читать docstring:
 def fn(items: list[int]) -> list[int]:
    ```Sorts items by their sin() values```
    # ...

 Это удобнее, но, как я уже говорил, эти докстринги должны быть, причём в актуальном состоянии.

 -- Решение 3: нормально называть:

 def sorted_by_sin(items: list[int]) -> list[int]:
    # ...

 Тут сразу понятно: итемсы сортируются по грехам их. Стоп, что?

 Ну короче вы поняли. Правильное название функции и короткий, читаемый код заменяют docstring. Признаться, раньше я был
 свидетелем докстринговым и везде старался их писать, но теперь я их пишу только во всяких публичных функциях
 публичных либ, чтобы документация красиво собиралась.

 - Вопрос в кассу: как проверить, что название хорошее?
 Если вы примерно угадываете, что функция делает - название хорошее.

 -- Легко читать > Самодокументация > НАЗВАНИЯ ПЕРЕМЕННЫХ

 Та же тема с НАЗВАНИЯМИ ПЕРЕМЕННЫХ. Дополнительно хочу отметить: никто вас не наругает, если вы используете
 несколько слов в названии переменной, и она вдруг от этого станет понятной. Если хорошее название - дело субъективное,
 то вот переопределение встроенных символов (например, list, set, next) - ОЧЕВИДНОЕ ЗЛО.

 НЕЛЬЗЯ ПЕРЕОПРЕДЕЛЯТЬ ВСТРОЕННЫЕ СИМВОЛЫ (list, set, next, sum, max, min, print и так далее)

 -- Легко читать > Самодокументация > КОММЕНТАРИИ

 Тут всё просто: код рассказывает компьютеру, что делать. Когда человек читает код, он понимает, что компьютер будет  делать.
 Поэтому в большинстве случаев комментировать это не надо. Такие комментарии только занимают место и не приносят никакой пользы.

 НО ЕСЛИ ВЫ НЕ ПОНИМАЕТЕ что делает код (или зачем) - КОММЕНТАРИЙ БУДЕТ СОВСЕМ НЕ ЛИШНИМ.


 -- Легко читать > Low RAM
 Я уже говорил, что у меня в голове место ограничено, поэтому я стараюсь как можно сильнее снизить когнитивную нагрузку
 - иначе говоря, минимизировать количество информации, которую мне нужно держать в голове. Для этого я стараюсь
 уменьшать, разбивать и упрощать функции.

 - Легко читать > Low RAM > НЕВЫСОКАЯ ФУНКЦИЯ
 Тут всё просто: чем короче функция, тем проще её понять.

 Разбитие функции
 Функция слишком длинная? Рецепт прост: разбейте её на несколько! Увы, в 16% постов авторы пишут мега-функции:

 Ну вот, например:

 def run(self):
     pixels = pygame.surfarray.pixels3d(self.display)

     index = 0
     running = True
     while running:
         self.model.stimulate()

         pixels[:, :, :] = (255 * (self.model.activity > 0))[:, :, None]
         pygame.display.flip()

         for event in pygame.event.get():
             if event.type == pygame.QUIT:
                 running = False
             elif event.type == pygame.KEYDOWN:
                 if event.key == pygame.K_ESCAPE:
                     running = False
                 elif event.key == pygame.K_s:
                     imsave("{0:04d}.png".format(index), pixels[:, :, 0])
                     index = index + 1
             elif event.type == pygame.MOUSEBUTTONDOWN:
                 position = pygame.mouse.get_pos()
                 self.model.activity[position] = 1

 Тут игровой цикл, где смешались вызов симуляции, отрисовка пикселей, обработка клавиатуры, скриншоты...
 Как упростить? Разбейте на функции:

 def run(self):
     while self.is_running:
         self.model.simulate()
         self.draw()
         self.handle_input()

 Группировка присваиваний в one-liner       <-----                                                      <-----
 Магическое превращение четырёх строчек в одну! Следите за руками:

 if a > b:                                max_ = a if a > b else b                                      <-----
     max_ = a
 else:
     max_ = b

 # ...вжух!

 Я люблю такие присваивания, потому что они занимают меньше места. Но ещё важная фишка в том, что у меня одно
 присваивание в коде вместо двух, значит, меньше шансов на ошибку.

 -- Легко читать > Low RAM > НЕШИРОКАЯ ФУНКЦИЯ

 Когда у вас слишком много отступов в коде - это знак, что что-то можно упростить. Например:
 Циклы:

 Если у вас в цикле много всего, то можно это всё вынести в отдельную функцию. Вы не только упрощаете код,
 но и "сдвигаете" всё из цикла на один уровень вложенности меньше:

 def run():
     for event in pygame.event.get():
         if event.type == pygame.QUIT:  # тут уровень отступов == 2
             running = False            # тут уровень отступов == 3
         # ...

 # ...вжух!

 def process_event(event: Event):
     if event.type == pygame.QUIT:  # тут уровень отступов == 1
         running = False            # тут уровень отступов == 2
     # ...

 def run():
     for event in pygame.event.get():
         process_event(event)

 Мини-бонус: если в цикле вызывается одна функция, то этот цикл очень просто распараллелить
 (при помощи ThreadPoolExecutor, например).

 - Длинные выражения
 Ну любит народ писать зубодробительные выражения (11%):
 Вот, например:
 # constraints on communist's or zhulik's votes
 def findVariants(s, aim, cnt, suffix):
     s.add((r9916['com'] - aim['com'] == \  # <--------------------------------!!!
       Sum([If(Bool('v_%d_%s' % (i, suffix)), rewritten_pecs[i]['increase']['com'], 0) for i in range(19)]) + \
       Sum([If(Bool('a_%d_%s' % (k, suffix)), 0, approved_pecs[k]['first']['com']) for k in range(53)])))


 Я не знаю, что можно сделать с выражением выше, но если у вас какая-то строчка эпической длины, то хотя бы попробуйте
 разбить её на несколько - так легче читается. В этом очень помогают скобки, ведь то, что нельзя делать в обычном мире,
 в мире скобок дозволено.

 Вот тут скобки позволяют писать + что-то с новой строчки, да ещё и комментарии можно добавлять:

 missing_set =  (  # <--------------------------------!!!
     [(all_letters, '-' * len(all_letters))] * 3 # тут считаем все буквы пропущенными
     + [(all_letters, all_letters)] * 10 # тут считаем все буквы НЕ пропущенными
     + [('aeiouy', '------')] * 30 # тут считаем пропущенными только гласные
 )

 Nested conditions
 Тут всё просто: зачем два if, если можно один? Вроде банальщина, а тем не менее - 2%:

 if min_val is not None and max_val is not None:
     if max_val < min_val:
         raise ValueError("max_val is greater than min_val")  # тут уровень отступов == 2

 # ...вжух!

 if min_val is not None and max_val is not None and max_val < min_val:
     raise ValueError("max_val is greater than min_val")       # тут уровень отступов == 1

 Pathlib
 pathlib (о котором я замолвлю словечко позже) позволяет читать и писать в одну строчку:

 with open('test.txt') as file:
     content = open.read()               # тут уровень отступов == 1

 # ...вжух!

 content = Path('test.txt').read_text()  # тут уровень отступов == 0

 Redundant else
 Один из моих любимых способов уменьшения отступов: если в теле после if у вас return или raise, то else не нужен.
 Проще на примере:

 if user_profile:
     # ...
     return HttpResponseRedirect(reverse("main:dashboard"))  # или raise

 else:
     # ...
     messages.success(request, _("Успешная регистрация."))   # тут уровень отступов == 1
     return HttpResponseRedirect(reverse("main:dashboard"))

 # ...вжух!

 if user_profile:
     # ...
     return HttpResponseRedirect(reverse("main:dashboard"))

 # ...
 messages.success(request, _("Успешная регистрация."))       # тут уровень отступов == 0
 return HttpResponseRedirect(reverse("main:dashboard"))

 -- Легко читать > Low RAM > НЕБОЛЬШОЙ КОНТЕКСТ

 Каждый if заставляет вас запоминать, что было ветвление на 2 или более случая. Каждая переменная заставляет вас помнить,
 что она есть и в ней что-то лежит. Каждый try заставляет ожидать исключения в каждой строчке до самого except.
 Вроде пустяки, но чем их больше, тем сложнее за всем уследить. Всё, что нужно держать в голове, я называю "контекстом",
 и в этой секции мы будем его уменьшать.

 Я уже рассказывал про него, но это такой классный паттерн, что я даже добавил его в плагин для flake8
 (правда, там много false positives). Правило такое: старайтесь выйти из функции / цикла как можно быстрее.
 На любой развилке if-else первым проверяйте то условие, которое позволит выйти из тела функции / цикла.

 if rate is not None:
     # в этом месте мы должны помнить, что есть ещё случай `if rate is None`, и его нужно потом рассмотреть
     r1 = (df[minus] / df[column] - 1).abs()
     r2 = (df[plus] / df[column] - 1).abs()
     return df.loc[(df['new_cases'].ge(100)) & ((r1.notnull() & (r1 <= rate)) | (r2.notnull() & (r2 <= rate)))]
 else:  # и вот мы наконец его рассматриваем
     raise Exception

 # ...вжух!

 if rate is None:  # сначала рассматриваем случай, который нас выкинет из текущего контекста
     raise Exception

 # если не выкинул - то хотя бы не нужно про него больше помнить
 r1 = (df[minus] / df[column] - 1).abs()
 r2 = (df[plus] / df[column] - 1).abs()
 return df.loc[(df['new_cases'].ge(100)) & ((r1.notnull() & (r1 <= rate)) | (r2.notnull() & (r2 <= rate)))]

 Или вот:

 if response.status == httplib.OK:
     parser = DNSParser()
     parser.feed(response.read())
     return parser.saved_data
 else:
     return 'Error ' + str(response.status)

 # ...вжух!

 if response.status != httplib.OK:
     return 'Error ' + str(response.status)

 parser = DNSParser()
 parser.feed(response.read())
 return parser.saved_data

 Обобщая, после этой оптимизации код должен выглядеть так:

 если что-то не так:
     return

 если что-то ещё не так:
     return

 если ошибка:
     raise

 # тут мы уверены, что всё в порядке
 код, делающий что-то полезное

 - Small try blocks

 В 4% постов авторы пытаются скормить в try как можно больше всего. Наверно, это какие-то корни рыболовов
 дают о себе знать - натянул сеть пошире и ловишь себе всё, что есть, иногда даже не гнушаясь ловить просто Exception.

 В идеале вы должны знать, что конкретно и где вы ловите - тогда при срабатывании блока except вы точно будете знать,
 из какой строчки что прилетело. Поэтому в идеале между try и except должно быть 1-3 строчки,
 а если больше - задумайтесь, возможно, вы не понимаете, что у вас происходит в коде.

 Кстати, try-except вводят дополнительный отступ, а чем больше отступов... ну вы помните.

 def new_from_file(self, filename, selected=True):
     try:
         file_path = normalize_path(filename, True)
         obj = DesktopParser(file_path)
         sname = obj.get('Name',locale=LOCALE)
         desc = obj.get('Comment',locale=LOCALE)
         icon = obj.get('Icon')
         pix = IconManager().get_icon(ThemedIcon('image-missing'),32)
         if icon:
             if icon.rfind('.') != -1:
                 pix = IconManager().get_icon(FileIcon(File(icon)),32)
             else:
                 pix = IconManager().get_icon(ThemedIcon(icon),32)

             data = (pix, '%s' % sname, obj, sname.upper(), file_path)
         return self.launcher_view.add_row(data,selected)
     except:
         return None

# ...вжух!

 def new_from_file(self, filename, selected=True):
     file_path = normalize_path(filename, True)
     try:
         obj = DesktopParser(file_path)
     except DesktopParserError:
        return

    sname = obj.get('Name',locale=LOCALE)
    desc = obj.get('Comment',locale=LOCALE)
    icon = obj.get('Icon')
    try:
        pix = IconManager().get_icon(ThemedIcon('image-missing'),32)
    except IconError:
        return

    if icon:
        if icon.rfind('.') != -1:
            pix = IconManager().get_icon(FileIcon(File(icon)),32)
        else:
            pix = IconManager().get_icon(ThemedIcon(icon),32)

        data = (pix, '%s' % sname, obj, sname.upper(), file_path)
    return self.launcher_view.add_row(data,selected)

 Если у вас прям какая-то ненадёжная функция и вы хотите весь её код завернуть в try-except, то хотя бы юзайте декоратор.
 @return_on_failure('')

 - Context manager
 Внезапно, в 7% постов авторы обходятся без контекстных менеджеров для открытия файлов. Они, наверно,
 супермены и всегда помнят, что надо закрывать файлы?

 @profile
 def create_file():
     x = [(random.random(),
           random_string(),
           random.randint(0, 2 ** 64))
          for _ in xrange(1000000)]

     pickle.dump(x, open('machin.pkl', 'w'))

 Я вот могу и забыть про file.close(). Эти ваши интернеты говорят, что если самому не вызвать close(), то cpython
 закрывает файлы, когда их refcount = 0 и сборщик мусора добирается до них, а вот pypy - только при  завершении процесса.
 Так что лучше использовать контекстные менеджеры, и пусть оно там само помнит, когда что закрыть и отключить:

 with open('machin.pkl', 'w') as out_file:
     pickle.dump(x, out_file)

 Здесь мы рассмотрели контекстный менеджер для open(), но есть и контекстные менеджеры для разного - соединения
 с базой данных, к примеру - полезные штуки!

 Yagni
 В коде не должно быть ненужного. Если у вас код под VCS, то смело выбрасывайте мёртвый код - потому что потом можно
 будет всегда вернуть (но, скорей всего, до этого не дойдёт). Ну и просто по мелочи:

 Заменяйте ненужные переменные на underscore

 for i in range(32):
     print(quantum_randbit(), end='')

 # ...вжух!

 for _ in range(32):
     print(quantum_randbit(), end='')

 Для путешественников во времени: object уже необязателен.

 class DataItem(object):
     __slots__ = ['name', 'age', 'address']

 # ...вжух!

 class DataItem:
     __slots__ = ['name', 'age', 'address']

 Не надо создавать контейнер, а потом наполнять его. Наполняйте сразу!

 Contour=[]
 Contour.append( [pcbnew.Millimeter2iu(plane_size[0]),   pcbnew.Millimeter2iu(plane_size[1]) ])
 Contour.append( [pcbnew.Millimeter2iu(plane_size[0]),  -pcbnew.Millimeter2iu(plane_size[1]) ])
 Contour.append( [-pcbnew.Millimeter2iu(plane_size[0]), -pcbnew.Millimeter2iu(plane_size[1]) ])
 Contour.append( [-pcbnew.Millimeter2iu(plane_size[0]),  pcbnew.Millimeter2iu(plane_size[1]) ])

 # ...вжух!

 Countour = [
    [pcbnew.Millimeter2iu(plane_size[0]),   pcbnew.Millimeter2iu(plane_size[1]) ],
    [pcbnew.Millimeter2iu(plane_size[0]),  -pcbnew.Millimeter2iu(plane_size[1]) ],
    [-pcbnew.Millimeter2iu(plane_size[0]), -pcbnew.Millimeter2iu(plane_size[1]) ],
    [-pcbnew.Millimeter2iu(plane_size[0]),  pcbnew.Millimeter2iu(plane_size[1]) ],
 ]


 -- Легко читать > Low RAM > BEST PRACTICES

 А ещё код легко читать, если его пишут так, как общепринято и актуально по нынешней спецификации.

 Range
 Внезапно для 4%, range уже начинается с нуля!

 for i in range(0, n):
    dydt[i] = y[i + n]

 # ...вжух!

 for i in range(n):
    dydt[i] = y[i + n]

 Enumerate
 Если в цикле вы используете счётчик и увеличиваете его на 1 в конце каждой итерации, то, скорее всего,
 доктор вам пропишет enumerate().

 counter = 0
 for vk in vk_apis:
    change_photo(vk)
    print(counter, 'done')
    counter += 1

 # ...вжух!

 for i, vk in enumerate(vk_apis):
    change_photo(vk)
    print(i, 'done')

 Suppress
 Сам недавно узнал! Позволяет укоротить try-except-pass:

 from contextlib import suppress
 try:
     flatPriceDelta = float(flatPriceInfo) - float(oldFlatPriceInfo)
 except ValueError:
     pass

 # ...вжух!

 with suppress(ValueError):
     flatPriceDelta = float(flatPriceInfo) - float(oldFlatPriceInfo)

 Pathlib
 pathlib - это как type hints: полезная штука, которую почему-то часто игнорируют. Если вы используете os.path,
 то время сесть в делореан, переместиться в будущее и начать пользоваться pathlib.

 os.remove("../m3u8_downloader/segments/temp.ts")
 # ...вжух!
 Path("../m3u8_downloader/segments/temp.ts").unlink()


 if not os.path.exists(tools_path):
     os.makedirs(tools_path)
 # ...вжух!
 tools_path.mkdir(parents=True, exist_ok=True)


 with open('posts.txt') as file:
 # ...вжух!
 with Path('posts.txt').open() as file:


 def SaveDriverFile(self):
   winPath = os.environ['WINDIR']
   sys32Path = os.path.join(winPath, "System32")
   targetPath = os.path.join(sys32Path, "drivers\\" + self.name + ".sys")
   file_data = open(self.file_path, "rb").read()
   open(targetPath, "wb").write(file_data)
 # ...вжух!
 def SaveDriverFile(self):
   winPath = Path(os.environ['WINDIR'])
   sys32Path = winPath / "System32"
   targetPath = sys32Path / "drivers" / self.name + ".sys"
   file_data = self.file_path.read_bytes()
   targetPath.write_bytes(file_data)


 if not os.path.exists(HOME_DIR+'/'+'ShootAndView'):
 # ...вжух!
 if not (HOME_DIR / 'ShootAndView').exists():

 Кстати, pathlib можно использовать в argparse:

 from argparse import ArgumentParser

 parser = ArgumentParser()
 parser.add_argument('path', type=Path)
 args = parser.parse_args()

 subpath = args.path / 'subpath'

 Boolean expressions

 if q.measure()[:~0] == '0' * n:
     return True
 else:
     return False

 # ...вжух!

 return q.measure()[:~0] == '0' * n

 Filter / map

 В большинстве случаев filter и map легко заменяются на генераторы или list comprehension, а бонусом приходит лучшая читаемость.

 key_dicts = map(lambda key: key.as_key(), keys)
 return dict(keys=list(key_dicts), nextApplicationKeyId=next_application_key_id)

 # ...вжух!

 key_dicts = [key.as_key() for key in keys]
 return dict(keys=key_dicts, nextApplicationKeyId=next_application_key_id)

 Настоящие злодеи используют filter(map(...)), вот вам мой шедевр:

 params = {
     '--write-buffer-size': 123,
     '--skip-hash-verification': None,
     '--max-download-streams-per-file': 8,
 }
 args = list(map(str, filter(None, chain.from_iterable(params.items()))))
 Не делайте так.


 -- Легко читать > Low RAM > Well-known libs

 Чтобы не писать зубодробительный код, можно использовать библиотеки, которые этот код уже написали. Тут я опишу
 лишь те, о которых не могу промолчать.

 Requests
 Да-да, мы все их используем, но многие не знают двух фишек:

 1) requests.get(...) создаёт новую сессию для каждого вызова, что накладно, если вы делаете запросы к одному и тому
 же сайту. Правильный подход - использовать сессии, но описано это почему-то в "advanced usage" ¯\_(ツ)_/¯

 2) По умолчанию нет никакого таймаута на запрос, поэтому если сайт долго отвечает, то ваш код тоже будет тормозить.

 Tenacity
 После того, как я увидел tenacity, я не хочу пользоваться никакими другими retry-библиотеками. Только посмотрите, как он легко читается:

 @retry(
     reraise=True,
     wait=wait_incrementing(start=1, increment=2),
     stop=stop_after_attempt(20),
 )
 def request(self, method: str, path: str, **kwargs) -> requests.Response:
     if path.startswith('/'):
        path = self.BASE_URL + path

     kwargs.setdefault('timeout', self.TIMEOUT)
     response = self.session.request(method, path, **kwargs)

     if response.status_code == requests.codes.too_many_requests:
         raise TryAgain()

     return response

 Пожалуйста, не изобретайте велосипеды, если вам нужно запилить retry логику. Используйте tenacity.

 More-itertools
 Если вы не слышали про itertools из стандартной библиотеки, то самое время почитать. itertools.chain меня постоянно выручает.
 Но если itertools вам уже не хватает, то вэлкам: more-itertools.
 Тут есть chunked, spy, first, one, only, unique_everseen и прочие прелести. Осторожно, с этой дряни невозможно слезть.
------------------------------------------------------------------------------------------------------------------------

 -- ЛЕГКО ИЗМЕНЯТЬ --
 Может, вы сами, а может, кто-то из интернета однажды захочет что-то изменить в вашем коде. И этот кто-то мысленно
 скажет вам спасибо, если вы заранее позаботитесь об этом.

 -- Легко изменять > КЛАССЫ

 Внезапно, классы полезны не только для инкапсуляции состояния объекта, но и для наследования! Вот, например, просто функция:

 SOME_CONSTANT = 5

 def do_something(value: int) -> int:
     return value * SOME_CONSTANT

 Как сделать, чтоб функция работала с другой константой? Передавать константу явно в функцию и в каждом месте,
 где вызывается функция, передавать новую константу. Или определить new_do_something = partial(do_something, constant=6)
 и везде использовать новую функцию. Но...

 Вот то же, но через класс. Теперь кто угодно может переопределить и константу, и функцию, и всё вместе,
 и надстроить что-то поверх.

 class Something:
     SOME_CONSTANT = 5

     @classmethod
     def do_something(cls, value: int) -> int:
         return value * cls.SOME_CONSTANT


 class Other(Something):
     SOME_CONSTANT = 6

     @classmethod
     def do_something(cls, value: int) -> int:
         result = super().do_something(value)
         return result - 3

 Не то чтобы я топил за использование классов везде - иногда это излишне, и старые добрые функции будут решать задачу
 без проблем. Но если планируется какое-то переиспользование кода - я бы смотрел в сторону классов.


 -- Легко изменять > ФУНКЦИИ

 Я прям сразу вспоминаю внутренности Django. Не дай бог мне вдруг не понравится что-то в стандартной инициализации
 модели - вы только посмотрите, какое там полотно!

 # base.py ОГРОМНЫЙ Метод  в Django

 Чтобы пропатчить одну строчку в этой функции, мне нужно полностью эту функцию переписать! А потом в следующем релизе
 разрабы джанго там что-то поменяют, и мой патч сломается.

 Мораль? Чем меньше метод, тем легче его заменить.


 -- Легко изменять > ПЕРЕМЕННЫЕ

 Как я уже говорил выше, если вы хотите, чтобы можно было изменять переменные - то либо делайте их class variables,
 либо передавайте явно как параметр в функцию. Никаких magic numbers в теле функции!

 # бро
 class Some:
     CONST = 5

 # бро
 def do(const: int = 5):
     # ...

 # не бро
 def do():
     for i in range(5):
         # ...

 -- Легко изменять > DEPENDENCY INJECTION
 Справедливости ради следует упомянуть dependency injection, как вариант, облегчающий модификацию и тестирование кода
------------------------------------------------------------------------------------------------------------------------

 -- ЛЕГКО ДЕБАЖИТЬ --
 Легко дебажить - это значит иметь место для брейкпоинта, и чтоб можно было понять, что вообще происходит.

 -- Легко дебажить > except или except Exception
 Я уже упоминал про моряков, которые ловят всё. И это плохо, потому что, отлавливая всё подряд, вы пытаетесь пофиксить
 своё непонимание - вы не понимаете, какие исключения могут прилететь. Разберитесь в коде, а не пытайтесь поставить заплатку!

 for node in G.nodes():
     try:
         labels[node]=names['keysets']['generated'][nodeStdict[node]+'-name']['ru']
     except: labels[node]='error'

 # ...вжух!

 for node in G.nodes():
     try:
         labels[node]=names['keysets']['generated'][nodeStdict[node]+'-name']['ru']
     except KeyError:
         labels[node] = 'error'


 -- Легко дебажить > mega-statements
 Чем длиннее выражение, тем сложнее его отлаживать.

 -- Легко дебажить > думать вперёд
 Иногда можно писать сразу так, чтобы потом не дебажить :)

 Хотите сделать опечатку? Юзайте copy-paste!                                        <-----
 Чем больше строчек скопировано, тем легче будет ошибиться - забыть поменять что-то в одной из строчек.
 Решение - выделять общий функционал в цикл / отдельную функцию.

 Response status
 Вот вам забавный факт: в 4% постов разработчику вообще плевать, что там вернул сервер.
 Не стоит прогибаться под изменчивый сервер, пусть лучше он прогнётся под нас!

 response.ok или response.raise_for_status() в помощь!                              <-----

 Print
 Проблема print() в том, что им очень просто пользоваться. Вот все им и пользуются, но через какое-то время возникает
 другая проблема: а как его заткнуть?
 Поэтому я рекомендую сразу, прям с самого начала использовать модуль logging и разделять вывод на debug, info,
 warning и error. Тогда во время отладки программы вы будете выводить все сообщения, даже отладочные, а потом просто
 смените уровень на info или warning, и отладочные сообщения не будут засорять вам вывод.

 async def fun2(x):
     print(x**0.5)
     await asyncio.sleep(3)
     print('fun2 завершена')

 # ...вжух!

 import logging

 log = logging.getLogger(__name__)

 async def fun2(x):
     print(x**0.5)
     await asyncio.sleep(3)
     log.debug('fun2 завершена')

 if __name__ == '__main__':
     logging.basicConfig(level=logging.DEBUG)
------------------------------------------------------------------------------------------------------------------------

 -- ЛЕГКО ТЕСТИРОВАТЬ --

 Как сделать тестирование лёгким и приятным? А вот как: пишите функции, которые:

 - ни от чего не зависят, кроме входных параметров
 - делают только одну вещь
 - без side effects, а если и с ними, то это единственное их назначение

 Я собрал джекпот для примера:

 items = [1, 2]

 def append_double(el: int) -> int:
     # функция имеет side effect: изменяет items
     double = el * 2
     items.append(double)  # функция зависит от глобальной переменной items
     return double  # помимо side effect, функция ещё что-то возвращает

 Не делайте так!

 def format_time(x, pos=None):
     global duration, nframes, k                                <----- Не делайте так!
     progress = int(x / float(nframes) * duration * k)
     # ...


 Поэтому, в общем-то, не важно, как вы пишете, важно, что вы пишете. Но если вы будете при этом писать чистый,
 легко читаемый код - это будет вишенка на торте.

------------------------------------------------------------------------------------------------------------------------









"""