"""

 Самое Важное!!!
 Всегда ДУМАТЬ! перед тем, как что-либо сделать, необходимо всё тщательно обдумать

 Радоваться Жизни  Радоваться разным мелочам

 Ценить:         Ценить то что есть и стремиться к лучшему, Ценить сегодняшний день и брать МАКСИМУМ
 Быть проще:     Ко всему относиться Проще и Спокойнее без Волнения
 Слушать Других: Прислушиваться к мнению других людей они могут быть правы  И делать выводы
 Время:          Тайм-менеджмент   Грамотное распределение времени, Контроль Времени, Правильно раставлять Приоритеты
 Уверенность:    Быть уверенным в себе НО Оценивать свои силы!
 Развития:       Развиваться, Учиться, учиться и ещё раз - учиться, Саморазвитие
 Не Надеяться:   Надеяться только на себя
 Контроль:       Быть менее Эмоциональным, Совладать с Эмоциями, Контролировать свои эмоции в любой ситуации
 Внимательность: Быть Внимательным
 Спокойствие:    Быть Спокойнее, Перестать Нервничать , Быть Расслабленным, Не Злиться на себя и на других
 Режим:          Правильный Сон, Пить Воду
 Зарядка:        Бег, Тренировки, Стойка на Голове
 Тельце в тепле: НЕ переохлаждаться

 Молчание золото:  Лучше промолчать, чем сказать и потом жалеть о том, что сказал
 Соломон:          Все пройдёт, и это тоже пройдёт
 Вообще это замечательный подход: осознать, что проблема не такая уж и проблема, и вполне решаема.
 Кто ищет-тот всегда найдет!
 Искать Другие способы
 Не спеши, а то успеешь...   Успеешь, но не туда куда хотел...
 Подумай, нужно ли тебе ЭТО и для Чего
 Надо принимать вещи такими, как они есть, и пользоваться ими с наибольшей для себя выгодой.
 Если научиться принимать вещи как они есть, страдание исчезнет.
 У каждого свои недостатки
________________________________________________________________________________________________________________________

 help(re.search) - Можно вызывать help к разным функциям  - Справка по любому объекту Python

 Заметки о Python:
 Всякий раз, когда вы используете скобки (...), используйте вместо них не захватывающие (?:...). Это связано с module re
 ограничением на количество захватывающих (или именованных) групп, которое ограничено 99.

 Не парсите HTML/XHTML/JSON с помощью регулярных выражений! Регулярные выражения не созданы для этого.

 Это правило не распространяется на парсинг самих данных. Например, если вам нужно найти все номера телефонов в
 HTML-документе - регулярные выражения идеально подойдут для этой задачи, если вы будете искать сами номера телефонов.
 Но если вы будете искать HTML-теги, атрибуты, классы, и только потом доставать нужные значения - это плохая идея.

 Напоминаю, что если регулярки использовать не по назначению - они могут нанести только вред.
 Стоит запомнить, что если задача легко решается без регулярных выражений - её так и стоит решать.

  Group ()    Non-capturing group   (?:)
 группы имеет смысл использовать только тогда, когда вы к ним обращаетесь или работаете с их данными. ()  (?:)
 Во всех остальных случаях нужно использовать Non-capturing group. (?:)

 Проверить Регулярку  прямо в PyCharm   Alt + Enter  внутри r'каретка' и выбираем  Check RegExp  и Тестируем и Экранирование
 Регулярку можно использовать в PyCharm Ctrl + f   и выбираем  .*    Чтобы  НЕ Игнорировать регистр  -  Cc      <-----
 Можно использовать  Онлайн-сервис:  regex101

 Регулярные выражения, или коротко, регулярки — очень мощный инструмент. Использовать их следует с умом и осторожностью,
 и только там, где они действительно приносят пользу, а не вред:
 - Плохо написанные регулярные выражения работают медленно
 - Их сложно читать, особенно если писал их не ты
 - Небольшое изменение задачи приводит к значительному изменению выражения

 IDE PyCharm  - После изменения тестовых данных или регулярки нужно перезапускать программу  Shift + f10

 Нельзя закомментировать код если курсор/каретка находиться внутри r""   re.findall(r'\d', 'ABC')  внутри r'каретка'


 # Это означает, что найденные совпадения не пересекаются и движок регулярных выражения ищет совпадения по порядку.
 print(re.findall(r'00', '000000000000'))  # -> ['00', '00', '00', '00', '00', '00']  # Нашлось всего лишь 6 совпадений.

 # В Python по-умолчанию Включено экранирование
 print('nnnn')  # -> nnnn
 print('nn\nn')
 # -> nn
 # -> n

 2 способа  отключения экранирования: Сырые строки r""  и  слэш \
 Всегда используем Сырые строки r""  -  отключить экранирование чтобы не использовать слэш \ постоянно

 fr'' rf'' - Нет разницы
 2 префикса сразу. fr-строка:  fr'test'       fr'' rf''  для escape в регулярках не работает квантификатор  {}
 2 префикса сразу. rf-строка:  rf'test'       fr'' rf''  для escape в регулярках не работает квантификатор  {}
 Решение!!!     - Используем двойные {{ }} и всё будет работать
 Можно использовать двойные фигурные скобки при f-string & r-raw, т.е. это будет как \w{,2}     re.sub(fr'{a}\w{{,2}}'

 Пример fr'' rf''  Используем двойные {{ }} и всё будет работать

 # Одинарные фигурные скобки питон будет воспринимать как переменную, а двойные, как квантификатор (количество повторений).
 # Не находит потому что в fr'{}' это как в ф-строке f'number {10}' или f'string {str(10)}'
 text = r'#DC143C #00FA9A #00BFFF #FF00FF #EEE8A #FF #FFD7 #940 #483D8 #pressF'
 # НЕ Работает
 print(re.findall(fr'(?i)#[0-9a-z]{6}', text))    # -> []                           # {6}   - Переменная
 # Работает                                                                         # {{6}} - Работает
 print(re.findall(fr'(?i)#[0-9a-z]{{6}}', text))  # -> ['#DC143C', '#00FA9A', '#00BFFF', '#FF00FF', '#pressF']  # fr'{{}}'
 print(re.findall(r'(?i)#[0-9a-z]{6}', text))     # -> ['#DC143C', '#00FA9A', '#00BFFF', '#FF00FF', '#pressF']  # r'{}'
 # Тут в конце регулярки вместо z стоит f
 print(re.findall(r'(?i)#[0-9a-f]{6}', text))     # -> ['#DC143C', '#00FA9A', '#00BFFF', '#FF00FF']


 re - Могут принимать в качестве аргумента  str  или bytes                                  <----   ВАЖНО!!!

 # rb  Для поиска в b''  БАЙТОВЫХ СТРОКАХ                                                   <----   ВАЖНО!!!
 text = '111'
 text_rb = b'111'
 print(re.findall(r'1', text))      # -> ['1', '1', '1']
 print(re.findall(rb'1', text_rb))  # -> [b'1', b'1', b'1']         # rb''


 --- Compare with Clipboard   PyCharm  Как сравнить текст или файл ---
 Ctrl + C или Ctrl + Х   и выделяем другой текст  и нажимаем ЛКМ и выбираем Compare with Clipboard
 Можно сравнивать и файлы.  Текст должен быть в ТРОЙНЫХ КАВЫЧКАХ                                                <-----


 x(?=y) находит x, только если за x следует y             # Positive Lookahead
 x(?!y) находит x, только если за x НЕ следует y          # Negative Lookahead
 (?<=y)x находит x, только если перед x следует y         # Positive Lookbehind
 (?<!y)x находит x, только если перед x НЕ следует y      # Negative Lookbehind

 # Ищет слово test среди двух цифр, но не захватывает их:
 text = r'12313495test123123'

 print(re.findall(r"(?<=\d)test(?=\d)", text))  # -> ['test']


 Ограничение Lookbehind    Можно использовать Только фиксированные квантификаторы внутри                        <-----
 Обратите внимание, что все выражения в lookbehind должны быть фиксированной ширины, иначе вы получите ошибку
 re.error: look-behind requires fixed-width pattern.

 # Длина вхождений выражений в Lookbehind может быть разной. Поэтому появится ошибка
 # Вызовут ошибку:
 re.search(r'(?<=test{0,})regex', 'ABC')    # -> re.error: look-behind requires fixed-width pattern
 re.search(r'(?<=g?)regex', 'ABC')          # -> re.error: look-behind requires fixed-width pattern
 re.search(r'(?<!Python+)regex', 'ABC')     # -> re.error: look-behind requires fixed-width pattern

 # Длина вхождений выражений в Lookbehind фиксированная. Всё выполнится без ошибок
 # Ошибки не будет:
 re.search(r'(?<=test)regex', 'ABC')        # -> None
 re.search(r'(?<=g{21})regex', 'ABC')       # -> None
 re.search(r'(?<!Pytho[mn])regex', 'ABC')   # -> None

 Такая особенность есть только у Lookbehind.                                                                   <-----
 Lookahead позволяет использовать внутри себя выражения неопределённой длины.                                  <-----

 Для тех кто не понял, так можно Lookahead (обратите внимание на .*):
 1(?=.*6) -> '1 2 3 6 2 8' (после 1 где то есть 6)
 3(?!.*1) -> '1 2 3 6 2 8' (после 3 нигде нет 1)

 А вот так нельзя Lookbehind (хотя можно к примеру на C#)
 (?<=6.*)8 -> '1 2 3 6 2 8' (перед 8 где то есть 6)
 (?<!8.*)3 -> '1 2 3 6 2 8' (перед 3 нигде нет 8)

 Обратите внимание, что в lookbehind можно использовать |, только если все шаблоны одинаковой длины.
 То есть такие выражения будут правильными:
 # Правильные                # НЕ Правильные
 (?<=hi!|bye)                (?<=hi!|long_text)    # re.error: look-behind requires fixed-width pattern
 (?<![abcdef]|\d)            (?<![abcdef]|\d{4})   # re.error: look-behind requires fixed-width pattern
 (?<=\w|\W|\s)               (?<=\w\s|\W)          # re.error: look-behind requires fixed-width pattern

 Для того, чтобы обойти такое исключение, нужно использовать | в non-capturing group:
 (?:(?<=hi!)|(?<=long_text))
 (?:(?<![abcdef])|(?<!\d{4}))
 (?:(?<=\w\s)|(?<=\W))

 В lookahead можно спокойно ставить условия с шаблонами разной длины, ошибок не будет.

 Никто не запрещает ставить несколько lookahead или lookbehind друг за другом.                         <-----   <-----

 # Разбор Ищем Букву X если перед X цифра 1,2,3,4,5 Но не 4  и если после X цифра 1,2,3,4,5 Но не 4    <-----   <-----
 text = '1X1 2X2 3X3 4X4 5X5 6X6 7X7 8X8 9X9'
 print(re.findall(r'(?<!4)(?<=[1-5])X(?=[1-5])(?!4)', text))  # -> ['X', 'X', 'X', 'X']


 ReDoS-атака неправильно использующие регулярные выражения, позволяющая их замедлить или полностью вывести из строя.
 # -  В чём суть Catastrophic Backtracking?

 # Запустим выражение на строке из 20 символов a:
 re.findall(r"(a+)+b", "a" * 20)
 # Выполнилось за 0.1421067714691162

 # Запустим выражение на строке из 30 символов a:
 re.findall(r"(a+)+b", "a" * 30)
 # Выполнилось за 147.2978949546814

 # Прирост более чем в тысячу раз!!!


 # Решение атомарная группа и притяжательные квантификаторы
 re.findall(r"(?>a++)++b", "a" * 30)
 # Выполнилось за 0.0

 -- Первое решение проблемы  Catastrophic Backtracking:  Притяжательные квантификаторы
 Если после жадного квантификатора поставить +, то он станет притяжательным:
 {m,n}+
 {,n}+
 {m,}+
 *+
 ++
 ?+

 Это значит, что движок не будет проходить огромное количество путей и закончит свою работу раньше,
 если совпадение не будет найдено.

 -- Второе решение проблемы  Catastrophic Backtracking:  Атомарная группировка  (?>regex)
 С помощью атомарной группировки можно сказать движку, что откатываться в этом месте и искать всевозможные пути
 не имеет смысла: внутри (?>regex) откат запрещён.


 Модуль re - это просто модуль расширения на языке C, включенный в Python   Шаблоны обрабатываются как строки   <-----


 Специальные символы:
 '.'              - любой символ кроме новой строки;  кроме переноса строки \n
 '^'              - началу строки;  Добавляем в НАЧАЛЕ строки
 '$'              - конец строки;   Добавляем в КОНЦЕ строки
 '*'              - Предыдущий символ 0 или более повторений;   сокращенная форма: {0,}    Жадный
 '+'              - Предыдущий символ 1 или более повторений;   сокращенная форма: {1,}    Жадный
 '?'              - Предыдущий символ 0 или 1 повторений;       сокращенная форма: {0,1}
 '*?', '+?','??'  - ограничение жадности;
 '*+', '++', '?+' - притяжательные квантификаторы, (новое в Python 3.11);
 '{m}'            - m повторений;                                             Нет смысла ставить '?'  Жадный/НЕ Жадный
 '{m,n}'          - как можно больше повторений в промежутке от m до n ;    Жадный
 '{m,n}?'         - как можно меньше повторений в промежутке от m до n;  НЕ Жадный/Ленивый
 '{m,n}+'         - притяжательная версия квантификатора выше, (новое в Python 3.11);
 '\'              - экранирование специальных символов;
 '[]'             - символьный класс;           Символьный класс [] - описывает только 1 символ
 '|'              - или  or;        если A совпало, то B не будет проверяться,  оператор ' | ' никогда не бывает жадным.
 '(...)'          - группа с захватом;

 Квантификаторы '*', '+' и '?' являются жадными. Они пытаются захватить как можно больше текста для анализа.
 Жадный      - означает что квантификатор находит самые 'ДЛИННЫЕ' последовательности     'ДЛИННЫЕ'       <-----
 НЕ Жадный ? - означает что квантификатор находит самые 'КОРОТКИЕ' последовательности    'КОРОТКИЕ'      <-----


 Расширения регулярных выражений:
 '(?aiLmsux)'                         - установка флагов регулярного выражения;
 '(?aiLmsux-imsx:...)'                - установка и удаление флагов;
 '(?>...)'                            - атомарная группа, (новое в Python 3.11);
 '(?:...)'                            - группа без захвата;
 '(?P<name>...)'                      - именованная группа;
 '(?P=name)'                          - обратная ссылка на именованную группу;
 '(?#...)'                            - комментарий;
 '(?=...)'                            - опережающая позитивная проверка;
 '(?!...)'                            - опережающая негативная проверка;
 '(?<=...)'                           - позитивная ретроспективная проверка;
 '(?<!...)'                           - негативная ретроспективная проверка;
 '(?(id/name)yes-pattern|no-pattern)' - стараться соответствовать yes-pattern;


 Вот полный список метасимволов: '.', '^', '$', '*', '+', '?', '{', '}', '[', ']', '\', '|', '(', ')'

 Для часто используемых символьных классов существуют краткие обозначения.                                     <-----
 Специальные последовательности:                              Эквивалентно символьному классу []:
 '\number' - соответствие группы с тем же номером;
 '\A'      - только с начало строки;
 '\b'      - пустая строка (начало или конец слова);                                   инверсия - это противоположность
 '\B'      - пустая строка (НЕ начало или НЕ конец слова);                                 '\B' инверсия '\b'
 '\d'      - любая десятичная цифра;                          [0-9]
 '\D'      - НЕ десятичная цифра;                             [^0-9]               [^\d]   '\D' инверсия '\d'
 '\s'      - пробельный символ;                               [ \t\n\r\f\v]
 '\S'      - НЕ пробельный символ;                            [^ \t\n\r\f\v]       [^\s]   '\S' инверсия '\s'
 '\w'      - буквенно-цифровые(str.isalnum()) и _             [A-Za-zА-Яа-я0-9_]
 '\W'      - НЕ буквенно-цифровые(str.isalnum()) и _          [^A-Za-zА-Яа-я0-9_]  [^\w]   '\W' инверсия '\w'
 '\Z'      - только с конец строки;


 Специальные последовательности - Сокращённые обозначения символьных классов  <-----

 Важно отметить, что буквы «Ё» и «ё» НЕ входят в диапазоны [А-Я] и [а-я]. Поэтому их надо отдельно включать, [а-яА-ЯЁё]
 иначе регулярное выражение будет работать с ошибками. [а-яА-ЯЁё]

 Утверждения нулевой ширины - Они НЕ заставляют движок регулярных выражений продвигаться по строке. Они вообще НЕ
 сравниваются с символами, они просто сообщают движку регулярных выражений о присутствии данного условия в строке
 или терпят неудачу.                                                                                  <-----     <-----
 Метасимволы нулевой ширины: |  ^  $  \A  \Z  \b  \B                                                  <-----     <-----

 Якоря         -  '^'   начало строки   '$'  конец строки
 Границы слова -  /b  начало конец слова
 Или           -  |
 Группы        -  ()

 Управляющие символы Python:                                                     # Сырые строки r''  экранирования откл.
 \t - Горизонтальная табуляция(Tab)  HT     print('AB\tCD')  # -> AB	CD       print(r'AB\tCD')  # -> AB\tCD
 \v - Вертикальная табуляция         VT     print('AB\vCD')  # -> ABCD         print(r'AB\vCD')  # -> AB\vCD
 \r - Возврат каретки                CR     print('AB\rCD')  # -> CD             print(r'AB\rCD')  # -> AB\rCD
 \n - Перевод строки                 LF     print('AB\nCD')  # -> AB \n CD       print(r'AB\nCD')  # -> AB\nCD
 \f - Конец страницы                 FF     print('AB\fCD')  # -> ABCD         print(r'AB\fCD')  # -> AB\fCD
 \a - Звонок                         BEL    print('AB\aCD')  # -> ABCD        print(r'AB\aCD')  # -> AB\aCD
 \b - Забой (Backspace)              BS     print('AB\bCD')  # -> ACD            print(r'AB\bCD')  # -> AB\bCD

 # Написать одну кавычку или две внутри таких-же
 print('\'')  # -> '
 print("\"")  # -> "


 # Чтобы экранировать используем Сырые строки r'' или обратный слэш '\'                         <-----
 print('AB\\\\nCD')   # -> AB\\nCD
 print(r'AB\\\\nCD')  # -> AB\\\\nCD

 "Сырая" строка r"" не может заканчиваться символом обратного слэша. Пути решения:              <-----
 print(r'\n\n\')         # -> SyntaxError: unterminated string literal (detected at line 117)
 print(r'\n\n\\'[:-1])   # -> \n\n\
 print(r'\n\n' + '\\')   # -> \n\n\
 print('\\n\\n')         # -> \n\n

 Ограничения для f-строки:                                                                      <-----
 # Вместе с сырой строкой r'' можно
 f'{r"Hello"}'  # -> Hello

 # Использовать backslash '\'  в Python < 3.12 НЕЛЬЗЯ         Python 3.12+ МОЖНО                <-----
 f'{"\"}'  # -> SyntaxError: f-string expression part cannot include a backslash
 f'{\}'    # -> SyntaxError: f-string expression part cannot include a backslash

 # Используем 2 префикса одновременно              Разницы между fr-строками и rf-строками нет. <-----
 raw_f_string = rf'C:\file.txt'  # rf''
 f_raw_string = fr'C:\file.txt'  # fr''

 HTML НЕ парсится регулярными выражениями. Лучше использовать Библиотеки для парсинга: BeautifulSoup , Requests

 Функции модуля re создают объект шаблона и вызывают соответствующий метод для него. Они также хранят скомпилированный
 объект в кеше, поэтому будущие вызовы с использованием одного и того же регулярного выражения не будут анализировать
 его снова и снова. Вне циклов, нет большой разницы что лучше использовать, благодаря внутреннему кэшу.   <-----

 Функции Functions  re:

 re.compile(pattern, flags=0)                     - Компилировать шаблон регулярного выражения
 re.search(pattern, string, flags=0)              - Поиск первого совпадения с pattern в любом месте или None если НЕ совпадает
 re.match(pattern, string, flags=0)               - Находит совпадение только в начале строки или None если НЕ совпадает
 re.fullmatch(pattern, string, flags=0)           - Поиск строки, полностью совпадающей c pattern или None
 re.split(pattern, string, maxsplit=0, flags=0)   - Разделить строку по разделителю и вернуть список подстрок
 re.findall(pattern, string, flags=0)             - Поиск всех совпадений и вернуть в виде списка или список кортежей
 re.finditer(pattern, string, flags=0)            - Возвращает итератор всех совпадения с pattern.
 re.sub(pattern, repl, string, count=0, flags=0)  - Поиск и замена, если нет замен строка возвращается без изменений.
 re.subn(pattern, repl, string, count=0, flags=0) - Аналогично re.sub но возвращает кортеж (new_string, number_of_subs_made)
 re.escape(pattern)                               - Экранирование специальных символов в pattern
 re.purge()                                       - Очищает кэш от регулярных выражений. Полезно при метасимволах regexp
------------------------------------------------------------------------------------------------------------------------

 -- Примеры функций re:

 ----------------------------------------  re.compile  -----------------------------------------------------------------

 # Пример с правильными переносами
 regex = re.compile("[A-Za-z_]"       # letter or underscore             буква или подчеркивание
                    "[A-Za-z0-9_]*"   # letter, digit or underscore      буква, цифра или подчеркивание
                   )
 print(re.findall(regex, 'ABC123---'))  # -> ['ABC123']


 prog = re.compile(r'(?i)[а-я]+')
 prog  # -> re.compile('(?i)[а-я]+', re.IGNORECASE)
 type(re.compile(r'\w+', re.IGNORECASE))              # -> <class 're.Pattern'>
 re.compile(r'\w+', re.IGNORECASE).findall('ABC123')  # -> ['ABC123']

 # Можно использовать со всеми функциями re                                                                     <-----
 p = re.compile(r'(\w+)\s*(\d+)')
 p.search('ABC 123')   # -> <re.Match object; span=(0, 7), match='ABC 123'>
 p.findall('ABC 123')  # -> [('ABC', '123')]

 # модуль re компилирует и кэширует регулярное выражение, практические нет разницы в использовании compile и БЕЗ
 # Разница только в ЧИТАЕМОСТИ и УДОБСТВЕ                                                                       <-----
 s1, s2, s3, s4 = 'foo.bar', 'foo123bar', 'baz99', 'qux & grault'

 pattern = re.compile('\d+')             regex = '\d+'
 pattern.findall(s1)  # -> []            re.findall(regex, s1)  # -> []            re.findall(r'\d+', s1)  # -> []
 pattern.findall(s2)  # -> ['123']       re.findall(regex, s2)  # -> ['123']       re.findall(r'\d+', s2)  # -> ['123']
 pattern.findall(s3)  # -> ['99']        re.findall(regex, s3)  # -> ['99']        re.findall(r'\d+', s3)  # -> ['99']
 pattern.findall(s4)  # -> []            re.findall(regex, s4)  # -> []            re.findall(r'\d+', s4)  # -> []

 ----------------------------------------  re.search  ------------------------------------------------------------------
 # Возвращает обьект re.Match object  Есть дополнительные методы Match                                          <-----
 re.search(r'(\w+)', 'AB ab 12')        # -> <re.Match object; span=(0, 2), match='AB'>
 type(re.search(r'(\w+)', 'AB ab 12'))  # -> <class 're.Match'>

 from re import search                                                                                          <-----
 # заканчивает работу при ПЕРВОМ совпадении    совпадение может НЕ начинаться с start() 0.
 re.search('super', 'superstition')            # -> <re.Match object; span=(0, 5), match='super'>
 re.search('super', 'superstition').span()     # -> (0, 5)
 re.search('super', 'superstition')[0]         # -> super
 re.search('Hello', 'superstition')            # -> None

 result = re.search('super', 'ssuperr super')
 result[0]                                     # -> super       возвращает только первое даже если их больше
 result = re.search('super', 'insuperable')
 result[0]                                     # -> super
 result.span()                                 # -> (2, 7)  span - индекс начала и конца найденной подстроки в тексте
 result.start(), result.end()                  # -> 2 7     start - первый индекс , end - последний индекс

 # Находит и НЕ находит совпадение                                                                               <-----
 from re import search
 re.search('[0-9][0-9][0-9]', 'foo456bar')  # -> <re.Match object; span=(3, 6), match='456'>      # Находит
 re.search('[0-9][0-9][0-9]', '12foo34')    # -> None                                             # такой строки нет

 re.search('1.3', 'foo123bar')  # -> <re.Match object; span=(3, 6), match='123'>                  # Находит
 re.search('1.3', 'foo13bar')   # -> None                                                         # такой строки нет

 ----------------------------------------  re.match  -------------------------------------------------------------------
 # Возвращает обьект re.Match object  Есть дополнительные методы Match                                          <-----
 re.match(r'(\w+)', 'AB ab 12')        # -> <re.Match object; span=(0, 2), match='AB'>
 type(re.match(r'(\w+)', 'AB ab 12'))  # -> <class 're.Match'>

 # проверяет только совпадает ли выражение в начале строки, то следовательно start() всегда будет 0.
 re.match('super', 'superstition').span()  # -> (0, 5)
 re.match('super', 'superstition')[0]      # -> super     Находит только если pattern в начале
 re.match('super', 'insuperable')          # -> None      pattern находится НЕ в начале

 # проверка его наличия None. Это обычно выглядит так:
 m = re.match(r'\w+',  'ABC' )                            m = re.match(r'\d+',  'ABC' )
 if m:                                                    if m:
     print('Match found: ', m.group())                        print('Match found: ', m.group())
 else:                                                    else:
     print('No match')                                        print('No match')
 # -> Match found:  ABC                                   # -> No match


 # Добавление .* устраняет эту оптимизацию, требуя сканирования до конца строки, а затем возврата, чтобы найти
  соответствие для остальной части регулярного выражения.                                           <-----       <-----
 # Не надо так делать, вместо этого просто используйте re.search()
 re.match(r'.*', ' abc ')   # НЕ НУЖНО Использовать match и   .*
 re.search(r'.*', ' abc ')  # Лучше используем search()

 ----------------------------------------  re.fullmatch ----------------------------------------------------------------
 # Возвращает обьект re.Match object  Есть дополнительные методы Match                                          <-----
 re.fullmatch(r'AB ab 12', 'AB ab 12')        # -> <re.Match object; span=(0, 8), match='AB ab 12'>
 type(re.fullmatch(r'AB ab 12', 'AB ab 12'))  # -> <class 're.Match'>

 re.fullmatch(r'super 205', 'super 205')       # -> <re.Match object; span=(0, 9), match='super 205'>
 re.fullmatch(r'[a-z]+\s\d+', 'super 205')     # -> <re.Match object; span=(0, 9), match='super 205'>
 re.fullmatch(r'[a-z]+\s\d+', 'super 205')[0]  # -> super 205
 re.fullmatch(r'[a-z]+\s\d+', 'puper 05')      # -> <re.Match object; span=(0, 8), match='puper 05'>
 re.fullmatch(r'[a-z]+\s\d+', 'puper 05 ')     # -> None

 ----------------------------------------  re.split  -------------------------------------------------------------------
 # Возвращает Список(list)   НЕТ Методов Match                                                                  <-----
 re.split(r'(\w+)', 'AB ab 12')        # -> ['', 'AB', ' ', 'ab', ' ', '12', '']
 type(re.split(r'(\w+)', 'AB ab 12'))  # -> <class 'list'>

 text = "10, -., !20&,, .. 30, A"

 words_reg = re.split(r"\W+", text)
 words_reg        # -> ['10', '20', '30', 'A']
 # Сравнение с методом строки str.split() - поддерживает только разделение пробелами или фиксированной строкой.
 text.split(' ')  # -> ['10,', '-.,', '!20&,,', '..', '30,', 'A']


 re.split(r' ', 'Hello world')  # -> ['Hello', 'world']

 re.split(r'\W+', 'Words, words, words.')          # -> ['Words', 'words', 'words', '']
 re.split(r'(\W+)', 'Words, words, words.')        # -> ['Words', ', ', 'words', ', ', 'words', '.', '']
 re.split(r'\W+', 'Words, words, words.', 1)       # -> ['Words', 'words, words.']
 re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)  # -> ['0', '3', '9']

 re.split(r'(\W+)', '...words, words...')  # -> ['', '...', 'words', ', ', 'words', '...', '']

 re.split(r'\b', 'Words, words, words.')   # ->  ['', 'Words', ', ', 'words', ', ', 'words', '.']
 re.split(r'\W*', '...words...')           # ->  ['', '', 'w', 'o', 'r', 'd', 's', '', '']
 re.split(r'(\W*)', '...words...')  # -> ['', '...', '', '', 'w', '', 'o', '', 'r', '', 'd', '', 's', '...', '', '', '']

 # Если используем группы захвата то возвращаемый список также включает соответствующие строки-разделители
 re.split('(\s*[,;/]\s*)', 'foo,bar  ;  baz / qux')  # -> ['foo', ',', 'bar', '  ;  ', 'baz', ' / ', 'qux']
 re.split('\s*[,;/]\s*', 'foo,bar  ;  baz / qux')    # -> ['foo', 'bar', 'baz', 'qux']
 re.split('(/)', '/foo/bar/baz/')                    # -> ['', '/', 'foo', '/', 'bar', '/', 'baz', '/', '']

 ----------------------------------------  re.findall  -----------------------------------------------------------------
 # Возвращает Список(list)   НЕТ Методов Match                                                                  <-----
 re.findall(r'(\w+)', 'AB ab 12')        # -> ['AB', 'ab', '12']
 type(re.findall(r'(\w+)', 'AB ab 12'))  # -> <class 'list'>

 re.findall(r'words', 'Words, words, words.')  # -> ['words', 'words']                      Работает как search/match
 re.findall(r'ords', 'Words, words, words.')   # -> ['ords', 'ords', 'ords']

 text = "период Российской империи (1721—1917), советский период (1917—1991)"

 years = re.findall(r"\d{4}", text)            #  найти 4 цифры
 periods = re.findall(r"\d{4}—\d{4}", text)    #  найти 4 цифры c разделителем и потом еще 4 цифры
 years      # -> ['1721', '1917', '1917', '1991']
 periods    # -> ['1721—1917', '1917—1991']

 text_2 = 'ул. Большая, дом № 12, корпус 2, квартира 200'

 re.findall(r'\d{2}', text_2)         # -> ['12', '20']                                        Найти 2 цифры
 re.findall(r'\d{1}', text_2)         # -> ['1', '2', '2', '2', '0', '0']                      Найти 1 цифру
 re.findall(r'\d+', text_2)           # -> ['12', '2', '200']                                  Найти все цифры
 re.findall(r'(?i)([а-я]+)', text_2)  # -> ['ул', 'Большая', 'дом', 'корпус', 'квартира']      Найти все слова

 re.findall(r'(\w+)=(\d+)', 'set width=20 and height=10')  # -> [('width', '20'), ('height', '10')]


 re.findall(r'\w+', '...foo,,,,bar:%$baz//|')     # -> ['foo', 'bar', 'baz']
 re.findall(r'#(\w+)#', '#foo#.#bar#.#baz#')      # -> ['foo', 'bar', 'baz']  # символ '#' за пределами группы ()
 re.findall(r'(\w+),(\w+)', 'A,B,C,D,E,F')        # -> [('A', 'B'), ('C', 'D'), ('E', 'F')]  # 3 Кортежа(tuple)
 re.findall(r'(\w+),(\w+),(\w+)', 'A,B,C,D,E,F')  # -> [('A', 'B', 'C'), ('D', 'E', 'F')]    # 2 Кортежа(tuple)

 ----------------------------------------  re.finditer  ----------------------------------------------------------------
 # Возвращает iterator  НЕТ Методов Match                                                                       <-----
 re.finditer(r'(\w+)', 'AB ab 12')        # -> <callable_iterator object at 0x000002051A465450>
 type(re.finditer(r'(\w+)', 'AB ab 12'))  # -> <class 'callable_iterator'>

 result = re.finditer(r'words', 'Words, words, words.')
 list(result)  # -> [<re.Match object; span=(7, 12), match='words'>, <re.Match object; span=(14, 19), match='words'>]

 text_2 = 'ул. Большая, дом № 12, квартира 200'

 result = re.finditer(r'\d+', text_2)  # Найти все цифры
 list(result)  # -> [<re.Match object; span=(19, 21), match='12'>, <re.Match object; span=(32, 35), match='200'>]

 ----------------------------------------  re.sub  ---------------------------------------------------------------------
 # Возвращает Строку(str) НЕТ Методов Match                                                                     <-----
 re.sub(r'(\w+)', 'A', 'AB ab 12')        # -> A A A
 type(re.sub(r'(\w+)', 'A', 'AB ab 12'))  # -> <class 'str'>

 re.sub(что меняем, на что меняем, где меняем)                                                                  <-----

 # почему НЕ работает                                       # почему  РАБОТАЕТ
 re.sub('abc', '*', 'ABC', re.IGNORECASE)        # -> ABC   re.sub('abc', '*', 'ABC', flags=re.IGNORECASE)       # -> *
 re.sub(r'ABC', '*', 'ABC', re.IGNORECASE)       # -> *     re.sub(r'ABC', '*', 'ABC', flags=re.IGNORECASE)      # -> *
 re.sub(r'(?i:ABC)', '*', 'ABC', re.IGNORECASE)  # -> *     re.sub(r'(?i:ABC)', '*', 'ABC', flags=re.IGNORECASE) # -> *
 re.sub(r'(?i)abc', '*', 'ABC', re.IGNORECASE)   # -> *     re.sub(r'(?i)abc', '*', 'ABC', flags=re.IGNORECASE)  # -> *

 info = '10 EUR 20 EUR 30 EUR - EURO EUROPE'

 result = re.sub(r"\bEUR\b", "USD", info)  # Замена EUR на USD
 result                          # -> 10 USD 20 USD 30 USD - EURO EUROPE
 # Сравнение с методом строки replace
 info.replace('EUR', 'USD')      # -> 10 USD 20 USD 30 USD - USDO USDOPE      <- USDOPE
 info.replace(' EUR ', ' USD ')  # -> 10 USD 20 USD 30 USD - EURO EUROPE

 result = re.sub(r"300", "10", "300 300")  # Замена 300 на 10                                           <-----
 result  # -> 10 10

 result = re.sub(r"300", "10", "300 300", count=1)  # 300 на 10   count - ограничение замен             <-----
 result  # -> 10 300

 # Замена в группе ()                                                                                   <-----
 text = "03/25/2018.   04/01/2018."
 re.sub(r'(\d\d)/(\d\d)/(\d{4})', r'\2.\1.\3', text)  # -> 25.03.2018.   01.04.2018.  # Группы может менять местами

 # Замена по индексу группы: '\1' '\2'                                                                   <-----
 re.sub(r'(\w+)\s*(\d+)', r'\2 \1',  'ABC 123')                                    # -> 123 ABC   # Поменяли местами
 # Замена по Имени группы:   '\g<name>'                                                                  <-----
 re.sub(r'(?P<first>\w+)\s*(?P<second>\d+)', r'\g<second> \g<first>',  'ABC 123')  # -> 123 ABC   # Поменяли местами

 # Интересный пример
 p = re.compile(r'x*')
 p.sub('-', 'abxd')  # -> -a-b--d-

 ----------------------------------------  re.subn  --------------------------------------------------------------------
 # Возвращает Кортеж(tuple) НЕТ Методов Match                                        <-----
 re.subn(r'(\w+)', 'A', 'AB ab 12')        # -> ('A A A', 3)
 type(re.subn(r'(\w+)', 'A', 'AB ab 12'))  # -> <class 'tuple'>

 info = '10 EUR 20 EUR 30 EUR - EURO EUROPE'

 result = re.subn(r"\bEUR\b", "USD", info)  # Замена EUR на USD и покажет сколько было замен
 result  # -> ('10 USD 20 USD 30 USD - EURO EUROPE', 3)   3 - количество замен

 result = re.subn(r"A", "B", "AAA")  # A на B  и количество замен
 result  # -> ('BBB', 3)   # 3 - замены

 result = re.subn(r"A", "B", "AAA", count=2)  # A на B  и количество замен и ограничение замен
 result  # -> ('BBA', 2)   # 2 - замены

 ----------------------------------------  re.escape  ------------------------------------------------------------------
 # Возвращает Строку(str) НЕТ Методов Match                                                                     <-----
 re.escape("!#$%&'*+-.^_`|~:")        # -> !\#\$%\&'\*\+\-\.\^_`\|\~:
 type(re.escape("!#$%&'*+-.^_`|~:"))  # -> <class 'str'>

 re.escape('foo^bar(baz)|qux') == 'foo\^bar\(baz\)\|qux'  # -> True

 # Очень ИНТЕРЕСНЫЕ Примеры Смотри все  Удобное Экранирование Всего!!!    fr"" - комбинации        <-----    <-----

 # Пример с одинаковым результатом
 text = r'[^START]Text{(END.)}'

 start, end = re.escape('[^START]'), re.escape('{(END.)}')
 regex = fr'(?<={start}).*(?={end})'
 re.findall(regex, text)    # -> ['Text']

 # Тоже самое
 regex = fr"(?<={re.escape('[^START]')})[\w ]*(?={re.escape('{(END.)}')})"
 re.findall(regex, text)    # -> ['Text']

 # Тоже самое
 lb = re.escape('[^START]')
 rb = re.escape('{(END.)}')

 regex = fr'{lb}(.*?){rb}'
 re.findall(regex, text)    # -> ['Text']

 ----------------------------------------  re.purge --------------------------------------------------------------------
 # Возвращает None НЕТ Методов Match                                                                            <-----
 re.purge()        # -> None
 type(re.purge())  # -> <class 'NoneType'>

 ----------------------------------------  search() vs. match() vs. fullmatch()  ----------------------------------------

 re.match("c", "abcdef")                   # -> None
 re.search("c", "abcdef")                  # -> <re.Match object; span=(2, 3), match='c'>
 # '^' можно использовать с search() для ограничения совпадения в начале строки
 re.match("c", "abcdef")                   # -> None
 re.search("^c", "abcdef")                 # -> None
 re.search("^a", "abcdef")                 # -> <re.Match object; span=(0, 1), match='a'>
 # Флаг MULTILINE   search() '^' будет соответствовать началу каждой строки.
 re.match("X", "A\nB\nX", re.MULTILINE)    # -> None
 re.search("^X", "A\nB\nX", re.MULTILINE)  # -> <re.Match object; span=(4, 5), match='X'>

 re.fullmatch("p.*n", "python")             # -> <re.Match object; span=(0, 6), match='python'>
 re.fullmatch("r.*n", "python")             # -> None

 ----------------------------------------  Важно о функциях  re --------------------------------------------------------

 # Кратко что возврщают функции re                                                                              <-----
 type(re.compile(r'\w'))              # -> <class 're.Pattern'>
 type(re.search(r'text', 'text'))     # -> <class 're.Match'>
 type(re.match(r'text', 'text'))      # -> <class 're.Match'>
 type(re.fullmatch(r'text', 'text'))  # -> <class 're.Match'>
 type(re.findall(r'text', 'text'))    # -> <class 'list'>
 type(re.finditer(r'text', 'text'))   # -> <class 'callable_iterator'>
 type(re.split(r'text', 'text'))      # -> <class 'list'>
 type(re.sub(r'text', '', 'text'))    # -> <class 'str'>
 type(re.subn(r'text', '', 'text'))   # -> <class 'tuple'>
 -----------------------------------------------------------------------------------------------------------------------


 -- Примеры работы с регулярками:
 -----------------------------  Литералы(буквы/цифры/метасимволы) и Символьный класс [] --------------------------------

 Символьный класс [] и его стандартные виды: \d, \D, \s, \S, \w, \W.

 text = 'Карта map и обьект bitmap - это разные вещи'

 re.findall(r'map', text)       # -> ['map', 'map']     Найдет все подстроки map
 # Если БЕЗ сырой строки r'' то нужно экранировать \\
 re.findall('\\bmap\\b', text)  # -> ['map']            Найдет только подстроку map   БЕЗ r''
 re.findall(r'\bmap\b', text)   # -> ['map']            Найдет только подстроку map   С   r''


 text = 'еда, беда, победа'
 re.findall(r'еда', text)      # -> ['еда', 'еда', 'еда']
 re.findall(r'(еда)', text)    # -> ['еда', 'еда', 'еда']   # Группирующие скобки ()
 text = '(еда), беда, победа'
 re.findall(r'\(еда\)', text)  # -> ['(еда)']  # Экранировали символы ()


 Символьный класс [] - описывает только 1 символ
 text = 'Еда, беду, -5 55 555 победа Ёё'

 re.findall(r'[Ее]д[ау]', text)               # -> ['Еда', 'еду', 'еда']
 re.findall(r'[0123456789]', text)            # -> ['5', '5', '5', '5', '5', '5']   #  Найдет только 1 цифру
 re.findall(r'\d', text)                      # -> ['5', '5', '5', '5', '5', '5']   #  Краткая форма найти все цифры
 re.findall(r'[0123456789][0123456789]', text)# -> ['55', '55']                     #  Найдет 2 цифры
 re.findall(r'[0-9][0-9]', text)              # -> ['55', '55']                     #  Определяем интервал
 re.findall(r'[-0-9][-0-9]', text)            # -> ['-5', '55', '55']  # Будем искать дефис '-' или любую цифру
 re.findall(r'[^0-9]+', text)                 # -> ['Еда, беду, -', ' ', ' ', ' победа Ёё']  # Будем искать не цифры
 re.findall(r'[а-я]+', text)                  # -> ['да', 'беду', 'победа']   # Будем искать маленькие буквы
 re.findall(r'[а-яА-Я]+', text)               # -> ['Еда', 'беду', 'победа']  # Будем искать маленькие/большие буквы
 re.findall(r'[А-Яа-я]+', text)               # -> ['Еда', 'беду', 'победа']  # Порядок любой
 re.findall(r'[А-Яа-я0-9]+', text)            # -> ['Еда', 'беду', '5', '55', '555', 'победа']  # Найти маленькие-большие буквы/цифры
 re.findall(r'[А-Яа-яЁё]+', text)             # -> ['Еда', 'беду', 'победа', 'Ёё']  # ёЁ  Нужно добавить
 re.findall(r'[.^$*+?{}()|[]', '.^$*+?{}[]\|()')# ['.', '^', '$', '*', '+', '?', '{', '}', '[', '|', '(', ')']  # Символы можно
 re.findall(r'[]]', '.^$*+?{}[]\|()')         # -> [']']  # Отдельно ] можно
 re.findall(r'[\\]', '.^$*+?{}[]\|()')        # -> ['\\']  # Кроме обратного слэша \
 re.findall(r'[\n\t]', '\n\t')                # -> ['\n', '\t']  # Учитываем перевод строки \n и табуляцию \t
 re.findall(r'\w+', text)                     # -> ['Еда', 'беду', '5', '55', '555', 'победа', 'Ёё']  # str.isalnum() и _
 re.findall(r'\w+', text, re.ASCII)           # -> ['5', '55', '555']  # Быть внимательным к установленным флагам
 re.findall(r'(?a)\w+', text, re.ASCII)  # -> ['5', '55', '555']  # Флаги можно ставить по-другому (?a) НО ТОЛЬКО ВНАЧАЛЕ

 # В [] Можно использовать Специальные последовательности все кроме:  '\A'  '\B'  '\Z'
 re.findall(r'[\b\d\D\s\S\w\W]+', text)        # -> ['Еда, беду, -5 55 555 победа Ёё']  # Работает
 re.findall(r'0x[\da-fA-F]', '0xf, 0xa, 0x5')  # -> ['0xf', '0xa', '0x5']  # Можно использовать Спец. последовательности

 -----------------------  Виды квантификаторов: {m,n}, {m}, {m,} {,n}, +, *, ?   Жадные  НЕ Жадные '?'  ----------------

 # Квантификаторы по умолчанию находят самые длинные последовательности(Жадные)   {2,3} - возьмет 3   {2,3}? - возьмет 2
 # {0,}  эквивалентно '*'       {1,}  эквивалентно '+'    {0,1}  эквивалентно '?'
 text = 'Google, Gooogle, Goooooogle'
 # Будет проходить по словам 1 РАЗ ВПЕРЕД! и искать последовательности                                           <-----
 re.findall(r'o{2,5}', text)   # -> ['oo', 'ooo', 'ooooo']          # Будет брать где-возможно от 2-5 букв      ЖАДНЫЙ
 re.findall(r'o{2,5}?', text)  # -> ['oo', 'oo', 'oo', 'oo', 'oo']  # Будет брать где-возможно только 2 буквы   НЕ ЖАДНЫЙ
 # Краткие формы записи квантификаторов
 re.findall(r'Go{2,}gle', text)  # -> ['Google', 'Gooogle', 'Goooooogle']  # Будет брать от 2 и более букв 'o'
 re.findall(r'Go{,4}gle', text)  # -> ['Google', 'Gooogle']                # Будет брать не более 4 букв 'o'

 phone = '89123456789 89123'
 re.findall(r'8\d{10}', phone)  # -> ['89123456789']  # Правильность номера

 text_2 = 'стеклянный, стекляный'  # 2 'нн'   1 'н'
 re.findall(r'стеклянн?ый', text_2)      # -> ['стеклянный', 'стекляный']  # н? - Означает что 'н' - НЕ ОБЯЗАТЕЛЬНАЯ
 re.findall(r'стеклянн{0,1}ый', text_2)  # -> ['стеклянный', 'стекляный']  # {0,1} Тоже самое что и '?'
 re.findall(r'стеклянный', text_2)       # -> ['стеклянный']               # Убрали '?'

 text_3 = 'author=Пушкин А.С; title = Евгений Онегин; price=200; year= 2001'
 # Разбор : r'\w+\s*=\s*[^;]+'
 # \w+  - символов слова должно быть от 1 и больше
 # \s*= - далее должен стоять знак =, но перед знаком = могут быть пробелы, пробелов может быть от 0 и более
 # \s*  - после знака = тоже могут быть пробелы от 0 и более
 # [^;]+ - выделяем все слова кроме ';'   учитываем все символы кроме ';' и перебираем от 1 и более
 re.findall(r'\w+\s*=\s*[^;]+', text_3)           # Тоже самое!
 # -> ['author=Пушкин А.С', 'title = Евгений Онегин', 'price=200', 'year= 2001']
 re.findall(r'\w{1,}\s{0,}=\s{0,}[^;]+', text_3)  # Тоже самое!
 # -> ['author=Пушкин А.С', 'title = Евгений Онегин', 'price=200', 'year= 2001']
 text_3.split(';')  # РЕШЕНИЕ методом строки split(';')  Но с регулярками можно выполнять более тонкие проверки!
 # -> ['author=Пушкин А.С', ' title = Евгений Онегин', ' price=200', ' year= 2001']
 # Разобьём на группы кортежей с помощью '()'
 re.findall(r'(\w+)\s*=\s*([^;]+)', text_3)
 # -> [('author', 'Пушкин А.С'), ('title', 'Евгений Онегин'), ('price', '200'), ('year', '2001')]

 text_4 = '<p>Картинка <img src="bg.jpg"> в тексте </p>'
 re.findall(r'<img.*>', text_4)     # -> ['<img src="bg.jpg"> в тексте </p>']  # '*'  Жадный     Возьмет Длинную
 re.findall(r'<img.*?>', text_4)    # -> ['<img src="bg.jpg">']                # '*?' НЕ Жадный  Возьмет Короткую
 re.findall(r'<img[^>]*>', text_4)  # -> ['<img src="bg.jpg">']                # Другое решение с '*' Жадным
 # Более правильное решение!!!
 re.findall(r'<img\s+[^>]*?src\s*=\s*[^>]+>', text_4)  # -> ['<img src="bg.jpg">']

 -----------------------  Сохраняющие скобки () и группировка  ---------------------------------------------------------
 # Группировка и сохранение результатов поиска

 text = 'lat = 5, lon=7, a= 5'
 re.findall(r'\w+\s*=\s*\d+', text)                # -> ['lat = 5', 'lon=7', 'a= 5']
 re.findall(r'lat\s*=\s*\d+|lon\s*=\s*\d+', text)  # -> ['lat = 5', 'lon=7']  # Условия  ИЛИ '|'  Но DRY
 # Сохраняющие () и НЕ Сохраняющие '?:' Группировки  скобки ()                                                    <-----
 # Первый (внешний) уровень:    'lat = 5', 'lon=7'
 re.findall(r'(?:lat|lon)\s*=\s*\d+', text)         # -> ['lat = 5', 'lon=7']  # '?:' - НЕ сохраняющая скобка (?:)
 # Второй (внутренний) уровень: 'lat', 'lon'
 re.findall(r'(lat|lon)\s*=\s*\d+', text)           # -> ['lat', 'lon']        #           сохраняющая скобка ()
 # Чтобы увидеть ОБА уровня:
 re.findall(r'((lat|lon)\s*=\s*\d+)', text)         # -> [('lat = 5', 'lat'), ('lon=7', 'lon')]  # Два уровня
 # Отдельно сохраним ключи и значения:
 re.findall(r'(lat|lon)\s*=\s*(\d+)', text)         # -> [('lat', '5'), ('lon', '7')]            # Отдельно
 # НЕ Сохраняющие скобки используем '?:' внутри (?:)
 re.findall(r'(lat|lon)\s*=\s*(?:\d+)', text)       # -> ['lat', 'lon']            # '?:'

 text_2 = '<p>Картинка <img src="bg.jpg"> в тексте </p>'
 re.findall(r'<img\s+[^>]*src=[\'"](.+?)[\'"]', text_2)  # -> ['bg.jpg']            # НЕ Оптимальный вариант
 # \1 - индекс скобки     Синтаксис таков:  \i (i-натуральное число: 1, 2, 3, ...)
 re.findall(r'<img\s+[^>]*src=([\'"])(.+?)\1', text_2)   # -> [('"', 'bg.jpg')]     # Оптимальный вариант
 # Имена в сохраняющей скобке:  Назначение:  (?P<name>...)      Обращение:  (?P=name)                             <-----
 re.findall(r'<(img)\s+[^>]*src=(?P<GGG>[\'"])(.+?)(?P=GGG)', text_2)   # -> [('img', '"', 'bg.jpg')]   # GGG - имя ()

 -----------------------  Проверки и Флаги  ----------------------------------------------------------------------------

# Группировка и сохранение результатов поиска
# Проверочные символы: ^, $, \A, \b, \B, \Z, (?=exp), (?!exp), (?=<exp), (?<!exp)     exp = Некий шаблон
# Проверочные выражения: (?(id|name)yes_pattern) и (?(id|name)yes_pattern|no_pattern).
# Флаги: re.ASCII или re.A, re.IGNORECASE или re.I, re.MULTILINE или re.M, re.DOTALL или re.S, re.VERBOSE или re.X.

 text = 'подоходный налог'
 re.findall(r'прибыл|обретение|доход', text)                # -> ['доход']   #  Найдет НЕ Конкретное слово
 re.findall(r'прибыл|обретение|\bдоход\b', text)            # -> []          #  Найдет Конкретное слово если оно есть

 text_2 = 'подоходный налог доход'
 # Найти конкретное слово
 re.findall(r'прибыл|обретение|\bдоход\b', text_2)           # -> ['доход']
 re.findall(r'\bприбыл\b|\bобретение\b|\bдоход\b', text_2)   # -> ['доход']  НЕ ЛУЧШИЙ ВАРИАНТ!!!  <-----
 re.findall(r'\b(прибыл|обретение|доход)\b', text_2)         # -> ['доход']     ЛУЧШИЙ ВАРИАНТ!!!  <-----
 re.findall(r'\b(?:прибыл|обретение|доход)\b', text_2)       # -> ['доход']  НЕ Сохраняющая группа ()   '?:'

 text_3 = '<script>\n let o document.getElementById("id_div");console.log(obj);\n</script>'
 # Флаг re.MULTILINE  '^' Будет соответствовать началу каждой строки
 re.findall(r'^<script.*?>([\w\W]+)(?=</script>)', text_3, re.MULTILINE)  # Позитивная опережающая проверка '(?=...)'
 # -> ['\n let o document.getElementById("id_div");console.log(obj);\n']          НЕТ  </script>'   <-----
 re.findall(r'^<script.*?>([\w\W]+)(?!</script>)', text_3, re.MULTILINE)  # Негативная опережающая проверка '(?!...)'
 # -> ['\n let o document.getElementById("id_div");console.log(obj);\n</script>'] Есть </script>'   <-----
 # позитивная ретроспективная проверка '(?<=...)'
 re.findall(r'^<script.*?>([\w\W]+)(?<=</script>)', text_3, re.MULTILINE)  # Тоже самое но захватывает шаблон '(?<=...)'
 # -> ['\n let o document.getElementById("id_div");console.log(obj);\n</script>']
 re.findall(r'^<script.*?>(.+)(?<=</script>)', text_3, re.MULTILINE)  # '.' вместо [\w\W]  '.' не включает '\n'
 # -> []

 text_4 = '<meta http-equiv="Content-Type " content="text/html; charset=windows-1251">'
 re.findall(r'([-\w]+)[ \t]*=[ \t]*[\'"]([^\'"]+)(?<![ \t])', text_4, re.MULTILINE)  # НЕ ПРАВИЛЬНО составили шаблон
 # -> [('http-equiv', 'Content-Type'), ('content', 'text/html; charset=windows-1251')]      # ПРОБЕЛ ИГНОРИРУЕТСЯ <-----
 re.findall(r'([-\w]+)[ \t]*=[ \t]*[\'"]([^\'"]+)', text_4, re.M)                    # НЕ ПРАВИЛЬНО Тонкий Момент!
 # -> [('http-equiv', 'Content-Type '), ('content', 'text/html; charset=windows-1251')]     # ПРОБЕЛ ПОЯВИЛСЯ     <-----
 re.findall(r'([-\w]+)[ \t]*=[ \t]*[\'"](.+?)(?<![ \t])[\'"]', text_4, re.MULTILINE) # НЕ КОРРЕКТНО!
 # -> [('http-equiv', 'Content-Type " content=')]                         # еще захватили  следующее значение: content=
 re.findall(r'([-\w]+)[ \t]*=[ \t]*[\'"](.+?)[\'"]', text_4, re.M)                       # КОРРЕКТНО!!!           <-----
 # -> [('http-equiv', 'Content-Type '), ('content', 'text/html; charset=windows-1251')]  # КОРРЕКТНО!!!           <-----

 text_5 = '<p align=center>Hello World!</p>'
 # Наличие группирующего выражения: '(?P<name>...)' - именованная группа '(?(id/name)yes-pattern|no-pattern)' - проверка
 re.findall(r'([-\w]+)[ \t]*=[ \t]*(?P<q>[\'"])?(?(q)([^\'"]+(?<![ \t]))|([^ \t>]+))', text_5, re.MULTILINE)
 # -> [('align', '', '', 'center')]

 # Можно использовать несколько флагов сразу:                                                                     <-----
 text = 'Python python PYTHON'
 re.findall(r'(?im)python', text)              # -> ['Python', 'python', 'PYTHON']   # Используем разные флаги  (?im)
 re.findall(r'python', text, flags=re.I|re.M)  # -> ['Python', 'python', 'PYTHON']   # Можно через "|"
 re.findall(r'(?aimsx)python', text)           # -> ['Python', 'python', 'PYTHON']   # Используем все флаги     (?aimsx)
 re.findall(r'python', text)                   # -> ['python']   # Выбрали только нужное слова без флагов

 -----------------------  объект re.Match, методы re.search, re.finditer, re.findall  ----------------------------------

 # Свойства(без вызова () ) и Методы(с вызовом () ) Обьекта  re.Match object                                      <-----
 # Существует 2 подхода применения регулярных выражений:
 # 1) Здесь и сейчас для однократного применения правила
 # 2) Компиляция и обработка, для многократного использования одного и того же правила

 text = '<font color=#CC0000>'
 match = re.search(r'(\w+)=(#[\da-fA-F]{6})\b', text)  # 2 сохраняющие группы: 1): (\w+)    2): (#[\da-fA-F]{6})
 match  # -> <re.Match object; span=(6, 19), match='color=#CC0000'>
 # Иерархия вхождений:
 match[0]        # -> color=#CC0000    # Индекс 0: Возвращает полное вхождение 'color=#CC0000'
 match.group(0)  # -> color=#CC0000    # тоже самое
 match[1]        # -> color            # Индекс 1: 'color'
 match.group(1)  # -> color            # тоже самое
 match[2]        # -> #CC0000          # Индекс 2: 'CC0000'
 match.group(2)  # -> #CC0000          # тоже самое
 match.group(0, 1, 2)  # -> ('color=#CC0000', 'color', '#CC0000')  # Кортеж всех вхождений
 match.groups()   # -> ('color', '#CC0000')  # Все группы начиная с индекса 1
 match.lastindex  # -> 2                     # Индекса последней сохраняющей группы  Узнать сколько всего групп
 match.start(1)   # -> 6                     # Начальный индекс в тексте определенной группы  или -1 если не обязательно
 match.end(1)     # -> 11                    # Конечный индекс  в тексте определенной группы  или -1 если не обязательно
 match.span(0)    # -> (6, 19)               # Начальная и Конечная в кортеже для всего вхождения
 match.endpos     # -> 20                    # Последний индекс до которого происходил поиск
 match.pos        # -> 0                     # Начальный индекс с которого происходил поиск
 match.re         # -> re.compile('(\\w+)=(#[\\da-fA-F]{6})\\b')    # Возвращает скомпилированный шаблон
 match.string     # -> <font color=#CC0000>  # Возвращает Анализируемую строку

 match = re.search(r'(?P<key>\w+)=(?P<value>#[\da-fA-F]{6})\b', text)  # Именованные группы
 match              # -> <re.Match object; span=(6, 19), match='color=#CC0000'>
 match.groupdict()  # -> {'key': 'color', 'value': '#CC0000'}   #  Словарь: имя группы и её значение
 match.lastgroup    # -> value                                  #  Последняя группа или None      вызов без ()
 # \g<name> - обращение к группе по имени;    \1, \2 ... - обращение к группе по номеру                          <-----
 match.expand(r'\g<key>:\g<value>')    # -> color:#CC0000       #  Ключ : Значение
 match.expand(r'\1:\2')                # -> color:#CC0000       #  тоже самое   но лучше имена '\g<key>:\g<value>'
 match.expand(r'\g<key>WOW\g<value>')  # -> colorWOW#CC0000     #  Ключ WOW Значение

 # Методы re.search, re.finditer, re.findall                                                                    <-----
 text = '<font color=#CC0000  bg=#ffffff>'
 # search - Находит только первое вхождение остальные игнорируются                        возвращает -  Match object
 re.search(r'(?P<key>\w+)=(?P<value>#[\da-fA-F]{6})\b', text)  # -> <re.Match object; span=(6, 19), match='color=#CC0000'>

 # finditer - Выделить обе группы (Найти несколько совпадений)  и возвращает итерируемый iterable обьект
 re.finditer(r'(?P<key>\w+)=(?P<value>#[\da-fA-F]{6})\b', text)  # -> <callable_iterator object at 0x00000197F5777E50>
 # Можно обойти в цикле
 for match in re.finditer(r'(?P<key>\w+)=(?P<value>#[\da-fA-F]{6})\b', text):
     print(match)
 #   <re.Match object; span=(6, 19), match='color=#CC0000'>
 #   <re.Match object; span=(21, 31), match='bg=#ffffff'>

 # findall - Список найденных обьектов
 re.findall(r'(?P<key>\w+)=(?P<value>#[\da-fA-F]{6})\b', text)  # -> [('color', '#CC0000'), ('bg', '#ffffff')]

 -----------------------  Методы re.match, re.split, re.sub, re.subn, re.compile  --------------------------------------
 # Методы для поиска вхождений                                                                                   <-----

 text = '+7(123)456-78-90'
 # match - определяет совпадение только вначале строки
 # Разница между match и search     match ищет только с начала строки в остальном они одинаковые    <-----

 # Нельзя начинать шаблон с квантификаторов +, *, ? , {}                все кроме {} можно экранировать          <-----
 m = re.match(r'\+7\(\d{3}\)\d{3}-\d{2}-\d{2}', text)    # нашел        начальные квантификаторы нужно экранировать '\'
 m = re.match(r'\+7[(]\d{3}[)]\d{3}-\d{2}-\d{2}', text)  # тоже самое
 m  # -> <re.Match object; span=(0, 16), match='+7(123)456-78-90'>

 text_1 = ' +7(123)456-78-90'   # Пробел вначале
 m = re.match(r'\+7\(\d{3}\)\d{3}-\d{2}-\d{2}', text_1)  # НЕ нашел потому что match ищет начиная с самого начала строки!
 m  # -> None

 # split - выполняет разбивку строки по заданному разделителю возвращает список
 text_2 = 'Hello\n\n Hello;;; Hello,,, Hello,'
 ar = re.split(r'[\n;,]+', text_2)  # Указываем символы по которым можно разделять
 #   '\n' в символьном классе [] - перенос строки            '+'  значит что разделителей может быть несколько
 ar  # -> ['Hello', ' Hello', ' Hello', ' Hello', '']

 # sub - замена в строке или возврат изначальной строки если нет замен                                       <-----
 text_3 = "Москва Казань Тверь Самара Уфа"

 list_1 = re.sub(r"\s*(\w+)\s*", "<p>\1</p>", text_3)
 list_1  # -> <p></p><p></p><p></p><p></p><p></p>   # хз так выводиться без r""
 # Но если добавить в замену сырую строку r'' всё будет работать!!!                                       <-----  <-----
 re.sub(r"\s*(\w+)\s*", r"<p>\1</p>", text_3)  # -> <p>Москва</p><p>Казань</p><p>Тверь</p><p>Самара</p><p>Уфа</p>


 # Можно в sub передать ссылку на функцию  Передаём без вызова ()                                            <-----

 count = 0
 def repl_sub(m):
     global count
     count += 1
     return f"<p={count}>{m.group(1)}</p>"

 re.sub(r"\s*(\w+)\s*", repl_sub , text_3)  # -> <p=1>Москва</p><p=2>Казань</p><p=3>Тверь</p><p=4>Самара</p><p=5>Уфа</p>

 # Интересно вывести findall()                                                                               <-----
 re.findall(r'\s*(\w+)\s*', 'Москва Казань Тверь Самара Уфа')  # -> ['Москва', 'Казань', 'Тверь', 'Самара', 'Уфа']

 # subn - работает так же как и sub но возвращает не только строку но и сколько было замен в кортеже (tuple)
 list_1, total = re.subn(r"\s*(\w+)\s*", "<p>\1</p>", text_3)
 list_1, total  # -> <p></p><p></p><p></p><p></p><p></p> 5
 # Но если добавить в замену сырую строку r'' всё будет работать!!!
 list_1, total = re.subn(r"\s*(\w+)\s*", r"<p>\1</p>", text_3)
 list_1, f'  ЗАМЕНЫ = {total}'  # -> <p>Москва</p><p>Казань</p><p>Тверь</p><p>Самара</p><p>Уфа</p>   ЗАМЕНЫ = 5


 # compile - компилирует регулярное выражение и возвращает в виде экземпляра класса Pattern                 <-----
 # compile - Удобно если мы будем использовать шаблон много раз                                             <-----

 rx = re.compile(r'\s*(\w+)\s*')
 # print(rx)        # -> re.compile('\\s*(\\w+)\\s*')  # Скомпилируемый шаблон
 # print(type(rx))  # -> <class 're.Pattern'>
 list_1, total = rx.subn(r"<\1>", text_3)
 list_2 = rx.sub(repl_sub, text_3)
 list_1, total, list_2
 # <Москва><Казань><Тверь><Самара><Уфа> 5 <p=6>Москва</p><p=7>Казань</p><p=8>Тверь</p><p=9>Самара</p><p=10>Уфа</p>

 -----------------------------------------------------------------------------------------------------------------------

 -- Специальные символы:

 ----------------------------------------  '.' -------------------------------------------------------------------------
 text = "RegExp in Python"

 re.findall(r'.', text)      # -> ['R', 'e', 'g', 'E', 'x', 'p', ' ', 'i', 'n', ' ', 'P', 'y', 't', 'h', 'o', 'n']
 re.findall(r'...', text)    # -> ['Reg', 'Exp', ' in', ' Py', 'tho']
 re.findall(r'.....', text)  # -> ['RegEx', 'p in ', 'Pytho']

 # Находит и НЕ находит совпадение                                                                               <-----
 re.search(r'foo.bar', 'fooxbar')   # -> <re.Match object; span=(0, 7), match='fooxbar'>  # Находит
 re.search(r'foo.bar', 'foobar')    # -> None                                             # такой строки нет
 re.search(r'foo.bar', 'foo\nbar')  # -> None                                             # такой строки нет

 re.sub(r'<.*?>', '', '<div>test</div>')     # -> test
 re.sub(r'<[^<>]+>', '', '<div>test</div>')  # -> test

 re.findall(r'<.+?>', '<div>test</div>')     # -> ['<div>', '</div>']
 re.findall(r'<[^<>]+>', '<div>test</div>')  # -> ['<div>', '</div>']

 # Можно подставлять любые символы!
 re.findall(r'A..A', 'ABBA ALLA')                  # -> ['ABBA', 'ALLA']
 re.findall(r'[aA]..[aA]', 'ABBA ALLA abba alla')  # -> ['ABBA', 'ALLA', 'abba', 'alla']

 # Как найти точку или  другой Специальный символ  -  экранирование '\' или []
 re.findall('.', 'ABC.')    # -> ['A', 'B', 'C', '.']
 re.findall('\.', 'ABC.')   # -> ['.']
 re.findall('[.]', 'ABC.')  # -> ['.']

 ----------------------------------------  '^' -------------------------------------------------------------------------

 # Находит и НЕ находит совпадение
 re.search(r'^foo', 'foobar')  # -> <re.Match object; span=(0, 3), match='foo'>  # Находит
 re.search(r'^foo', 'barfoo')  # -> None                                         # foo должно быть только в начале

 text = "RegExp in Python"

 re.findall(r'\w', text)    # -> ['R', 'e', 'g', 'E', 'x', 'p', 'i', 'n', 'P', 'y', 't', 'h', 'o', 'n']
 re.findall(r'^\w', text)   # -> ['R']
 re.findall(r'^\w+', text)  # -> ['RegExp']

 # Будет совпадать только с началом строки                                              <-----
 re.findall('^From', 'From Here to Eternity')  # -> ['From']
 re.findall('^From', 'Reciting From Memory')   # -> []

 # Тоже самое но с  search()
 re.search('^From', 'From Here to Eternity')  # -> <re.Match object; span=(0, 4), match='From'>
 re.search('^From', 'Reciting From Memory')   # -> None

 # Найти конкретную фразу, а не слово
 re.findall(r'^Я нашел!$', 'Я нашел!')      # -> ['Я нашел!']                           <-----
 re.findall(r'^Я нашел!$', 'Я нашел его!')  # -> []                                     <-----

 ----------------------------------------  '$' -------------------------------------------------------------------------
 # '$' - концу строки, который определяется как конец строки или любое место, за которым следует символ новой строки \n
 re.findall('}$', '{block}')    # -> ['}']
 re.findall('}$', '{block} ')   # -> []
 re.findall('}$', '{block}\n')  # -> ['}']

 text = "RegExp in Python"
 re.findall(r'\w', text)    # -> ['R', 'e', 'g', 'E', 'x', 'p', 'i', 'n', 'P', 'y', 't', 'h', 'o', 'n']
 re.findall(r'\w$', text)   # -> ['n']
 re.findall(r'\w+$', text)  # -> ['Python']

 # Находит и НЕ находит совпадение                                                                               <-----
 from re import search
 re.search(r'bar$', 'foobar')    # -> <re.Match object; span=(0, 3), match='foo'>  # Находит
 re.search(r'bar$', 'barfoo')    # -> None                                         # bar должно быть только в конце
 re.search(r'bar$', 'foobar\n')  # -> <re.Match object; span=(3, 6), match='bar'>  # Перед \n Находит

 ----------------------------------------  '*'  {0,}  ------------------------------------------------------------------

 # Механизм согласования сначала идет так далеко, как может и если совпадение не найдено, он будет постепенно выполнять
 резервное копирование и повторять оставшуюся часть шаблона регулярного выражения снова и снова или НЕУДАЧА

 re.findall('a[bcd]*b', 'abcbd')  # -> ['abcb']    # хороший пример    <-----

 re.findall(r'[a-a]*', 'abcbd')  # -> ['a', '', '', '', '', '']  # Тоже самое
 re.findall(r'[a]*', 'abcbd')    # -> ['a', '', '', '', '', '']  # Тоже самое
 re.findall(r'[bcd]*', 'abcbd')  # -> ['', 'bcbd', '']
 re.findall(r'[b]*', 'abcbd')    # -> ['', 'b', '', 'b', '', '']

 re.findall(r'[bcd]*', 'abcb')   # -> ['', 'bcb', '']

 # Найдёт всё между foo и bar включая foo bar  но не перед/после  foo bar
 re.search(r'foo.*bar', '# foo $qux@grault % bar #') # -> <re.Match object; span=(2, 23), match='foo $qux@grault % bar'>

 ----------------------------------------  '+'  {1,}  ------------------------------------------------------------------

 re.findall('ca+t', 'cat ')    # -> ['cat']
 re.findall('ca+t', 'caaat ')  # -> ['cat']
 re.findall('ca+t', 'ct ')     # -> []

 # Перед '+' Нужно 1 или больше повторений
 re.search('foo-+bar', 'foobar')    # -> None                                               # -> НЕ Найдет
 re.search('foo-+bar', 'foo-bar')   # -> <re.Match object; span=(0, 7), match='foo-bar'>    # ->    Найдет
 re.search('foo-+bar', 'foo--bar')  # -> <re.Match object; span=(0, 8), match='foo--bar'>   # ->    Найдет

 ----------------------------------------  '?'  {0,1}  -----------------------------------------------------------------

 # Может являться НЕобязательным
 re.findall('home-?brew', 'homebrew ')  # -> ['homebrew']
 re.findall('home-?brew', 'home-brew')  # -> ['home-brew']

 # Перед '?' Нужно 0 или 1 повторений
 re.search('foo-?bar', 'foobar')      # -> <re.Match object; span=(0, 6), match='foobar'>   # ->    Найдет
 re.search('foo-?bar', 'foo-bar')     # -> <re.Match object; span=(0, 7), match='foo-bar'>  # ->    Найдет
 re.search('foo-?bar', 'foo--bar')    # -> None

 ----------------------------------------  '*'  '+'  '?'  --------------------------------------------------------------
 {0,}  эквивалентно '*'    {1,}  эквивалентно '+'   {0,1}  эквивалентно '?'     Лучше использовать *+? чем {0,}{1,}{0,1}

 # Две одинаковые строчки !
 re.findall(r'\w+\s*=\s*[^;]+', 'A=1; B = 2; C =3')           # -> ['A=1', 'B = 2', 'C =3']
 re.findall(r'\w{1,}\s{0,}=\s{0,}[^;]+', 'A=1; B = 2; C =3')  # -> ['A=1', 'B = 2', 'C =3']

 # Две одинаковые строчки !
 re.findall(r'\w+\s*\w+', 'AB BC')           # -> ['AB BC']
 re.findall(r'\w{1,}\s{0,}\w{1,}', 'AB BC')  # -> ['AB BC']

 re.findall(r'ab', 'abcabac')            # -> ['ab', 'ab']
 re.findall(r'ab*', 'abcabac')           # -> ['ab', 'ab', 'a']
 re.findall(r'ab+', 'abcabac')           # -> ['ab', 'ab']
 re.findall(r'ab?', 'abcabac')           # -> ['ab', 'ab', 'a']

 re.findall(r'ab', 'abc abbb acb abc')   # -> ['ab', 'ab', 'ab']
 re.findall(r'ab*', 'abc abbb acb abc')  # -> ['ab', 'abbb', 'a', 'ab']
 re.findall(r'ab+', 'abc abbb acb abc')  # -> ['ab', 'abbb', 'ab']
 re.findall(r'ab?', 'abc abbb acb abc')  # -> ['ab', 'ab', 'a', 'ab']

 text = "RegExp in Python"
 re.findall(r'\w+', text)  # -> ['RegExp', 'in', 'Python']
 re.findall(r'\w*', text)  # -> ['RegExp', '', 'in', '', 'Python', '']
 re.findall(r'\w?', text)  # -> ['R', 'e', 'g', 'E', 'x', 'p', '', 'i', 'n', '', 'P', 'y', 't', 'h', 'o', 'n', '']

 # Найти email '+'
 text = 'test@mail.ru olga31@gmail.com pupsik_99@yandex.ru'
 re.findall(r'\w+@\w+.\w+', text)  # -> ['test@mail.ru', 'olga31@gmail.com', 'pupsik_99@yandex.ru']

 # Найти Логи '*'
 text = 'log.txt log1.txt log2.txt log3.txt log33.txt log133.txt'
 re.findall(r'log\d*\.txt', text)  # -> ['log.txt', 'log1.txt', 'log2.txt', 'log3.txt', 'log33.txt', 'log133.txt']

 # Найти фамилии '?'
 text = 'Назин Назина'
 re.findall(r'Назина?', text)  # -> ['Назин', 'Назина']

 Интересный пример посмотри!
 re.findall(r'[01]\d|2[0-3]', '1:00')   # -> ['00']

 re.findall(r'[01]?\d|2[0-3]', '1:00')  # -> ['1', '00']             #  '?'
 re.findall(r'[01]*\d|2[0-3]', '1:00')  # -> ['1', '00']             #  '+'
 re.findall(r'[01]+\d|2[0-3]', '1:00')  # -> ['00']                  #  '*'

 re.findall(r'[01]?\d|2[0-3]', '010:00')  # -> ['01', '0', '00']     #  '?'
 re.findall(r'[01]+\d|2[0-3]', '010:00')  # -> ['010', '00']         #  '+'
 re.findall(r'[01]*\d|2[0-3]', '010:00')  # -> ['010', '00']         #  '*'

 ----------------------------------------  '*?'  '+?'  '??' ------------------------------------------------------------
 re.findall(r'ab', 'abcabac')             # -> ['ab', 'ab']
 re.findall(r'ab*?', 'abcabac')           # -> ['a', 'a', 'a']
 re.findall(r'ab+?', 'abcabac')           # -> ['ab', 'ab']
 re.findall(r'ab??', 'abcabac')           # -> ['a', 'a', 'a']

 re.findall(r'ab', 'abc abbb acb abc')    # -> ['ab', 'ab', 'ab']
 re.findall(r'ab*?', 'abc abbb acb abc')  # -> ['a', 'a', 'a', 'a']
 re.findall(r'ab+?', 'abc abbb acb abc')  # -> ['ab', 'ab', 'ab']
 re.findall(r'ab??', 'abc abbb acb abc')  # -> ['a', 'a', 'a', 'a']

 ----------------------------------------  '{m}'  '{m,n}'  '{m,n}?'  '{m,n}+'  -----------------------------------------
 text = '1, 10, 100, 1000'

 re.findall(r'\d{3}', text)     # -> ['100', '100']                                          # НЕ Жадный
 re.findall(r'\d{1,3}', text)   # -> ['1', '10', '100', '100', '0']                          # Жадный
 re.findall(r'\d{1,3}?', text)  # -> ['1', '1', '0', '1', '0', '0', '1', '0', '0', '0']      # НЕ Жадный
 re.findall(r'\d{1,3}+', text)  # -> ['1', '10', '100', '100', '0']
 re.findall(r'\d{3,}+', text)   # -> ['100', '1000']
 re.findall(r'\d{,3}+', text)   # -> ['1', '', '', '10', '', '', '100', '', '', '100', '0', '']

 re.findall(r'\b\d{1}\b', text)     # -> ['1']
 re.findall(r'\b\d{1,3}\b', text)   # -> ['1', '10', '100']
 re.findall(r'\b\d{1,3}?\b', text)  # -> ['1', '10', '100']
 re.findall(r'\b\d{1,3}+\b', text)  # -> ['1', '10', '100']
 re.findall(r'\b\d{3,}+\b', text)   # -> ['100', '1000']
 re.findall(r'\b\d{,3}+\b', text)   # -> ['1', '', '10', '', '100', '', '']

 # Убрать символы
 re.sub(r'G', '', 'GGG-A-GGG')      # -> -A-
 re.sub(r'G{1}', '', 'GGG-A-GGG')   # -> -A-
 re.sub(r'G{3,}', '', 'GGG-A-GGG')  # -> -A-
 re.sub(r'GG', '', 'GGG-A-GGG')     # -> G-A-G
 re.sub(r'G{2}', '', 'GGG-A-GGG')   # -> G-A-G

 # Не забывайте — квантификатор применяется к последнему символу Или группе символов ()
 text = 'dataa datadata'
 re.findall(r'data{2}', text)    # -> ['dataa']
 re.findall(r'(data){2}', text)  # -> ['data']


 # Хороший пример
 for i in range(1, 6):
     s = f"x{'-' * i}x"
     print(f'{i}  {s:10}', re.search('x-{2,4}x', s))

 # -> 1  x-x        None
 # -> 2  x--x       <re.Match object; span=(0, 4), match='x--x'>
 # -> 3  x---x      <re.Match object; span=(0, 5), match='x---x'>
 # -> 4  x----x     <re.Match object; span=(0, 6), match='x----x'>
 # -> 5  x-----x    None

 # Пустые {} - уже НЕ метасимвол а соответствует обычным символам '{}'                                      <------
 re.search('x{}y', 'x{}y')  # -> <re.Match object; span=(0, 4), match='x{}y'>

 ----------------------------------------  Жадный квантификатор против НЕ Жадного --------------------------------------
 s = '<html><head><title>Title</title>'

 len(s)                        # -> 32
 re.match('<.*>', s).span()    # -> (0, 32)
 re.match('<.*>', s).group()   # -> <html><head><title>Title</title>   # Жадный    Нашел MAX последовательность   *
 re.match('<.*?>', s).group()  # -> <html>                             # НЕ Жадный Нашел MIN последовательность   *?

 # Жадный  Против   Не Жадный/Ленивый
 re.search('a{3,10}', 'a'*10 )   # -> <re.Match object; span=(0, 10), match='aaaaaaaaaa'>  # Нашел 10 штук  'а'
 re.search('a{3,10}?', 'a'*10 )  # -> <re.Match object; span=(0, 3), match='aaa'>          # Нашел 3  штуки 'а'

 # Сравнение Жадных *+? Против НЕ Жадных *? +? ??
 re.search('<.*>', '%<foo> <bar> <baz>%')   # -> <re.Match object; span=(1, 18), match='<foo> <bar> <baz>'>
 re.search('<.*?>', '%<foo> <bar> <baz>%')  # -> <re.Match object; span=(1, 6), match='<foo>'>

 re.search('<.+>', '%<foo> <bar> <baz>%')   # -> <re.Match object; span=(1, 18), match='<foo> <bar> <baz>'>
 re.search('<.+?>', '%<foo> <bar> <baz>%')  # -> <re.Match object; span=(1, 6), match='<foo>'>

 re.search('ba?', 'baaaa')                  # -> <re.Match object; span=(0, 2), match='ba'>
 re.search('ba??', 'baaaa')                 # -> <re.Match object; span=(0, 1), match='b'>


 # Разделить по заданному параметру      <------                                                            <------
 re.findall(r'\d*?1', '17383147371')  # -> ['1', '73831', '47371']        # Разделить по 1
 re.findall(r'\d*?3', '17383147371')  # -> ['173', '83', '1473']          # Разделить по 3
 re.findall(r'\w*?A', 'ABCABC')       # -> ['A', 'BCA']                   # Разделить по A

 ----------------------------------------  '\' -------------------------------------------------------------------------
 text = "3.50, 3150, 3:50"

 re.findall(r"3.50", text)   # -> ['3.50', '3150', '3:50']
 re.findall(r"3\.50", text)  # -> ['3.50']                            '\'   <-----

 re.sub(r'[()]', '1', '()')  # -> 11
 re.sub(r'\(\)', '1', '()')  # -> 1                                         <-----

 # Экранирование специальных символов    используем '\' или символьный класс []
 # Список  специальных символов которые нужно экранировать:     .^$*+?{}[]\|()
 re.findall(r'.',  'A.')   # -> ['A', '.']
 re.findall(r'\.', 'A.')   # -> ['.']

 re.findall(r'{}()', '({A})')    # -> []
 re.findall(r'[{}()]', '({A})')  # -> ['(', '{', '}', ')']

 re.findall(r'\\', 'A\\')   # -> ['\\']
 re.findall(r'[\\]', '\A')  # -> ['\\']

 re.findall(r'|', 'A|')    # -> ['', '', '']
 re.findall(r'[|]', 'A|')  # -> ['|']
 re.findall(r'\|', 'A|')   # -> ['|']

 ----------------------------------------  [] [^] ----------------------------------------------------------------------
 import string, re

 text = string.printable
 print(text)  # -> 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~

 re.findall(r"[0-9]", text)        # -> ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
 re.findall(r"[012345]", text)     # -> ['0', '1', '2', '3', '4', '5']
 re.findall(r"[0-5]", text)        # -> ['0', '1', '2', '3', '4', '5']
 re.findall(r"[9]", text)          # -> ['9']

 re.findall(r"[a-f]", text)        # -> ['a', 'b', 'c', 'd', 'e', 'f']
 re.findall(r"[afz]", text)        # -> ['a', 'f', 'z']

 re.findall(r"[A-D]", text)        # -> ['A', 'B', 'C', 'D']
 re.findall(r"[a-cA-C0-2]", text)  # -> ['0', '1', '2', 'a', 'b', 'c', 'A', 'B', 'C']

 # [^] - Игнорировать выбранные символы     Игнорирует только если '^' внутри символьного класса   <-----
 re.findall(r'[^0-2aA]', '0123abAB')  # -> ['3', 'b', 'B']
 re.findall(r'[^hl0]', 'hello100')    # -> ['e', 'o', '1']


 text = 'Анна Алла аоик А74арплт Аркан А^&а Абба'
 re.findall(r'А[нл][нл]а', text)  # -> ['Анна', 'Алла']
 re.findall(r'А..а', text)        # -> ['Анна', 'Алла', 'А74а', 'Арка', 'А^&а', 'Абба']


 # двухзначные числа от 00 до 59    # Будет пробегаться по всему тексту в поиске
 re.findall('[0-5][0-9]', '2359')  # ->  ['23', '59']         # [0-5][0-9] все двухзначные числа от 00 до 59
 re.findall('[0-5][0-9]', '2460')  # ->  ['24']               # [0-5][0-9] все двухзначные числа от 00 до 59
 re.search('[0-5][0-9]', '2359').group()     # ->  23         # Метод search() найдёт только одно вхождение

 Хороший пример!!!
 re.findall(r'([01][0-9]?|2[0-3]):[0-5][0-9]', '24:00')  # -> []  Эквивалентные регулярки   [0-9]
 re.findall(r'([01]\d?|2[0-3]):[0-5]\d', '24:00')        # -> []  Эквивалентные регулярки   \d

 re.findall(r'[01][0-9]?|2[0-3]:[0-5][0-9]', '24:00')    # -> ['00']  Эквивалентные регулярки   [0-9]
 re.findall(r'[01]\d?|2[0-3]:[0-5]\d', '24:00')          # -> ['00']  Эквивалентные регулярки   \d

 re.findall(r'[01][0-9]?|2[0-3]:[0-5][0-9]', '23:59')    # -> ['23:59']  Эквивалентные регулярки  [0-9]
 re.findall(r'[01]\d?|2[0-3]:[0-5]\d', '23:59')          # -> ['23:59']  Эквивалентные регулярки  \d


 # найдёт все квадратные скобки и их содержимое.        <-----                                          <-----
 text = r'[][1][12] [123][1234][12345] [123456][1234567][12345678] [123456789]'
 re.findall(r'\[.*?\]', text)  # -> ['1', '73831', '47371']                                             <-----

 # Найти все последовательности символов, окруженные двойными кавычками.                                <-----
 text = r'Слово "РОМ" и слово "СМЕРТЬ" для вас означает одно и то же...'
 re.findall(r'".+?"', text)  # -> ['"РОМ"', '"СМЕРТЬ"']


 Разница между регулярным выражением [A-z] и [a-zA-Z]
 [a-zA-Z] - символы ASCII в диапазоне от A до Z и в диапазоне от a до z  Диапазон 65-90 и 97-122
 [A-z]    - все символы от 65 до 122 в таблице ASCII     Входят символы: 91 -> 96  это - [\]^_`

 A = 65        [ = 91     _ = 95
 Z = 90        \ = 92     ` = 96
 a = 97        ] = 93
 z = 122       ^ = 94

 ----------------------------------------  '|' -------------------------------------------------------------------------

 re.findall(r'a|A', 'ABC')                   # -> ['A']
 re.findall(r'ABC|Good', 'ABC Python Good')  # -> ['ABC', 'Good']

 text = "By 'tree fiddy' I mean 'three fifty' 3.50"
 re.findall(r"three fifty|tree fiddy|3\.50", text)  # -> ['tree fiddy', 'three fifty', '3.50']

 # Если перебор идет в середине слова, его нужно взять в круглые скобки!
 re.search(r'(А(н|л)я)', 'Аня Аля')[0]  # -> Аня
 re.search(r'(А(н|л)я)', 'Аля Аня')[0]  # -> Аля

 # Вывод правильной даты
 text = '01.01.1999, 05.08.2015, 08.08.8888, 99.99.2000 05.06.2999 33.01.2000 32.01.2888'

 # Результат одинаковый      синтаксис разный
 re.findall(r'(3[01]|0[1-9]|2[0-9])\.(0[1-9]|1[0-2])\.(20[0-9][0-9]|1[89][0-9][0-9])', text)  # [0-9][0-9]
 # -> [('01', '01', '1999'), ('05', '08', '2015')]
 re.findall(r'(3[01]|0[1-9]|2[0-9])\.(0[1-9]|1[0-2])\.(20[0-9][0-9]|1[89]\d{1,2})', text)     # \d{1,2} вместо [0-9][0-9]
 # -> [('01', '01', '1999'), ('05', '08', '2015')]
 re.findall(r'(3[01]|0[1-9]|2[0-9])[.](0[1-9]|1[0-2])[.](20[0-9][0-9]|1[89]\d{1,2})', text)   # [.] вместо \.
 # -> [('01', '01', '1999'), ('05', '08', '2015')]

 ----------------------------------------  '(...)' ---------------------------------------------------------------------
 Указывает начало и конец группы    Group

 re.match(r'([01]\d?|2[0-3]):[0-5][0-9]', '23:59').groups()    # -> ('23',)
 re.match(r'([01]\d?|2[0-3]):([0-5][0-9])', '23:59').groups()  # -> ('23', '59')

 # нумерация захваченных групп начинается с единицы, а не с нуля.
 result = re.match(r'(a(b)c)d', 'abcd')
 result.group(0)        # -> abcd   # Весь вывод
 result.group(1)        # -> abc
 result.group(2)        # -> b
 result.group(0, 1, 2)  # -> ('abcd', 'abc', 'b')
 result.groups()        # -> ('abc', 'b')
 result.group(1, 2, 1, 2, 1, 2)            # -> ('abc', 'b', 'abc', 'b', 'abc', 'b')   # Как хотим используем Группы

 # Отношение к группе как к единице                                                                   <-----    <-----

 re.search('(bar)+', 'foo bar baz')           # -> <re.Match object; span=(4, 7), match='bar'>
 re.search('(bar)+', 'foo barbar baz')        # -> <re.Match object; span=(4, 10), match='barbar'>
 re.search('(bar)+', 'foo barbarbarbar baz')  # -> <re.Match object; span=(4, 16), match='barbarbarbar'>

 # Тоже самое но с findall()
 re.findall('([bar]+)', 'foo bar baz')           # -> ['bar', 'ba']
 re.findall('([bar]+)', 'foo barbar baz')        # -> ['barbar', 'ba']
 re.findall('([bar]+)', 'foo barbarbarbar baz')  # -> ['barbarbarbar', 'ba']

 # 2-4 вхождения 'bar' или 'baz' за которым необязательно следует 'qux'                                <-----
 re.search('(ba[rz]){2,4}(qux)?', 'bazbarbazqux')    # -> <re.Match object; span=(0, 12), match='bazbarbazqux'>
 re.search('(ba[rz]){2,4}(qux)?', 'barbar')          # -> <re.Match object; span=(0, 6), match='barbar'>

 # Как можно вкладывать группирующие круглые скобки                                          <-----       <-----
 # Более сложный пример с разбором его на мелкие части!                                      <-----       <-----
 print(re.search('(foo(bar)?)+(\d\d\d)?', 'foofoobar'))    # -> <re.Match object; span=(0, 9), match='foofoobar'>

 # foo(bar)?         -  'foo' необязательно, за которым следует 'bar'
 # (foo(bar)?)+      -  1 или более foo(bar)?
 # \d\d\d            -  Три десятичных знака
 # (\d\d\d)?         -  1 или 0  \d\d\d

 НЕТ различий в производительности при поиске между группами с захватом и без захвата.     '(...)'  '(?:...)'   <-----
 -----------------------------------------------------------------------------------------------------------------------

 -- Специальные последовательности:
 ----------------------------------------  '\d+'  '\D+'   '\d'   '\D'  -------------------------------------------------

 \d - Символьный класс Цифр     [0-9]
 \D - Символьный класс НЕ Цифр  [^0-9]  [^\d]

 re.findall(r'\d+', '123abc')        # -> ['123']           re.findall(r'\D+', '123abc')        # -> ['abc']
 re.findall(r'\d+', '123abc, abc1')  # -> ['123', '1']      re.findall(r'\D+', '123abc, abc1')  # -> ['abc, abc']

 re.findall(r'\d', '1a')      # -> ['1']                    re.findall(r'\D', '1a')      # -> ['a']
 re.findall(r'\d', '1a, a1')  # -> ['1', '1']               re.findall(r'\D', '1a, a1')  # -> ['a', ',', ' ', 'a']

 ----------------------------------------  '\w+'  '\W+  '  \w'   '\W'  -------------------------------------------------

 \w - Символьный класс Символов Слова     [A-Za-zА-Яа-я0-9_]
 \W - Символьный класс НЕ Символов Слова  [^A-Za-zА-Яа-я0-9_]  [^\w]

 re.findall(r'\w+', '12ab.*%$@!_')    # -> ['12ab', '_']         re.findall(r'\W+', '12ab.*%$@!_')    # -> ['.*%$@!']
 re.findall(r'\w+', '12ab.*%$, a1!_') # -> ['12ab', 'a1', '_']   re.findall(r'\W+', '12ab.*%$, a1!_') # -> ['.*%$, ', '!']

 re.findall(r'\w', '1a!@_')      # -> ['1', 'a', '_']            re.findall(r'\W', '1a!@_')      # -> ['!', '@']
 re.findall(r'\w', '1a!@, a1!_') # -> ['1', 'a', 'a', '1', '_']  re.findall(r'\W', '1a!@, a1!_') # -> ['!', '@', ',', ' ', '!']

 ----------------------------------------  '\s'  '\S'  -----------------------------------------------------------------
 \s - Символьный класс Пробельных символов Unicode     [ \t\n\r\f\v]
 \S - Символьный класс НЕ Пробельных символов Unicode  [^ \t\n\r\f\v]  [^\s]

 re.search(r'\s', 'foo\nbar baz')  # -> <re.Match object; span=(3, 4), match='\n'>

 re.sub(r'\s', '9', ' AB C ')      # -> 9AB9C9
 re.sub(r'\S', '9', ' AB C ')      # ->  99 9
 re.findall(r'[\S]', '999 AAA')    # -> ['9', '9', '9', 'A', 'A', 'A']
 re.findall(r'[\s]', '999 AAA')    # -> [' ']
 re.findall(r'[\s\d]', '999 AAA')  # -> ['9', '9', '9', ' ']

 # Нет разницы между  [\s] и \s    тоже самое и для других отдельных символьных классов
 re.findall(r'[\s]', ' \t\v\r\n\f')  # -> [' ', '\t', '\x0b', '\r', '\n', '\x0c']
 re.findall(r'\s', ' \t\v\r\n\f')    # -> [' ', '\t', '\x0b', '\r', '\n', '\x0c']
 re.findall(r'[\S]', ' \t\v\r\n\f')  # -> []
 re.findall(r'\S', ' \t\v\r\n\f')    # -> []

 ----------------------------------------  '\b'   '\B' -----------------------------------------------------------------
 внутри символьного класса метасимвол '\b' не используется, а представляет символ backspace   [\b] - Возврат на 1 символ
                                                                                              print('AA\b') # -> A
 text = 'арка чарка аркан баварка знахарка'

 # Найти конкретное слово     '\b'
 re.findall(r'\bарка\b', text)  # -> ['арка']                           <-----

 # Найти все слова которые НАЧИНАЮТСЯ с выбранного значения
 re.findall(r'\bарка', text)     # -> ['арка', 'арка']                  <-----
 re.findall(r'\bарка\w*', text)  # -> ['арка', 'аркан']                 <-----

 # Найти все слова которые ЗАКАНЧИВАЮТСЯ  выбранным значением
 re.findall(r'арка\b', text)     # -> ['арка', 'арка', 'арка', 'арка']           <-----
 re.findall(r'\w*арка\b', text)  # -> ['арка', 'чарка', 'баварка', 'знахарка']   <-----


 # формально '\b' определяется как граница между '\w' и '\W' или '\W' и '\w'                    <-----         <-----

 re.findall(r'\bfoo\b', 'foo foo. (foo) bar foo baz ')  # -> ['foo', 'foo', 'foo', 'foo']  # В таких найдёт     <-----
 re.findall(r'\bfoo\b', 'foobar foo3')                  # -> []                            # В таких НЕ найдёт  <-----

 # Сравнение '\B' и '\b'        '\B'  противоположность '\b'                                    <-----         <-----
 re.findall(r'py\B', 'python py3 py2')  # -> ['py', 'py', 'py']   # В таких найдёт     <-----
 re.findall(r'py\B', 'py py. py!')      # -> []                   # В таких НЕ найдёт  <-----

 re.findall(r'py\b', 'python py3 py2')  # -> []                   # В таких НЕ найдёт  <-----
 re.findall(r'py\b', 'py py. py!')      # -> ['py', 'py', 'py']   # В таких найдёт     <-----

 # Хороший пример
 # \b
 re.findall(r'\b[ABCD]', 'ABCD')   # -> ['A']   # Возьмем Первый символ
 re.findall(r'[ABCD]\b', 'ABCD')   # -> ['D']   # Возьмем Последний символ
 re.findall(r'\bAB\b', 'ABCD AB')  # -> ['AB']  # Возьмем конкретный символ

 re.findall(r'\b[ABCD]', 'ABCD BA CA F')  # -> ['A', 'B', 'C']  # Возьмем ВСЕ Первые символы которые ищем
 re.findall(r'[ABCD]\b', 'ABCD BA CA F')  # -> ['D', 'A', 'A']  # Возьмем ВСЕ Последние символы которые ищем
 re.findall(r'\b[ABCD]\b', 'ABCD BA CA F')  # -> []             # НЕ Найдет в СИМВОЛЬНОМ КЛАССЕ []
 re.findall(r'\bABCD\b', 'BA ABCD CA F')    # -> ['ABCD']       # БЕЗ СИМВОЛЬНОГО КЛАССА [] Найдет

 #\B
 re.findall(r'\B[ABCD]', 'ABCD BA CA F')    # -> ['B', 'C', 'D', 'A', 'A']  # Возьмем ВСЕ НЕ Первые символы которые ищем
 re.findall(r'[ABCD]\B', 'ABCD BA CA F')    # -> ['A', 'B', 'C', 'B', 'C']  # Возьмем ВСЕ НЕ Последние символы которые ищем
 re.findall(r'\B[ABCD]\B', 'ABCD BA CA F')  # -> ['B', 'C']                 # Найдет в СИМВОЛЬНОМ КЛАССЕ []
 re.findall(r'\BABCD\B', 'BA ABCD CA F')    # -> []                         # БЕЗ СИМВОЛЬНОГО КЛАССЕ [] НЕ Найдет

 # Находит и НЕ находит совпадение                                                                               <-----
 from re import search
 re.search(r'\bbar', 'foo bar')  # -> <re.Match object; span=(4, 7), match='bar'>  # Находит
 re.search(r'\bbar', 'foobar')   # -> None                           # Должна находиться в начале слова
 re.search(r'foo\b', 'foobar')   # -> None                           # Должна находиться в конце  слова
 re.search(r'\bbar\b', 'foo bar baz')  # -> <re.Match object; span=(4, 7), match='bar'>  # Находит
 re.search(r'\bbar\b', 'foobarbaz')    # -> None                                         # Только целое слово

 # \B  Противоположность \b
 re.search(r'\Bfoo\B', 'foo')          # -> None
 re.search(r'\Bfoo\B', '.foo.')        # -> None
 re.search(r'\Bfoo\B', 'barfoobaz')    # -> <re.Match object; span=(3, 6), match='foo'>

 ----------------------------------------  '\A'  ------------------------------------------------------------------------
 Когда режим MULTILINE выключен '\A' и '^' фактически одинаковы. В многострочном режиме они различны:
 '\A' по-прежнему совпадает только в начале строки, а '^' может совпадать в любом месте внутри строки,
 которая следует за символом новой строки \n.

 # Сравнение '\A' и '^'
 text = 'Line one\nword on line two\n'
 re.findall(r'\Aword', text, flags=re.M)         # -> []          # '/A'  ставим в начале текста
 re.findall(r'^word', text, flags=re.MULTILINE)  # -> ['word']

 # Без режима/флага ОДИНАКОВЫЕ!                                                   <-----
 re.findall(r'\Aword', 'word\n')    # -> ['word']
 re.findall(r'^word', 'word\n')     # -> ['word']

 re.findall(r'\Aword', '\nword\n')  # -> []
 re.findall(r'^word', '\nword\n')   # -> []

 re.findall(r'\Aword', 'word')      # -> ['word']
 re.findall(r'^word', 'word')       # -> ['word']

 ----------------------------------------  '\Z'  ------------------------------------------------------------------------
 Совпадает только c концом строки.
 '\Z' и  '$'  Разница становится очевидной только тогда, когда вы используете  флаг  re.MULTILINE,  re.M,  (?m)

 # Сравнение '\Z' и '$'
 text = 'Line one word\nLine two\n'
 re.findall(r'word\Z', text, flags=re.M)          # -> []         # '/Z'  ставим в конце текста
 re.findall(r'word$',  text, flags=re.MULTILINE)  # -> ['word']

 # Без режима/флага тоже ЕСТЬ РАЗНИЦА!                                              <-----
 re.findall(r'word\Z', 'word\n')    # -> []
 re.findall(r'word$', 'word\n')     # -> ['word']

 re.findall(r'word\Z', '\nword\n')  # -> []
 re.findall(r'word$', '\nword\n')   # -> ['word']

 re.findall(r'word\Z', 'word')      # -> ['word']
 re.findall(r'word$', 'word')       # -> ['word']

 ----------------------------------------  '\number'   '\1' '\2' '\3' ... '(?P<name>...)'  '(?P=name)'  ----------------
 # Обратные ссылки в шаблоне позволяют указать, что содержимое более ранней группы также должно быть найдено в текущем месте строки.
 re.search(r'\b(\w+)\s+\b', 'Paris in the the spring').group()                   # -> Paris
 re.search(r'\b(\w+)\s+\b\1', 'Paris in the the spring').group()                 # -> the the
 re.search(r'\b(\w+)\s+\b', 'ABC 123 123').group()                               # -> ABC
 re.search(r'\b(\w+)\s+\b\1', 'ABC 123 123').group()                             # -> 123 123

 # Так же работают Именованные группы                                                             <-----
 re.search(r'\b(\w+)\s+\b', 'Paris in the the spring').group()                   # -> Paris
 re.search(r'\b(?P<word>\w+)\s+\b(?P=word)', 'Paris in the the spring').group()  # -> the the
 re.search(r'\b(\w+)\s+\b', 'ABC 123 123').group()                               # -> ABC
 re.search(r'\b(?P<word>\w+)\s+\b(?P=word)', 'ABC 123 123').group()              # -> 123 123


 # Очень полезные при заменах                                                          <-----     <-----

 re.sub(r'([A])\s*([B])\s*([C])', r'\3 \1 \2', 'A B C')                                          # -> C A B
 re.sub(r'([A])\s*([B])\s*([C])', r'\g<3> \g<1> \g<2>', 'A B C')                                 # -> C A B
 re.sub(r'(?P<one>[A])\s*(?P<two>[B])\s*(?P<three>[C])', r'\g<three> \g<one> \g<two>', 'A B C')  # -> C A B

 \1 - индекс скобки     Синтаксис таков:  \i (i-натуральное число: 1, 2, 3, ...)
 \g<name> - обращение к группе по имени;    \1, \2 ... - обращение к группе по номеру

 '\1' эквивалентно re.search(...).group(1), первому выражению, разделенному круглыми скобками, внутри регулярного выражения.

 re.search(r'(\d)\1', '54222267890')[0]     # -> 22
 re.search(r'(\d)\1\1', '54222267890')[0]   # -> 222
 re.search(r'(\d)\1{3}', '54222267890')[0]  # -> 2222
 re.search(r'(2)(222)', '54222267890').groups()  # -> ('2', '222')

 # Соответствует слову, за которым следует запятая, а затем еще раз то же слово      <-----       <-----
 m = re.search(r'(\w+),\1', 'foo,foo')
 m           # -> <re.Match object; span=(0, 7), match='foo,foo'>
 m.group(1)  # -> foo
 m = re.search(r'(\w+),\1', 'qux,qux')
 m           # -> <re.Match object; span=(0, 7), match='qux,qux'>
 m.group(1)  # -> qux
 # Не имеет совпадения поскольку то, что идет до запятой, не совпадает с тем, что идет после нее
 m = re.search(r'(\w+),\1', 'foo,qux')
 m           # -> None                   # \1 обратная ссылка не совпадает.          <-----       <-----

 # Всегда используем r'' - строки!!!                                                 <-----       <-----
 re.search('([a-z])#\1', 'd#d')   # -> None                                           # Без r'' - строки
 re.search(r'([a-z])#\1', 'd#d')  # -> <re.Match object; span=(0, 3), match='d#d'>    # r'' - строка
 # Интерпретатор может спутать обратную ссылку с восьмеричным значением
 oct(ord('\1'))                   # -> 0o1   # Восьмиричное значение

 # Найдёт все повторяющиеся последовательности из трёх цифр, которые идут друг за другом.         <-----       <-----
 text = r'534535345377777753453'
 re.search(r'(\d{3})\1', text).group()                   # -> 777777   # Номерная группа    () \1
 re.search(r'(?P<first>\d{3})(?P=first)', text).group()  # -> 777777   # Именованная группа (?P<first>)(?P=first)


 # Найдёт все повторяющиеся буквы в тексте
 text = r'gg wp'
 re.search(r'([a-zA-Zа-яА-ЯёЁ])\1', text)                   # -> <re.Match object; span=(0, 2), match='gg'>
 re.search(r'(?P<first>[a-zA-Zа-яА-ЯёЁ])(?P=first)', text)  # -> <re.Match object; span=(0, 2), match='gg'>


 # Нужно найти последовательности из 2 одинаковых арабских цифр
 text = r'6996966969'
 print(re.findall(r'([\d]{2})\1', text))                 # -> ['96', '69']
 print(re.findall(r'(?P<name>[\d]{2})(?P=name)', text))  # -> ['96', '69']

 # Так тоже работает без []
 print(re.findall(r'(\d{2})\1', text))                   # -> ['96', '69']

 # Ссылки на нумерованные группы Обрати внимание на span откуда находит                           <-----
 text = r'12334test testtest'

 re.search(r'([a-z]{4})', text)     # -> <re.Match object; span=(5, 9), match='test'>
 re.search(r'([a-z]{4})\1', text)   # -> <re.Match object; span=(10, 18), match='testtest'>
 re.search(r'([a-z]{4}) \1', text)  # -> <re.Match object; span=(5, 14), match='test test'>

 -----------------------------------------------------------------------------------------------------------------------


 -- Расширения регулярных выражений

 ----------------------------------------  '(?:...)'  ------------------------------------------------------------------
 Группа без захвата   Non-capturing group

 (?:\d.){2} равносильно \d.\d.

 re.match("([abc])+", "abc").groups()     # -> ('c',)   # Группа с захватом
 re.match("(?:[abc])+", "abc").groups()   # -> ()       # Группа без захвата   (?:)

 m = re.search(r'([A-Z]+)\s*([a-z]+)\s*([0-9])', 'AB ab 12')
 m.groups()  # -> ('AB', 'ab', '1')                                  # Все группы                        <-----

 m = re.search(r'(?:[A-Z]+)\s*([a-z]+)\s*([0-9])', 'AB ab 12')
 m.groups()  # -> ('ab', '1')                                        # Удалили одну группу:  (?:[A-Z]+)  <-----
 m = re.search(r'(?:[A-Z]+)\s*(?:[a-z]+)\s*(?:[0-9])', 'AB ab 12')
 m.groups()  # -> ()                                                 # Удалили Все группы:    (?:)       <-----
 m  # -> <re.Match object; span=(0, 7), match='AB ab 1'>             # Но всеравно выводит результат!    <-----

 # Сделали 2 группы без захвата
 m = re.search('(\w+),(?:\w+),(?:\w+)', 'foo,quux,baz')
 m.groups()  # -> ('foo',)

 ----------------------------------------  '(?P<name>...)'  ------------------------------------------------------------
 Именованная группа - работает аналогично обычной группе (...)

 # Проще чем запоминать или высчитывать номер группы '\1'
 re.search(r'(?P<first>\w+)\s*(?P<second>\d+)',   'ABC 123').group('first')   # -> ABC   # (?P<first>\w+)
 re.search(r'(?P<first>\w+)\s*(?P<second>\d+)',   'ABC 123').group('second')  # -> 123   # (?P<second>\d+)

 # Разные способы замен: \g<name>   \g<1>   \1
 re.sub(r'(?P<first>\w+)\s*(?P<second>\d+)', r'\g<first> \g<1> \1', 'ABC 123')  # -> ABC ABC ABC

 # Cловарь(dict) Именованных групп
 re.match(r'(\w+)\s*(\d+)', 'ABC 123').groupdict()                      # -> {}
 re.match(r'(?P<name_1>\w+)\s*(?P<name_2>\d+)', 'ABC 123').groupdict()  # -> {'name_1': 'ABC', 'name_2': '123'}

 ----------------------------------------  '(?P=name)'  ----------------------------------------------------------------
 Обратная ссылку на именованную группу
 Это соответствует любому совпавшему тексту, который был сопоставлен с более ранней группой с именем name или НЕУДАЧА

 re.search(r'(?P<name>\w+)\s*', 'A A')            # -> <re.Match object; span=(0, 2), match='A '>
 re.search(r'(?P<name>\w+)\s*(?P=name)', 'A A')   # -> <re.Match object; span=(0, 3), match='A A'>

 # Обратные ссылки по имени и по индексу
 re.search(r'(\w+),\1', 'foo,foo').group(1)                       # -> foo
 re.search(r'(?P<word>\w+),(?P=word)', 'foo,foo').group('word')   # -> foo

 ----------------------------------------  '(?=...)'  ------------------------------------------------------------------
 Должно совпасть справа (Позитивная опережающая проверка)     Positive Lookahead         Пишем СПРАВА!!!

 # Соответствие - A11 A113       НЕ Соответствие - A1 A511

 re.findall(r'A(?=11)', 'A11 A113  |  A1 A511')         # -> ['A', 'A']                          <-----
 re.search(r'A(?=11)', 'A11 A113  |  A1 A511').start()  # -> 0      Совпадение с 0 индекса A11   <-----

 # Найдет 'Isaac '  только если ЗА ним следует 'Asimov'.
 re.findall(r'Isaac (?=Asimov)', 'Isaac Asimov')    # -> ['Isaac ']           <-----
 re.findall(r'Isaac (?=Asimov)', 'Asimov Isaac ')   # -> []                   <-----

 # Совпадает если ПОСЛЕ [A-Z]+ будет любая цифра!                  <-----     <-----
 re.findall(r'[A-Z]+(?=\d+)', 'A1 BBB C30')  # -> ['A', 'C']

 ----------------------------------------  '(?!...)'  ------------------------------------------------------------------
 Не должно совпасть справа (Негативная опережающая проверка)   Negative Lookahead         Пишем СПРАВА!!!

 # Соответствие - A1 A511        НЕ Соответствие - A11 A113
 re.findall(r'A(?!11)', 'A11 A113  |  A1 A511')         # -> ['A', 'A']                           <-----
 re.search(r'A(?!11)', 'A11 A113  |  A1 A511').start()  # -> 13      Совпадение с 13 индекса A1   <-----

 # Найдет 'Isaac '  только если ПЕРЕД ним следует 'Asimov'.
 re.findall(r'Isaac (?!Asimov)', 'Asimov Isaac ')   # -> ['Isaac ']           <-----
 re.findall(r'Isaac (?!Asimov)', 'Isaac Asimov')    # -> []                   <-----

 # Совпадает если ПОСЛЕ [A-Z]+ НЕ будет любая цифра!                          <-----     <-----
 re.findall(r'[A-Z]+(?!\d+)', 'A1 BBB C30')  # -> ['BBB']

 ----------------------------------------  '(?<=...)'  -----------------------------------------------------------------
 Должно совпасть слева (Позитивная ретроспективная проверка)    Positive Lookbehind        Пишем СЛЕВА!!!

 # Соответствие - Ольга Назина      НЕ Соответствие - Анна Назина
 re.findall(r'(?<=Ольга )Назина', 'Ольга Назина  |  Анна Назина')         # -> ['Назина']                    <-----
 re.search(r'(?<=Ольга )Назина', 'Ольга Назина  |  Анна Назина').start()  # -> 6    Совпадение с 6 индекса   <-----

 # должен соответствовать только строкам некоторой фиксированной длины!
 re.findall(r'(?<=abc)def', 'abcdef')    # -> ['def']
 re.search(r'(?<=abc)def', 'abcdef')[0]  # -> def

 # Этот пример ищет слово после дефиса:
 re.findall(r'(?<=-)\w+', 'spam-egg')    # -> ['egg']    <-----
 re.search(r'(?<=-)\w+', 'spam-egg')[0]  # -> egg        <-----

 # Совпадает если ДО [A-Z]+ будет любая цифра!           <-----     <-----
 re.findall(r'(?<=\d)[A-Z]+', '1A BBB10 30C')  # -> ['A', 'C']

 ----------------------------------------  '(?<!...)'  -----------------------------------------------------------------
 Не должно совпасть слева (Негативная ретроспективная проверка)   Negative Lookbehind       Пишем СЛЕВА!!!

 # Соответствие - Анна Назина      НЕ Соответствие - Ольга Назина
 re.findall(r'(?<!Ольга )Назина', 'Ольга Назина  |  Анна Назина')         # -> ['Назина']                      <-----
 re.search(r'(?<!Ольга )Назина', 'Ольга Назина  |  Анна Назина').start()  # -> 22    Совпадение с 22 индекса   <-----

 # Совпадает если ДО [A-Z]+ НЕ будет любая цифра!           <-----     <-----
 re.findall(r'(?<!\d)[A-Z]+', '1A BBB10 30C')  # -> ['BBB']

 ----------------------------------------  '(?(id/name)yes-pattern|no-pattern)'  ---------------------------------------
 По сути это if...else

 Сразу Примеры:

 # Если находим A значит ищем B иначе ищем C     1 - Номер группы
 re.search(r"(A)?(?(1)B|C)", 'ABC')   # -> <re.Match object; span=(0, 2), match='AB'>
 re.search(r"(A)?(?(1)B|C)", 'BC')    # -> <re.Match object; span=(1, 2), match='C'>

 # Можно и без последнего условия  Шаблон после | необязателен и может быть опущен.
 re.search(r"(A)?(?(1)B)", 'ABC')    # -> <re.Match object; span=(0, 2), match='AB'>
 re.search(r"(A)?(?(1)B)", 'BC')     # -> <re.Match object; span=(1, 2), match='C'>

 # Если находим A значит ищем B иначе ищем C     name - Имя группы
 print(re.search(r"(?P<name>A)(?(name)B|C)", 'ABC').group())   # -> AB
 print(re.search(r"(?P<name>A)(?(name)BC)", 'ABC').group())    # -> ABC

 Будет стараться соответствовать yes-pattern если группа с указанным идентификатором или именем существует
 no-pattern является не обязательным и может быть опущена.

 # это ПЛОХОЙ шаблон соответствия электронной почты
 re.match(r'(<)?(\w+@\w+(?:\.\w+)+)(?(1)>|$)', '<user@host.com>').group(0)  # -> <user@host.com>
 re.match(r'(<)?(\w+@\w+(?:\.\w+)+)(?(1)>|$)', 'user@host.com').group()     # -> user@host.com
 re.match(r'(<)?(\w+@\w+(?:\.\w+)+)(?(1)>|$)', '<user@host.com')            # -> None
 re.match(r'(<)?(\w+@\w+(?:\.\w+)+)(?(1)>|$)', 'user@host.com>')            # -> None


 regex = r'^(###)?foo(?(1)bar|baz)'  # Ниже обьяснение регулярки regex
 # ^(###)?       - указывает, что строка поиска может начинаться с '###'. Если да, то группирующие круглые скобки ###
 создадут группу с номером 1. В противном случае такой группы не будет.  foo -  соответствует строке 'foo'.
 # (?(1)bar|baz) - соответствует «bar», если группа 1 существует           «baz», если ее нет

 re.search(regex, '###foobar')  # -> <re.Match object; span=(0, 9), match='###foobar'>
 re.search(regex, '###foobaz')  # -> None
 re.search(regex, 'foobar')     # -> None
 re.search(regex, 'foobaz')     # -> <re.Match object; span=(0, 6), match='foobaz'>


 -- Условие (?(n)yes|no) --
 Хорошее обьяснение прочитай                                                                          <-----     <-----

 Пример 1:
 regex = r"(a)?(?(1)b|c)"

 # Группа (a)? ищет букву a. К группе применён квантификатор ?, т.к. этой буквы может не быть в тексте
 # Если в первой группе нашлась буква a, то условие (?(1)b|c) ищет букву b
 # Если первая группа ничего не нашла, то условие ищет букву c

 # В данном примере регулярное выражение найдёт все ab и c в тексте

 Пример 2:
 Условие очень удобно использовать для поиска скобок:

 regex = r"^(\[)?\d(?(1)\]|)$" # Выражение для поиска цифры в скобках или без скобок

 # Группа (\[)? ищет первую скобку. К группе применён квантификатор ?, т.к. скобки может и не быть
 # Условие (?(1)\]|) ищет правую скобку, если в первой группе найдена левая скобка.
 # Если первая группа ничего не нашла, то условие ничего не ищет.

 # Найдёт 1 и [2]
 # Проигнорирует 3] и [4


 А что если разбить по строчно:
 regex = r"^(\[)?\d(?(1)\]|)$"

 ^         #  начало строки
 (\[)?     #  1 группа где возможна скобочка "["
 \d        #  Любое число
 (?(1)\]|) #  Если 1 группа на месте то ищем "]" иначе | ничего
 $         #  конец строки

 ----------------------------------------  '(?#...)'  ------------------------------------------------------------------
 # Используем Внутри Комментарий
 re.findall(r'(?# Большие Буквы)([A-Z]+)\s*(?#Цифры)(\d+)(?#Работает)', 'ABC 123')  # -> [('ABC', '123')]

 ----------------------------------------  '(?aiLmsux)'  ---------------------------------------------------------------
 # Флаги должны идти первыми!  Иначе будет ошибка                                                        <-----
 re.findall(r'(?aimsx)([A-Z]+)\s*(\d+)', 'Aa 123 ФСБ')  # -> [('Aa', '123')]  Установили флаги (?aimsx)
 re.findall(r'([A-Z]+)\s*(\d+)', 'Aa 123')              # -> []               БЕЗ Флагов

 ----------------------------------------  '(?aiLmsux-imsx:...)'  ------------------------------------------------------
 Установить/Удалить флаги для части выражения!
 'a', 'L', 'u' являются взаимоисключающими поэтому они не могут быть объединены или следовать за '-'       Только один

 # Установка флага                                                                                       <-----
 re.findall('(?i:foo)bar', 'FOObar')  # -> ['FOObar']
 re.findall('(?i:foo)bar', 'FOOBAR')  # -> []

 # Удаление флага                                                                                        <-----
 re.findall('(?i)(?-i:foo)bar', 'FOOBAR')                   # -> []            # Снимаем флаг
 re.findall('(?-i:foo)bar', 'FOOBAR', flags=re.IGNORECASE)  # -> []            # Снимаем флаг
 re.findall('foobar', 'FOOBAR', flags=re.IGNORECASE)        # -> ['FOOBAR']    # НЕ Снимаем флаг

 # Флаги Снимаем для точки/игнора регистра
 re.findall(r'[A-Z]+.*[A-Z]', 'AAA\n\n aaa', flags=re.IGNORECASE | re.DOTALL)          # -> ['AAA\n\n aaa']
 re.findall(r'(?-is:[A-Z]+.*[A-Z])', 'AAA\n\n aaa', flags=re.IGNORECASE | re.DOTALL)   # -> ['AAA']

 # Классный пример Установить/Снять флаг для выражений
 re.findall(r'(?i:[a-z]+)(?s:.+)', 'AAAaaa\n\n')         # -> ['AAAaaa\n\n']
 re.findall(r'(?is)[a-z]+.+', 'AAAaaa\n\n')              # -> ['AAAaaa\n\n']
 re.findall(r'(?is)(?-i:[a-z]+)(?-s:.+)', 'AAAaaa\n\n')  # -> ['aaa']

 -----------------------------------------------------------------------------------------------------------------------


 -- Флаги шаблона регулярного выражения  Flags:
 (?flags) где flags - один или несколько флагов:  (?aimsx)
 Несколько флагов сразу:  '|'  re.IGNORECASE | re.ASCII    re.I|re.A|re.S|re.L|re.M|re.X

 Может лучше ставить flags=

 class re.RegexFlag

 ----------------------------------------  re.IGNORECASE  re.I    (?i)  ------------------------------------------------

 # Выполняет без УЧЕТА Регистра                                      Соответствует встроенному флагу (?i)

 #  игнорируя регистр
 re.findall(r'[A-Z]', 'ABCabc', re.IGNORECASE)        # -> ['A', 'B', 'C', 'a', 'b', 'c']
 re.findall(r'[a-z]', 'ABCabc', flags=re.IGNORECASE)  # -> ['A', 'B', 'C', 'a', 'b', 'c']
 re.findall(r'[a-z]', 'ABCabc', re.I)                 # -> ['A', 'B', 'C', 'a', 'b', 'c']
 re.findall(r'(?i)[a-z]', 'ABCabc')                   # -> ['A', 'B', 'C', 'a', 'b', 'c']  #    (?i) аналогично
 re.findall(r'[A-Z]', 'ABCabc')                       # -> ['A', 'B', 'C']
 re.findall(r'[a-z]', 'ABCabc')                       # -> ['a', 'b', 'c']

 # НЕ ПОНИМАЮ!!!   При установку c  flags= и без              <-----                <-----                <-----

 # У кого ХОРОШО работает:

 print(re.findall(r'abc', 'ABC', flags=re.IGNORECASE))    # -> ['ABC']
 print(re.findall(r'abc', 'ABC', re.IGNORECASE))          # -> ['ABC']

 print(re.finditer(r'abc', 'ABC', flags=re.IGNORECASE))   # -> <callable_iterator object at 0x000002704C9F9AE0>
 print(re.finditer(r'abc', 'ABC', re.IGNORECASE))         # -> <callable_iterator object at 0x000002704C9F9AE0>

 print(re.match(r'abc', 'ABC', flags=re.IGNORECASE))      # -> <re.Match object; span=(0, 3), match='ABC'>
 print(re.match(r'abc', 'ABC', re.IGNORECASE))            # -> <re.Match object; span=(0, 3), match='ABC'>

 print(re.search(r'abc', 'ABC', flags=re.IGNORECASE))     # -> <re.Match object; span=(0, 3), match='ABC'>
 print(re.search(r'abc', 'ABC', re.IGNORECASE))           # -> <re.Match object; span=(0, 3), match='ABC'>

 print(re.fullmatch(r'abc', 'ABC', flags=re.IGNORECASE))  # -> <re.Match object; span=(0, 3), match='ABC'>
 print(re.fullmatch(r'abc', 'ABC', re.IGNORECASE))        # -> <re.Match object; span=(0, 3), match='ABC'>


 # У кого ПЛОХО работает:
                                                             <-----                <-----
 print(re.split(r'abc', 'ABC', flags=re.IGNORECASE))       # -> ['', '']
 print(re.split(r'abc', 'ABC', re.IGNORECASE))             # -> ['ABC']

 print(re.subn(r'abc', '*', 'ABC', flags=re.IGNORECASE))   # -> ('*', 1)
 print(re.subn(r'abc', '*', 'ABC', re.IGNORECASE))         # -> ('ABC', 0)

 print(re.sub(r'abc', '*', 'ABC', flags=re.IGNORECASE))    # -> *
 print(re.sub(r'abc', '*', 'ABC', re.IGNORECASE))          # -> ABC

 # Флаг внутри РАБОТАЕТ!! 2 Варианта установки Флага  (?i:abc)     (?i)abc

 # (?i:) установкa
 print(re.split(r'(?i:abc)', 'ABC', ))      # -> ['', '']
 print(re.split(r'(?i:abc)', 'ABC', ))      # -> ['', '']

 print(re.subn(r'(?i:abc)', '*', 'ABC', ))  # -> ('*', 1)
 print(re.subn(r'(?i:abc)', '*', 'ABC', ))  # -> ('*', 1)

 print(re.sub(r'(?i:abc)', '*', 'ABC', ))   # -> *
 print(re.sub(r'(?i:abc)', '*', 'ABC', ))   # -> *

 # (?i) установкa
 print(re.split(r'(?i)abc', 'ABC', ))       # -> ['', '']
 print(re.split(r'(?i)abc', 'ABC', ))       # -> ['', '']

 print(re.subn(r'(?i)abc', '*', 'ABC', ))   # -> ('*', 1)
 print(re.subn(r'(?i)abc', '*', 'ABC', ))   # -> ('*', 1)

 print(re.sub(r'(?i)abc', '*', 'ABC', ))    # -> *
 print(re.sub(r'(?i)abc', '*', 'ABC', ))    # -> *


 ----------------------------------------  re.ASCII  re.A    (?a)  -----------------------------------------------------

 # заставляет \w, \W, \b, \B, \s \S выполнять только ASCII поиск     Соответствует встроенному флагу (?a)
 re.ASCII включает [a-zA-Z0-9_]

 # Странно но ABC123 - ASCII символы но с русскими AB   выводит только один раз AB
 re.findall(r'[а-яА-Я]+', 'ABC123 русский алфавит _АБВГДЕ', re.ASCII)  # -> ['русский', 'алфавит', 'АБВГДЕ']  # Аналоги
 re.findall(r'[а-яА-Я]+', 'ABC123 русский алфавит _АБВГДЕ', re.A)      # -> ['русский', 'алфавит', 'АБВГДЕ']  # Аналоги
 re.findall(r'\w+', 'ABC123 русский алфавит _АБВ', re.ASCII)  # -> ['ABC123', '_']  # ИГНОРИРУЕТ НЕ ASCII Символы!
 re.findall(r'(?a)\w+', 'ABC123 русский алфавит _АБВ')        # -> ['ABC123', '_']  # без флага но с (?a) ИГНОРИРУЕТ
 re.findall(r'\w+', 'ABC123 русский алфавит _АБВ')  # -> ['ABC123', 'русский', 'алфавит', '_АБВ']  # без флага выводит все


 # Можно использовать несколько флагов сразу:
 # Игнорируем регист и только ASCII            re.IGNORECASE|re.ASCII                      (?ia) или '|'
 re.findall(r'(?ia)[а-я]+', 'ABC123 русский алфавит _АБВГДЕ')                     # -> ['русский', 'алфавит']
 re.findall(r'[а-я]+', 'ABC123 русский алфавит _АБВГДЕ', re.IGNORECASE|re.ASCII)  # -> ['русский', 'алфавит']
 re.findall(r'[а-я]+', 'ABC123 русский алфавит _АБВГДЕ', re.I|re.A)               # -> ['русский', 'алфавит']

 ----------------------------------------  re.DOTALL  re.S    (?s)  ----------------------------------------------------
 # заставляет специальный символ '.' соответствовать любому символу вообще, включая перевод строки '\n'.
 Без этого флага '.' будет соответствовать все, кроме новой строки  \n.

 text = '\n'
 re.findall(r'.', text)             # -> []
 re.findall(r'.', text, re.DOTALL)  # -> ['\n']   # Разные способы указать флаг:     re.DOTALL
 re.findall(r'.', text, re.S)       # -> ['\n']   # Разные способы указать флаг:     re.S
 re.findall(r'(?s).', text)         # -> ['\n']   # Разные способы указать флаг:     (?s)

 ----------------------------------------  re.VERBOSE  re.X    (?x)  ---------------------------------------------------
 Можно использовать комментарии '#' Игнорирует пробел но если он не в [] или перед ним обратный слеш '\'

 # Пробелы игнорирует и можно ставить внутри регулярки комментарии #
 re.findall(r'\d+      # Найдём только ЦИФРЫ   ', 'ABab11', re.VERBOSE)   # -> ['11']     # Поставили комментарий внутри
 re.findall(r'[a-z]+   # Найдём только БУКВЫ   ', 'ABab11', re.X | re.I)  # -> ['ABab']   # Тоже самое но 2 флага
 re.findall(r'(?x)\w+  # Найдём ВСЁ  ', 'ABab11')                         # -> ['ABab11'] # Тоже работает с флагом (?x)

 ----------------------------------------  re.MULTILINE  re.M    (?m)  -------------------------------------------------
 влияет на совпадение привязок ^ и $.

 # MULTILINE позволяет '^' и '$' работать с каждой строкой.
 re.findall('\w+$', 'foo\nbar')              # -> ['bar']
 re.findall('\w+$', 'foo\nbar', flags=re.M)  # -> ['foo', 'bar']
 re.findall('^\w+', 'foo\nbar')              # -> ['foo']
 re.findall('^\w+', 'foo\nbar', flags=re.M)  # -> ['foo', 'bar']

 ----------------------------------------  re.LOCALE  re.L    (?L)  ----------------------------------------------------
 Делает метасимволы \w, \W, \b, \B зависимыми от текущей локали, а не от базы данных Unicode.  Модуль unicodedata <-----
 Он работает только с байтовыми строками, а не со строками Unicode.  Компиляция будет происходить МЕДЛЕННЕЕ
 Предупреждение Этот флаг не рекомендуется Механизм локалей очень НЕнадежен  лучше использовать  -   re.ASCII

 ----------------------------------------  re.NOFLAG  ------------------------------------------------------------------
 Указывает, что флаг не применяется, значение равно 0. Можно использовать как значение по умолчанию    Python 3.11+

 def myfunc(text, flag=re.NOFLAG):
     return re.match(text, flag)

 ----------------------------------------  re.DEBUG  ------------------------------------------------------------------
 Отображение отладочной информации о скомпилированном выражении.               встроенного флага НЕТ
 re.compile(r'\w+', flags=re.DEBUG)         # Покажет отладочную информацию
 re.findall(r'\w+', 'ABC', flags=re.DEBUG)  # Можно применять с другими функциями re

 -----------------------------------------------------------------------------------------------------------------------


 -- Объекты регулярных выражений  Regular Expression Objects --

 class re.Pattern - Скомпилированный объект регулярного выражения, возвращаемый re.compile()

 -- Методы объекта регулярного выражения Pattern:

 Pattern.search(string[, pos[, endpos]])    - Находит первое совпадение в строке
 Pattern.match(string[, pos[, endpos]])     - Находит совпадение с началом строки
 Pattern.fullmatch(string[, pos[, endpos]]) - Совпадение с целой строкой
 Pattern.split(string, maxsplit=0)          - Разбивает строку с помощью регулярных выражений
 Pattern.findall(string[, pos[, endpos]])   - Находит все совпадения в строке
 Pattern.finditer(string[, pos[, endpos]])  - Iterator Находит все совпадения в строке
 Pattern.sub(repl, string, count=0)         - Поиск и замена
 Pattern.subn(repl, string, count=0)        - Поиск и замена + кол-во замен

 ----------------------------------------  Pattern.search(string[, pos[, endpos]])  ------------------------------------

 Pattern.search() -  Сканирует строку и находит первое место совпадения или None. Отличается от совпадения нулевой длины
 rx.search(string, 0, 50)  эквивалентен  rx.search(string[:50], 0)

 pattern = re.compile("d")  # Скомпилировали шаблон
 pattern.search("dog")      # -> <re.Match object; span=(0, 1), match='d'>    # совпадение по индексу 0
 pattern.search("dog"[0:])  # -> <re.Match object; span=(0, 1), match='d'>    # Тоже самое
 pattern.search("dog", 1)   # -> None   # Нет совпадений поиск не включает позицию символа 'd'

 ----------------------------------------  Pattern.match(string[, pos[, endpos]])  -------------------------------------

 Pattern.match() - если ноль или более символов в начале строки string или None. Отличается от совпадения нулевой длины

 pattern = re.compile('o')
 pattern.match("dog")     # -> None                                       # Совпадений нет т.к. 'o' не первый символ
 pattern.match("dog", 1)  # -> <re.Match object; span=(1, 2), match='o'>  # Совпадение найдено 'o' второй символ слова

 ----------------------------------------  Pattern.fullmatch(string[, pos[, endpos]])  ---------------------------------

 Pattern.fullmatch() - если ВСЯ строка соответствует регулярному выражению или None. Отличие от совпадения нулевой длины

 pattern = re.compile("o[gh]")
 pattern.fullmatch("dog")    # -> None     # Совпадений нет т.к. 'o' не первый символ
 pattern.fullmatch("ogre")   # -> None     # Совпадений нет т.к. совпала не вся строка
 pattern.fullmatch("doggie", 1, 3)         # Совпадение найдено, т.к. поиск ограничен  от 1 до 3
 # -> <re.Match object; span=(1, 3), match='og'>
 pattern.fullmatch("doggie"[:3], 1)        # Тоже самое но со Срезами [:3], 1
 # -> <re.Match object; span=(1, 3), match='og'>

 ----------------------------------------  Pattern.split(string, maxsplit=0)  ------------------------------------------
 Pattern.split() - Идентичен функции re.split()

 pattern = re.compile("\s*[,;/]\s*")
 pattern.split('foo,bar  ;  baz / qux')  # -> ['foo', 'bar', 'baz', 'qux']    # Разделители:  ,;/ пробелы

 ----------------------------------------  Pattern.findall(string[, pos[, endpos]])  -----------------------------------

 Pattern.findall() - аналогичен функции re.findall() и необязательные параметры pos и endpos для ограничение поиска

 pattern = re.compile("(\w+),(\w+)")
 pattern.findall('foo,bar,baz,qux,quux,corge', 4, 20)  # -> [('bar', 'baz'), ('qux', 'quux')]

 pattern = re.compile("\w+")
 pattern.findall('...foo,,,,bar:%$baz//|', 3, 20)      # -> ['foo', 'bar', 'baz']

 ----------------------------------------  Pattern.finditer(string[, pos[, endpos]])  ----------------------------------

 Pattern.finditer() - аналогичен функции re.finditer() и необязательные параметры pos и endpos для ограничение поиска

 pattern = re.compile("\w+")
 it = pattern.finditer(r'...foo,,,,bar:%$baz//|')
 next(it)  # -> <re.Match object; span=(3, 6), match='foo'>
 next(it)  # -> <re.Match object; span=(10, 13), match='bar'>
 next(it)  # -> <re.Match object; span=(16, 19), match='baz'>
 next(it)  # -> StopIteration

 ----------------------------------------  Pattern.sub(repl, string, count=0)  -----------------------------------------
 Pattern.sub() - Идентичен функции re.sub()

 pattern = re.compile("\w+")
 pattern.sub(r'xxx', 'foo.bar.baz.qux')           # -> xxx.xxx.xxx.xxx           # Возвращает <class 'str'>
 pattern.sub(r'xxx', 'foo.bar.baz.qux', count=2)  # -> xxx.xxx.baz.qux           # Тоже самое но с Ограничением Замен

 ----------------------------------------  Pattern.subn(repl, string, count=0)  ----------------------------------------
 Pattern.subn() - Идентичен функции re.subn()

 pattern = re.compile("\w+")
 pattern.subn(r'xxx', 'foo.bar.baz.qux')           # -> ('xxx.xxx.xxx.xxx', 4)    # Возвращает <class 'tuple'>
 pattern.subn(r'xxx', 'foo.bar.baz.qux', count=2)  # -> ('xxx.xxx.baz.qux', 2)    # Тоже самое но с Ограничением Замен
 -----------------------------------------------------------------------------------------------------------------------


 -- Атрибуты объекта регулярного выражения Pattern    Без вызова ()  Работают только с compile --

 Pattern.flags      - Флаги соответствия регулярному выражению
 Pattern.groups     - Число групп захвата
 Pattern.groupindex - Словарь вида: {group: match}
 Pattern.pattern    - Шаблон регулярного выражения


 ----------------------------------------  Pattern.flags  --------------------------------------------------------------
 Pattern.flags - Это комбинация флагов, присвоенных compile()  (?...) или re.I | re.A

 pattern = re.compile("\w+", flags=re.IGNORECASE | re.S)  # Тоже самое
 pattern = re.compile("(?is)\w+")                         # Тоже самое
 pattern.search('FOOBARBAZ')         # -> <re.Match object; span=(0, 9), match='FOOBARBAZ'>   # Тоже самое
 re.search(pattern, 'FOOBARBAZ')     # -> <re.Match object; span=(0, 9), match='FOOBARBAZ'>   # Тоже самое

 re.compile("\w+", flags=re.IGNORECASE).flags  # -> 34  логическое ИЛИ or ФЛАГА                                 <-----
 re.compile("\w+", flags=re.I | re.A).flags    # -> 258 логическое ИЛИ or ФЛАГОВ                                <-----
 re.compile("(?aimsx)\w+",).flags              # -> 346 логическое ИЛИ or ФЛАГОВ                                <-----

 ----------------------------------------  Pattern.groups  -------------------------------------------------------------

 Pattern.groups - это число групп захвата в шаблоне.

 re.compile("(\w+),(\w+),(\w+)").groups  # -> 3    # Сколько групп
 re.compile("\w+").groups                # -> 0    # Сколько групп

 ----------------------------------------  Pattern.groupindex  ---------------------------------------------------------

 Pattern.groupindex - Словарь  именованных групп  '(?P<name>...)'   или пустой словарь {}

 re.compile("(\w+)").groupindex                    # -> {}                   # Словарь(dict)
 re.compile("(?P<w1>\w+),(?P<w2>\w+)").groupindex  # -> {'w1': 1, 'w2': 2}   # Словарь(dict)

 ---------------------------------------- Pattern.pattern  -------------------------------------------------------------

 Pattern.pattern - Строка шаблона, из которой был скомпилирован объект шаблона.

 re.compile("(\w+),(\w+),(\w+)").pattern  # -> (\w+),(\w+),(\w+)
 re.compile("\d+\s+\d+").pattern          # -> \d+\s+\d+

 -----------------------------------------------------------------------------------------------------------------------

 -- Match Objects  Объект совпадения с шаблоном Match --

 Функции re.match()  re.search()  re.fullmatch()  возвращают None когда нет совпадений, то можно проверить if...else

 match = re.search(pattern, string)
 match = re.match(pattern, string)
 match = re.fullmatch(pattern, string)
 if match:
     process(match)

 -- Методы re.Match object    При использовании методов:  search(), match(), fullmatch():

 Match.expand(template)        - Строка c содержимым найденной группы
 Match.group([group1, ...])    - Одна или несколько подгрупп совпадения
 Match.__getitem__(g)          - Идентичен Match.group()
 Match.groups(default=None)    - Кортеж, содержащий все подгруппы совпадения
 Match.groupdict(default=None) - Словарь, содержащий все совпавшие именованные подгруппы
 Match.start([group])          - Индексы НАЧАЛА подстроки совпадающей с группой
 Match.end([group])            - Индексы КОНЦА  подстроки совпадающей с группой
 Match.span([group])           - Двойной кортеж вида (m.start(), m.end())


 -----------------------------------------  Match.expand(template)  ----------------------------------------------------

 Match.expand(template) - возвращает строку c содержимым группы template, как это делает метод re.sub()

 m = re.compile(r'(?P<name>\w+),(?P<name_2>\w+),(?P<name_3>\w+)')
 re.sub(m, r'--\g<name>-- !!\g<1>!! AA \1 AA', 'foo,bar,baz')  # -> --foo-- !!foo!! AA foo AA   # Тоже самое что и ниже

 m = re.search(r'(?P<name>\w+),(?P<name_2>\w+),(?P<name_3>\w+)', 'foo,bar,baz')
 m.expand(r'--\g<name>-- !!\g<1>!! AA \1 AA')  # -> --foo-- !!foo!! AA foo AA     # Можно добавить что хочешь
 m.expand(r'11 \g<0> 11')  # -> foo,bar,baz    # Вывод всего сразу \g<0>          # Можно добавить что хочешь

 m  # -> <re.Match object; span=(0, 11), match='foo,bar,baz'>                     # Вывод НЕ изменился

 re.search(r'w(.*)m', 'awesome').expand(r'\1')  # -> eso
 re.sub(r'w(.*)m', r'[\1]', 'awesome')          # -> a[eso]e

 -----------------------------------------  Match.group([group1, ...])  ------------------------------------------------

 Match.group() - возвращает одну или несколько подгрупп совпадения

 m = re.match(r"(\w+) (\w+)", "Isaac Newton, physicist")
 m.group()              # ->  Isaac Newton   # Тоже самое
 m.group(0)             # ->  Isaac Newton   # Тоже самое
 m.group(1)             # ->  Isaac
 m.group(2)             # ->  Newton
 m.group(1, 2)          # ->  ('Isaac', 'Newton')

 m = re.match(r"(?P<first_name>\w+) (?P<last_name>\w+)", "Malcolm Reynolds")
 m.group('first_name')  # ->  Malcolm
 m.group(1)             # ->  Malcolm        # На именованные группы также можно ссылаться по их индексу
 m.group('last_name')   # ->  Reynolds

 # Если группа совпадает несколько раз, доступно только последнее совпадение:
 re.match(r"(..)+", "a1b2c3").group()   # -> a1b2c3    # 3 совпадения шаблона со строкой
 re.match(r"(..)+", "a1b2c3").group(1)  # -> c3        # для извлечения доступно только последнее

 -----------------------------------------  Match.__getitem__(g)  ------------------------------------------------------
 Match.__getitem__() - Идентичен m.group(g)                       obj[n]   эквивалетно   obj.__getitem__(n)   <-----

 m = re.match(r"(\w+) (\w+)", "Isaac Newton, physicist")
 m[0]        # ->  Isaac Newton     # Полное совпадение
 m.group(0)  # ->  Isaac Newton     # Тоже самое
 m[1]        # ->  Isaac            # Первая заключенная в скобки подгруппа.
 m[2]        # ->  Newton           # Вторая заключенная в скобки подгруппа.
 m.__getitem__(2)  # ->  Newton     # Тоже самое под капотом использование срезов []  вызывает   __getitem__

 m = re.match(r"(?P<first_name>\w+) (?P<last_name>\w+)", "Isaac Newton")
 m['first_name']        # -> Isaac
 m.group('first_name')  # -> Isaac
 m['last_name']         # -> Newton
 m.__getitem__('last_name')  # ->  Newton    # Тоже самое под капотом использование срезов []  вызывает   __getitem__

 -----------------------------------------  Match.groups(default=None)  ------------------------------------------------

 Match.groups() - вернет кортеж, содержащий все подгруппы совпадения. default группы которые не смогли захватить результат

 m = re.match(r"(\d+)\.(\d+)", "24.1632")
 m.groups()       # ->  ('24', '1632')

 m = re.match(r"(\d+)\.?(\d+)?", "24")
 m.groups()       # -> ('24', None)    # 2 группа по умолчанию None.
 m.groups('---')  # -> ('24', '---')   # теперь 2 группа по умолчанию '---'

 -----------------------------------------  Match.groupdict(default=None)  ---------------------------------------------

 m = re.match(r"(?P<first_name>\w+) (?P<last_name>\w+)", "Malcolm Reynolds")
 m.groupdict()                # -> {'first_name': 'Malcolm', 'last_name': 'Reynolds'}
 m.groupdict()['first_name']  # -> Malcolm

 m = re.match(r'foo,(?P<w1>\w+),(?P<w2>\w+)?,qux', 'foo,bar,,qux')
 m.groupdict()                # -> {'w1': 'bar', 'w2': None}
 m.groupdict(default='---')   # -> {'w1': 'bar', 'w2': '---'}

 -----------------------------------------  Match.start([group])  Match.end([group]) -----------------------------------
 Match.start/end - индексы начала и конца подстроки, если группа НЕ существует -1

 email = "tony@tiremove_thisger.net"
 m = re.search("remove_this", email)
 email[:m.start()] + email[m.end():]  # -> tony@tiger.net

 s = 'foo123bar456baz'
 m = re.search(r'(\d+)\D*(?P<num>\d+)', s)
 m  # -> <re.Match object; span=(3, 12), match='123bar456'>
 m.group(1)                       # -> 123
 m.start(1), m.end(1)             # -> 3 6
 s[m.start(1):m.end(1)]           # -> 123
 m.group('num')                   # -> 456
 m.start('num'), m.end('num')     # -> 9 12
 s[m.start('num'):m.end('num')]   # -> 456

 # группа которая не участвует в сопоставлении:
 m = re.search(r'(\w+),(\w+),(\w+)?', 'foo,bar,')
 m.group(3)                       # -> None
 m.start(3), m.end(3)             # -> -1 -1

 -----------------------------------------  Match.span([group])  -------------------------------------------------------
 Match.span() - вернет двойной кортеж вида (m.start(group), m.end(group))  или  кортеж(-1, -1)

 s = 'foo123bar456baz'
 m = re.search(r'(\d+)\D*(?P<num>\d+)', s)
 m  # -> <re.Match object; span=(3, 12), match='123bar456'>
 m.span()                  # -> (3, 12)

 -----------------------------------------------------------------------------------------------------------------------


 -- Атрибуты объекта сопоставления Match:

 Match.pos                     - Индекс вхождения в строку начала совпадения
 Match.endpos                  - Индекс вхождения в строку конца совпадения
 Match.lastindex               - Индекс последней найденной группы захвата
 Match.lastgroup               - Имя последней соответствующей группы захвата
 Match.re                      - Объект регулярного выражения
 Match.string                  - Строка, в которой осуществляется поиск

 -----------------------------------------  Match.pos  Match.endpos  ---------------------------------------------------
 Match.pos    - индекс вхождения в строку в которой механизм регулярного выражения начал поиск совпадения.
 Match.endpos - индекс вхождения в строку, дальше которой механизм регулярного выражения не пойдет.

 pattern = re.compile(r'\d+')
 m = pattern.search('foo123bar', 2, 7)
 m  # -> <re.Match object; span=(3, 6), match='123'>    # по умолчанию начало совпадения и конец  (3, 6)
 m.pos, m.endpos            # -> 2 7                    # изменили начало/конец поиска  2, 7

 -----------------------------------------  Match.lastindex  -----------------------------------------------------------

 Match.lastindex - целочисленный индекс последней найденной группы захвата или None

 m = re.match(r"(?P<first_name>\w+) (?P<last_name>\w+)", "Malcolm Reynolds")
 m.lastindex     # -> 2
 m[m.lastindex]  # -> Reynolds

 # Не всегда последняя совпадающая группа является последней встречающейся группой    <-----
 m = re.match('((a)(b))', 'ab')
 m.groups()      # -> ('ab', 'a', 'b')
 m.lastindex     # -> 1
 m[m.lastindex]  # -> ab

 -----------------------------------------  Match.lastgroup  -----------------------------------------------------------

 Match.lastgroup - Имя последней соответствующей группы захвата или None

 m = re.match(r"(?P<first_name>\w+) (?P<last_name>\w+)", "Malcolm Reynolds")
 m.lastgroup     # -> last_name
 m[m.lastgroup]  # -> Reynolds

 # None если последняя захваченная группа не является ИМЕНОВАННОЙ группой             <-----
 re.match(r"(\w+) (\w+)", "Malcolm Reynolds").groups()   # -> ('Malcolm', 'Reynolds')
 re.match(r"(\w+) (\w+)", "Malcolm Reynolds").lastgroup  # -> None

 -----------------------------------------  Match.re -------------------------------------------------------------------

 Match.re - объект регулярного выражения  Pattern.match()  Pattern.search()  Pattern.fullmatch()

 # Модуль re кэширует регулярные выражения после их компиляции                                   <-----   <-----
 regex = r'(\w+),(\w+),(\w+)'
 m1 = re.search(regex, 'foo,bar,baz')
 m1.re                      # -> re.compile('(\\w+),(\\w+),(\\w+)')
 m1                         # -> <re.Match object; span=(0, 11), match='foo,bar,baz'>
 pattern = re.compile(regex)
 pattern                    # -> re.compile('(\\w+),(\\w+),(\\w+)')
 m1.re is pattern           # -> True
 m2 = pattern.search('qux,quux,corge')
 m2.re                      # -> re.compile('(\\w+),(\\w+),(\\w+)')
 m2.re is pattern is m1.re  # -> True

 # Как только у вас появится доступ к объекту регулярного выражения все атрибуты этого объекта также станут доступны:
 m1.re.groups            # -> 3
 m1.re.pattern           # -> (\w+),(\w+),(\w+)
 m1.re.pattern == regex  # -> True
 m1.re.flags             # -> 32

 # Вы также можете вызвать на нем ЛЮБОЙ из методов re                                               <-----
 m = re.search(r'(\w+),(\w+),(\w+)', 'foo,bar,baz')
 m.re                                 # -> re.compile('(\\w+),(\\w+),(\\w+)')
 m.re.match('quux,corge,grault')      # -> <re.Match object; span=(0, 17), match='quux,corge,grault'>
 m.re.findall('quux,corge,grault')    # -> [('quux', 'corge', 'grault')]
 m.re.fullmatch('quux,corge,grault')  # -> <re.Match object; span=(0, 17), match='quux,corge,grault'>

 -----------------------------------------  Match.string ---------------------------------------------------------------
 Match.string - это строка, переданная в Pattern.match()  Pattern.search()  Pattern.fullmatch()  Работает только с ними

 # Работает ТОЛЬКО c <class 're.Match'>    search, match, fullmatch                                 <-----   <-----
 m = re.search(r'(\w+),(\w+),(\w+)', 'foo,bar,baz')
 m = re.match(r'(\w+),(\w+),(\w+)', 'foo,bar,baz')
 m = re.fullmatch(r'(\w+),(\w+),(\w+)', 'foo,bar,baz')
 m.string  # -> foo,bar,baz
 type(m)  # -> <class 're.Match'>
 -----------------------------------------------------------------------------------------------------------------------



 -- Интересные примеры!    Внимательно смотри какие функции используют!!!                <------

 -----------------------------------------------------------------------------------------------------------------------

 # Замена в findall
 re.findall(r'(Оля) \+ Маша', 'Оля + Маша')  # -> ['Оля']

 Посмотри Пример:
 # Найдет цифры которые заканчиваються на 12345
 print(re.findall(r'12[12345]', '120-121-122-123-124-125-126-127-128-128'))   # -> ['121', '122', '123', '124', '125']

 # Найдет Все Кроме 12345
 print(re.findall(r'12[^12345]', '120-121-122-123-124-125-126-127-128-128'))  # -> ['120', '126', '127', '128', '128']


 -----------------------------------------------------------------------------------------------------------------------

 text = 'Привет как твои дела'

 # Забрать первые 4 символа
 print(re.findall(r'^....', text))   # -> ['Прив']

 # Забрать последние 4 символа
 print(re.findall(r'....$', text))   # -> ['дела']

 # Забрать по 4 символа
 print(re.findall(r'....', text))    # -> ['Прив', 'ет к', 'ак т', 'вои ', 'дела']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт все последовательности Привет и привет в тексте.

 text = 'Привет-привет'

 print(re.findall(r'[Пп]ривет', text))     # -> ['Привет', 'привет']
 print(re.findall(r'(?i)привет', text))    # -> ['Привет', 'привет']
 print(re.findall(r'(?:П|п)ривет', text))  # -> ['Привет', 'привет']


 -----------------------------------------------------------------------------------------------------------------------

 # Запишите его сокращённую версию [12346789]

 text = 'AB0123456789CD'

 print(re.findall(r'[12346789]', text))  # -> ['1', '2', '3', '4', '6', '7', '8', '9']
 print(re.findall(r'[1-46-9]', text))    # -> ['1', '2', '3', '4', '6', '7', '8', '9']
 print(re.findall(r'[^05\D]', text))     # -> ['1', '2', '3', '4', '6', '7', '8', '9']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт все цифры из шестнадцатеричной системы счисления.

 text = '٠١٢٣٤٥٦٧٨٩'

 print(re.findall(r'[\dA-F]', text))   # -> ['٠', '١', '٢', '٣', '٤', '٥', '٦', '٧', '٨', '٩']
 print(re.findall(r'[0-9A-F]', text))  # -> []


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт все кабинеты с трёхзначным номером: 100 - 999.

 text = 'Начальнику второго отделения прибыть в 314 кабинет в понедельник.'

 print(re.findall(r'[1-9][0-9][0-9] кабинет', text))  # -> ['314 кабинет']
 print(re.findall(r'[1-9][0-9]{2} кабинет', text))    # -> ['314 кабинет']

 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт все шестизначные коды подтверждения.

 text = 'VK: 972119 - код для входа на Вашу страницу.'

 print(re.findall(r'[0-9]{6}', text))  # -> ['972119']
 print(re.findall(r'\d{6}', text))     # -> ['972119']

 # Тоже работает                                                                <-----
 print(re.findall(r'\d'*6, text))      # -> ['972119']
 print(re.findall(r'[0-9]'*6, text))   # -> ['972119']


 -----------------------------------------------------------------------------------------------------------------------

 # Состоит из 5 символов кроме перехода на новую строку \n

 text = 'последовательности из 5 символов'

 print(re.findall(r'.....', text))     # -> ['после', 'доват', 'ельно', 'сти и', 'з 5 с', 'имвол']
 print(re.findall(r'.{5}', text))      # -> ['после', 'доват', 'ельно', 'сти и', 'з 5 с', 'имвол']
 print(re.findall(r'[^\n]{5}', text))  # -> ['после', 'доват', 'ельно', 'сти и', 'з 5 с', 'имвол']


 -----------------------------------------------------------------------------------------------------------------------

 # Состоит из 3 букв латинский и кириллический алфавиты верхнего и нижнего регистров Окружена пробелами с двух сторон

 text = 'последовательности из 5 символов что начало нас требуют от нас развития'

 print(re.findall(r'(?i)\s[a-zа-яё]{3}\s', text))  # -> [' что ', ' нас ', ' нас ']
 print(re.findall(r' [^0-9_\W]{3} ', text))        # -> [' что ', ' нас ', ' нас ']

 # Тоже самое но с \b
 print(re.findall(r'(?i)\b[a-zа-яё]{3}\b', text))  # -> [' что ', ' нас ', ' нас ']


 -----------------------------------------------------------------------------------------------------------------------

 # Все последовательности, состоящие из трёх точек: ...

 text = 'Я бежал... Пока мышцы не стало жечь огнем, а кровь не стала едкая, как кислота... И тогда... Я побежал дальше...'

 print(re.findall(r'[.]{3}', text))  # -> ['...', '...', '...', '...']
 print(re.findall(r'\.{3}', text))   # -> ['...', '...', '...', '...']


 -----------------------------------------------------------------------------------------------------------------------

 # Что нужно найти: Последовательности use strict; и use strict

 text = 'strict;use strict;use someSpamuuse stricttещёспам'

 print(re.findall(r'use strict;?', text))      # -> ['use strict;', 'use strict']
 print(re.findall(r'use strict;{0,1}', text))  # -> ['use strict;', 'use strict']

 s = 'use strict'
 print(re.findall(fr'{s};{{0,1}}', text))      # -> ['use strict;', 'use strict']


 -----------------------------------------------------------------------------------------------------------------------

 # Состоит как минимум из 2-ух букв  латинский и кириллический алфавиты верхнего регистра

 text = 'АООТ-акционерное общество открытого типа.ЗАО - закрытое акционерное общество.ОАО-открытое акционерное общество'

 print(re.findall(r'[A-ZА-ЯЁ]{2,}', text))     # -> ['АООТ', 'ЗАО', 'ОАО']

 -----------------------------------------------------------------------------------------------------------------------

 # Нужно найти номерные знаки Но буквы в нижнем регистре        [переменная] - Важно

 text = 'с065мк8 з724ок14 м976мм76 л147ом31 г944ть6 с206рн345'
 print(re.findall(r'\b[авекмнорстух]\d{2,3}[авекмнорстух]{2}\d{2,3}\b', text))     # -> ['м976мм76', 'с206рн345']

 s = 'авекмнорстух'
 print(re.findall(fr'\b[{s}]\d{{2,3}}[{s}]{{2}}\d{{2,3}}\b', text))                # -> ['м976мм76', 'с206рн345']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт все пары координат в тексте: широту и долготу.

 text = 'Песок. Ориентир - красная изолента. Прикоп 2-3см 16.874124 -24.984161'

 print(re.findall(r'\b-?\d{1,3}\.\d+\s-?\d{1,3}\.\d+\b', text))  # -> ['16.874124 -24.984161']

 coord = r"-?\b\d{1,3}\.\d+"
 print(re.findall(fr'{coord} {coord}', text))                   # -> ['16.874124 -24.984161']


 -----------------------------------------------------------------------------------------------------------------------

 # Извлекает протокол полученной ссылки: http или https

 text = 'https://httpsssssssssssss.com/ggtps/hhttps/'

 print(re.findall(r'\bhttps?\b', text))     # -> ['https']
 print(re.findall(r'(https?)://', text))    # -> ['https']  # Такое решение лучше
 print(re.findall(r'https?(?=://)', text))  # -> ['https']  # Такое решение лучше


 -----------------------------------------------------------------------------------------------------------------------

 # Нужно найти последовательности, состоящие из римских цифр: IVXLCDM.

 text = 'В MMXIII году в школе CXXIII состоялся очередной выпуск XI классов.'

 print(re.findall(r'[IVXLCDM]+', text))         # -> ['MMXIII', 'CXXIII', 'XI']
 print(re.findall(r'\b[IVXLCDM]{1,}\b', text))  # -> ['MMXIII', 'CXXIII', 'XI']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт все смайлики в тексте.                                               Внимательно посмотри на  -  [переменная]

 text = r'¦I734m8/тшAFТ¦0dtoю6:OQЮРе:|Yщ:/СЬmfK8/VбcКг:/0Цf=|НЫ9s8\uhУ:^^|'

 print(re.findall(r'[:8;¦=][\^-]?[|\\0()/PODIC]', text))  # -> ['¦I', '8/', '¦0', ':O', ':|', ':/', '8/', ':/', '=|', '8\\']

 eyes = re.escape(r':8;¦=')
 nose = re.escape(r'^-')
 mouth = re.escape(r'|\0()/PODIC')
 print(re.findall(fr'[{eyes}][{nose}]?[{mouth}]', text))  # -> ['¦I', '8/', '¦0', ':O', ':|', ':/', '8/', ':/', '=|', '8\\']


 --------------------------------------    Жадные и Ленивые Квантификаторы  Пример   -----------------------------------

 text = r'0123456789'

 # Ищет максимально возможные последовательности
 print(re.findall(r'\d{2,7}', text))   # -> ['0123456', '789']
 # Ищет минимально возможные последовательности
 print(re.findall(r'\d{2,7}?', text))  # -> ['01', '23', '45', '67', '89']

 # Разницы НЕТ  Тоже самое
 print(re.findall(r'\d{5}', text))   # -> ['01234', '56789']
 print(re.findall(r'\d{5}?', text))  # -> ['01234', '56789']

 # findall()
 print(re.findall(r'\d*', text))   # -> ['0123456789', '']
 print(re.findall(r'\d*?', text))  # -> ['', '0', '', '1', '', '2', '', '3', '', '4', '', '5', '', '6', '', '7', '', '8', '', '9', '']

 print(re.findall(r'\d+', text))   # -> ['0123456789']
 print(re.findall(r'\d+?', text))  # -> ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

 print(re.findall(r'\d?', text))   # -> ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '']
 print(re.findall(r'\d??', text))  # -> ['', '0', '', '1', '', '2', '', '3', '', '4', '', '5', '', '6', '', '7', '', '8', '', '9', '']


 # search()
 print(re.search(r'\d*', text).group())   # -> 0123456789
 print(re.search(r'\d*?', text)[0])       # -> ''          # Ничего не нашел

 print(re.search(r'\d+', text).group())   # -> 0123456789
 print(re.search(r'\d+?', text)[0])  # -> 0

 print(re.search(r'\d?', text).group())   # -> 0
 print(re.search(r'\d??', text)[0])  # -> ''              # Ничего не нашел


 -----------------------------------------------------------------------------------------------------------------------

 # Разделит число из тестовых данных на числа, в конце которых стоит единица. 1

 text = r'17383147371'

 print(re.findall(r'\d*?1', text))   # -> ['1', '73831', '47371']
 print(re.findall(r'\d*1', text))    # -> ['17383147371']          Без ?


 -----------------------------------------------------------------------------------------------------------------------

 # Все чётные числа с минимально возможной длиной.

 text = r'7754894135199344455'

 print(re.findall(r'\d*?[02468]', text))      # -> ['7754', '8', '94', '13519934', '4', '4']
 print(re.findall(r'[13579]*[02468]', text))  # -> ['7754', '8', '94', '13519934', '4', '4']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт все квадратные скобки и их содержимое.

 text = r'[][1][12] [123][1234][12345] [123456]'

 print(re.findall(r'\[.*?\]', text))  # -> ['[]', '[1]', '[12]', '[123]', '[1234]', '[12345]', '[123456]']
 print(re.findall(r'\[.*?]', text))   # -> ['[]', '[1]', '[12]', '[123]', '[1234]', '[12345]', '[123456]']


 --------------------------------------    Хороший пример производительности и разница    ------------------------------

 # Начинается на букву и заканчивается буквой.

 text = r'RFB 9W90rb9-4br9-wB9-DFWHE'

 print(re.findall(r'(?i)[a-zа-яё].*?[a-zа-яё]+?', text))  # -> ['RF', 'B 9W', 'rb', 'br', 'wB', 'DF', 'WH']
 print(re.findall(r'[^_\d\W].*?[^_\d\W]', text))          # -> ['RF', 'B 9W', 'rb', 'br', 'wB', 'DF', 'WH']

 # Обратить Внимание на переменную [] - при создании
 letter = r'[a-zA-Zа-яА-ЯЁё]'
 print(re.findall(rf'{letter}.*?{letter}', text))         # -> ['RF', 'B 9W', 'rb', 'br', 'wB', 'DF', 'WH']

 #  интересно с точки зрения оптимальности, что лучше [^\d\W_] или [a-zA-Zа-яА-ЯЁё]  ?
 # [a-zA-Zа-яА-ЯЁё] - быстрее где-то на 30%  +/-
 # [^\d\W_]         - Будет работать и с другими Языками


 # Хороший пример С Немецким алфавитом !
 text = r'Ö1234Ü'

 print(re.findall(r'[a-zA-Zа-яА-ЯЁё].*?[a-zA-Zа-яА-ЯЁё]+?', text))  # -> []           Не Находит
 print(re.findall(r'[^_\d\W].*?[^_\d\W]', text))                    # -> ['Ö1234Ü']


 --------------------------------------    Разбор групп    -------------------------------------------------------------

 text = r'010101234'

 print(re.findall(r'(\d{2})', text))          # -> ['01', '01', '01', '23']  # Обычная    Группа
 print(re.findall(r'(?P<test>\d{2})', text))  # -> ['01', '01', '01', '23']  # Именовання Группа

 # Обьяснение работы обращения к группам
 print(re.search(r'(\d{2})\1', text).group())                 # -> 0101
 print(re.search(r'(?P<test>\d{2})(?P=test)', text).group())  # -> 0101


 # \number (?P=name) Находят тоже самое что ищем мы!
 text = r'1133333311'

 print(re.search(r'(\d{3})\1', text).group())                 # -> 333333
 print(re.search(r'(?P<test>\d{3})(?P=test)', text).group())  # -> 333333


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт все повторяющиеся последовательности из трёх цифр

 text = r'696696'

 # findall() Показывает только группу!
 print(re.findall(r'(\d{3})\1', text))                  # -> ['696']  # Обычная    Группа
 print(re.findall(r'(?P<name>\d{3})(?P=name)', text))   # -> ['696']  # Именовання Группа

 # search()
 print(re.search(r'(\d{3})\1', text)[0])                 # -> 696696  # Обычная    Группа
 print(re.search(r'(?P<name>\d{3})(?P=name)', text)[0])  # -> 696696  # Именовання Группа


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт все слова и словосочетания, состоящие из двух одинаковых частей  Разделитель дефис -

 text = r'йо-йо балалайка гиппопотам чуть-чуть мама папа дядя мимикрия татарин кокос довод'

 # findall() Показывает только группу!
 print(re.findall(r'\b([а-я]+)-?\1\b', text))                  # -> ['йо', 'чуть', 'ма', 'па', 'дя']
 print(re.findall(r'\b(?P<name>[а-я]+)-?(?P=name)\b', text))   # -> ['йо', 'чуть', 'ма', 'па', 'дя']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт найдёт все повторяющиеся буквы в тексте.

 text = r'gg wp'

 # findall() Показывает только группу!
 print(re.findall(r'([а-яёa-z])\1', text, flags=re.IGNORECASE))  # -> ['g']
 print(re.findall(r'(?i)(?P<name>[а-яёa-z])(?P=name)', text))    # -> ['g']

 # Интересный вывод
 print(re.search(r'([а-яёa-z])\1', text).group(), re.I)        # -> gg re.IGNORECASE
 print(re.search(r'([A-Za-zА-яёЁ])\1', text).group())          # -> gg                   Без флага re.IGNORECASE


 --------------------------------------    Условие (?(n)yes|no)    -----------------------------------------------------

 # Найдёт все последовательности if и <if>, но не <if и if>, стоящие между началом и концом строки.

 text = r'<if>'

 # Если находим < то ищем if> или ищем if
 print(re.search(r"^(<)?(?(1)if>|if)$", text)[0])  # -> <if>

 # Если находим <if то ищем > или ищем if
 print(re.search(r"^(<if)?(?(1)>|if)$", text)[0])             # -> <if>
 print(re.search(r"^(?P<name><)?(?(name)if>|if)$", text)[0])  # -> <if>

 # Решения с разными тестовыми данными

 print(re.search(r"^(if|<if>)$", '<if>'))                    # -> <re.Match object; span=(0, 4), match='<if>'>
 print(re.search(r"^(if|<if>)$", 'if'))                      # -> <re.Match object; span=(0, 2), match='if'>
 print(re.search(r"^(if|<if>)$", '<if'))                     # -> None
 print(re.search(r"^(if|<if>)$", 'if>'))                     # -> None
 print(re.search(r"^(if|<if>)$", 'if>if><if<><>>if<'))       # -> None

 # Тоже самое   Условие в регулярках if...else
 print(re.search(r"^(<)?(?(1)if>|if)$", '<if>'))             # -> <re.Match object; span=(0, 4), match='<if>'>  ()
 print(re.search(r"^(?P<name><)?(?(name)if>|if)$", '<if>'))  # -> <re.Match object; span=(0, 4), match='<if>'>  (?P<name>)

 # Тоже самое но findall выводит другое
 print(re.findall(r"^(<)?(?(1)if>|if)$", '<if>'))  # -> ['<']                   1    - это Нумерованная группа
 print(re.findall(r"^(?P<name><)?(?(name)if>|if)$", '<if>'))  # -> ['<']        name - это Именованная группа

 res = re.finditer(r"^(if|<if>)$", '<if>')
 print([i.group() for i in res])                # -> ['<if>']


 --------------------------------------    Positive Lookbehind   Positive Lookahead    ---------------------------------

 # Последовательность из любых символов от [^START] до {(END.)}   Слева [^START] Внутри Любые символы Справа {(END.)}

 text = r'[^START]Text{(END.)}'

 re.findall(r'(?<=\[\^START\]).*(?=\{\(END\.\)})', text)  # -> ['Text']   # Positive Lookbehind   Positive Lookahead


 # Очень крутые ответы Посмотри    fr''    escape                                         <-----  <-----  <-----

 text = r'[^START]Text{(END.)}'

 start, end = re.escape('[^START]'), re.escape('{(END.)}')
 regex = fr'(?<={start}).*(?={end})'
 re.findall(regex, text)                                  # -> ['Text']

 # Тоже самое
 regex = fr"(?<={re.escape('[^START]')})[\w ]*(?={re.escape('{(END.)}')})"
 re.findall(regex, text)                                  # -> ['Text']


 --------------------------------------    Negative Lookbehind   Negative Lookahead    ---------------------------------

 # Найдёт все символы /   слева и справа не стоит /      Слеш-одиночка

 text = r'/text/'

 re.findall(r'(?<!/)/(?!/)', text)  # -> ['/', '/']     # Negative Lookbehind   Negative Lookahead


 --------------------------------------    Несколько Lookahead  или Lookbehind  друг за другом    ----------------------

 # Начинается на заглавную букву. Последовательность не стоит в начале предложения. Перед ней не стоит: .!?

 text = r'Неправильно ты, дядя Фёдор, бутерброд ешь.'

 # В условиях можно указывать даже спец символы
 print(re.findall(r'(?<!^)(?<!\. )[А-ЯЁ][а-яё]*', text))       # -> ['Фёдор']
 print(re.findall(r'(?<!\A)(?<![.?!]\s)[А-ЯЁ][а-яё]+', text))  # -> ['Фёдор']


 -----------------------------------------------------------------------------------------------------------------------

 # Все последовательности x с чётной длиной.

 text = r'x xx xxx xxxx xxxxx xxxxxx xxxxxxx xxxxxxxx xxxxxxxxx xxxxxxxxxx xxxxxxxxxxx xxxxxxxxxxxx xxxxxxxxxxxxx'

 print(re.findall(r'\b(?:xx)+\b', text))  # -> ['xx', 'xxxx', 'xxxxxx', 'xxxxxxxx', 'xxxxxxxxxx', 'xxxxxxxxxxxx']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт все НЕотрицательные числа.

 text = r'4902 84234-32 3129 -1 -3 -1 3-1 31-3 12 391 -319-31-3-12-3912390193-4'

 re.findall(r'(?<![\-\d])\d+', text)  # -> ['4902', '84234', '3129', '3', '31', '12', '391']
 re.findall(r'\b(?<!-)[0-9]+', text)  # -> ['4902', '84234', '3129', '3', '31', '12', '391']
 re.findall(r'(?<!\S)\d+', text)      # -> ['4902', '84234', '3129', '3', '31', '12', '391']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт все отрицательные числа.

 text = r'4902 84234-32 3129 -1 -3 -1 3-1 31-3 12 391 -319-31-3-12-3912390193-4'

 re.findall(r'(?<!^\d)-\d+', text) # -> ['-32', '-1', '-3', '-1', '-1', '-3', '-319', '-31', '-3', '-12', '-3912390193', '-4']
 re.findall(r'-\d+', text)         # -> ['-32', '-1', '-3', '-1', '-1', '-3', '-319', '-31', '-3', '-12', '-3912390193', '-4']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдите все слова да, нет, наверное в тексте. Они могут начинаться с букв разных регистров.

 text = r'«Да нет наверное» - фраза непонятная многим иностранцам. Это означает как бы "нет",'

 print(re.findall(r'\b([дД]а|[нН]ет|[нН]аверное)\b', text))    # -> ['Да', 'нет', 'наверное', 'нет']

 # Повторюсь  findall() показывает группы если мы их не убрали (?:...)
 print(re.findall(r'\b([Дд]а|[Нн](ет|аверное))\b', text))      # -> [('Да', ''), ('нет', 'ет'), ('наверное', 'аверное'), ('нет', 'ет')]
 print(re.findall(r'\b(?:[Дд]а|[Нн](?:ет|аверное))\b', text))  # -> ['Да', 'нет', 'наверное', 'нет']


 -----------------------------------------------------------------------------------------------------------------------

 # Начинается с (1, или 3, или bc1) Потом Весь латинский алфавит, кроме: O, I, l. Все цифры, кроме 0. длина от 27 до 34

 text = r'39Bett9aVjBtgLHkPL1Zv5P3kxtbVHiQqa 3Qbn5xTVuHDMtTGwkpgsjLrVMBecmobnNh'

 print(re.findall(r'\b(1|3|bc1)[1-9a-km-zA-HJ-NP-Z]{27,34}\b', text))    # -> ['3', '3']   Обычная группа   (...)
 print(re.findall(r'\b(?:1|3|bc1)[1-9a-km-zA-HJ-NP-Z]{27,34}\b', text))  #             Группы Без захвата   (?:...)
 # -> ['39Bett9aVjBtgLHkPL1Zv5P3kxtbVHiQqa', '3Qbn5xTVuHDMtTGwkpgsjLrVMBecmobnNh']


 # Обьяснение ниже как работает
 print(re.findall(r'\b(?:1|3|bc1)(?:(?![OIl0])[a-zA-Z\d]){27,34}\b', text))  # Интересное решение
 # -> ['39Bett9aVjBtgLHkPL1Zv5P3kxtbVHiQqa', '3Qbn5xTVuHDMtTGwkpgsjLrVMBecmobnNh']

 # расположение условия слева от квадратных скобок указывает на то, что оно применяется и к более ранней части выражения,
 то есть к (?:1|3|bc1). Если расположить негативную проверку справа от скобок, то регулярка начнёт захватывать
 последовательности, в которых сразу после (?:1|3|bc1) идёт один из запрещённых символов.


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт в тексте: Привет, Олег или Привет, Григорий  или Пока, Олег или Пока, Григорий:

 text = r'ЩЩВАРЩЫАРЩЫВППривет, Олегвщыврцыра9ц909ав'

 print(re.findall(r'(Привет|Пока), (Олег|Григорий)', text))         # -> [('Привет', 'Олег')]
 print(re.findall(r'(?:П)(?:ока|ривет), (?:Олег|Григорий)', text))  # -> ['Привет, Олег']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт в тексте: я готов, я готова, ты готов, ты готова, он готов, она готова, мы готовы, вы готовы, они готовы

 text = r'я готова я готов ты готова ты готов'

 print(re.findall(r'\b(?:(?:я|ты|он) готов|(?:я|ты|она) готова|(?:мы|вы|они) готовы)\b', text))
 # -> ['я готова', 'я готов', 'ты готова', 'ты готов']

 print(re.findall(r'((мы|вы|они)|(я|ты)|(она)|(он)) готов(?(2)ы|(?(3)а?|(?(4)а|)))\b', text))
 # -> [('я', '', 'я', '', ''), ('я', '', 'я', '', ''), ('ты', '', 'ты', '', ''), ('ты', '', 'ты', '', '')]

 # Классный варинт ЧИТАЕМЫЙ
 pat1 = r'\b(?:я|ты|она)\b \bготова\b'
 pat2 = r'\b(?:я|ты|он)\b \bготов\b'
 pat3 = r'\b(?:мы|вы|они)\b \bготовы\b'

 regex = fr'{pat1}|{pat2}|{pat3}'
 print(re.findall(regex, text))  # -> ['я готова', 'я готов', 'ты готова', 'ты готов']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдите трёхзначные номера, перед которыми идёт №, Номер, или Number.

 text = r'№ 123 893 Номер 983 432 Number 948 481'

 print(re.findall(r'((?<=№ )\d+)|((?<=Номер )\d+)|((?<=Number )\d+)', text))  # -> [('123', '', ''), ('', '983', ''), ('', '', '948')]
 print(re.findall(r'(?:(?<=№ )|(?<=Номер )|(?<=Number ))\d{3}', text))        # -> ['123', '983', '948']
 print(re.findall(r'(?:(?<=№ )|(?<=Number )|(?<=Номер ))\d{3}', text))        # -> ['123', '983', '948']


 --------------    "в lookbehind можно использовать |, только если все шаблоны одинаковой длины"      ------------------

 text = r'№ 123 893 Номер 983 432 Number 948 481'
 # Ошибка  re.error: look-behind requires fixed-width pattern

 print(re.findall(r'(?<=(№|Номер|Number)\s)\d{3}', text))  # -> re.error: look-behind requires fixed-width pattern
 print(re.findall(r'(?:№|Н|N) (\d{3})', text))  # -> ['123']


 text = r'№ 123 893 Н 983 432 N 948 481'
 # Вот без Ошибки Но только если длина одинаковая и текст изменил
 print(re.findall(r'(?:№|Н|N) (\d{3})', text))  # -> ['123', '983', '948']

 -----------------------------------------------------------------------------------------------------------------------

 # Валидация hex-цветов

 text = r'#DC143C #00FA9A #00BFFF #FF00FF #EEE8A #FF #FFD7 #940 #483D8 #pressF ##00FFAA'

 print(re.findall(r'(?i)#[0-9a-f]{6}', text))                      # -> ['#DC143C', '#00FA9A', '#00BFFF', '#FF00FF', '#00FFAA']
 # Правильно обрабатывает тест вида ##00FFAA  Вопрос нужно тут экранировать /#
 print(re.findall(r'(?:(?<=^)|(?<=\s))\#[0-9a-fA-F]{6}\b', text))  # -> ['#DC143C', '#00FA9A', '#00BFFF', '#FF00FF']
 # Без экранирования \# такой же вывод
 print(re.findall(r'(?:(?<=^)|(?<=\s))#[0-9a-fA-F]{6}\b', text))   # -> ['#DC143C', '#00FA9A', '#00BFFF', '#FF00FF']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт все слова, содержащие в себе букву а.

 text = r'Равным образом постоянный количественный'

 print(re.findall(r'(?i)\b[а-яё]*а[а-яё]*\b', text))                   # -> ['Равным', 'образом']
 print(re.findall(r'(?<!\d|_)[а-яёА-ЯЁ]*а[а-яёА-ЯЁ]*(?!\d|_)', text))  # -> ['Равным', 'образом']
 print(re.findall(r'[А-Яа-яЁё]*(?=а)[А-Яа-яЁё]*\b', text))             # -> ['Равным', 'образом']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт слова, после которых следующим символом идёт один из следующих знаков препинания: .,:?!;

 text = r'Эй, Эх, Богдан, Богом дан Богдан, Богом дан, е Я Богдан, я Богом дан, меня Бог дал Я Богдан, я Богом дан'

 print(re.findall(r'\w+(?=[.,:?!;])', text))          # -> ['Эй', 'Эх', 'Богдан', 'Богдан', 'дан', 'Богдан', 'дан', 'Богдан']
 print(re.findall(r'[а-яА-ЯёЁ]+(?=[.,:?!;])', text))  # -> ['Эй', 'Эх', 'Богдан', 'Богдан', 'дан', 'Богдан', 'дан', 'Богдан']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт первое слово в тексте.   В последовательности может содержаться дефис

 text = r'Привет. Я подсяду? Спасибо.'

 print(re.findall(r'(?i)\A([а-я]*)-?([а-я]*)', text))  # -> [('Привет', '')]
 print(re.findall(r'\A[А-Яа-яЁё-]+', text))            # -> ['Привет']
 print(re.findall(r'^[а-яА-ЯёЁ]+[^\s]\w*\b', text))    # -> ['Привет']


 -----------------------------------------------------------------------------------------------------------------------

 # Нужно найти переменные, записаные в стиле lowerCamelCase

 text = r'just_a_variable Wrong_Variable SendNudes doubleShibaInu '

 print(re.findall(r'\b[a-z]+[A-Z]*[a-z]*[A-Z]*[a-z]*\d*\b', text))  # -> ['doubleShibaInu']
 print(re.findall(r'\b[a-z]+(?:[A-Z][a-z]+)*\d*\b', text))          # -> ['doubleShibaInu']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт все переменные, записанные в стиле snake_case

 text = r'get_id sendMessage echo_all canvas wrapper RegularExpression upperCAse nice_Flick_SHOT that_was_bad '

 print(re.findall(r'\b[a-z]+_?\d*[a-z]*_?[a-z]*\d*\b', text))  # -> ['get_id', 'echo_all', 'canvas', 'wrapper', 'that_was_bad']
 print(re.findall(r'\b[a-z]+_*[a-z_]*\d*\b', text))            # -> ['get_id', 'echo_all', 'canvas', 'wrapper', 'that_was_bad']


 -----------------------------------------------------------------------------------------------------------------------

 # Используются символы a-z, A-Z, 0-9, _ Длина от 5 до 32  Не начинаться с цифры или _ Не заканчиваться на _

 text = r'i0i#r ⇒ kigd@2 ⇒ taaphli-octoandri ⇒ crypticfrоg ⇒ тест ⇒ suDhAsa010'

 print(re.findall(r'(?<!\S)\b[a-zA-Z_0-9]{5,32}\b(?!\S)', text))                    # -> ['suDhAsa010']
 print(re.findall(r'(?<!\S)[a-zA-Z][a-zA-Z0-9_]{3,30}[a-zA-Z0-9](?!\S)', text))     # -> ['suDhAsa010']

 # Может быть Кириллица [а-яА-ЯёЁ] или другие в перемешку с Латиница [a-zA-Z] если используем \w
 print(re.findall(r'(?<!\S)\w{3,30}[a-zA-Z0-9](?!\S)', text))                       # ->['crypticfrоg', 'suDhAsa010']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдите все валидные пустые массивы, или массивы с числами.

 text = r'[123, 123, ] [23, ] [, 123, 123][, ][,324][2022 2022][1 2 3 4]'

 print(re.findall(r'\[(?:\d|\d,|\d+,+\s*)*?\]', text))     # -> ['[123, 123, ]', '[23, ]']
 print(re.findall(r'\[(?:(?:\d+, ?)*(?:\d+)?)?\]', text))  # -> ['[123, 123, ]', '[23, ]']
 print(re.findall(r'\[(?:\d+(?:,|, )?)*\]', text))         # -> ['[123, 123, ]', '[23, ]']


 -----------------------------------------------------------------------------------------------------------------------

 # Найдёт Перед последовательностью стоит v=

 text = r'https://www.youtube.com/watch?v=abcdefghABCDEFGH'

 re.findall(r'(?<=v=)\w+', text)  # -> ['abcdefghABCDEFGH']


 -----------------------------------------------------------------------------------------------------------------------

 #  Нужно найти первый попавшийся ключ в виде:  Activation key: XXXXX-XXXXX-XXXXX-XXXXX-XXXXX

 lst = ['Hi', 'Here is my Activation key: PKRHK-6622Q-T49PV-CC3PX-TRX2Y', 'Bye', 'Test', 'Lmao', ]

 import re

 for i in lst:
     res = re.search(r'(?<=Activation key: )([A-Z\d]{5}-){4}([A-Z\d]){5}', i)
     if res:
         print(res[0])
 # -> PKRHK-6622Q-T49PV-CC3PX-TRX2Y

 # Или через ввод пользователя и морж :=
 import re, sys

 for line in sys.stdin:
     if key := re.search(r'Activation key: (([A-Z\d]{5}-){4}[A-Z\d]{5})', line):
         print(key.group(1))


 -----------------------------------------------------------------------------------------------------------------------

 # Нужно получить ключ t и его значение.  t=

 text = '{"errorCode":909,"logStatus":null,;t=0.5555+112321"}'

 print(re.search(r't=.*(?="\})', text)[0])        # -> t=0.5555+112321
 print(re.search('t=[0-9.+]+', input()).group())  # Ввод пользователя # input()


 -----------------------------------------------------------------------------------------------------------------------

 # Нужно вывести: Первое слово в предложении: word, где word - найденное слово.

 text = 'My car is the fastest!'

 word = re.match(r'([a-z])+', text, flags=re.IGNORECASE)
 print(fr'Первое слово в предложении: {word.group()}' if word else '')  # -> Первое слово в предложении: My

 # Тоже самое с моржом :=
 if word := re.match(r'[a-zA-Z]+\b', text):
     print(fr'Первое слово в предложении: {word[0]}')                   # -> Первое слово в предложении: My


 -----------------------------------------------------------------------------------------------------------------------

 # Найти последовательность из 12, 18 или 24 случайных слов нижнего регистра

 text = 'theme primary opinion edit dragon maid boil ankle link shield erupt melody'

 if word := re.match(r'([a-z]+[^,\d]\s?){12,}', text):
 # if word := re.match(r'([a-z]+ ){11}[a-z]+\b', text):  # Тоже самое
     print(fr'{word[0]}')  # -> theme primary opinion edit dragon maid boil ankle link shield erupt melody


 -----------------------------------------------------------------------------------------------------------------------

 # Нужно доставать все символы до @ в почтовых адресах.

 text = 'example@gmail.com'

 if word := re.match(r'.*(?=@)', text):             if word := re.match(r'(\w+)@', text):
     print(fr'{word.group()}')  # -> example            print(fr'{word.group(1)}')  # -> example


 -----------------------------------------------------------------------------------------------------------------------

 # Найдите все последовательности цифр, которые начинаются от 13 цифр включительно.

 text = '1234567891011121'

 print(True if re.fullmatch(r'\d{13,}', text) else False)  # -> True
 print(bool(re.fullmatch(r'\d{13,}', text)))               # -> True  # Более ПРАВИЛЬНЫЙ Вариант


 -----------------------------------------------------------------------------------------------------------------------

 # Проверить пароль на валидность Состоит из a-z, A-Z, 0-9, @#$%^&*()_-+!?  длина минимум 8 символов

 text = 'g0JDQ0#(dka02b vp!'

 shielding = re.escape(r'@#$%^&*()_-+!?')  # Вводим нужные символы для Экранирования
 print(shielding)                          # -> @\#\$%\^\&\*\(\)_\-\+!\?

 print(bool(re.fullmatch(rf'[a-zA-Z0-9{shielding}]{{8,}}', text)))            # -> False
 print(bool(re.fullmatch(r'\S{8,}', text)))                                   # -> False
 print(bool(re.fullmatch(r'[a-zA-Z0-9@\#\$%\^\&\*\(\)_\-\+!\?]{8,}', text)))  # -> False  # Лучше использовать  escape()


 -----------------------------------------------------------------------------------------------------------------------

 # Это точно номер? начинаться с + минимум 11 цифр Между цифрами могут быть разделители: ( )- Длина разделителя от 0 до 2

 text = '+688 893 512 92 14'

 print(bool(re.fullmatch(r'\+?(\d([\s\(\)-]{,2})?){11,}', text)))  # -> True
 print(bool(re.fullmatch(r'\+?(\d[()\s-]{0,2}){11,}', text)))      # -> True


 -----------------------------------------------------------------------------------------------------------------------


 # Хочешь попробуй решить ИНТЕРЕСНУЮ задачу

 # Что нужно сделать:
 # Найдите все последовательности, которые могут быть многочленами. Многочлен состоит из слагаемых.
 # Каждое слагаемое это следующее произведение:

 # Первым множителем может быть целое число (любая последовательность цифр)
 # Числа могут быть отрицательными
 # Вторым множителем может быть x
 # x может быть возведён в любую степень (любая последовательность цифр)
 # Между множителями ничего не стоит
 # в произведении может не быть одного из множителей
 # x не всегда возведен в какую-либо степень
 # Между слагаемыми стоит - или +.

 # Тестовые данные
 lst_true = ['x^3-11x^2+38x-40', '6x^4+19x^3-7x^2-26x+12', '15x^5-8x^4+46x^3+21x^2-21x+3',
            '4x^6+9x^5-x^4+22x^3-x^2+9x-18', '6x^4+x^3+2x^2-4x+1', 'x', '5x+2',  '-x',  'x^2-x',  '-9', True]

 lst_false = ['-x9', 'x792x', 'xx', '--34', 'x^3+14^x', '-^10', False]

 text = r'15x^5-8x^4+46x^3+21x^2-21x+3'

 # Вот решение ЛЕГКОЙ задачи    not not  посмотри в print
 result = re.fullmatch(r'(-?\d*(?:x\^\d+|x)?\+?\b)+', text)
 print(not not result)  # -> True                                <-----   <-----    <-----   not not

 # Тоже самое
 print(bool(re.fullmatch(r'([-+]?\d*x?(\^\d)?\b)*', text)))  # -> True

 # Еще лучше!
 num = r'-?([1-9]\d?)'
 x = r'-?(x\^[1-9]|x)'
 print(bool(re.fullmatch(fr'({num}{x}?|{num}?{x})([+-]({num}{x}?|{num}?{x}))*', text)))


 -----------------------------------------------------------------------------------------------------------------------

 re.finditer() - Возвращает Итератор Match объектов   Все вхождения!

 pattern = r'\d{3}'
 text = 'abc 123 def 456 fed 321 cba'

 result = re.finditer(pattern, text, 0)

 for i in result:                                        for i in result:
     print(i)                                                print(i[0])    # i[0]

 # -> <re.Match object; span=(4, 7), match='123'>        # -> 123
 # -> <re.Match object; span=(12, 15), match='456'>      # -> 456
 # -> <re.Match object; span=(20, 23), match='321'>      # -> 321


 -----------------------------------------------------------------------------------------------------------------------

 # Пятибуквенные слова Длина - 5 букв Не является подпоследовательностью [A-Za-zА-ЯЁа-яё]  лат/кир алфавит обоих регистров

 text = 'Мы вынуждены отталкиваться от того, что разбавленное изрядной долей эмпатии, рациональное мышление способствует'

 result = re.finditer(r'\b[а-яёa-z]{5}\b', text, flags=re.IGNORECASE)
 for i in result:
     print(i[0], end=' ')                          # -> долей
     print(i, end=' ')                             # -> <re.Match object; span=(62, 67), match='долей'>

 # Тоже самое
 print(*(re.finditer(r''\b[^\W\d_]{5}\b'', text)))  # -> <re.Match object; span=(62, 67), match='долей'>


 -----------------------------------------------------------------------------------------------------------------------

 # Получите все числовые значения, после которых идёт знак ₽

 text = r'<div class="col-md-2 col-xs-9 _right mono-num">74,9990 ₽<td>81,2239&nbsp;₽</td>'

 print(*[i[0] for i in re.finditer(r'[\d,]+\s₽', text)])        # -> 74,9990 ₽
 print(*[i[0] for i in re.finditer(r'\d+(?:,\d+)? ₽', text)])   # -> 74,9990 ₽


 -----------------------------------------------------------------------------------------------------------------------

 # Нужно вывести все электронные почты, которые есть в тексте.

 text = "test mihryutkamihryutka1@gmail.com serginio1963@gmail.ru"

 print(*re.findall(r'([\w-]+@[a-z\d]+\.(?:com|ru))', text), sep='       ')                           # Тоже самое
 print(*re.findall(r'\b[a-zA-Z0-9-_]+@[a-zA-Z0-9-_]+\.[a-zA-Z0-9]{1,3}\b', text), sep='       ')     # Тоже самое
 # -> mihryutkamihryutka1@gmail.com       serginio1963@gmail.ru


 -----------------------------------------------------------------------------------------------------------------------

 # Найдите все даты в тексте. Форматы дат:   nn/nn/nnnn     nnnn/nn/nn     nn.nn.nnnn     nnnn.nn.nn

 text = "02.11.2072fs2012,09/18fsdg18/09/2012d2022.20.23d2014,25,03f25\03\1864g2015.24.06f2008.24.10"

 for i in re.findall(r'((\d{2}[./]\d{2}[./]\d{4})|(\d{4}[./]\d{2}[./]\d{2}))', text):
     print(i[0], end='  ')                               # -> 02.11.2072  18/09/2012  2022.20.23  2015.24.06  2008.24.10

 # Тоже самое
 data1 = '(?:(?:\d{2}/){2}\d{4})|(?:\d{4}/\d{2}/\d{2})'
 data2 = '(?:(?:\d{2}[.]){2}\d{4})|(?:\d{4}[.]\d{2}[.]\d{2})'

 print(*re.findall(rf'{data1}|{data2}', text), sep='  ') # -> 02.11.2072  18/09/2012  2022.20.23  2015.24.06  2008.24.10


 -----------------------------------------------------------------------------------------------------------------------

 # МОЯ ЛЮБИМАЯ ЗАДАЧА  Часы от 0 до 23 Потом идёт : Минуты от 0 до 59           <------     <------

 # Вывести 24:00 время

 text = "13:79 24:33 02:60 03:81 23:59 28:64 46:50 14:39 91:19 13:35 02:57 10:10 00:00 59:59 15:51"

 # Разные варинты посмотри все Обрати внимание на диапазоны!  [0-5]  [012345]

 for i in re.findall(r'(?:[01][0-9]:[0-5][0-9])|(?:2[0-3]:[0-5][0-9])', text):
     print(i, end='   ')                       # -> 23:59   14:39   13:35   02:57   10:10   00:00   15:51

 for i in re.findall(r'(?:00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|20|21|22|23):[0-5][0-9]', text):
     print(i, end='   ')                       # -> 23:59   14:39   13:35   02:57   10:10   00:00   15:51

 for i in re.findall(r'([01]\d:[0-5]\d)|(2[0-3]:[0-5]\d)', text):
     print(i[0] if i[0] else i[1], end='   ')  # -> 23:59   14:39   13:35   02:57   10:10   00:00   15:51

 [print(i, end='   ') for i in re.findall(r'(?:(?:[01][\d])|(?:2[0-3])):[0-5][\d]', text)]
 # ->  23:59   14:39   13:35   02:57   10:10   00:00   15:51


 -----------------------------------------------------------------------------------------------------------------------

 # Выведите все ссылки, которые находятся в тегах a!    Очень тяжело было!      <------     <------

 text = '<a target="_blank" href="https:/stepik.org/">Hyperlink</a>'

 for i in re.findall(r'<a.*?href="(.+?)"', text):
     print(i)                                       # -> https:/stepik.org/

 match = re.findall(r"<a.+?href=\"(.+?)\"", text)
 print(*match)                                      # -> https:/stepik.org/

 data = re.findall(r'<a.*</a>', text)
 print(*re.findall(r'(?<=href=").*?(?=")', *data))   # -> https:/stepik.org/


 -----------------------------------------------------------------------------------------------------------------------

 # Сделал 2 группы и выводит по очереди. Обьяснение ниже

 for i in re.findall(r'<a.*(href=")(.*?)"', text):
    print(i)                       # -> ('href="', 'https:/stepik.org/')

 просто скобки - это группы, в этом случае только они идут в вывод(по очереди). Например, если бы строка была бы
 "_12344АБ12112_" и шаблон r".*(А)(Б).*", в ответе было бы ("A", "B")


 -----------------------------------------------------------------------------------------------------------------------

 # Разделите текст на предложения. Делите по знакам препинания .?!.

 text = 'Привет, как твои дела? Привет, нормально, учу регулярные выражения.'

 print(re.split(r'[.?!]', text))  # -> ['Привет, как твои дела', ' Привет, нормально, учу регулярные выражения', '']


 -----------------------------------------------------------------------------------------------------------------------

 # Нужно разделить текст на слова по следующим символам: .?!, .

 text = 'Привет, как твои дела? Привет, нормально, учу регулярные выражения.'

 print(re.split(r'[.?!,\s]', text))
 # -> ['Привет', '', 'как', 'твои', 'дела', '', 'Привет', '', 'нормально', '', 'учу', 'регулярные', 'выражения', '']


 -----------------------------------------------------------------------------------------------------------------------

 # Разделите текст по категориям Начинается с Категория: Потом идёт [а-яА-Я\s]+ Заканчивается на \n

 text = ('Категория: Телефоны\nSupreme Burner\nMotorola Razr\nКатегория: Смарт часы и браслеты\nApple Watch 6\nGarmin'
         ' Venu\nXiaomi Mi Smart Band 6\nКатегория: Игры\nSpore')

 re.split(r'Категория:\s[а-я\s]+\\n', text, flags=re.IGNORECASE)


 -----------------------------------------------------------------------------------------------------------------------

 # И снова Вопрос про re.IGNORECASE    (?i) всегда работает а re.I не всегда           <-----
 # Замените все гласные на восклицательный знак.  Нужно удалить все гласные в тексте: aeioyuAEIOUауоыиэяюёеАУОЫИЭЯЮЁЕ

 text = 'Especially this one my kinda favourite'

 # Работают НЕ полностью
 print(re.sub(r'[aeioyuауоыиэяюёе]', '!', text, re.I))                 # -> Esp!c!ally this one my kinda favourite
 print(re.sub(r'[aeioyuауоыиэяюёе]', '!', text, re.IGNORECASE))        # -> Esp!c!ally this one my kinda favourite

 # Работают полностью
 print(re.sub(r'[aeioyuауоыиэяюёе]', '!', text, flags=re.IGNORECASE))  # -> !sp!c!!ll! th!s !n! m! k!nd! f!v!!r!t!
 print(re.sub(r'(?i)[aeioyuауоыиэяюёе]', '!', text))                   # -> !sp!c!!ll! th!s !n! m! k!nd! f!v!!r!t!


 -----------------------------------------------------------------------------------------------------------------------

 # Уберите все html теги и выведите оставшийся текст.

 text = '<span>Привет!</span>'

 print(re.sub(r'<[^>]*?>', '', text, re.I))  # -> Привет!
 print(re.sub(r'<.*?>', '', text, re.I))     # -> Привет!


 -----------------------------------------------------------------------------------------------------------------------

 # Нужно найти все ФИО в тексте и заменить их на строку ФИО.  Также ФИО могут склоняться.

 text = r'Ркоман Яна Диевна'

 n, s, o = text.split()
 text1 = r'Создатель нелегитимной организации Ркоман Яна Диевна предлагает мне, Трофиму Алексу Сергу, подделать документы.'

 name = rf'({n[:-2]}\w+) ({s[:-2]}\w+) ({o[:-2]}\w+)'
 surname = rf'(({n[:-2]}\w+) ({s[0]}\.) ({o[0]}\.))'

 print(re.sub(rf'{surname}|{name}', 'ФИО', text1))
 # -> Создатель нелегитимной организации ФИО предлагает мне, Трофиму Алексу Сергу, подделать документы.


 -----------------------------------------------------------------------------------------------------------------------

 # Удалите все знаки препинания из текста и выведите количество совершённых замен.

 text = "Через час те из вас, кто останется в живых, будут завидовать мёртвым"

 print(re.subn(fr'[.?!,:]', '', text)[1])         # -> 3

 # Посмотри на переменную   Тоже самое
 punct = r'[.?!,:]'                                        punct = r'.?!,:'
 print(punct)                               # -> [.?!,:]   print(punct)  # -> .?!,:
 print(re.subn(fr'{punct}', '', text)[-1])  # -> 3         print(re.subn(rf'[{punct}]', '', text)[-1])  # -> 3


 -----------------------------------------------------------------------------------------------------------------------

 # Замените все цифры на X. Выведите полученную строку и количество совершённых замен.

 text = "65,905 views  Nov 19, 2022 "

 print(re.subn(fr'\d', 'X', text))               # -> ('XX,XXX views  Nov XX, XXXX ', 11)
 print(__import__('re').subn(r'\d', 'X', text))  # -> ('XX,XXX views  Nov XX, XXXX ', 11)

 -----------------------------------------------------------------------------------------------------------------------

 # Передайте в метод ссылку

 text = r'https://regex101.com/'

 print(re.escape(rf'{text}'))          # -> https://regex101\.com/
 print(__import__('re').escape(text))  # -> https://regex101\.com/


 -----------------------------------------------------------------------------------------------------------------------




 --------------------------------------    Работа с группами   ---------------------------------------------------------

 regex = r'П(?P<name>.+?)т' # Захватим весь текст между П и т в группу с именем name
 text = 'Привет, как тебя зовут?'

 match = re.match(regex, text)
 print(match)          # -> <re.Match object; span=(0, 6), match='Привет'>
 print(match.group())  # -> Привет       # Если в метод не передать аргумент, то он по умолчанию выведет нулевую группу
 print(match.group(0)) # -> Привет       # Можно передать номер нужной группы в метод
 print(match[0])       # -> Привет       # Благодаря геттеру в Match-объекте к группам можно обращаться с помощью квадратных
 print(match.group("name")) # -> риве    # Получаем то, что захватила группа с именем name
 print(match["name"])       # -> риве    # Получаем то, что захватила группа с именем name через квадратные скобки
 print(match.group(0, "name", 1))  # -> ('Привет', 'риве', 'риве')      # Можно получить сразу несколько групп
 print(match.groups()) # ('риве',)       # кортеж со всеми группами, кроме нулевой


 -----------------------------------------------------------------------------------------------------------------------

 # findall - Если в findall есть группы, то в список будут включены только группы         <-----   <-----
 # В начале тега стоит: <p Любые символы  >
 text = '<noscript class="noscript"><p class="l-header">Сайт не работает<br>без JavaScript 😕</p></noscript>'

 print(*re.findall(r'<p.*?>(.*?)</p>', text))               # ->  Сайт не работает<br>без JavaScript 😕
 print(*re.findall(r'<p[^<]*?>(.+?)</p>', text))            # ->  Сайт не работает<br>без JavaScript 😕
 print(*re.findall(r'(?:<p.*?>)(?<!</p>)(.*?)</p>', text))  # ->  Сайт не работает<br>без JavaScript 😕



 --------------------------------------    Топ Задание!!!   ------------------------------------------------------------
 --------------------------------------    Топ Решение!!!   ------------------------------------------------------------

 # Вариант c re.finditer()  re.VERBOSE - можно делать комментарии

 # Разделяем найденные ссылки   Быть внимательныс в f'''''' учитывается Всё!!!  любые скрытые пробелы!
 text = 'https://regex101.com/'

 result = re.finditer(r'''
                 (?P<prot>https?)://                      # Протокол
                 (?P<dom>(?:[a-zA-Z\d_]+\.){1,}[a-z]+)/   # Домен
                 [a-zA-Z\d_/\-&]*                         # Путь
                 (?P<params>\?[a-zA-Z=\d_\-&]+)?          # Параметры
                 (?P<anc>\#[a-zA-Z_\d\-&]+)?              # Якорь
 ''', text, flags=re.VERBOSE)

 for i in result:
     print(f'''Полная ссылка: {i.group(0)}
 Протокол: {i.group('prot')} | Домен: {i.group('dom')} | Параметры: {i.group('params')} | Якорь: {i.group('anc')}\n''')

 # -> Полная ссылка: https://regex101.com/
 # -> Протокол: https | Домен: regex101.com | Параметры: None | Якорь: None




 Второй вариант!!! c re.match() и моржом

 text = 'https://example.com/ https://stepik.org/'

 link = r'\b(https?)\://([a-z.]+)/(?:[a-z0-9-/_]*)(\?[a-z=&0-9]*)?(#[a-z]+)?'

 for i in text.split():
     if s := re.match(link, i):
         print('Полная ссылка:', s[0])
         print(f'Протокол: {s[1]} | Домен: {s[2]} | Параметры: {s[3]} | Якорь: {s[4]}')
         print()

 # -> Полная ссылка: https://example.com/
 # -> Протокол: https | Домен: example.com | Параметры: None | Якорь: None

 # -> Полная ссылка: https://stepik.org/
 # -> Протокол: https | Домен: stepik.org | Параметры: None | Якорь: None



 --------------------------------------    Группы и re.findall()   -----------------------------------------------------

 Если в регулярном выражении используются скобочные группы, то вместо списка со всеми соответствиями вернётся список
 с кортежами совпадений соответствующих групп.

 pattern = r'(=)(\w{3})='
 string = '=abc= =123= =def= 456 =fed= =321= =cba='

 result = re.findall(pattern, string)
 print(result) # [('=', 'abc'), ('=', '123'), ('=', 'def'), ('=', 'fed'), ('=', '321'), ('=', 'cba')]



 # findall - Если в регулярном выражении есть группы, то в список будут включены только группы
 # Получите все названия html-тегов  В начале тега стоит < или </ Внутри [a-zA-Z0-9]  В конце тега стоит >
 text = '<div class="o3j99 LLD4me yr19Zb LS8OJ"><style>.LS8OJ</style><div class="k1</div>'

 print(re.findall(r'</?(\w+?)\b', text))   # ->  ['div', 'style', 'style', 'div', 'div', 'div']
 print(re.findall(r'</?(\w+).*?>', text))  # ->  ['div', 'style', 'style', 'div', 'div']


 # findall - Если в регулярном выражении есть группы, то в список будут включены только группы
 # Получите список кортежей с логином, паролем, и токеном.  Логин: [0-9]   Пароль: [a-zA-Z0-9]  Токен: [a-z0-9]
 text = '15:W4:bd 13:SL:17 15:hq:cb 12:Iw:82'

 print(re.findall(r'(\d+):([a-zA-Z\d]+):([a-zA-Z\d]+)', text))
 # -> [('15', 'W4', 'bd'), ('13', 'SL', '17'), ('15', 'hq', 'cb'), ('12', 'Iw', '82')]
 print(re.findall(r'\b(\d+):([a-zA-Z0-9]+):([a-z0-9]+)\b', text))
 # -> [('15', 'W4', 'bd'), ('13', 'SL', '17'), ('15', 'hq', 'cb'), ('12', 'Iw', '82')]


 -----------------------------------------------------------------------------------------------------------------------

 # Получите все названия html-тегов.

 text = '<div class="o3j99 LLD4me yr19Zb LS8OJ"><style></div></div>'

 print(re.findall(r'</?([a-z0-9]+)\b', text))  # -> ['div', 'style', 'div', 'div']
 print(re.findall(r'</?(\w+).*?>', text))      # -> ['div', 'style', 'div', 'div']


 -----------------------------------------------------------------------------------------------------------------------

 # Получите список кортежей с логином, паролем, и токеном.

 text = '150:j7j:bde  133:SLk:177'

 print(re.findall(r'([0-9]+):([a-zA-Z0-9]+):([a-z0-9]+)', text))  # -> [('150', 'j7j', 'bde'), ('133', 'SLk', '177')]
 print(re.findall(r'(\d+):(\w+):([a-z\d]+)', text))               # -> [('150', 'j7j', 'bde'), ('133', 'SLk', '177')]


 --------------------------------------    Группы и re.split()   -------------------------------------------------------

 Если в шаблоне регулярного выражения используются групппы, то их значения будут вставлены между разделёнными строками:

 # Если в шаблоне нет групп, re.split работает так же, как и str.split
 res1 = re.split(r'\s[+*=]\s', '2 + 2 * 2 = 6')
 print(res1)  # -> ['2', '2', '2', '6']

 # Если использовать группы, то между каждыми разделёнными строками будут значения из групп
 res2 = re.split(r'(\s)([+*=])(\s)', '2 + 2 * 2 = 6')
 print(res2)  # -> ['2', ' ', '+', ' ', '2', ' ', '*', ' ', '2', ' ', '=', ' ', '6']
 # Это может понадобиться, если нужно разделить строки, и оставить между ними разделитель.

 # Сначала не очень понятно, зачем использовать группы с re.split.
 # Но если убрать ненужные группы из второго примера, то всё становится ясно
 res3 = re.split(r'\s([+*=])\s', '2 + 2 * 2 = 6')
 print(res3)  # -> ['2', '+', '2', '*', '2', '=', '6']



 # Разделить строку по  +:=*/-
 text = '3снова+в5 *тексте6спам-.4 : 4 = 32'

 # Без групп
 print(re.split(r'[^+:=*/\-\d]+', text))             # -> ['3', '+', '5', '*', '6', '-', '4', ':', '4', '=', '32']
 # С группами
 print(re.split(r'[^\d]*([+:=*/-])[^\d]*', text))    # -> ['3', '+', '5', '*', '6', '-', '4', ':', '4', '=', '32']


 # Разделить строку по  ? и &  оставив эти символы в полученном списке.
 text = 'https://stackoverflow.com/questions/tagged/regex?tab=votes&page=11&pagesize=15'

 print(re.split(r'([?&]+)', text))             # -> ['3', '+', '5', '*', '6', '-', '4', ':', '4', '=', '32']
 # -> ['https://stackoverflow.com/questions/tagged/regex', '?', 'tab=votes', '&', 'page=11', '&', 'pagesize=15']


 --------------------------------------    Группы в re.sub() и re.subn()    --------------------------------------------

 Группы в re.sub() и re.subn() ничего не дают, но их можно использовать в заменах!

 # Важно Можно использовать rf'' fr'' - строки в заменах                                               <-----
 text = 'test1 test2 test3 test4 test5'
 print(re.sub(r'(test)(\d)', rf'{str(42) + str(10)}F{1 + 1}', text))  # -> 4210F2 4210F2 4210F2 4210F2 4210F2


 Если в строке, на которую будет происходить замена найденных совпадений написать \n или \g<name>,
 где n это номер группы, а name это имя группы, то они будут заменены на совпадения этих групп:

 string = "Ненавижу людей, которые пишут дату в формате mm/dd/yyyy. Ну кто пишет 02/22/2022 или 07/13/2022?"
 print(re.sub(r'(\d{2}).(\d{2}).(\d{4})', r'\2.\1.\3', string))
 # Ненавижу людей, которые пишут дату в формате mm/dd/yyyy. Ну кто пишет 22.02.2022 или 13.07.2022?



 # Замените два повторяющиеся слова на одно.

 text = 'Нужно удалять удалять повторяющиеся слова слова.'

 print(re.sub(r'([а-яё]+)\s\1', r'\1', text))                   # ->  Нужно удалять повторяющиеся слова.
 print(re.sub(r'(?P<name>\w+)\s(?P=name)', r'\g<name>', text))  # ->  Нужно удалять повторяющиеся слова.

 # Очень интересное решение                                                                               <-----
 print(__import__('re').sub(r'(\w+) \1', r'\1', text))          # ->  Нужно удалять повторяющиеся слова.



 # Замените **Жирный текст** на <strong>Жирный текст</strong>, и *Курсив* на <em>Курсив</em>.

 text = '*Курсив* и **Жирный текст**'

 print(re.sub(r'(\*([a-zA-Zа-яА-Я\s]+)\*)', r'<em>\2</em>', re.sub(r'(\*\*([a-zA-Zа-яА-Я\s]+)\*\*)', r'<strong>\2</strong>', text)))
 print(re.sub(r'(\*(.*?)\*)', r'<em>\2</em>', re.sub(r'(\*\*(.*?)\*\*)', r'<strong>\2</strong>', text)))
 print(re.sub(r'(\*)(.*?)\1', r'<em>\2</em>', re.sub(r'(\*{2})(.*?)\1', r'<strong>\2</strong>', text)))
 # -> <em>Курсив</em> и <strong>Жирный текст</strong>

 # Тоже самое
 first = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', text)
 print(re.sub(r'\*(.+?)\*', r'<em>\1</em>', first))  # -> <em>Курсив</em> и <strong>Жирный текст</strong>



 # Найдите все прокси, и добавьте к ним в начало протокол http://.

 text = 'Будем 193.193.240.37:45944'

 print(re.sub(r'((\d+\.?){4}:\d+)', r'http://\1', text))  # -> Будем http://193.193.240.37:45944
 print(re.sub(r'([\d.]+:\d+)', r'http://\1', text))       # -> Будем http://193.193.240.37:45944


 # даты формата mm/dd/yyyy, замените их на dd/mm/yyyy   разделители используют символы . и /.  Тяжелое задание
 text = 'Завтра будет 05/23/2022'

 print(re.sub(r'(\d{2})([./])(\d{2})\2(\d{4})', r'\3\2\1\2\4', text))  # -> Завтра будет 23/05/2022
 print(re.sub(r'(\d{2}[/.])(\d{2}[/.])', r'\2\1', text))               # -> Завтра будет 23/05/2022


 # Замените егонный/еённый/ихний на его/её/их
 text = 'Это был егонный билет. Слова "егонный", "еённый"'

 print(re.sub(r'(?i:(его|её|их)[а-я]+|её[а-я]+|их[а-я]+)', r'\1', text))  # -> Это был его билет. Слова "его", "её"
 print(__import__('re').sub(r"(?i)(его|её|их)[а-яё]*", r'\1', text))      # -> Это был его билет. Слова "его", "её"


 --------------------------------------    Зачем нужен match.expand()?    ----------------------------------------------

 match.expand() генерирует строку, путём вставки в неё значений из найденных групп.
 re.sub() ищет совпадения в тексте, если совпадения найдены, то генерирует строку, путём вставки в неё значений
 из найденных групп, и заменяет совпадения на сгенерированные строки.

 С помощью match.expand() удобно генерировать строки с найденными данными.


 # Нужно найти первую цену в тексте: Любая числовая последовательность В конце стоит ₽$

 # Вариант с моржом :=  и обычной группой
 text = 'Товар/подписка менее 300$ (2$ дополнительная плата)'

 if match := re.search(r'(\d+[₽$])', text):
     print(match.expand(r'Цена данного товара \1'))        # -> Цена данного товара 300$

 # Вариант обычный  с именованной группой
 text = 'Хочу купить себе какую-то ненужную вещь за 1000₽ или 5000₽'

 match = re.search(r'(?P<name>\d+[₽$])', text)
 if match:
     print(match.expand(r'Цена данного товара \g<name>'))  # -> Цена данного товара 1000₽


 --------------------------------------    Обьяснение Магии re.sub и другие примеры  Важно!!!  -------------------------

 # Замените **Жирный текст** на <strong>Жирный текст</strong>, и *Курсив* на <em>Курсив</em>.
 text = '*Курсив* и **Жирный текст**'

 def convert(match_obj):
     key, text = match_obj.groups()
     return {'**': r'<strong>{}</strong>', '*': r'<em>{}</em>'}.get(key).format(text)

 print(re.sub(r'(\*{1,2})(.*?)\1', convert, text))  # -> <em>Курсив</em> и <strong>Жирный текст</strong>

 мы функцию convert не вызываем (поэтому нет скобок с аргументами), а передаем в качестве  одного из параметров в
 re.sub и sub уже сам вызывает функцию convert , подставляя найденное (тот самый match_obj) в качестве аргумента

 тут все работает так: re.sub ищет паттерн в строке, если находит - передает матч-объект в convert, convert
 этот матч-объект обрабатывает и возвращает строку. На эту строку re.sub меняет найденный фрагмент
 (который был в матч-объекте) и продолжает поиск по строке.

 по тому же принципу, кстати, отрабатывают и другие функции... например map и filter. Например, хорошо знакомый вариант:

 lst = [*map(int, '1 2 3'.split())]
 который вполне можно записать и таким образом:
 lst = [*map(lambda x: int(x), '1 2 3'.split())]
 и тогда у int будут скобки (тут без скобок получается лямбда)


 --------------------------------------    Функции в re.sub() и re.subn()    -------------------------------------------

 Вместо строки, на которую нужно заменить вхождение, в re.sub() и re.subn() можно передать функцию, которая будет
 генерировать ту самую строку. Возвращать из функции нужно всегда строку!!!    <-----

 В функцию передаётся Match объект, и теперь мы можем получать доступ к группам, а также как-либо изменять
 и обрабатывать эти данные.

 Например, нам нужно найти все слова и заменить их на их же длину. Давайте сделаем это с помощью функций!

 def func(m):
     return str(len(m[0]))

 regex = r'[a-zA-Z]{1,}'
 text = 'Lorem Ipsum is simply dummy text of the printing and typesetting industry.'

 res_func = re.sub(regex, func, text)
 res_lambda = re.sub(regex, lambda m: str(len(m[0])), text)

 print(res_func)  # 5 5 2 6 5 4 2 3 8 3 11 8.
 print(res_func == res_lambda)  # True

 В примере сверху в функциях я:

 Получаю Match объект в функции.
 Из него беру нулевую группу - т.е. всё, что захватило регулярное выражение.
 Получаю её длину, конвертирую в строку, и возвращаю значение.
 Можно использовать как и лямбда-функции, так и обычные.


 # Найдите все числа в тексте и возведите их в квадрат.

 text = '2 в квадрате это 4'

 def func(m):
     return str(int(m[0]) ** 2)

 print(re.sub(r'\d+', func, text))                         # -> 4 в квадрате это 16
 # Тоже самое с lambda
 print(re.sub(r'\d+', lambda x: str(int(x[0])**2), text))  # -> 4 в квадрате это 16


 # Замените все слова, которые начинаются на букву А в любом регистре, на удалено(n), где n - длина удалённого слова.

 text = 'А роза упала на лапу Азора.'

 def func(m):
     return f'удалено({len(m[0])})'

 print(re.sub(r'\b[Аа][а-яеё]*', func, text))                             # -> удалено(1) роза упала на лапу удалено(5).
 # Тоже самое с lambda
 print(re.sub(r'(?i)\b(а\w*)', lambda x: fr'удалено({len(x[0])})', text)) # -> удалено(1) роза упала на лапу удалено(5).
 # Чтобы понимать что нашло
 print(re.findall(r'\b(а\w*)', text, flags=re.IGNORECASE))                # -> ['А', 'Азора']


 # Напишите программу, которая найдёт все am и pm в тексте и заменит их друг на друга.

 text = "It's already 12:00am and I still don't want to sleep."

 # match case                      # Обычное решение
 def func(m):                      def func(m):
     match m[0]:                       if m[0] == 'am':
         case 'am':                        return 'pm'
             return 'pm'               return 'am'
         case _:
             return 'am'

 print(re.sub(r'(am)|(pm)', func, text))
 # Тоже самое с lambda
 print(re.sub(r'(am|pm)', lambda x: 'am' if x[0] == 'pm' else 'pm', text))
 print(re.sub(r'[ap]m', lambda x: {'am': 'pm', 'pm': 'am'}[x[0]], text))     # Создали внутри словарь
 print(re.sub(r'(am|pm)', lambda m: ('pm', 'am')[m[0] == 'pm'], text))
 # -> It's already 12:00pm and I still don't want to sleep.


 # Напишите программу, которая делит на 3 все числа, кратные 3.
 text = "0 1 2 3 4 5 6 7 8 9 10"

 def func(m):
     if int(m[0]) % 3 == 0:
         return str(int(int(m[0]) / 3))
     return m[0]

 print(re.sub(r'\d+', func, text))                                                      # -> 0 1 2 1 4 5 2 7 8 3 10
 # Тоже самое с lambda
 print(re.sub(r'\d+', lambda x: x[0] if int(x[0]) % 3 else str(int(x[0]) // 3), text))  # -> 0 1 2 1 4 5 2 7 8 3 10


 --------------------------------------    Зачем нужен re.compile()?    ------------------------------------------------

 Каждый раз, когда вы используете регулярное выражение в каком-либо методе, оно автоматически компилируется.
 С помощью метода re.compile() можно вручную скомпилировать регулярное выражение, и уже использовать его по назначению.

 С помощью re.compile() можно:
 - уменьшить количество кода, если одно регулярное выражение используется несколько раз
 - увеличить производительность кода, если одно регулярное выражение используется несколько раз

 Если вы не используете много регулярных выражений - не стоит бояться что производительность упадёт, так как все
 использованные регулярные выражения кешируются, и им не приходится компилироваться во второй раз, пока не очистится кеш.
 Кеш кстати очищается с помощью метода re.purge(), но его нет смысла использовать, так как кеш чистится автоматически.

 После компиляции регулярного выражения, функция re.compile() возвращает объект Pattern.


 # Скомпилировать регулярное выражение, которое находит все mac-адреса: nn:nn:nn:nn:nn:nn где n это 16-ричное число  [0-9A-F]

 text = "Мак-адрес моего друга:F0:98:9D:1C:93:F6. Мой мак-адрес: 0F:70:DE:55:60:19."

 pattern = re.compile(r'(?:[0-9A-F]{2}:){5}[0-9A-F]{2}')
 print(pattern.findall(text))  # -> ['F0:98:9D:1C:93:F6', '0F:70:DE:55:60:19']

 # Тоже самое
 n = r'[\dA-F]{2}'
 pattern = re.compile(rf'(?:{n}:){{5}}{n}')
 print(pattern.findall(text))  # -> ['F0:98:9D:1C:93:F6', '0F:70:DE:55:60:19']


 # Найдите первое слово, которое содержится в определённом диапазоне.
 text = "soda senior tuition library task tone few torch vacuum"
 start = 2  # Начало поиска
 end = 29   # Конец поиска

 pattern = re.compile(r'\b[a-z]+\b')

 # С моржом :=
 if (match := pattern.search(text, pos=start, endpos=end)):
     print(match[0])  # -> senior

 # Без моржа :=
 match = pattern.search(text, pos=start, endpos=end)
 if match:
     print(match[0])  # -> senior


 --------------------------------------    Как использовать флаги?    --------------------------------------------------

 Всего существует 9 флагов, которые открывают нам доступ к новым свойствам регулярных выражений.
 Чтобы использовать флаги, достаточно их передать как именованный аргумент в нужный метод:

 -- ГЛОБАЛЬНЫЕ флаги, т.е. они действуют на всё регулярное выражение целиком. --

 Если нужно использовать несколько флагов сразу - нужно сложить их вместе. Да, именно сложить:

 test1 = re.findall(r'123', '123', flags=re.MULTILINE)  # 1 флаг
 test2 = re.findall(r'123', '123', flags=re.MULTILINE + re.IGNORECASE)  # 2 флага
 test3 = re.findall(r'123', '123', flags=re.MULTILINE + re.IGNORECASE + re.DOTALL)  # 3 флага

 Ну или написать между ними символ |:

 test1 = re.findall(r'123', r'123', flags=re.MULTILINE)  # 1 флаг
 test2 = re.findall(r'123', r'123', flags=re.MULTILINE | re.IGNORECASE)  # 2 флага
 test3 = re.findall(r'123', r'123', flags=re.MULTILINE | re.IGNORECASE | re.DOTALL)  # 3 флага

 Сокращённые версии:

 test1 = re.findall(r'123', r'123', flags=re.M)  # 1 флаг
 test2 = re.findall(r'123', r'123', flags=re.M + re.I)  # 2 флага
 test3 = re.findall(r'123', r'123', flags=re.M + re.I + re.S)  # 3 флага

 Встроенные флаги нужно ставить в начало выражения:

 test1 = re.findall(r'(?i)123', r'123', flags=re.M)  # 1 флаг
 test2 = re.findall(r'(?im)123', r'123', flags=re.M + re.I)  # 2 флага
 test3 = re.findall(r'(?ims)123', r'123', flags=re.M + re.I + re.S)  # 3 флага


 -- ЛОКАЛЬНЫЕ флаги!  Пока они есть только в встроенном виде: (?aiLmsux-imsx:regex) --

 regex = r"(?i)(?ms-i:local) global"
 ГЛОБАЛЬНЫЙ флаг i, но он будет работать только при поиске текста global.
 А при поиске текста local, флаг i отключается, и вместо него используются флаги m и s.


 -- Объект RegexFlag --

 Получать из объекта Pattern флаги в числовом виде. Чтобы конвертировать их в привычный нам вид,
 достаточно провести следующие манипуляции:

 pattern = re.compile(r'[a-zA-Z]{1,}')
 print(pattern.flags)      # 32
 print(re.RegexFlag(32))   # re.UNICODE

 pattern = re.compile(r'[a-zA-Z]{1,}', flags=re.IGNORECASE)
 print(pattern.flags)      # 34
 print(re.RegexFlag(34))   # re.IGNORECASE|re.UNICODE

 pattern = re.compile(r'[a-zA-Z]{1,}', flags=re.IGNORECASE + re.DOTALL + re.MULTILINE + re.ASCII + re.VERBOSE)
 print(pattern.flags)      # 346
 print(re.RegexFlag(346))  # re.ASCII|re.IGNORECASE|re.MULTILINE|re.DOTALL|re.VERBOSE


 -------------------------------------    re.IGNORECASE    -------------------------------------------------------------

 При использовании флага регулярные выражения будут игнорировать регистр.

 НЕЛЬЗЯ просто указать 3-м параметром флаг re.I, ошибки не будет, но и работать тоже не будет,
 нужно обязательно указывать название flags: flags=re.I                           <-----   <-----

 Обьяснение почему флаг  re.I  не всегда работает                                 <-----   <-----
 Всё зависит от функции.

 # В функциях, где flags стоит после обязательных аргументов, будет всё норм
 m = re.search(r'[a-z]+', 'ASADF', re.I)
 print(m[0]) #ASADF
 # А если так же поставить в функции, где перед флагом стоит ещё один необязательный аргумент:
 # re.sub(pattern, repl, string, count=0, flags=0)
 # re.split(pattern, string, maxsplit=0, flags=0)

 # То заменит 2 маленькие 'o' на 'X', так как re.I = 2, которые он и подставит в атрибут count (сколько раз делать замену)
 print(re.sub(r'o', 'X', 'LOST ooooo', re.I))  # -> 'LOST XXooo'
 # Так что думаю, что всё таки рекомендуется указывать именно flags=re.I           <-----   <-----


 Полная версия:           re.IGNORECASE
 Сокращённая версия:      re.I
 Встроенный флаг:         (?i)
 Числовое представление:  2


 string = 'I like flags I LIKE FLAGS i like flags'

 test1 = re.findall(r'I like flags', string, flags=re.IGNORECASE)
 test2 = re.findall(r'I like flags', string, flags=re.I)
 test3 = re.findall(r'(?i)I like flags', string)
 test4 = re.findall(r'I like flags', string)

 print(test3)                               # -> ['I like flags', 'I LIKE FLAGS', 'i like flags']   # С Флагом   (?i)
 print(test4)                               # -> ['I like flags']                                   # Без Флага
 print(test1 == test2 and test2 == test3)   # -> True
 print(re.RegexFlag(2))                     # -> re.IGNORECASE


 # Заменить O на X, o на x.
 text = "LOST CXNTURY - CYBERSITY | scarlord - FALSE HOPE"

 def get_x(m):
     return {'o': 'x', 'O': 'X'}[m[0]]

 print(re.sub(r'o', get_x, text, flags=re.IGNORECASE))                # -> LXST CXNTURY - CYBERS | scarlxrd - FALSE HXPE
 print(re.sub(r'(?i)o', lambda x: {'o': 'x', 'O': 'X'}[x[0]], text))  # -> LXST CXNTURY - CYBERS | scarlxrd - FALSE HXPE
 print(re.sub('(?i)o', lambda m: chr(ord(m[0]) ^ 23), text))          # -> LXST CXNTURY - CYBERS | scarlxrd - FALSE HXPE


 # Найдите все слова привет. Регистр учитывать не нужно.
 text = "привет ПРИВЕТ пРиВеТ"
 print(__import__("re").findall(r'(?i:привет)', text))  # -> ['привет', 'ПРИВЕТ', 'пРиВеТ']


 -------------------------------------    re.MULTILINE    --------------------------------------------------------------

 При использовании флага спецсимволы ^ и $ будут совпадать не с началом и концом всего текста, а с началом и концом строк.

 Полная версия:           re.MULTILINE
 Сокращённая версия:      re.M
 Встроенный флаг:         (?m)
 Числовое представление:  8

 string = '''
 I like flags
 I like flags
 I like flags
 '''

 test1 = re.findall(r'^I like flags$', string, flags=re.MULTILINE)
 test2 = re.findall(r'^I like flags$', string, flags=re.M)
 test3 = re.findall(r'(?m)^I like flags$', string)             # ищет совпадение по строкам
 test4 = re.findall(r'^I like flags$', string)                 # ищет совпадение со всем текстом

 print(test3)                              # -> ['I like flags', 'I like flags', 'I like flags']   # С Флагом   (?m)
 print(test4)                              # -> []                                                 # Без Флага
 print(test1 == test2 and test2 == test3)  # -> True
 print(re.RegexFlag(8))                    # -> re.MULTILINE


 # Найдите все строки в этой переменной, которые состоят только из символов ^ и $.
 text = '''$$^^$^$$4^^$^^$$$
 ^$^$
 ^$$^$^^^$^^$$^$$$$
 ^^^^$$S^$^$^$^$^^$$'''

 print(re.findall(r'^[$^]+$', text, flags=re.MULTILINE))  # -> ['^$^$', '^$$^$^^^$^^$$^$$$$']


 -------------------------------------    re.ASCII    ------------------------------------------------------------------

 Шаблоны \w, \W, \b, \B, \d, \D, \s и \S будут выполнять только ASCII соответствие,
 вместо соответствия по умолчанию - соответствия по UNICODE .

 Полная версия:           re.ASCII
 Сокращённая версия:      re.A
 Встроенный флаг:         (?a)
 Числовое представление:  256

 Можно использовать, чтобы отсечь ненужные языки и не писать длинные выражения в квадратных скобках.
 Возможно поиск будет происходить чуть быстрее, т.к. будет обрезано большое количество символов.

 в  ASCII меньше вразы символов - соответсвенно скорость посика и обработки особенно больших текстов выше!
 Чтобы сократить код, к примеру если нужно не пропускать кирилицу и etc. (и т. д.)  писать [a-zA-Z0-9]  Лучше  (?a)\w

 string = 'I like flags Я люблю Флаги'

 test1 = re.findall(r'\w+', string, flags=re.ASCII)
 test2 = re.findall(r'\w+', string, flags=re.A)
 test3 = re.findall(r'(?a)\w+', string)
 test4 = re.findall(r'\w+', string)

 print(test1)                              # -> ['I', 'like', 'flags']                            # С флагом  re.ASCII
 print(test4)                              # -> ['I', 'like', 'flags', 'Я', 'люблю', 'Флаги']     # Без флага
 print(test1 == test2 and test2 == test3)  # -> True
 print(re.RegexFlag(256))                  # -> re.ASCII


 -------------------------------------    re.UNICODE    ----------------------------------------------------------------

 Шаблоны \w, \W, \b, \B, \d, \D, \s и \S будут выполнять соответствие по UNICODE. Существует для обратной совместимости
 с re.ASCII, но он является излишеством, так как по умолчанию Python выполняет сопоставления в UNICODE.

 Полная версия:           re.UNICODE
 Сокращённая версия:      re.U
 Встроенный флаг:         (?u)
 Числовое представление:  32

 Python по умолчанию выполняет сопоставления в UNICODE ¯\_(ツ)_/¯

 pattern = re.compile(r'[a-zA-Z]{1,}')    # Флагов нет
 print(pattern.flags)     # -> 32
 print(re.RegexFlag(32))  # -> re.UNICODE


 -------------------------------------    re.LOCALE    -----------------------------------------------------------------

 Сопоставляет \w, \W, \b, \B  без учета регистра, зависимо от текущей локали. Использование этого флага не рекомендуется,
 так как механизм локализации очень ненадежен и он работает только с 8-битными локалями.

 Полная версия:           re.LOCALE
 Сокращённая версия:      re.L
 Встроенный флаг:         (?L)
 Числовое представление:  4

 Не нашёл применения для этого флага ¯\_(ツ)_/¯


 -------------------------------------    re.DOTALL    -----------------------------------------------------------------

 Точка . теперь будет соответствовать любому символу. Если флаг НЕ используется - точка соответствует любому символу,
 кроме символа новой строки.

 Полная версия:           re.DOTALL
 Сокращённая версия:      re.S
 Встроенный флаг:         (?s)
 Числовое представление:  16

 string = '''
 I like flags
 I like flags
 I like flags
 '''

 test1 = re.findall(r'I like flags.', string, flags=re.DOTALL)
 test2 = re.findall(r'I like flags.', string, flags=re.S)
 test3 = re.findall(r'(?s)I like flags.', string)
 test4 = re.findall(r'I like flags.', string)

 print(test3)                              # -> ['I like flags\n', 'I like flags\n', 'I like flags\n']  # С флагом  (?s)
 print(test4)                              # -> []                                                      # Без флага
 print(test1 == test2 and test2 == test3)  # -> True
 print(re.RegexFlag(16))                   # -> re.DOTALL


 # Нужно найти весь текст от start до end, текст может быть растянут на несколько строк.
 text = '''start
 Каждое
 Слово
 На
 Новой
 Строке
 end'''

 print(re.findall(r'start(.*)end', text, flags=re.DOTALL))  # -> ['\nКаждое\nСлово\nНа\nНовой\nСтроке\n']
 print(re.findall(r'(?s)(?<=start).*(?=end)', text))        # -> ['\nКаждое\nСлово\nНа\nНовой\nСтроке\n']
 print(re.findall(r'start(.*)end', text))                   # -> []                                        # Без Флага


 -------------------------------------    re.VERBOSE    ----------------------------------------------------------------

 Позволяет писать более читабельные регулярные выражения, отделять части регулярного выражения пробелами и переносами
 строк, а также писать комментарии после символа #.

 Полная версия:           re.VERBOSE
 Сокращённая версия:      re.X
 Встроенный флаг:         (?x)
 Числовое представление:  64

 Можно писать такие регулярные выражения, и всё будет работать:
 test1 = re.findall(r'''[1-9] +  # Любая цифра, кроме 0
                    .            # Любой символ, кроме новой строки
                    \d {2,}      # Любая цифра''', '4G22', flags=re.VERBOSE)

 test2 = re.findall(r'''[1-9] +
                    .
                    \d {2,}''', '4G22', flags=re.VERBOSE)

 Использование сокращённых и встроенных флагов:

 test1 = re.findall(r'''[1-9] +
                    .
                    \d {2''', '4G22', flags=re.VERBOSE)

 test2 = re.findall(r'''[1-9] +
                    .
                    \d {2''', '4G22', flags=re.X)

 test3 = re.findall(r'''(?x)
                    [1-9] +
                    .
                    \d {2''', '4G22')

 print(test3)                              # -> ['4G22']
 print(test1 == test2 and test2 == test3)  # -> True
 print(re.RegexFlag(64))                   # -> re.VERBOSE


 Скомпилируйте следующее регулярное выражение, и запишите его в переменную pattern: Используем 3 Тройные кавычки
 pattern = re.compile(r'''
 Here is the pattern body.
 ''', re.VERBOSE)


 -------------------------------------    re.DEBUG    ------------------------------------------------------------------

 Показывает отладочную информацию о скомпилированном выражении. Используется только с re.compile.

 Полная версия:           re.DEBUG
 Сокращённая версия:      Нет
 Встроенный флаг:         Нет
 Числовое представление:  128

 regex = re.compile(r'I like flags', flags=re.DEBUG)  # Выводит отладочную информацию
 print(re.RegexFlag(128))             # -> re.DEBUG


 -------------------------------------    re.NOFLAG    -----------------------------------------------------------------

 Указывает, что в функции/методе не применяется флаг.

 Полная версия:           re.NOFLAG
 Сокращённая версия:      Нет
 Встроенный флаг:         Нет
 Числовое представление:  0

 Можно использовать как значение по умолчанию для своих функций:

 def myfunc(text, flags=re.NOFLAG):
     return re.match(text, flags)

 print(re.RegexFlag(0))  # -> re.NOFLAG

 -------------------------------------    re.RegexFlag    --------------------------------------------------------------

 Флаги в числовом виде

 # Можно самому поиграть с цифрами))
 print(re.RegexFlag(0))            # -> re.NOFLAG
 print(re.RegexFlag(1))            # -> re.TEMPLATE
 print(re.RegexFlag(2))            # -> re.IGNORECASE
 print(re.RegexFlag(100000))       # -> re.UNICODE|re.DEBUG|0x18600
 print(type(re.RegexFlag))         # -> <class 'enum.EnumType'>
 print(type(re.RegexFlag(int())))  # -> <flag 'RegexFlag'>        # Любое число вводим будем тоже самое


 -----------------------------------------------------------------------------------------------------------------------




 Веселые задачи!!!


 -----------------------------------------------------------------------------------------------------------------------

 Преобразуйте CamelCase «Верблюжий регистр» в snake_case «Змеиный регистр».

 text = 'SomeNumbers123'

 def fun(m: str):
     return f'{m[0]}_'

 print(re.sub(r'([a-z](?=[A-Z\d]))|([A-Z](?=[A-Z\d]))', fun, text).lower())     # -> some_numbers_123


 # Тоже самое
 from re import sub
 print(sub(r'[A-Z]|(?<=\D)\d', lambda m: f'_{m[0].lower()}', text).lstrip('_'))  # -> some_numbers_123


 # Тоже самое
 regex = r'(?:[A-Z][a-z]*|\d+)'
 print("_".join(re.findall(regex, text)).lower())                                # -> some_numbers_123


 -----------------------------------------------------------------------------------------------------------------------

 Преобразуйте snake_case «Змеиный регистр» в CamelCase «Верблюжий регистр».

 text = 'very_very_big_variable_123'

 def fun(m: str):
     return f'{m[0].upper()}'

 print(__import__('re').sub(r'((?<=_)|(?<=\A))[a-z]', fun, text).replace('_', ''))  # -> VeryVeryBigVariable123

 # Тоже самое без re
 print(text.title().replace('_', ''))  # -> VeryVeryBigVariable123


 -----------------------------------------------------------------------------------------------------------------------

 # Замените в строке последние 5 символов на первые 5.

 text = 'hello crazy world snake'

 from re import sub, match
 print(sub(r'.{1,5}$', match(r'^.{1,5}', text).group(), text))   # -> hello crazy world hello

 print(re.sub(r'^(.{5}).*$', lambda m: m[0][:-5] + m[1], text))  # -> hello crazy world hello
 print((text:='hello crazy world snake')[:-5] + text[:5])        # -> hello crazy world hello

 -----------------------------------------------------------------------------------------------------------------------

 text = 'ap fl hk ap hk fl'

 # Вернуть первое слово, у которого существуют повторения в строке. Если такого слова нет - функция возвращает None.

 def find_repeated(text: str) -> str | None:
     match = re.search(r"\b(\w+)\b(?=.+\b\1\b)", text)
     if match:
         return match[0]

 print(find_repeated(text))  # -> ap


 -----------------------------------------------------------------------------------------------------------------------

 # Библиотека regex для Использование POSIX class

 Напишите регулярное выражение, которое проверит, что в пароле выполняются следующие условия:

 Длина минимум 6 символов
 Содержит букву нижнего регистра
 Содержит букву верхнего регистра
 Содержит цифру
 Может содержать только буквы и цифры (_ не подойдёт)
 Если пароль подходит - выведите True, иначе - False.

 import regex

 text = 'ddddddd4ddddAs'

 pattern = '''
 (?x)^(?=[^\W_]{6,})  # длина пароля более 6 символов
 (?=.*?\d)  # определяю наличие цифры
 (?=.*?[[:upper:]])  # определяю наличие заглавной буквы
 (?=.*?[[:lower:]])  # определяю наличие маленькой буквы
 [^\W_]+$  # записываю пароль правильными символами
 '''.strip()
 pattern = regex.compile(pattern)

 print(bool(pattern.fullmatch(text)))  # -> True

 +-------------+-----------------------+----------------------------------------------------------------------+
 | POSIX class | similar to            | meaning                                                              |
 +-------------+-----------------------+----------------------------------------------------------------------+
 | [:upper:]   | [A-Z]	               | uppercase letters                                                    |
 | [:lower:]   | [a-z]	               | lowercase letters                                                    |
 | [:alpha:]   | [A-Za-z]	           | upper- and lowercase letters                                         |
 | [:digit:]   | [0-9]	               | digits                                                               |
 | [:xdigit:   | [0-9A-Fa-f]	       | hexadecimal digits                                                   |
 | [:alnum:]   | [A-Za-z0-9]	       | digits, upper- and lowercase letters                                 |
 | [:punct:]   | 	                   | punctuation (all graphic characters except letters and digits)       |
 | [:blank:]   | [ \t]	               | space and TAB characters only                                        |
 | [:space:]   | [ \t\n\r\f\v]         | blank (whitespace) characters                                        |
 | [:cntrl:]   | 	                   | control characters                                                   |
 | [:graph:]   | [^ [:cntrl:]]         | graphic characters (all characters which have graphic representation)|
 | [:print:]   | [[:graph:] ]          | graphic characters and space                                         |
 +-------------+-----------------------+----------------------------------------------------------------------+


 text = 'ddddddd4ddddAs'

 # Без ругулярки
 funcs, password = (str.isalpha, str.isupper, str.islower, str.isdigit), text
 print(all(map(lambda func: any(map(func, password)), funcs)) and len(password) >= 6)  # -> True

 -----------------------------------------------------------------------------------------------------------------------

























"""