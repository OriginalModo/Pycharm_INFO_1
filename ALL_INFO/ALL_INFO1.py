"""

 Самое Важное!!!
 Всегда ДУМАТЬ! перед тем, как что-либо сделать, необходимо всё тщательно обдумать

 Радоваться Жизни  Радоваться разным мелочам

 Осторожность!   Быть осторожным, Думать о последствиях
 Ценить:         Ценить то что есть и стремиться к лучшему, Ценить сегодняшний день и брать МАКСИМУМ
 Быть проще:     Ко всему относиться Проще и Спокойнее без Волнения
 Слушать Других: Прислушиваться к мнению других людей они могут быть правы  И делать выводы
 Время:          Тайм-менеджмент   Грамотное распределение времени, Контроль Времени, Правильно раставлять Приоритеты
 Уверенность:    Быть уверенным в себе НО Оценивать свои силы!
 Развития:       Развиваться, Учиться, учиться и ещё раз - учиться, Саморазвитие
 Не Надеяться:   Надеяться только на себя
 Контроль:       Быть менее Эмоциональным, Совладать с Эмоциями, Контролировать свои эмоции в любой ситуации
 Внимательность: Быть Внимательным
 Спокойствие:    Быть Спокойнее, Перестать Нервничать , Быть Расслабленным, Не Злиться на себя и на других
 Режим:          Правильный Сон, Пить Воду
 Зарядка:        Бег, Тренировки, Стойка на Голове
 Тельце в тепле: НЕ переохлаждаться

 Молчание золото:  Лучше промолчать, чем сказать и потом жалеть о том, что сказал
 Соломон:          Все пройдёт, и это тоже пройдёт
 Вообще это замечательный подход: осознать, что проблема не такая уж и проблема, и вполне решаема.
 Кто ищет-тот всегда найдет!
 Искать Другие способы
 Не спеши, а то успеешь...   Успеешь, но не туда куда хотел...
 Подумай, нужно ли тебе ЭТО и для Чего
 Надо принимать вещи такими, как они есть, и пользоваться ими с наибольшей для себя выгодой.
 Если научиться принимать вещи как они есть, страдание исчезнет.
 У каждого свои недостатки


 Примерные цифры + у каждого свои способности! Миф
 Пирамида Обучения Дейла или Конус опыта Дейла:
 Мы запоминаем в среднем:
 10% того, что читаем,
 20% того, что видим,
 30% того, что слышим,
 50% того, что видим и слышим,
 70% того, что обсуждаем с другими людьми
 90% того, что делаем.

 ЧТЕНИЕ ВСЛУХ для запоминания лучше чем про себя.
 ЧТЕНИЕ ВСЛУХ - увеличению словарного запаса, развитию памяти и повышению грамотности человека.
________________________________________________________________________________________________________________________


 КОД ЧИТАЕТСЯ ГОРАЗДО ЧАЩЕ, ЧЕМ ПИШЕТСЯ.

 Запоминать, думаю, не надо - главное помнить, что такое есть. И при необходимости загуглить, чтобы напомнить себе
 синтаксис. Главное, уметь это применять там, где оно нужно.

 Главный навык настоящего времени - умение гуглить, а не пытаться запомнить все и сразу

 Python — мультипарадигменный язык программирования со СТРОГОЙ ДИНАМИЧЕСКОЙ ТИПИЗАЦИЕЙ
 СТРОГАЯ ТИПИЗАЦИЯ - означает, что операции между разными типами данных требуют явного их преобразования

 ДИНАМИЧЕСКАЯ ТИПИЗАЦИЯ - при котором переменная связывается с типом в момент присваивания значения,
 а не в момент объявления переменной

 Многие истины, за которые мы цепляемся, зависят от нашей собственной точки зрения.

 Python – кросс-платформенный язык, поэтому он работает практически везде, от смартфонов до серверов,
 с разными операционными системами, от Windows, Linux и MacOS до Symbian и Android.

 Почти каждый язык программирования эквивалентен машине Тьюринга и, следовательно, имеет «равную мощность»

 Turing machine(Машина Тьюринга) - представляет собой простейшую вычислительную машину с линейной памятью, которая
 согласно формальным правилам перехода преобразует входные данные с помощью последовательности элементарных действий.

 Несмотря на простоту модели, она способна реализовать любой компьютерный алгоритм.
 Алгоритм — это упорядоченный набор действий, который необходимо выполнить для решения поставленной задачи.

 Алгоритмы в Python — это набор инструкций, написанных на языке программирования Python, которые определяют порядок
 выполнения операций для решения определенной задачи.

 Эвристический метод, или просто эвристика, — это метод, который приводит к решению, не гарантируя, что оно — лучшее или оптимальное

 Приближенное решение: ЭВРИСТИЧЕСКИЕ АЛГОРИТМЫ часто находят решения, которые достаточно хороши для практических нужд,
 но не обязательно являются оптимальными.

 Жадные алгоритмы
 ЖАДНЫЙ АЛГОРИТМ (greedy algorithm) — это алгоритм, который на каждом шагу делает локально наилучший выбор в надежде,
 что итоговое решение будет оптимальным.
 ЖАДНЫЙ АЛГОРИТМ (англ. Greedy algorithm) — алгоритм, заключающийся в принятии локально оптимальных решений на каждом этапе

 ЛИНЕЙНЫЙ АЛГОРИТМ  O(n)
 Используя Big O нотацию: O(n), или «сложность порядка n (order n)».   O(n) - ЛИНЕЙНОЕ ВРЕМЯ
 Так же такой тип алгоритмов называют «линейными» или что алгоритм «линейно масштабируется».
 ЛИНЕЙНЫЙ АЛГОРИТМ — алгоритм, в котором вычисления выполняются строго последовательно.

 Псевдокод - это неформальный язык описания алгоритмов. Задача - обеспечить понимание алгоритма человеком
 Язык программирования - это формальный язык, предназначенный для написания компьютерных программ.

 в Python НЕТ Оператора - goto, потому что есть способы ветвления(if, or, and , if/else) и циклы (while, for, continue, break)
 goto - Прыжки по коду. Оператор перехода к определённой точке программы, обозначенной номером строки либо меткой.

 Языки низкого уровня — это машинный код и ассемблер.
 Машинные языки и машинно-ориентированные языки — это языки низкого уровня

 Ассемблер —  Он нужен для программирования микроконтроллеров или написания программ, которые работают с процессорами напрямую
 На ассемблере пишут драйверы устройств и некоторые компоненты операционных систем — например, ядро или загрузчик.

 Ассемблер - напрямую взаимодействует с процессором, и каждая его команда представляет собой инструкцию для процессора,
 а не для операционной или файловой системы. Процесс перевода языка ассемблера в машинный код называется ассемблированием.

 Несмотря на видимое отличие в сложности между Python и Ассемблером, важно понимать, что каждая команда Ассемблера выполняет
 всего лишь одну операцию, в то время как одна команда Python вызывает несколько операций процессора при выполнении.

 В Ассемблере почти не тратится зря процессорное время. Низкоуровневый двоичный ассемблер

 В чем разница между языком низкого, среднего и высокого уровня?

 Да, это просто общие термины. Это связано с абстракцией и с тем, насколько вы близки к тому, что на самом деле делает компьютер.

 Вот список языков программирования от очень низкого до очень высокого уровня:

 - Машинный код, вероятно, можно считать языком программирования самого низкого уровня.
 - Язык ассемблера находится на уровне указания процессору, что делать. Еще есть этап преобразования в машинный код.
 - C — это шаг вперед по сравнению с ассемблером, потому что вы можете указать, что вы хотите сделать, в несколько более
   абстрактных терминах, но вы все еще довольно близки к железу.
 - C++ делает все, что может C, но добавляет возможность абстрагировать элементы в классы.
 - Java / C# в чем-то похожи на C++, но без возможности делать все, что вы можете делать в C (например, манипулирование
   указателями в случае Java [спасибо, Джо!]). Однако у них есть сбор мусора, который вам придется делать вручную на C++.
 - Python / Ruby представляют собой еще более высокий уровень и позволяют забыть о многих деталях, которые вам нужно
   будет указать в чем-то вроде Java или C#.
 - SQL — еще более высокий уровень (он декларативный). Просто скажите: «Дайте мне все предметы в таблице,
   отсортированные по возрасту», и программа найдет для вас наиболее эффективный способ сделать это.

 От низкого к высокому вы можете классифицировать языки следующим образом:
 Машинный код -> Язык ассемблера -> Скомпилированный язык -> Интерпретируемый язык

 Python - высокоуровневый язык программирования
 Высокоуровневый язык программирования — язык программирования, разработанный для быстроты и удобства использования
 программистом. Основная черта высокоуровневых языков — это абстракция.

 Высокоуровневый язык программирования предоставляет более абстрактные концепции и инструменты, позволяющие
 программистам сконцентрироваться на решении задач, а не на деталях работы компьютера.

 Высокоуровневый язык программирования — язык программирования, использующий высокий уровень абстракции для быстрой
 и упрощенной записи компьютерных программ. В таком ЯП для описания структур данных и операций над ними используются
 смысловые конструкции, понятные человеку.

 Популярные языки программирования высокого уровня: Python, JavaScript, C, C++, C#, Java, PHP, Ruby и другие

 Python является мультипарадигменным языком программирования, поддерживающим: императивное, процедурное, структурное,
 объектно-ориентированное программирование, метапрограммирование, функциональное программирование(заточено под многопоточку)
  и асинхронное программирование.

 Мультипарадигменный язык программирования — это язык программирования, который поддерживает несколько парадигм программирования

 Парадигма, в программировании (ПОДХОД К ПРОГРАММИРОВАНИЮ) — это совокупность идей и понятий,
 определяющих стиль написания компьютерных программ.

 Парадигмы программирования — (ПОДХОД К ПРОГРАММИРОВАНИЮ) это совокупность методов, концепций, принципов, техник и инструментов,
 которые определяют способ организации программы на языке программирования и ход её выполнения.

 Парадигма программирования — это классификация, стиль или способ программирования.

 ДВЕ ОСНОВНЫЕ ПАРАДИГМЫ: ИМПЕРАТИВНАЯ и ДЕКЛАРАТИВНАЯ.

 Императивный подход описывает, каким образом ты что-то делаешь.
 Декларативный описывает, что именно ты делаешь.

 ИМПЕРАТИВНОЕ ПРОГРАММИРОВАНИЕ - содержит прямые указания, что должен сделать компьютер и в каком порядке должны выполняться инструкции
 ИМПЕРАТИВНОЕ ПРОГРАММИРОВАНИЕ - Инструкции должны выполняться последовательно.

 ИМПЕРАТИВНОЕ ПРОГРАММИРОВАНИЕ — оно же «приказывающее» или «повелительное» — подразумевает парадигму,
 в которой мы описываем последовательные команды, которые должен совершить процессор, чтобы получить необходимый нам результат

 Примерами императивных языков -  Java, Python, JavaScript, C, C++, ...
 Node. js — не отдельный язык программирования, а платформа для использования JavaScript на стороне сервера.
 Node.js – это кроссплатформенная среда для разработки клиентских приложений, в основе которой лежит язык программирования JavaScript.
 Node.js (Node) — это платформа с открытым исходным кодом для работы с языком JavaScript

 Node.js работает на движке V8, транслирующем JavaScript в машинный код. Простыми словами, Node.js — это приложение на C++,
 которое получает на входе код JavaScript и выполняет его.

 ДЕКЛАРАТИВНОЕ ПРОГРАММИРОВАНИЕ - во главе которой ставится описание ожидаемого результата.
  Мы не описываем шаги для достижения цели, а описываем то, что хотим получить.
 Примеры декларативных языков  -  SQL   HTML   CSS

 Обобщённое программирование - задачи обобщённого программирования решаются за счёт отсутствия ограничений на типы данных.
 Достигается использованием средств языка совместно со внешними анализаторами кода: Mypy

 Функциональное программирование -  в центре внимания которой находятся функции.
 - функция является объектом первого класса
 - функции высших порядков: functools
 - фокус на работу со списками
 - рекурсии, замыкание, частичное применение функции с помощью метода partial(), карринг, ...
 - operator и functools для функционального программирования

 Модульное программирование - просто дает возможность разбиения программы на модули.

 Метапрограммирование - связанный с созданием программ, которые порождают другие программы как результат своей работы.
 Метаклассы являются основным инструментом метапрограммирования в Python.

 Аспектно-ориентированное программирование (АОП) - основанная на идее разделения функциональности для улучшения
 разбиения программы на модули.
 Базовая поддержка аспектно-ориентированного программирования реализуется за счёт Метапрограммирования.

 Структурное программирование - в основе которой лежит представление программы в виде иерархической структуры блоков.
 Позволяет писать программу как набор блоков. Такими блоками являются ветвления, циклы, последовательность операторов
 Основные конструкции - это последовательность действий, ветвление(развилка) и циклы.

 Процедурное программирование - возможность программисту определять каждый шаг в процессе решения задачи.
 Программирование на императивном языке, при котором последовательно выполняемые операторы можно собрать в подпрограммы.

 Функция - подпрограмма, выполняющая какие-либо операции и возвращающая значение.
 Процедура - подпрограмма, которая только выполняет операции, без возврата значения.

 В питоне нет понятия процедуры, только функции и методы (это функции у классов).

 Статический прием типизации данных устанавливает тип переменной в процессе компиляции,
 а динамический — во время работы программы. Статически типизированный язык программирования
 проверяет переменную и присваивает ей тип, который в дальнейшем нельзя изменить

 Интерпретатор - преобразует исходный код Python в машинные инструкции, которые процессор может понять и выполнить.
 Когда вы запускаете скрипт или программу на Python, интерпретатор считывает код,
 проверяет его синтаксис на ошибки и построчно выполняет инструкции (сверху вниз)

 Интерпретатор - это программа, которая выполняет построчно сценарий непосредственно на языке высокого уровня, а
 не переводит его в машинный код. Для большинства пользователей Python интерпретатором, который вы используете, является CPython .

 Субинтерпретатор — это копия полного интерпретатора CPython, которая может работать независимо от
 основного интерпретатора, запускаемого вместе с вашей программой.

 Компилятор — программа, переводящая написанный на языке программирования текст в набор машинных кодов.

 Главное отличие компилируемых языков от интерпретируемых в скорости выполнения программ.
 Компилируемые языки: работа в два этапа 1) Компиляция - перевод в машинный код 2) Исполнение - запуск на пк
 Интерпретируемые языки: работа построчно , построчно исполняет интерпретатор.

 Приоритет операторов:
 3. **Инверсия** (NOT)      - `not`
 1. **Конъюнкция** (AND)    - `and`
 2. **Дизъюнкция** (OR)     - `or`
 4. **Импликация** (→)      - `<=` (обычно не реализуется напрямую в Python, но можно использовать для описания логики)
 5. **Эквивалентность** (↔) - `==`


 Приоритет операторов:
 Скобки                 ()
 Степень                **
 Унарный минус          -
 Умножение, деление     */ // %
 Сложение, вычитание    +-


 # Скобки помогают возводить в степень отрицательные числа.
 a = (-5)**2
 b = -5**2
 print(a)     # -> -25
 print(b)     # -> 25

 print((-5))  # -> -5


 -- Деление --

 # Деление с положительные цифрами     # Деление с отрицытельными цифрами      # Два операнда отрицытельными цифрами
 print(42 / 5)    # -> 8.4             print(-42 / 5)   # -> -8.4              print(-42 / -5)   # -> 8.4
 print(42 // 5)   # -> 8               print(-42 // 5)  # -> -9                print(-42 // -5)  # -> 8
 print(42 % 5)    # -> 2               print(-42 % 5)   # -> 3                 print(-42 % -5)   # -> -2

 # Если число меньше делителя
 print(5 % 10)   # -> 5
 print(5 // 10)  # -> 0

 # При Обычном делении / мы всегда получаем float()
 print(10 / 2)    # -> 5.0
 # При делении нацело // мы всегда получаем int()
 print(10 // 2)   # -> 5

 # Как узнать корень   Математический знак корня (символ - √)
 print(81**0.5)          # -> 9.0
 import math
 print(math.sqrt(81))    # -> 9.0


 # Разбиение на цифры
 print(123 % 10)    # -> 3   # Последняя цифра (единицы, младший разряд)
 print(123 // 10)   # -> 12  # Отбросить Последняю цифру
 print(12 % 10)     # -> 2   # Десятки
 print(123 // 100)  # -> 1   # Сотни


 # Сравнение Строк Подумай почему!   Сравнение по таблице ASCII
 print('a' == 'A')      # -> False
 print('good' > 'bad')  # -> True
 print('abcdef' > 'z')  # -> False  # Длина не влияет!


 # Умножение списков
 a_list = [3, 2, 1] * 2
 print(a_list)  # -> [3, 2, 1, 3, 2, 1]

 # Умножение строк
 a_str = 'Python' * 2
 print(a_str)   # -> PythonPython


 # Интересный вывод сначала думал что будет ошибка...
 print(("3" + "4") * (2 + 1))  # -> 343434


 # Интересный пример
 voice = "baritone"
 print(voice[-9])   # -> IndexError: string index out of range


 Как компьютер хранит информацию?
 Самая маленькая единица информации в компьютере – это бит
 Он может принимать либо значение 0, либо 1 в уже знакомой нам двоичной системе счисления.

 1 байт = 8 бит
 1 килобайт = 1024 байт
 1 мегабайт = 1024 килобайт
 1 гигабайт = 1024 мегабайт
 1 терабайт = 1024 гигабайт

 Обозначений значительно больше
 К примеру:
 Гугол (googol) - это число со 100 нулями, а именно 10 ** 100.
 Число Грэма — самая большая цифра в математике.

 В одном байте у нас 8 бит, следовательно мы имеем всего 8 ячеек в которые можно положить либо 0, либо 1.
 в 1 байте 8 позиций, которые могут принимать два числа, то общее число возможных чисел будет равно =
 # 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 = 2**8 = 256 = различных значений.
 Выходит, что мы сможем хранить в таком устройстве положительные числа от 0 до 255.

 # Для целых чисел существует такая вещь, как ДЛИННАЯ АРИФМЕТИКА
 # При использовании длинной арифметики вычисления происходят МЕДЛЕННЕЕ, но зато это очень удобно.
 print(12312312312312312312312312312312312312312312312312312 + 12312312312312312312312312312312312312312312312312312)
 # 24624624624624624624624624624624624624624624624624624

 # Кстати к float ДЛИННАЯ АРИФМЕТИКА не относится
 print(1111111111234234.11111111111111234323423)  # 1111111111234234.1


 -- Как изучать программирование (PYTHON, но не только) --

 1) официальная документация. Должна быть в закладках, используем, читаем, используем поиск, всегда начинаем с нее.  python.org
 2) английский язык. Он обязателен, ничего не поделать, начинаем хотя бы с чтения со словарем.
 Программа минимум - свободное чтение, максимум - разговорный, который открывает в том числе карьерные возможности.
 3) книги. Одной волшебной книги нет, читаем их побольше, обязательно конспектируем, не ноем про "воду",
 все ПРИМЕРЫ НАБИРАЕМ РУКАМИ, все задания в конце глав прорешиваем. Не забываем экспериментировать с кодом. Советую:
 Марк Лутц "Изучаем Пайтон"
 Dan Bader "Python Tricks: The Book"
 Luciano Ramalho "Fluent Python"
 Дэвид Бизли "Книга рецептов" (только после предыдущих книг)

 4) гугл. Секретный и неизвестный никому в 21 веке ресурс. Учимся им пользоваться и искать нужное.
 Не задаем вопрос кому бы то ни было, не погуглив проблему.


 --- Правильные переносы Длинного Кода/Строки Python ---

 Используйте слеш \ для переноса строк (любых).  или Лучше Нажать Ctrl + Alt + L    в  PyCharm        <-----

 Пример:
 lines = *map("".join, field), \
         *map("".join, zip(*field)), \
         *map("".join, zip(*((row[index], row[-index - 1],)
                             for index, row in enumerate(field))))

 Почему for так нужно форматировать - потому что здесь он часть конструкции (generator expression):
                                                                          # Тоже самое с формативанием
 ((row[index], row[-index - 1],) for index, row in enumerate(field))      ((row[index], row[-index - 1],)
                                                                           for index, row in enumerate(field))

 Вообще, кроме pep8 существует Дзен Python и здравый смысл в конце концов, и лучше бы это нечитаемое нагромождение кода
 расписать на несколько отдельных строк БЕЗ всяких извращений.                                      <-----   <-----

 Flake8 — это инструмент для проверки кода на соответствие стандартам стиля PEP 8 и поиска ошибок в Python.

 Перенос в Контекстном менеджере '/'
 with open('/path/to/some/file/you/want/to/read') as file_1, \       #  Косая черта   Backslash  для переноса
      open('/path/to/some/file/being/written', 'w') as file_2:
     file_2.write(file_1.read())

 Списки/Кортежи/Словари можно объявлять двумя способами:
 # Первый вариант!                                  # Второй вариант!
 my_list = [                                        my_list = [
     1, 2, 3,                                           1, 2, 3,
     4, 5, 6,                                           4, 5, 6,
     ]                                              ]

 result = some_function_that_takes_arguments(       result = some_function_that_takes_arguments(
     'a', 'b', 'c',                                     'a', 'b', 'c',
     'd', 'e', 'f',                                     'd', 'e', 'f',
     )                                              )

 # Перенести можно с помощью '\'

 # Перенос с ф-строками                                          # Тоже самое
 print(f'number {10} '                                           print(f'number {10} string {str(10)}')
       f'string {str(10)}')  # -> number 10 string 10            # -> number 10 string 10

 # Проблема Пробелов!!! в Выводе Много пробелов!
 list_of_words = ["The weather is good.",
                  "Hot dog is the best food, \
                  it would be a sure sign that it was still yummy.",]
 print(*list_of_words)
 # -> The weather is good. Hot dog is the best food,                  it would be a sure sign that it was still yummy.

 # Исправили Проблему пробелов!
 list_of_words = ["The weather is good.",
                  "Hot dog is the best food,"
                  "it would be a sure sign that it was still yummy.",]
 print(*list_of_words)
 # -> The weather is good. Hot dog is the best food,it would be a sure sign that it was still yummy.

 --- END Правильные переносы Длинного Кода/Строки Python ---


 в Python выражения (x) и x Обычно означают одно и тоже
 x = 5
 print((x))  # -> 5
 print(x)    # -> 5


 +=  быстрее чем +  при  объединение более двух строк.    еще вместо + можно использовать  f-string  или ''.join
 Пример замеров скорости:
 # Использование "+" к строкам
 print(timeit("s1 = s1 + s2 + s3", setup="s1 = ' ' * 100000; s2 = ' ' * 100000; s3 = ' ' * 100000", number=100))
 # 0.6025011998135597
 # Использование "+="  к строкам:
 print(timeit("s1 += s2 + s3", setup="s1 = ' ' * 100000; s2 = ' ' * 100000; s3 = ' ' * 100000", number=100))
 # 0.2828226999845356
 += быстрее, чем + при объединение более двух строк, поскольку первая строка (например, s1 for s1 += s2 + s3)
 не уничтожается при вычислении полной строки.


 Подумайте о том, что происходит в операции n += 1. Python должен проверить, есть ли у объекта n функция добавления
 (и если это не так - он поднимает все унаследованные классы, чтобы узнать, предоставляют ли они эту функцию).
 Затем другой объект (1 в данном случае) передается так, чтобы функция добавления могла решить, как обрабатывать операцию.
 Помните, что вторым аргументом может быть любой другой объект не обязательно совместимый. Все это происходит ДИНАМИЧЕСКИ.


 -- Способы присваивание значений --
 # Интересный момент
 a, *b, c = [1, 4]
 print(a, b, c)  # -> 1 [] 4

 a, *b, c = [4]
 print(a, b, c)  # -> ValueError: not enough values to unpack (expected at least 2, got 1)

 *a, b, c = 'No money', 'no honey'
 print(a, b, c)  # -> [] No money no honey

 # *values = [1, 2, 3, 4, 5]  # -> SyntaxError: starred assignment target must be in a list or tuple
 # слева при распаковке должен стоять кортеж.
 *values, = [1, 2, 3, 4, 5]                         # Ставим висячую запятую ,
 print(values)               # -> [1, 2, 3, 4, 5]

 Цепочки присваивания значений:
 # Каскадное присваивание
 a = b = c = 0
 print(a, b, c) -> 0, 0, 0
 Присваивание с распаковкой можно использовать для обмена значениями переменных:
 a, b = b, a
 Примеры распаковки/упаковки последовательностей:
 # Множественное присваивание.
 a, b, c = 0, 5, 10
 print(a, b, c) -> 0 5 10

 a, b, c = 'abc'
 print(a, b, c) -> a, b, c

 a, b, *c = 'abc'
 print(a, b, c) -> a b ['c']

 a, b, c = ['one', 'two', 'three']
 print(a, b, c) -> one two three

 a, *b = ['one', 'two', 'three']
 print(a, b) -> one ['two', 'three']

 new = 'NEW'
 lst = [*new]
 print(lst)  # -> ['N', 'E', 'W']

 РАСПАКОВКА РАБОТАЕТ С ЛЮБЫМ ИТЕРИРУЕМЫМ ОБЪЕКТОМ!
 data = ['ACME', 50, 91.1, (2012, 12, 21)]
 name, shares, price, (year, mon, day) = data
 print(name, shares, price, (year, mon, day))  # -> ACME 50 91.1 (2012, 12, 21)

 Распаковка итерируемых объектов в переменные с помощью расширенной распаковки:
 fruits = ['lemon', 'orange', 'banana', 'tomato']
 first, second, *orher = fruits
 print(orher) -> ['banana', 'tomato']

 first, *middle, last = fruits
 print(middle) -> ['orange', 'banana']

 Распаковка итерируемых объектов может быть вложенной:
 fruits = ['lemon', 'orange', 'banana', 'tomato']
 ((first_letter, *other_letter), *other) = fruits
 print(first_letter, other_letter) -> l ['e', 'm', 'o', 'n']
 print(other) -> ['orange', 'banana', 'tomato']

 Упаковка итерируемых объектов (сложение) в новый список:
 fruits = ['lemon', 'orange', 'banana', 'tomato']
 x = [*fruits, *reversed(fruits)]
 print(x) -> ['lemon', 'orange', 'banana', 'tomato', 'tomato', 'banana', 'orange', 'lemon']

 x = [*fruits[2:], *fruits[:2]]
 print(x) -> ['banana', 'tomato', 'lemon', 'orange']

 # Здесь создадим кортеж
 x = (*fruits[1:], fruits[0])
 print(x) -> ('orange', 'banana', 'tomato', 'lemon')

 Оператор "моржа" walrus в Python :=
 Присваивание значений в выражении walrus в Python :=

 # Повторно использовать значение, которое дорого вычислять
 [y := f(x), y**2, y**3]

 x = y = z = 0   # Эквивалент  (z := (y := (x := 0)))

 Примеры использования оператора walrus Морж.
 # `func()` вызывается 3 раза:
 result = [func(x), func(x)**2, func(x)**3]

 # Повторно используется только результат `func()`:
 result = [y := func(x), y**2, y**3]
 Да, можно просто добавить y = func(x) перед объявлением списка, и тогда не нужен оператор walrus, но это одна
 дополнительная ненужная строка кода.

 # `func()` вызывается 2 раза
 result = [func(x) for x in data if func(x)]
 # `func()` вызывается только 1 раз
 result = [y for x in data if (y := func(x))]

 Как применить метод или функцию к последовательности объектов?
 result = [obj.method() for obj in mylist]     result = [function(obj) for obj in mylist]

 for obj in mylist:        for obj in mylist:
    obj.method()               function(obj)

 ОБЯЗАТЕЛЬНО ВЫУЧИТЬ!
 Хитрые ВЕЩИ Python  -  Знание этих придирок может в долгосрочной перспективе сэкономить вам часы отладки:
 1):
 x, y = (0, 1) if True else None, None              x, y = (0, 1) if True else (None, None)
 print(x, y)  # -> (0, 1) None                      print(x, y)  # -> 0 1

 2):
 t = ('one', 'two')             t = ('one')                     t = ()
 for i in t:                    for i in t:                     print(t) # -> ()
     print(i) # -> one two          print(i) # -> o n e

 t = ('one', 'two')             t = ('one',) #  t = 'one',      t = () # () специальный токен и обозначает пустой tuple.
 for i in t:                    for i in t:                     print(t) # -> tuple()
     print(i) # -> one two          print(i) # -> one

 3): Неявная конкатенации строк:  ["1"  "2", "3"] # -> ['12', '3'] , len(["1"  "2", "3"]) # -> 2
 four_words_list = [
     "A",
     "B",
     "C"           # <---- !!!!!  ОТСУТСТВУЕТ ЗАПЯТАЯ  ','   неявная конкатенации строковых литералов
     "D",
 ]
 print(four_words_list)        # -> ['A', 'B', 'CD']
 print(len(four_words_list))   # -> 3

 4): НЕПУСТЫЕ кортежи оцениваются как True
 a = "python"
 b = "javascript"
 assert (a == b, "not equal") # -> SyntaxWarning: assertion is always true, perhaps remove parentheses? # НЕ Правильно
 assert a == b, "not equal"   # -> AssertionError: not equal  # Правильно
 assert a == b  # -> AssertionError   тоже самое ->   # assert (a == b)  # -> AssertionError

 5:) Методы Изменяют объекты на месте и возвращают None

 НЕ ПРАВИЛЬНО!!!                          ПРАВИЛЬНО!!!
 a_list = [1, 2, 3]                       a_list = [1, 2, 3]
 a_dict = {"key_1": 1,"key_2": 2,}        a_dict = {"key_1": 1,"key_2": 2,}
 a_set = {1, 2, 3}                        a_set = {1, 2, 3}
 Методы “in-place”                        Методы “in-place”
 a_list = a_list.append(4)                a_list.append(4)
 a_dict = a_dict.update({"A": 3})         a_dict.update({"A": 3})
 a_set = a_set.add(4)                     a_set.add(4)
 print(a_list) # -> None                  print(a_list) # -> [1, 2, 3, 4]
 print(a_dict) # -> None                  print(a_dict) # -> {'key_1': 1, 'key_2': 2, 'A': 3}
 print(a_set)  # -> None                  print(a_set)  # -> {1, 2, 3, 4}
 Смысл заключается в повышении производительности за счет отказа от копирования объекта, если операцию можно выполнить на месте.


 Имена Переменных
 - Могут содержать ТОЛЬКО [a-z, A-Z], [0-9] и нижнее подчеркивание _    \w
 - Интерпретатор чувствительный к регистру a != A
 - Давать переменным такие имена, которые передают смысл хранимых в них значений.
 - Имя переменной не может совпадать с ключевым словом  НО с Мягким ключевым словом может
 - Всё пишем на Англ языке    кириллицу[а-яёА-ЯЁ] можно но  НЕ нужно

 # Первый символ не должен быть цифрой, только буквой или нижним подчёркиванием.
 1a = 10  # -> SyntaxError: invalid decimal literal

 # Не могут содержить символы  кроме нижнего подчеркивание _
 a!b = 10  # -> SyntaxError: invalid syntax

 # Если нужно разделить переменную лучше используем snake_case
 my_variable = 10


 Переменные связываются с объектами ТОЛЬКО после создания объектов.    <-----
 class Gizmo:
     def __init__(self):
         print(f'Gizmo id {id(self)}')

 x = Gizmo()       # -> Gizmo id 1818795939984

 # Создается объект Gizmo   НО!  Переменная y так и НЕ будет создана
 y = Gizmo() * 10  # -> Gizmo id 2153632369872
 # TypeError: unsupported operand type(s) for *: 'Gizmo' and 'int'

 В Python присваивание происходит СПРАВА НАЛЕВО. Сначала вычисляется значение правой части
 (объект создается или извлекается), а затем это значение связывается с переменной слева.
 Всегда сначала читайте ПРАВУЮ часть, ту, где объект создается или извлекается                    <-----

 Переменная лишь указывает на данные - хранит ссылку, а не сами данные.
 Переменные — это просто имена, ссылающиеся на объекты
 Идентификатор - Присваивание значения идентификатору связывает переменную с этим именем.
 Переменные(variables) в Python — это именованные ссылки на объекты, которые хранятся в памяти компьютера.
 Свободные переменные(Free variables) - Если переменная используется в блоке кода, но не определена там
 Связанная(ограниченные) переменная(Bound variables) -  Локальные, глобальные переменные и параметры
 Свободная переменная — это переменная, которая не является локальной (внутренней) для функции
 Свободная переменная — это переменная, не связана в локальной области видимости.

 Пример:
 f(x) = x * z
 z - свободная переменная, поскольку она не привязана ни к одному параметру.
 x - является Связанной, ограниченной переменной

 Python делает это различие из-за замыканий.
 Является ли переменная свободной или связанной, является относительным; это зависит от фрагмента кода, который вы просматриваете.

 Переменные сами по себе не являются объектами; это просто строковые ключи в словаре, формирующем пространство имен.
 Для функций локальное пространство имен даже не является словарем; имена компилируются в индексы массива.

 Подводные камни (ловушки цепочек сравнения):
 Тождество - равенство двух выражений. В Python Тождество: ==
 Транзитивный - переходный,  способный иметь прямое дополнение. В Python транзитивно: а = b и b = с вытекает а = с
 Нетранзитивные операторы:

 a = c = 1
 b = 2
 print(a == b == c) -> False
 print(a != b != c) -> True   # ЛОВУШКА
 print(a != b and b != c and c != a) -> False

 Смешивание операторов в цепочках сравнений:
 Важно правильно раставлять приоритеты!
 a = 0
 print(a is a < 1)   -> True
 print((a is a) < 1) -> False
 print(a is (a < 1)) -> False

 Преобразование строк в список, кортеж или множество символов:
 a = 'abc'
 tuple_a = tuple(a)
 list_a = list(a)
 set_a = set(a)
 dict_a = dict(a)   # -> ValueError: dictionary update sequence element #0 has length 1; 2 is required
 print(tuple_a)     # -> ('a', 'b', 'c')
 print(list_a)      # -> ['a', 'b', 'c']
 print(set_a)       # -> {'c', 'b', 'a'}
 print(dict_a)      # -> ValueError: dictionary update sequence element #0 has length 1; 2 is required

 Использование необработанных (сырых) строк Python  r"":
 print('C:\some\name')        print(r'C:\some\name')
 # C:\some                    # C:\some\name
 # ame

 Python очень медленный из-за Динамической типизации
 Интерпретатор Python совершает очень много действий для того, чтобы выяснить какого типа переменная

 Monkey patch (обезьяний патч) — Это просто динамическая замена атрибутов/функций во время выполнения
 class A:
    def func(self):
        return "Hello"

 def new_func(self):
     return "Hello, World"

 A.func = new_func          # monkey-patch        <-----

 Проще говоря, Monkey patch вносит изменения в модуль или класс во время работы программы.
 MonkeyPatch — это часть кода Python, которая расширяет или изменяет другой код во время выполнения (обычно при запуске).

 Простой пример выглядит так:
 from SomeOtherProduct.SomeModule import SomeClass

 def speak(self):
     return "ook ook eee eee eee!"
 SomeClass.speak = speak     # monkey-patch       <-----

 Поскольку классы Python изменяемы, а методы — это всего лишь атрибуты класса, вы можете делать это сколько угодно — и,
 по сути, вы можете даже заменять классы и функции в модуле совершенно таким же образом.
 Будьте осторожны при использовании monkeypatching!                                                            <-----


 Вопрос: Чем фреймворк отличается от библиотеки?
 ФРЕЙМВОРК(большая библиотека) - использования инструментов/функций по строгим правилам
 БИБЛИОТЕКА - просто набор инструментов/функций которые используем как хотим
 Библиотека - это общий термин, обозначающий фрагмент кода, который можно использовать повторно.

 Одинарный символ подчеркивания _:
 Иногда используется в качестве имени временных или незначительных переменных («неважных»). Кроме того, он представляет
 результат последнего выражения в сеансе интерпретатора REPL Python.

 for _ in range(32):                                                # Помечать можно функции   <-----
    print('Привет, Мир.')                                           def _():
                                                                        pass
 # Можно вторым или первым или любым так использовать _
 for i, _ in enumerate([1, 2, 3]):
     print(i, end=' ')  # -> 0 1 2

 car = ('красный', 'легковой автомобиль', 12, 3812.4)
 color, _, _, mileage = car
 print(color, _, _, mileage) -> красный 12 12 3812.4

 20 + 3 -> 23
 _ -> 23

 list() -> []
 _.append(1)
 _.append(2)
 _.append(3)
 _ -> [1, 2, 3]

 Одинарный замыкающий символ подчеркивания: var_
 Иногда самое подходящее имя переменной уже занято ключевым словом языка Python. По этой причине такие имена,
 как class или def, в Python нельзя использовать в качестве имен переменных. В этом случае можно в конец имени добавить
 символ одинарного подчеркивания, чтобы избежать конфликта из-за совпадения имен:

 def make_object(name, class):     ->  class
    pass
 SyntaxError: invalid syntax

 def make_object(name, class_):    ->  class_
    pass


 # После else может снова идти еще один блок  if/elif/else
 def _(res):
     if res.isupper():
         a = '1111'
     else:
         a = ''
     if a:
         return a
     else:
        return

 print(_('ABCDE')) # -> 1111


 Аннотации типов - подсказка какого типа агрумент приходит и что функция возвращает   def my_func(a: int, b: str) -> None:pass
 a: int = 10        a: "int" = 10        a: '''int''' = 10   def my_func(a: 'str', c: "int") -> list[str]:
 b: str = '10'      b: 'str' = '10'      и с двойными тоже      pass

 Аннотация(annotation) - подсказка типа(type hint) - подсказки типов данных в Python
 аннотации глобальных переменных, атрибутов классов и функций хранятся в  -  __annotations__
 Внутри функции аннотации для локальных переменных не сохраняются, поэтому к ним нельзя получить доступ внутри функции.
 Только аннотации для переменных на уровне модуля и класса приводят к __annotations__ присоединению объекта.
 Основными встроенными типами для аннотаций типов являются Generic Alias и Union .
 Объекты GenericAlias - (добавлен в Python 3.9.) создаются путем подписки на класс (обычно контейнер), например list[int].
 Они предназначены в первую очередь для аннотаций типов.

 Внимание. Интерпретатор Python не проверяет и не принимает во внимание аннотации типов функций и переменных. Их могут
 использовать сторонние инструменты, такие как средства проверки типов, IDE, линтеры и т. д.

 Аннотация типа показывает методы которые может использовать тип данных (класс). Без аннотации не показывает. - в PyCharm
 в Pycharm это - Ctrl+Space, Контрол+Пробел - посмотреть возможные методы

 Модуль typing обеспечивает поддержку выполнения аннотации типов. Наиболее фундаментальная поддержка состоит из типов:
 typing.Any, typing.Union, typing.Tuple, typing.Callable, typing.TypeVar и typing.Generic.

 from typing import Callable                     # Лучше используем    from collections.abc import Callable

 Линтеры: Они проверяют код на соответствие стандартам
 PEP 8 - является официальным стандартом написания кода на Python. Этот документ содержит рекомендации и правила,
 которым стоит следовать, чтобы ваш код был легко читаемым, понятным и единообразным.
 PEP (Python Enhancement Proposal, Предложение по улучшению Python) - это документ, в котором описаны новые функции, предложенные для Python
 Mypy — статический анализатор типов для Python, который позволяет находить ошибки несоответствия типов в коде

 -- Mypy ускоряет ли скорость работы кода в Python?  Сразу ответ НЕТ! --
 Нет, `mypy` не ускоряет скорость работы кода в Python. `mypy` — это статический анализатор типов, который проверяет
 корректность аннотаций типов в коде на этапе разработки. Он помогает выявлять ошибки типизации и улучшает качество кода,
 но НЕ влияет на производительность выполняемой программы.

 --- collections.abc — Абстрактные базовые классы для контейнеров ---

 В стандартной библиотеке Python есть несколько готовых абстрактных классов, которые можно использовать для
 наследования или проверки типа объекта.

 Этот модуль предоставляет абстрактные базовые классы , которые можно использовать для проверки того, предоставляет ли
 класс определенный интерфейс; например, является ли оно хешируемым или является ли оно отображением.

 - использования классов collections.abc - наследование классов для поддержки определенного интерфейса.


 issubclass(list, collections.abc.Iterable)    # проверяет, является ли класс list подклассом collections.abc.Iterable.
 isinstance(list(), collections.abc.Iterable)  # проверяет, является экземпляр list() экземпляром collections.abc.Iterable.
 Оба выражения возвращают True, но проверяют разные аспекты: классовую иерархию и экземпляр соответственно.


 # проверяет, является ли экземпляр пустого списка (list()) экземпляром collections.abc.Iterable. Вернет True, списки итерируемы.
 isinstance(list(), collections.abc.Iterable)  # -> True

 # проверяет, является ли класс list экземпляром collections.abc.Iterable. Вернет False, так как list — это класс, а не экземпляр.
 isinstance(list, collections.abc.Iterable)    # -> False


 АВС                    Наследует от            Абстрактные методы                 Миксинные методы

 Container [ 1 ]                                 __contains__

 Hashable [ 1 ]                                  __hash__

 Iterable [ 1 ] [ 2 ]                            __iter__

 Iterator [ 1 ]         Iterable                __next__                           __iter__

 Reversible [ 1 ]       Iterable                __reversed__

 Generator [ 1 ]        Iterator                send,throw                         close, __iter__, __next__

 Sized [ 1 ]                                    __len__

 Callable [ 1 ]                                 __call__

 Collection [ 1 ]       Sized, Iterable,        __contains__, __iter__,
                        Container               __len__

 Sequence               Reversible,             __getitem__, __len__               __contains__, __iter__,
                        Collection                                                 __reversed__, index, и count

 MutableSequence        Sequence                __getitem__, __setitem__,          Унаследованные Sequence методы и
                                                __delitem__, __len__,              append, clear, reverse, extend,
                                                 insert                            pop, remove, и __iadd__

 ByteString             Sequence                __getitem__, __len__               Унаследованные Sequence методы

 Set                    Collection              __contains__, __iter__,            __le__, __lt__, __eq__, __ne__,
                                                 __len__                           __gt__, __ge__, __and__, __or__,
                                                                                    __sub__, __xor__ и isdisjoint

 MutableSet             Set                     __contains__, __iter__,            Унаследованные Set методы и clear, pop,
                                                __len__, add, discard              remove, __ior__, __iand__, __ixor__, и __isub__

 Mapping                Collection              __getitem__, __iter__,             __contains__, keys, items, values,
                                                 __len__                           get, __eq__, и __ne__

 MutableMapping         Mapping                 __getitem__, __setitem__,          Унаследованные Mapping методы и pop,
                                                __delitem__, __iter__, __len__     popitem, clear, update, и setdefault

 MappingView            Sized                                                       __len__

 ItemsView              MappingView, Set                                            __contains__, __iter__

 KeysView               MappingView, Set                                            __contains__, __iter__

 ValuesView             MappingView, Collection                                     __contains__, __iter__


 Awaitable [ 1 ]                                __await__

 Coroutine [ 1 ]        Awaitable               send,throw                          close

 AsyncIterable [ 1 ]                            __aiter__

 AsyncIterator [ 1 ]    AsyncIterable           __anext__                           __aiter__

 AsyncGenerator [ 1 ]   AsyncIterator           asend,athrow                        aclose, __aiter__,__anext__

 Buffer [ 1 ]                                   __buffer__

 Сноски

 [ 1 ]( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 )
 Эти ABC переопределяются __subclasshook__() для поддержки тестирования интерфейса путем проверки наличия необходимых
 методов и того, что им не присвоено значение None. Это работает только для простых интерфейсов. Более сложные интерфейсы
 требуют регистрации или прямого создания подклассов.

 [ 2 ]
 Проверка isinstance(obj, Iterable) обнаруживает классы, зарегистрированные как Iterable или имеющие метод __iter__().
 но он не обнаруживает классы, которые выполняют итерацию с помощью метода __getitem__().
 Единственный надежный способ определить, является ли объект итеративным, — это вызвать iter(obj).


 Built-in Constants (Встроенные константы) Python contains singletons: None, True, False, Ellipsis, NotImplemented, __debug__
 являются единственными экземпляроми.
 Имена None, False, True и __debug__ не могут быть переназначены, поэтому их можно рассматривать как "истинную" константу.
 Любое присвоение другого значения для True, False, None, __debug__ ->  SyntaxError: cannot assign to True, False, None, __debug__

 None - является специальным объектом, который представляет отсутствие значения.

 # None является одиночным объектом и занимает фиксированное количество памяти!
 print(f'getsizeof None:  {sys.getsizeof(None)} байт')             # -> getsizeof None:  16 байт
 print(f'asizeof   None:  {asizeof.asizeof(None)} байт')           # -> asizeof   None:  16 байт
 None - Один из самых маленьких объектов по памяти!!!


 True - bool(True) -> True, True == 1, True == 1.0,  True = 'a' -> SyntaxError: cannot assign to True
 False - bool(False) -> False, False == 0, False == 0.0,  False = 'a' -> SyntaxError: cannot assign to False

 NotImplemented - это что-то вроде объявления о том, что функция не может обработать входные данные, но вместо
 возникновения исключения, интерпретатор запускает отраженную операцию но в перевернутом порядке входных аргументов.
 a.__eq__(b) -> b.__eq__(a)
 Если все попытки возвращают значение NotImplemented, интерпретатор возвращается к встроенному поведению
 (которое основано на идентичности для == и != ) и выдает соответствующее исключение.

 Ellipsis - представляет собой буквальное многоточие ... , для замены :,:,: в синтаксисе срезов.
 основное применение связано с библиотеками для научных расчетов, такими как NumPy и SciPy.
 Этот тип имеет одно значение ...   type(...) -> <class 'ellipsis'>, type(...)() -> Ellipsis
 bool(Ellipsis) -> True,  bool(...) -> True,  type(Ellipsis)() -> Ellipsis, type(Ellipsis) ->  <class 'ellipsis'>

 Ellipsis - НЕ теряет идентичность при сериализации.  Ellipsis в контексте сериализации означает, что объект может быть
 преобразован в формат, подходящий для хранения или передачи, без утраты своей идентичности или ключевых характеристик.


 # Кстати так тоже можно создавать функции  С такими отступами:                                     <-----
 def                func(lst)               :
                    pass


 Разница между ... и pass
 pass - означает блок, в котором не должно быть кода . Заглушка  Пустота.  Предназначен , чтобы явно ничего не делать.
 ...  - собираются заполнить позже (пустой блок) . Имеет тот же эффект, что и, например: def foo(): 1


 def function(): pass     class Foo(): pass
 def function(): ...      class Foo(): ...

 # Так тоже будет работать  Можно использовать вместо pass и ...       docstring вместо pass и ...            <-----
 def function():          class Foo():
    '''docstring'''           '''docstring'''

 Пустую функцию можно создать и так.  Функция будет создана без ошибок.
 def init_stuff():    def init_stuff():
    1                     'hello'

 None - для обозначения отсутствия значения. type(None) -> <class 'NoneType'> , type(None)() -> None, bool(None) -> False
 None = 1  -> SyntaxError: cannot assign to None

 __debug__ - __debug__ True, если Python не был запущен с опция командной строки -O
 Инструкция assert будет игнорироваться (не будет выполняться) интерпретатором Python, если запустить его в
 оптимизированном режиме (опция командной строки -O при запуске скрипта Python).
 __debug__ = False -> SyntaxError: cannot assign to __debug__

 PYTHONOPTIMIZE – это переменная окружения, которую можно использовать для управления поведением интерпретатора Python.
 Применяется для оптимизации скомпилированного кода. С его помощью можно удалить отладочную информацию, что в итоге
 ускоряет выполнение кода. Обычно -O удаляет из скомпилированного байт-кода docstrings и assert
 PYTHONOPTIMIZE=1 - Игнорирует документационные строки (docstrings), что может снизить использование памяти и немного
 ускорить выполнение
 PYTHONOPTIMIZE=2 - Кроме игнорирования docstrings, дополнительно отключает assert, что может привести к небольшому
 ускорению работы программы

 --- assert ---
 Вы говорите программе проверить это условие и немедленно вызвать ошибку, если условие ложно.
 Инструкция assert - это удобный способ вставить отладочные утверждения в программу. Этот оператор помогает обнаружить
 проблемы на ранних этапах программы, когда причина ясна, а не позже как побочный эффект какой-либо другой операции.

 Базовая форма инструкции утверждения assert в Python:
 assert expression

 # эквивалентно коду
 if __debug__:
     if not expression: raise AssertionError

 Расширенная форма инструкции утверждения assert в Python:
 assert expression1 expression2

 # эквивалентно коду
 if __debug__:
     if not expression1:
         raise AssertionError(expression2)

 Общий пример использования assert:
 Когда выражение в утверждении assert истинно, то ничего не происходит:
 assert 2 < 5

 assert поднимает исключение AssertionError:
 assert 2 > 5  -> AssertionError

 Пример утверждения assert с сообщением:
 assert expression, message

 assert 2 + 2 == 5, "Houston we've got a problem"

 Не используйте круглые скобки для вызова assert функции. Это заявление. Если вы это сделаете, assert(condition, message)
 Вы запустите assert кортеж (condition, message) в качестве первого параметра.
 assert True, 'no good'    # -> Ничего не происходит
 assert (True, 'no good')  # -> SyntaxWarning: assertion is always true, perhaps remove parentheses?

 Другие примеры!
 assert True   # nothing happens  Ничего не происходит
 assert False  # AssertionError
 assert [0]    # nothing happens  Ничего не происходит
 assert []     # AssertionError


 # Интересный пример
 def foo(n):
     assert n >= 2, 'Число НЕ подходит'
     return n ** 2

 print(foo(3))  # -> 9
 print(foo(1))  # -> AssertionError: Число НЕ подходит

 # Можно разные проверики делать!
 assert isinstance('1', int | float), 'BAD'  # -> AssertionError: BAD
 assert 1 in [1, 2, 3]

 -- Всегда проверяй свой код  Простое тестирование с assert --

 Любой программист на любом языке программирования обязан проверять свой код. "Пацан накодировал -пацан протестировал".
 Только тесты являются доказательством того, что ваш код работает, а вовсе не то, что вы на своей машине его запускали!
 В любой ситуации пиши тесты, в любой непонятной ситуации запускай тесты. Тесты это не только хороший тон, но еще и
 спокойный сон программиста и огромный плюс на собеседовании.
 ВНИМАНИЕ - не используйте ассерты в коде самого приложения! Только в тестах и вот таких проверках.

 Стандартный алгоритм действий:
 1) внимательно читаем задачу, многие ломаются еще на этом этапе =)
 2) пишем заготовку функции с аннотациями, реализацию не пишем
 3) пишем наши проверки, тщательно продумываем крайние случаи, что может прийти на вход. Если есть примеры ввода-вывода
 в задаче то добавляем их в проверки
 4) реализуем код, как угодно плохо, главная цель -тесты все должны работать. Кстати по мере опыта код с самого начала
 будет не таким и страшным
 5) если в ходе реализации или проверок находим слабые места в тестах, то добавляем новые проверки
 6) рефакторим код, делаем его короче, понятнее, читаемее
 7) профит!

 Польза от тестов:
 1) есть доказательство что код работает (пусть и на ограниченном наборе значений)
 2) поэтапно в реальном времени видим прогресс (все больше тестов выполняется)
 3) при готовом наборе имеем возможность безопасно рефакторить код
 4) можем поизвращаться, применить разные хитрые уловки, главное все время запускать тесты

 Это все работает и для больших проектов, правда там уже не на простых ассертах это реализуется, но принцип все тот же - сеть безопасности!

 -- Частые ошибки начинающих питонистов --
 Именование! Называем вещи своими именами, коллекции во множественном числе, функции -что делают
 Всегда используем ф-строки, НИКОГДА не складываем строки
 не делаем то, что происходит по-умолчанию (str(input))
 используем листкомпс и генэксп только если есть преобразование И/ИЛИ фильтрация
 лучше листкомпс, генэксп, чем map/filter
 используем while True для вечных циклов
 если список не нужен, используем генэксп
 не используем range (len(list)), если нужен индекс то используем enumerate
 используем if collection чтобы проверить что не пустая
 используем встроенные функции
 ловим конкретное исключение, пишем информацию в ветке except

 -- Модуль sys обеспечивает доступ к некоторым переменным и функциям, взаимодействующим с интерпретатором python.

 import sys
 arr_1 = []
 arr_2 = arr_1
 print(sys.getrefcount(arr_1)) - функция показывает сколько ссылок ссылается на обьект

 sys.path - Путь к модулям Python
 sys.breakpointhook() - точка остановы
 sys.version - Версия Python
 sys.argv - список аргументов командной строки, передаваемых сценарию Python.
 sys.argv[0] - Имя скрипта
 sys.argv[1:] - Аргументы командной строки
 sys.stdin — стандартный поток ввода
 sys.stdout — стандартный поток вывода
 sys.stderr — стандартный поток ошибок
 sys.int_info - именованный кортеж, который содержит информацию о внутреннем представлении Python целых чисел. Атрибуты только для чтения.

 0 - это дескриптор файла. Мы можем получить доступ к потоку ввода-вывода через файловый дескриптор.
 0 - это stdin - стандартный ввод, тоже самое, что input().  open(0)


 СИСТЕМА ВВОДА-ВЫВОДА ПОСТРОЕНА НА СЛОЯХ - Текстовые файлы конструируются путем добавления слоя кодирования/декодирования
 в UNICODE  поверх беферизованного файла, открытого в динарном режиме. Атрибут buffer просто ссылается на этот файл.


 -- Модуль os предоставляет множество функций для работы с операционной системой, причём их поведение, как правило,
 не зависит от ОС, поэтому программы остаются переносимыми.  Модуль os доступ к функциям ОС

 import os
 os.path - модуль, реализующий некоторые полезные функции для работы с путями.
 os.name - имя операционной системы
 os.environ - словарь переменных окружения. Изменяемый (можно добавлять и удалять переменные окружения).
 os.getlogin() - Возвращает имя пользователя, вошедшего в систему на управляющем терминале процесса.
 os.getpid() - текущий id процесса.
 os.getppid() - Вернуть идентификатор родительского процесса.

  ДВУХРЕЖИМНЫЙ API   re   os
 - Модуль re поддерживает как строковые, так и байтовые операции с регулярными выражениями.   str или bytes
 - Модуль os может работать с аргументами типа str или bytes

 -- Модуль glob  - Поиск файлов по шаблонам в стиле Unix --
 Модуль glob находит все пути, соответствующие указанному шаблону, в соответствии с правилами, используемыми оболочкой
 Unix. Результаты возвращаются в произвольном порядке.
 Unix – это семейство переносимых, многопользовательских и многозадачных операционных систем.
 Какие системы относятся к Unix? - macOS, Linux  и остальные семейста Unix
 Linux - это семейство операционных систем с открытым исходным кодом, дочка UNIX-системы.    <-----

 -- библиотека PyInstaller
 Превращение файла .py в программу .exe     Сделать из  Python-скрипта исполняемый файл exe

 -- Модуль pathlib — это мощная часть стандартной библиотеки Python,
 которая позволяет нам быстро манипулировать путями файловых систем в любой операционной системе.
 import pathlib, from pathlib import Path
 Класс pathlib.Path() представляет пути файловой системы, которые работают с системными вызовами и являются подклассом pathlib.PurePath.
 pathlib  позволяет читать и писать в одну строчку, автоматически закрывает файл

 # Pathlib
 pathlib (о котором я замолвлю словечко позже) позволяет читать и писать в одну строчку:

 with open('test.txt') as file:
     content = open.read()               # тут уровень отступов == 1

 # ...вжух!

 content = Path('test.txt').read_text()  # тут уровень отступов == 0


 -- Отладчик и что делать при ошибках  Pycharm Debug Shift+F9 --
 Помните, что при ошибках нужно действовать так:
 1) Прочитать и желательно понять ошибку (!)
 2) перейти по ссылке в место, где она падает и снова подумать
 3) поставить брекпоинт и отлаживать

 -- Отладчик (debugger) в PyCharm. Часть 2 --
 Отладка программ занимает очень большое время у любого программиста, наши программы чаще не работают, чем работают.
 Потому очень важно как можно раньше освоить такой инструмент как отладчик и как можно быстрее перейти от использования принтов к нему.

 1) в стеке вызовов мы можем посмотреть состояние нашей программы (переменных) на прошлых этапах выполнения.
 Это позволяет понять откуда пошла проблема
 2) Evaluate - это инструмент, который позволяет выполнять какие то вычисления, проверять код и даже менять значения
 в текущем скоупе, что может быть удобно для проверки каких то предположений об ошибке
 3) Отслеживание (watches) - помогает нам следить за значениями каких-либо переменных по ходу выполнения программы


 -- Модуль pdb - определяет интерактивный отладчик исходного кода для программ Python. Он поддерживает установку
 (условных) точек останова и пошаговое выполнение на уровне строки исходного кода.  -   Python Debugger

 import pdb
 pdb.set_trace() - вводит отладчик в кадр стека вызова.

 -- Модуль locale в Python, региональные настройки


 -- Модуль calendar  - Календарные функции    Общие функции, связанные с календарем
  полезные функции, связанные с календарем, а так же позволяет выводить календари подобно команде bash cal в Unix.


 -- Модуль time   -  Реальное время ОС.    Работа с системным временем операционной системы
 предоставляет доступ к нескольким различным типам часов, каждый из которых используется для разных целей

 Модуль time является struct_time низкоуровневым и не поддерживает форматирование с помощью f-строк          <-----
 вместо f-строк нужно использовать  time.strftime                                                            <-----

 import time
 t = time.gmtime()

 print(time.strftime("%Y %m %d", t))    # -> 2024 06 01
 print(time.strftime(f"{t:%Y %m %d}"))  # -> TypeError: unsupported format string passed to time.struct_time.__format__
 print(t)
 # time.struct_time(tm_year=2024, tm_mon=6, tm_mday=1, tm_hour=8, tm_min=58, tm_sec=39, tm_wday=5, tm_yday=153, tm_isdst=0)

 # Перевести в секунды
 t = time.mktime(t)
 print(t)  # -> 1717252837.0
 # Обратно из секунд в struct_time
 t = time.gmtime(t)
 print(t)
 # time.struct_time(tm_year=2024, tm_mon=6, tm_mday=1, tm_hour=14, tm_min=41, tm_sec=14, tm_wday=5, tm_yday=153, tm_isdst=0)
 # В форматированное время:
 print(time.strftime("%Y %m %d %H:%M:%S", t))  # -> 2024 06 01 14:43:14
 # f-строки не работают с time
 print(f"{t:%Y %m %d %H:%M:%S}")  # -> TypeError: unsupported format string passed to time.struct_time.__format__


 Функции  Functions:
------------------------------------------------------------------------------------------------------------------------
 time.asctime([t]) - преобразует кортеж или struct_time, представляющие время, возвращаемое time.gmtime() или time.localtime()

 import time
 time.asctime()
 time_local = time.localtime()
 time_local
 # time.struct_time(tm_year=2024, tm_mon=6, tm_mday=1, tm_hour=9, tm_min=20, tm_sec=24, tm_wday=5, tm_yday=153, tm_isdst=0)
 time.asctime(time_local)  # -> Sat Jun  1 09:20:24 2024

------------------------------------------------------------------------------------------------------------------------
 time.pthread_getcpuclockid(thread_id) - Возвращает clk_id часов процессорного времени, специфичных для потока,
 для указанного thread_id . Используйте threading.get_ident() или атрибут ident объектов threading.Thread,
 чтобы получить подходящее значение. Предупреждение Передача недействительного или просроченного thread_id может
 привести к неопределенному поведению, например к ошибке сегментации.
 Доступность: Unix
------------------------------------------------------------------------------------------------------------------------
 time.clock_getres(clk_id) - Возвращает разрешение (точность) указанных часов clk_id.
 Доступность: Unix
------------------------------------------------------------------------------------------------------------------------
 time.clock_gettime(clk_id) → float - Возвращает время указанных часов clk_id
 Доступность: Unix
------------------------------------------------------------------------------------------------------------------------
 time.clock_gettime_ns(clk_id) → int - Аналогично clock_gettime(), но возвращает время в наносекундах.
 Доступность: Unix
------------------------------------------------------------------------------------------------------------------------
 time.clock_settime(clk_id, time: float) - Установите время указанных часов clk_id . В настоящее время CLOCK_REALTIME
 это единственное допустимое значение для clk_id .  clock_settime_ns(), чтобы избежать потери точности,  типом float.
 Доступность: Unix
------------------------------------------------------------------------------------------------------------------------
 time.clock_settime_ns(clk_id, time: int) - Аналогично, clock_settime() но время устанавливается в наносекундах.
 Доступность: Unix

------------------------------------------------------------------------------------------------------------------------
 time.ctime([secs]) - Преобразовать секунды в строку с датой и временем

 import time

 time.ctime()      # -> Sat Jun  1 09:33:26 2024
 secs = time.time()
 secs              # -> 1717223643.1448178
 time.ctime(secs)  # -> Sat Jun  1 09:34:03 2024

------------------------------------------------------------------------------------------------------------------------
 time.get_clock_info(name) - Детали реализации и точность часов . Поддерживаемые имена часов и  функций :
 'monotonic':    time.monotonic()
 'perf_counter': time.perf_counter()
 'process_time': time.process_time()
 'thread_time':  time.thread_time()
 'time':         time.time()

------------------------------------------------------------------------------------------------------------------------
 time.gmtime([secs]) -  преобразует время, выраженное в секундах, в именованный кортеж структуры времени time.struct_time

 import time
 sec_utc = time.time()
 print(sec_utc)  # -> 1717242591.144278

 time_utc = time.gmtime(sec_utc)
 print(time_utc)
 # time.struct_time(tm_year=2024, tm_mon=6, tm_mday=1, tm_hour=11, tm_min=49, tm_sec=51, tm_wday=5, tm_yday=153, tm_isdst=0)
 print(time.strftime("%d.%m.%Y г. %H:%M:%S", time_utc))  # -> 01.06.2024 г. 11:49:51

------------------------------------------------------------------------------------------------------------------------
 time.localtime([secs]) - Получить локальное время в виде времени time.struct_time

 import time
 sec_utc = time.time()
 print(sec_utc)  # -> 1717242863.4139378

 time_local = time.localtime(sec_utc)
 print(time_local)
 # time.struct_time(tm_year=2024, tm_mon=6, tm_mday=1, tm_hour=14, tm_min=54, tm_sec=23, tm_wday=5, tm_yday=153, tm_isdst=0)
 print(time.strftime("%d.%m.%Y г. %H:%M:%S", time_local))  # -> 01.06.2024 г. 14:54:23

------------------------------------------------------------------------------------------------------------------------
 time.mktime(t) - Преобразует структуру времени t в секунды "эпохи" Unix. Возвращает float для совместимости с time.time().
 t - структура времени time.struct_time.
 import time

 struct_time = time.strptime('10/10/2020 10:15', '%d/%m/%Y %H:%M')
 print(struct_time)
 # time.struct_time(tm_year=2020, tm_mon=10, tm_mday=10, tm_hour=10, tm_min=15, tm_sec=0, tm_wday=5, tm_yday=284, tm_isdst=-1)
 print(time.mktime(struct_time))  # -> 1602314100.0

------------------------------------------------------------------------------------------------------------------------
 time.monotonic() → float  - возвращает значение, в долях секунды "монотонных" часов, то есть часов,
 которые не могут двигаться назад   т. е. не зависят от корректировки/обновления системных часов.

 import time

 t_start = time.monotonic()
 time.sleep(1)
 t_stop = time.monotonic()
 t_run = t_stop - t_start
 print(t_run)  # -> 1.0
 t_run         # -> 1.0150000001303852  # Python Console

------------------------------------------------------------------------------------------------------------------------
 time.monotonic_ns() → int - Аналогично monotonic(), но возвращает время в наносекундах.

 time.monotonic()     # -> 1297632.531
 time.monotonic_ns()  # -> 1297632531000000

------------------------------------------------------------------------------------------------------------------------
 time.perf_counter() → float - Измерение времени выполнения (производительности) кода/скрипта

 import time

 t_start = time.perf_counter()
 time.sleep(1)
 all_time = time.perf_counter() - t_start
 all_time  # -> 1.0002193001564592
------------------------------------------------------------------------------------------------------------------------
 time.perf_counter_ns() → int - Аналогично perf_counter(), но возвращает время в наносекундах.

 time.perf_counter()      # -> 1297964.86919
 time.perf_counter_ns()   # -> 1297964869214700

------------------------------------------------------------------------------------------------------------------------
 time.process_time() → float - Сумма системного и пользовательского процессорного времени

 import time
 t_start = time.process_time()
 time.sleep(1)
 time.process_time() - t_start  # -> 0.0

------------------------------------------------------------------------------------------------------------------------
 time.process_time_ns() → int - Аналогично process_time(), но возвращает время в наносекундах.

 time.process_time()     # -> 0.140625
 time.process_time_ns()  # -> 140625000

------------------------------------------------------------------------------------------------------------------------
 time.sleep(secs) - Приостановка выполнения программы, secs может быть float, для указания более точного время приостановки.

 import time
 t_start = time.monotonic()
 time.sleep(3)
 time.monotonic() - t_start  # -> 3.0

------------------------------------------------------------------------------------------------------------------------
 time.strftime(format[, t]) - Получение форматированной строки с датой и временем  кортежа  time.struct_time возвращаемое
 time.gmtime() или time.localtime()
                                                                               # Полезный пример  <-----
 import time
 from time import gmtime, strftime

 print(strftime("%a, %d %b %Y %H:%M:%S +0000", gmtime()))     # -> Sat, 01 Jun 2024 12:21:30 +0000

 # Формат даты для записи в базу данных.
 print(time.strftime("%Y-%m-%d", time.localtime()))           # -> 2024-06-01

 # Человеческий формат даты.
 print(time.strftime("%d.%m.%Y г. %H:%M", time.localtime()))  # -> 01.06.2024 г. 15:22

------------------------------------------------------------------------------------------------------------------------
 time.strptime(string[, format]) - Преобразовать строку с датой в именованный кортеж структуры времени time.struct_time
 которую возвращают функции time.gmtime() или time.localtime()

 import time
 time.strptime("30 Nov 00", "%d %b %y")
 # time.struct_time(tm_year=2000, tm_mon=11, tm_mday=30, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=335, tm_isdst=-1)

 # Разберем дату полученную из базы данных в формате 'YYYY-MM-DD'.                           <-----
 str_date = '2024-06-01'
 struct = time.strptime(str_date, '%Y-%m-%d')
 struct
 # time.struct_time(tm_year=2024, tm_mon=6, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=5, tm_yday=153, tm_isdst=-1)

 time.mktime(struct)                   # -> 1717189200.0
 time.strftime('%d.%m.%Y г.', struct)  # -> 01.06.2024 г.

 # Разберем расширенный формат даты 'YYYY-MM-DD HH:MM:SS' полученный из базы данных.         <-----
 str_date = '2024-06-01 15:29:27'
 struct = time.strptime(str_date, '%Y-%m-%d %H:%M:%S')
 struct
 # time.struct_time(tm_year=2024, tm_mon=6, tm_mday=1, tm_hour=15, tm_min=29, tm_sec=27, tm_wday=5, tm_yday=153, tm_isdst=-1)

 time.strftime('%H:%M - %d.%m.%Y г.', struct)   # -> 15:29 - 01.06.2024 г.


 # Важно чтобы разделители были одинаковые!!!                                                         <-----
 # Ошибка потому что нужно передавать '2024 06' "%Y %m"  с теми же знаками разделителями              <-----
 time.strptime('2024 06', "%Y%m")   # -> ValueError: time data '2024 06' does not match format '%Y%m'
 time.strptime('2024 06', "%Y %m")  # -> Работает потому что знаки разделители одинаковые

 time.strptime('2024,06', "%Y%m")   # -> ValueError: time data '2024,06' does not match format '%Y%m'
 time.strptime('2024,06', "%Y,%m")  # -> Работает потому что знаки разделители одинаковые

------------------------------------------------------------------------------------------------------------------------
 class time.struct_time - Кортеж с именованным интерфейсом структуры времени (struct_time) модуля time
 представляет собой тип последовательности значений времени, возвращаемых функциями time.gmtime(), time.localtime()
 и time.strptime(). Это кортеж с именованным интерфейсом: значения могут быть доступны по индексу и по имени атрибута.

 Index  Attribute        Values
 0      tm_year          (for example, 1993)
 1      tm_mon           range [1, 12]
 2      tm_day           range [1, 31]
 3      tm_hour          range [0, 23]
 4      tm_min           range [0, 59]
 5      tm_sec           range [0, 61]
 6      tm_wday          range [0, 6], понедельник = 0
 7      tm_yday          range [1, 366]
 8      tm_isdst         0, 1 or -1
 N/A    tm_zone          Сокращение названия часового пояса
 N/A    tm_gmtoff        Смещение к востоку от UTC в секундах
 Обратите внимание, что в отличие от структуры языка C, значением месяца является диапазон [1, 12], а не [0, 11].
 tm_isdst =  1 когда действует летнее время
 tm_isdst =  0 НЕ летнее время
 tm_isdst = -1 значение неизвестно и обычно приводит к заполнению правильного состояния.

 В вызовах функции time.mktime(), элемент кортежа tm_isdst может быть установлен в 1, когда действует летнее время,
 и в 0, если это не так. Значение -1 указывает, что это значение неизвестно, и обычно приводит к заполнению правильного состояния.

 import time
 struct = time.localtime()
 print(struct)
 # time.struct_time(tm_year=2024, tm_mon=6, tm_mday=1, tm_hour=15, tm_min=48, tm_sec=37, tm_wday=5, tm_yday=153, tm_isdst=0)
 print(struct.tm_year)       # -> 2024
 print(struct.tm_mon)        # -> 6
 print(struct.tm_mday)       # -> 1
 print(struct.tm_hour)       # -> 15
 print(struct.tm_min)        # -> 48
 print(struct.tm_sec)        # -> 37
 print(struct.tm_wday)       # -> 5
 print(struct.tm_isdst)      # -> 0

 # преобразование структуры времени в секунды
 print(time.mktime(struct))                      # -> 1717246190.0
 # преобразование структуры в человекочитаемую строку с датой
 print(time.strftime('%d.%m.%Y %H:%M', struct))  # -> 01.06.2024 15:50
 print(type(struct))                             # -> <class 'time.struct_time'>

 Когда кортеж с неправильной длиной передается функции, ожидающей time.struct_time или имеющей элементы
 неправильного типа, возникает ошибка TypeError

------------------------------------------------------------------------------------------------------------------------
 time.time() → float - Возвращает время в секундах с начала эпохи. Эпоха — это точка начала времени, возвращаемое
 значение time.gmtime(0). Сегодня 1 января 1970 года, 00:00:00 (UTC) на всех платформах.

 time.time()  # -> 1717315883.430602

 time.gmtime(0)  # Чтобы узнать, какова эпоха на данной платформе
 # time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0)
 time.strftime("%Y.%m.%d  %H:%M:%S %A %j", time.gmtime(0))  # -> 1970.01.01  00:00:00 Thursday 001

 # Из секунд в дату
 sec = time.time()
 struct = time.localtime(sec)
 time.strftime("%Y.%m.%d", struct)  # -> 2024.06.02

------------------------------------------------------------------------------------------------------------------------
 time.time_ns() → int - Аналогично, time() но возвращает время как целое число наносекунд с начала эпохи .

 time.time_ns()  # -> 1717318809395007300
 time.time()     # -> 1717318809.3950071

------------------------------------------------------------------------------------------------------------------------
 time.thread_time() → float - Возвращает  суммы системного и пользовательского процессорного времени текущего потока.

 time.thread_time()  # -> 0.140625

------------------------------------------------------------------------------------------------------------------------
 time.thread_time_ns() → int - Аналогично thread_time(), но возвращает время в наносекундах.

 time.thread_time_ns()  # -> 187500000
 time.thread_time()     # -> 0.1875

------------------------------------------------------------------------------------------------------------------------
 time.tzset() - Установить правила времени для часового пояса. Доступность - Unix.  MacOS, Linux.  НЕ РАБОТАЕТ в Windows

 import time
 import os

 # НЕ РАБОТАЕТ в Windows                                            <-----
 os.environ['TZ'] = 'EST+05EDT,M4.1.0,M10.5.0'
 time.tzset()
 time.strftime('%X %x %Z')  # -> '02:07:36 05/08/03 EDT'

------------------------------------------------------------------------------------------------------------------------
 -- Константы часового пояса:

 time.altzone   # -> -14400                             # Смещение местного (ЛЕТНЕГО)  часового пояса в секундах
 time.daylight  # -> 0                                  # Не нулевое значение, если определен часовой пояс летнего времени
 time.timezone  # -> -10800                             # Смещение местного (НЕ ЛЕТНЕГО) часового пояса в секундах
 time.tzname    # -> ('RTZ 2 (зима)', 'RTZ 2 (лето)')   # 1) Имя (ЛЕТНЕГО)часового пояса, 2) Имя (НЕ ЛЕТНЕГО) часового пояса

------------------------------------------------------------------------------------------------------------------------

 -- Модуль zoneinfo  - База часовых поясов    Поддержка часовых поясов
 class zoneinfo.ZoneInfo(key) -  предназначен для использования в модуле datetime, который предоставляет типы:
 datetime.time и datetime.datetime.

 from zoneinfo import ZoneInfo
 from datetime import datetime

 zone = ZoneInfo("Pacific/Kwajalein")
 print(zone)        # -> Pacific/Kwajalein
 print(type(zone))  # -> <class 'zoneinfo.ZoneInfo'>

 dt = datetime(2020, 4, 1, 3, 15, tzinfo=zone)
 print(f"{dt.isoformat()} [{dt.tzinfo}]")  # -> 2020-04-01T03:15:00+12:00 [Pacific/Kwajalein]

------------------------------------------------------------------------------------------------------------------------

 Функции Functions :

 zoneinfo.available_timezones() - Получить Множество(set) содержащий все действительные ключи для часовых поясов
 zoneinfo.reset_tzpath(to=None) - Устанавливает или сбрасывает путь поиска часового пояса ( TZPATH) для модуля.

 Globals:
 zoneinfo.TZPATH - содержит пути для поиска файлов часовых поясов в базе данных часовых поясов

 PYTHONTZPATH - Это строка, разделенная os.pathsep, содержащая путь поиска часового пояса.



 -- Модуль datetime  -  Работа с датой и временем. Форматирование, преобразования и обработка даты и времени
 Модуль datetime предоставляет классы для манипулирования датами и временем.

 ВЫСОКОУРОВНЕВЫЕ типы модуля работают с ф-строками                                      <-----
 import datetime
 dt = datetime.datetime.now()
 print(f'День: {dt:%d}, Месяц: {dt:%B}, время: {dt:%H:%M}.')  # -> День: 02, Месяц: June, время: 12:37.
 print(f'{dt:%Y %m %d %M %S %f}')                             # -> 2024 06 02 37 21 401098
 print(f"{dt:%Y/%m/%d   %H:%M:%S:%f}")                        # -> 2024/06/02   12:37:21:401098

 datetime.MINYEAR  # -> 1
 datetime.MAXYEAR  # -> 9999
 datetime.UTC      # -> UTC

 Объекты даты и времени могут быть классифицированы как "Осведомленные"/"Осознанные" или "Наивные".    <-----

 "Наивный" - объект, который не имеет часового пояса. Использовать где часовой пояс не имеет значения или уже известен заранее.
  Осведомленный" - явно привязан часовой пояс.

 "ОСВЕДОМЛЕННЫЙ" или "ОСОЗНАННЫЙ" - обладает информацией о часовом поясе и летнем времени

 "Наивный" объект не содержит достаточно информации о времени в конкретном месте.
 "Наивные" объекты легко понять и работать с ними за счет игнорирования некоторых аспектов реальности.


 Модуль datetime определяет следующие типы:

 class datetime.date - представляет собой идеализированную "наивную" дату, при условии, что текущий
 григорианский календарь всегда был и всегда будет в силе. Имеет атрибуты: year, month, day.

 class datetime.time - представляет собой идеализированное время, независимое от любого конкретного дня, при условии,
 что каждый день имеет ровно 24 * 60 * 60 секунд. Имеет атрибуты: hour, minute, second, microsecond и tzinfo.

 class datetime.datetime - представляет собой сочетание объектов datetime.date и datetime.time.
 Имеет атрибуты: year, month, day, hour, minute, second, microsecond и tzinfo.

 class datetime.timedelta - представляет собой длительность, выражающая разницу между двумя экземплярами даты,
 времени или даты и времени с микросекундным разрешением.

 class datetime.tzinfo - представляет собой абстрактный базовый класс для информационных объектов часового пояса.
 Он используются классами datetime и time для предоставления настраиваемого понятия корректировки времени,
 например для учета часового пояса и/или перехода на летнее время.

 class datetime.timezone - реализует абстрактный базовый класс tzinfo как фиксированное смещение от UTC.

 Общие свойства.
 Типы date, time, datetime и timezone имеют следующие общие характеристики:
 - Объекты этих типов неизменны.
 - Объекты этих типов являются хешируемыми, что означает, что они могут использоваться в качестве ключей словаря.
 - Объекты этих типов поддерживают сериализацию с помощью модуля pickle.
------------------------------------------------------------------------------------------------------------------------

 -- Объект timedelta  представляет продолжительность, разницу между двумя datetime или date экземплярами


 class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)
 Представляет собой продолжительность, разницу между двумя датами или временем.
 Все аргументы являются необязательными и по умолчанию имеют значение 0. Аргументы могут быть целыми числами или
 числами с плавающей запятой, а также могут быть положительными или отрицательными.


 # КОГДА НЕ РАБОТАЕТ timedelta

 # Интересный модуль dateutil
 from dateutil.relativedelta import relativedelta

 a = datetime(2012, 9, 23)

 # ТАК НЕ РАБОТАЕТ
 # a + timedelta(months=1)  # -> TypeError: 'months' is an invalid keyword argument for __new__()

 print(a+relativedelta(months=+1))          # -> 2012-10-23 00:00:00
 print(a+relativedelta(months=+4))          # -> 2013-01-23 00:00:00

 b = datetime(2012, 12, 21)
 d = b - a
 print(d)                                   # -> 89 days, 0:00:00
 d = relativedelta(b, a)

 print(d.months)                            # -> 2
 print(relativedelta(months=+2, days=+28))  # -> relativedelta(months=+2, days=+28)


 from datetime import timedelta

 delta = timedelta( days=50, seconds=27, microseconds=10, milliseconds=29000, minutes=5, hours=8, weeks=2)
 delta                  # -> 64 days, 8:05:56.000010    # Остались только дни, секунды и микросекунды
 delta                  # -> datetime.timedelta(days=64, seconds=29156, microseconds=10)  В Python console     <-----
 Атрибуты экземпляра (только для чтения):
 delta.days             # -> 64
 delta.seconds          # -> 29156
 delta.microseconds     # -> 10
 delta.__dict__  # -> AttributeError: 'datetime.timedelta' object has no attribute '__dict__'.   Нет __dict__  <-----
 type(delta)     # -> <class 'datetime.timedelta'>                                                             <-----

 Метод экземпляра   Instance method:
 delta.total_seconds()  # -> 5558756.00001     # общее количество секунд

 Атрибуты класса:
 delta.max         # -> 999999999 days, 23:59:59.999999
 delta.min         # -> -999999999 days, 0:00:00
 delta.resolution  # -> 0:00:00.000001

 Поддерживаются сравнения объектов datetime.timedelta с некоторыми оговорками.
 Сравнения == или != всегда возвращают bool, независимо от типа сравниваемого объекта:
 delta1 = timedelta(seconds=57)
 delta2 = timedelta(hours=25, seconds=2)
 delta2 != delta1     # -> True
 delta2 == 5          # -> False
 assert delta2 == delta1, 'Не равны друг другу'  # -> AssertionError: Не равны друг другу

 Для всех других сравнений,  < , > когда объект timedelta сравнивается с объектом другого типа, вызывается исключение TypeError:
 delta2 > delta1      # -> True
 delta2 > 5           # -> TypeError: '>' not supported between instances of 'datetime.timedelta' and 'int'

 Примеры использования: timedelta
 from datetime import timedelta

 year = timedelta(days=365)
 ten_years = 10 * year
 ten_years               # ->  datetime.timedelta(days=3650)
 ten_years.days // 365   # ->  10
 nine_years = ten_years - year
 nine_years                            # -> datetime.timedelta(days=3285)
 three_years = nine_years // 3
 three_years, three_years.days // 365  # -> (datetime.timedelta(days=1095), 3)

 Дополнительный пример нормализации:
 year = timedelta(days=365)
 another_year = timedelta(weeks=40, days=84, hours=23,
                          minutes=50, seconds=600)
 year == another_year  # -> True
 year.total_seconds()  # -> 31536000.0

 -- Подсчет прошедших и предстоящих дат.                                                              <-----

 # Узнаем дату "дня программиста". Как известно, день программиста приходится на 256 день в году.
 import datetime

 today = datetime.date.today()
 first_day_year = datetime.date(today.year, 1, 1)
 delta = datetime.timedelta(days=256)
 prog_day = first_day_year + 256 # -> TypeError: unsupported operand type(s) for +: 'datetime.date' and 'int'
 prog_day = first_day_year + delta
 print(f'{prog_day.day}.{prog_day.month}.{prog_day.year}')  # ->  13.9.2024

 # Узнаем, какая дата будет через 4 недели 5 дней и 10 часов.                                         <-----

 today = datetime.datetime.now()
 print(today)  # -> 2024-06-02 14:04:57.120408
 tmd = datetime.datetime.now() + datetime.timedelta(weeks=4, days=5, hours=10)
 print(tmd)    # -> 2024-07-06 00:04:57.120408
 print(f'{tmd.day}.{tmd.month}.{tmd.year}')  # -> 6.7.2024

 # Узнаем, какая дата была 100 дней назад.

 today = datetime.datetime.now()
 print(today)                                      # -> 2024-06-02 14:26:07.065792
 print(f'{today.day}.{today.month}.{today.year}')  # -> 2.6.2024
 delta = datetime.timedelta(days=100)
 date = today - delta
 print(date)                                       # -> 2024-02-23 14:26:07.065792
 print(f'{date.day}.{date.month}.{date.year}')     # ->  23.2.2024

 # Создание диапазона дат в Python                                                                  <-----  <-----

 base = datetime.date.today()
 numdays = 3
 date_list = [base + datetime.timedelta(days=x) for x in range(numdays)]
 print(date_list)  # -> [datetime.date(2024, 6, 2), datetime.date(2024, 6, 3), datetime.date(2024, 6, 4)]
 print([str(i) for i in date_list])  # -> ['2024-06-02', '2024-06-03', '2024-06-04']


------------------------------------------------------------------------------------------------------------------------
 -- Объекты date  представляет дату (год, месяц и день)   Варианты создания объекта даты

 class datetime.date(year, month, day) - бъект даты, который представляет дату - год, месяц и день

 class datetime.date
 Имеет атрибуты: year, month, day.

 import datetime
 date = datetime.date(year=2000, month=10, day=30)  # Аналогично строчке ниже
 date = datetime.date(2000, 10, 30)                 # Так тоже можно
 date        # -> 2000-10-30
 date        # -> datetime.date(2000-10-30)         В Python console     <-----
 date.day    # -> 30
 date.month  # -> 10
 date.year   # -> 2000
 type(date)  # -> <class 'datetime.date'>           <-----

 Все аргументы обязательны. Аргументы должны быть целыми числами в следующих диапазонах:                    <-----
 year  - MINYEAR(1) <= year <= MAXYEAR(9999)
 month - 1 <= month <= 12
 day   - день в пределах 1 <= day <= n, n - количество дней в данном месяце и году.

 date = datetime.date(year=30000, month=100, day=30)  # -> ValueError: year 30000 is out of range
 date = datetime.date(year=2000, month=100, day=30)   # -> ValueError: month must be in 1..12
 date = datetime.date(year=2000, month=10, day=320)   # -> ValueError: day is out of range for month

 Обязательно нужно заполнять все ТРИ аргумента!!!
 date = datetime.date(year=2000, month=10)  # -> TypeError: function missing required argument 'day' (pos 3)

 Создание объекта datetime.date другими способами:

 -- Другие конструкторы, все методы класса  Other constructors, all class methods:

 classmethod date.today() - возвращает текущую местную дату, эквивалентно:  datetime.date.fromtimestamp(time.time()).
 from datetime import date
 date.today()                     # -> 2024-05-31
 date.today()                     # -> datetime.date(2024, 5, 31)   В Python console     <-----

------------------------------------------------------------------------------------------------------------------------
 classmethod date.fromtimestamp(timestamp) - Возвращает локальную дату, соответствующую временной метке POSIX,
 например, возвращаемую time.time().

 import datetime, time

 datetime.date.fromtimestamp(time.time())  # -> 2024-05-31
 datetime.date.fromtimestamp(time.time())  # -> datetime.date(2024, 5, 31)   В Python console     <-----

 sec = datetime.datetime.now().timestamp()
 sec_2 = time.time()
 print(sec)                                 # -> 1717328749.508868
 print(sec_2)                               # -> 1717328749.5088687
 print(datetime.date.fromtimestamp(sec))    # -> 2024-06-02
 print(datetime.date.fromtimestamp(sec_2))  # -> 2024-06-02

------------------------------------------------------------------------------------------------------------------------
 classmethod date.fromordinal(ordinal) -  дата из числа, Это обратный метод toordinal() возвращает порядковый номер

 d = datetime.date(year=2000, month=10, day=30)
 d.toordinal()      # -> 730423
 d.fromordinal(d.toordinal())  # -> datetime.date(2000, 10, 30)
 d.max.toordinal()  # -> 3652059

 datetime.date.fromordinal(11111111)     # -> ValueError: year 30422 is out of range
 datetime.date.fromordinal(11111111111)  # -> OverflowError: Python int too large to convert to C long

 ValueError, если только 1 <= ordinal <= date.max.toordinal(). Для любой даты d, date.fromordinal(d.toordinal()) == d.

------------------------------------------------------------------------------------------------------------------------
 classmethod date.fromisoformat(date_string) - возвращает дату, соответствующую строке date_string в формате,
 заданным в любом допустимом формате ISO 8601, кроме порядковых дат (например, YYYY-DDD):

 date.fromisoformat('2019-12-04')  # -> datetime.date(2019, 12, 4)
 date.fromisoformat('20191204')    # -> datetime.date(2019, 12, 4)
 date.fromisoformat('2021-W01-1')  # -> datetime.date(2021, 1, 4)

------------------------------------------------------------------------------------------------------------------------
 classmethod date.fromisocalendar(year, week, day) - возвращает дату, соответствующую календарной дате ISO,
 указанной по году year, неделе week и дню day. Это обратная функция date.isocalendar()

 datetime.date.fromisocalendar(2011, 22, 1)   # -> datetime.date(2011, 5, 30)
 datetime.date.fromisocalendar(2011, 22, 10)  # -> ValueError: Invalid day: 10 (range is [1, 7])

------------------------------------------------------------------------------------------------------------------------
 from datetime import date
 Атрибуты класса  Class attributes:
 date.min         # -> datetime.date(1, 1, 1)
 date.max         # -> datetime.date(9999, 12, 31)
 date.resolution  # -> datetime.timedelta(days=1)

 Атрибуты экземпляра (только для чтения)   Instance attributes (read-only):
 date.year        # -> <attribute 'year' of 'datetime.date' objects>
 date.month       # -> <attribute 'month' of 'datetime.date' objects>
 date.day         # -> <attribute 'day' of 'datetime.date' objects>

------------------------------------------------------------------------------------------------------------------------
 Методы экземпляра  Instance methods:

 date.replace(year=self.year, month=self.month, day=self.day) -  Изменить значения дня, месяца, года в дате
 from datetime import date
 d = date(2002, 12, 31)                                           d = date(2002, 12, 31)
 d.replace(day=26)      # -> datetime.date(2002, 12, 26)          d = d.replace(day=26)
 d.replace(month=1)     # -> datetime.date(2002, 1, 31)           d = d.replace(month=1)
 d.replace(year=1990)   # -> datetime.date(1990, 12, 31)          d = d.replace(year=1990)
 # Методам нужно присвоение = чтобы изменить значение             # Теперь  d будет изменено Методы  НЕ in-place  <-----
 d                      # -> datetime.date(2002, 12, 31)          d  # -> datetime.date(1990, 1, 26)              <-----

------------------------------------------------------------------------------------------------------------------------
 date.timetuple() - возвращает объект структуры времени time.struct_time, например возвращенное функцией time.localtime().

 d = datetime.date.today()
 d  # -> datetime.date(2024, 5, 31)
 d.timetuple()
 # time.struct_time(tm_year=2024, tm_mon=5, tm_mday=31, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=4, tm_yday=152, tm_isdst=-1)
 Метод date.timetuple() эквивалентен:    time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, -1))

------------------------------------------------------------------------------------------------------------------------
 date.toordinal() - возвращает григорианский порядковый номер даты, где 1 января 1 года имеет порядковый номер 1.

 d = datetime.date.today()
 d.toordinal()  # -> 739037

------------------------------------------------------------------------------------------------------------------------
 date.weekday() - возвращает день недели в виде целого числа, где понедельник равен 0, а воскресенье - 6.

 d = datetime.date.today()
 d.weekday() # -> 4

------------------------------------------------------------------------------------------------------------------------
 date.isoweekday() - возвращает день недели в виде целого числа, где понедельник равен 1, а воскресенье - 7.

 d = datetime.date.today()
 d.isoweekday() # -> 5

------------------------------------------------------------------------------------------------------------------------
 date.isocalendar() - возвращает именованный кортеж с тремя компонентами: год year, неделя week и день недели weekday.

 datetime.date(2024, 5, 31).isocalendar()  # -> datetime.IsoCalendarDate(year=2024, week=22, weekday=5)

------------------------------------------------------------------------------------------------------------------------
 date.isoformat() - возвращает строку, представляющую дату в формате ISO 8601 YYYY-MM-DD:

 datetime.date.today().isoformat()  # -> '2024-05-31'

------------------------------------------------------------------------------------------------------------------------
 date.__str__() - для объекта даты d, справедливо утверждение: str(d) эквивалентна методу d.isoformat().

 d = datetime.date.today()
 d            # -> datetime.date(2024, 5, 31)
 str(d)       # -> '2024-05-31'
 d.__str__()  # -> '2024-05-31'

------------------------------------------------------------------------------------------------------------------------
 date.ctime() - возвращает строку, представляющую дату. date.ctime() эквивалентен time.ctime(time.mktime(data.timetuple()))

 d = datetime.date.today()
 d.ctime()                         # -> 'Fri May 31 00:00:00 2024'
 datetime.date(2024, 1, 1).ctime() # -> 'Mon Jan  1 00:00:00 2024'

------------------------------------------------------------------------------------------------------------------------
 date.strftime(format) - возвращает строку, представляющую дату, которую задают явной строкой формата.

 import datetime
 d = datetime.date.today()
 d.strftime('%d/%m/%y')      # -> '31/05/24'
 d.strftime('%A %d. %B %Y')  # -> 'Friday 31. May 2024'

 dt = datetime.datetime.now()
 dt.strftime('%H:%M - %m.%d.%Y года')            # -> '15:46 - 05.31.2024 года'
 dt.strftime('%H часов %M минут %m.%d.%Y года')  # -> '15 часов 46 минут 05.31.2024 года'
 dt.strftime('%m/%d/%y')                         # -> '05/31/24'
 dt.strftime('%Y-%m-%d')                         # -> '2024-05-31'

 # Можно использовать f-string вместо strftime                                                 <-----
 dt.strftime('%Y-%m-%d')  # ->'2024-05-31'                                                     <-----
 f"{dt:%Y-%m-%d}"         # ->'2024-05-31'                                                     <-----
 f'День: {dt:%d}, Месяц: {dt:%B}, время: {dt:%H:%M}.'  # -> 'День: 31, Месяц: May, время: 15:46.'
------------------------------------------------------------------------------------------------------------------------

 -- Объекты  datetime   Создание объекта даты и времени
 это отдельный объект, объединяющий всю информацию из объекта даты datetime.date и объекта времени datetime.time.

 class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)

 Аргументы year, month и day обязательны. Аргумент tzinfo может быть None или экземпляром подкласса datetime.tzinfo.
 Остальные аргументы должны быть целыми числами:

 year          - MINYEAR <= year <= datetime.MAXYEAR,
 month         - 1 <= month <= 12,
 day           - 1 <= day <= n_day, n_day - количество дней в данном месяце и году,
 hour=0        - 0 <= hour < 24,                   range(24)
 minute=0      - 0 <= minute < 60,                 range(60)
 second=0      - 0 <= second < 60,                 range(60)
 microsecond=0 - 0 <= microsecond < 1000000,       range(1000000)
 tzinfo=None   - может быть None или экземпляром подкласса datetime.tzinfo.
 fold=0        - [0, 1].  возвращает зимнее 0 или летнее 1 время.

 Если задан аргумент вне этих диапазонов, вызывается исключение ValueError.

 import datetime
 d = datetime.datetime(2024, 5, 31)
 d  # -> datetime.datetime(2024, 5, 31, 0, 0)
 d.day, d.month, d.year                     # -> (31, 5, 2024)
 d.hour, d.minute, d.second, d.microsecond  # -> (0, 0, 0, 0)
 type(d)                                    # -> <class 'datetime.datetime'>

 # Узнаем сколько прошло времени с события.                                                         <-----
 td = datetime.datetime.now() - datetime.datetime(2020, 1, 13)
 print(td)  # -> 1602 days, 13:58:40.552938

 # Узнаем сколько осталось времени до события.                                                      <-----
 td = datetime.datetime(2024, 12, 1) - datetime.datetime.now()
 print(td)  # -> 181 days, 9:59:25.291308

 -- Создание объекта datetime.datetime другими способами   Other constructors, all class methods:

 classmethod datetime.today() - возвращает текущую локальную дату и время с tzinfo=None.

 import datetime
 datetime.datetime.today()                     # -> datetime.datetime(2024, 5, 31, 14, 17, 37, 709415)

 Эквивалентно:
 datetime.datetime.fromtimestamp(time.time())  # -> datetime.datetime(2024, 5, 31, 14, 17, 37, 709415)
 datetime.datetime.now()                       # -> datetime.datetime(2024, 5, 31, 14, 17, 37, 709415)  но без  tz

------------------------------------------------------------------------------------------------------------------------
 classmethod datetime.now(tz=None) - возвращает текущую локальную дату и время.

 datetime.datetime.now()  # -> datetime.datetime(2024, 5, 31, 14, 22, 38, 893000)

 classmethod datetime.utcnow()  # -> Устарел с Python 3.12 и будет удален в будущей версии:
 вместо этого метода используйте datetime.datetime.now() с UTC (timezone.utc).

------------------------------------------------------------------------------------------------------------------------
 classmethod datetime.fromtimestamp(timestamp, tz=None) - возвращает локальную дату и время, соответствующие
 метке времени POSIX time.time().  Этот метод предпочтительнее, чем datetime.datetime.utcfromtimestamp().

 import datetime, time
 sec = time.time()
 sec                                   # -> 1717154788.9624312
 datetime.datetime.fromtimestamp(sec)  # -> datetime.datetime(2024, 5, 31, 14, 26, 28, 962431)

 classmethod datetime.utcfromtimestamp(timestamp) -  Устарел с Python 3.12 и будет удален в будущей версии:
 вместо этого метода используйте datetime.fromtimestamp() с UTC (timezone.utc).

------------------------------------------------------------------------------------------------------------------------
 classmethod datetime.fromordinal(ordinal) анлогичен методу      classmethod date.fromordinal(ordinal)

------------------------------------------------------------------------------------------------------------------------
 classmethod datetime.combine(date, time, tzinfo=time.tzinfo) - возвращает новый объект datetime.datetime()

 import datetime

 date = datetime.date.today()            # дата
 time = datetime.time(23, 55)            # время
 delta = datetime.timedelta(minutes=30)  # интервал
 # соединяем все вместе
 datetime.datetime.combine(date, time) + delta   # -> datetime.datetime(2024, 6, 1, 0, 25)

------------------------------------------------------------------------------------------------------------------------
 classmethod datetime.fromisoformat(date_string) - возвращает дату и время datetime.datetime(), соответствующую строке
 date_string, в любом допустимом формате ISO 8601

 from datetime import datetime
 datetime.fromisoformat('2011-11-04')                     # -> datetime.datetime(2011, 11, 4, 0, 0)
 datetime.fromisoformat('20111104')                       # -> datetime.datetime(2011, 11, 4, 0, 0)
 datetime.fromisoformat('2011-11-04T00:05:23')            # -> datetime.datetime(2011, 11, 4, 0, 5, 23)
 datetime.fromisoformat('2011-11-04T00:05:23Z')
 #  datetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone.utc)
 datetime.fromisoformat('20111104T000523')                # -> datetime.datetime(2011, 11, 4, 0, 5, 23)
 datetime.fromisoformat('2011-W01-2T00:05:23.283')        # -> datetime.datetime(2011, 1, 4, 0, 5, 23, 283000)
 datetime.fromisoformat('2011-11-04 00:05:23.283')        # -> datetime.datetime(2011, 11, 4, 0, 5, 23, 283000)
 datetime.fromisoformat('2011-11-04 00:05:23.283+00:00')
 #  datetime.datetime(2011, 11, 4, 0, 5, 23, 283000, tzinfo=datetime.timezone.utc)
 datetime.fromisoformat('2011-11-04T00:05:23+04:00')
 #  datetime.datetime(2011, 11, 4, 0, 5, 23, tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))

------------------------------------------------------------------------------------------------------------------------
 classmethod datetime.fromisocalendar(year, week, day) - возвращает объект даты и времени, соответствующих календарной
 дате ISO, указанной в атрибутах year, week, day.  Это обратный метод datetime.isocalendar().

 datetime.datetime.fromisocalendar(2024, 5, 5)  # -> 2024-02-02 00:00:00

------------------------------------------------------------------------------------------------------------------------
 classmethod datetime.strptime(date_string, format) -  возвращает объект даты и времени datetime.datetime(),
 соответствующее проанализированный строке date_string в соответствии с форматом.

 Эквивалетно: datetime.datetime(*(time.strptime(date_string, format)[0:6]))
 time.strptime(string[, format])

 import datetime

 date_str = 'Fri, 24 Apr 2021 16:22:54 +0000'
 format = '%a, %d %b %Y %H:%M:%S +0000'
 datetime.datetime.strptime(date_str, format)  # -> datetime.datetime(2021, 4, 24, 16, 22, 54) # Python Console
 date_str = 'Fri, 5 May 2024 15:50:54 +0000'
 format = '%a, %d %b %Y %H:%M:%S +0000'
 datetime.datetime.strptime(date_str, format)  # -> datetime.datetime(2024, 5, 5, 15, 50, 54)  # Python Console

 # Важно чтобы разделители были одинаковые!!!                                                         <-----
 # Ошибка потому что нужно передавать '2024/06' "%Y/%m"  с теми же знаками разделителями              <-----
 datetime.strptime('2024/06', "%Y%m")     # -> ValueError: time data '2024/06' does not match format '%Y%m'
 datetime.strptime('2024/06', "%Y/%m")    # -> Работает Работает потому что знаки разделители одинаковые
 datetime.strptime('2024//06', "%Y/%m")   # -> ValueError: time data '2024//06' does not match format '%Y/%m'
 datetime.strptime('2024//06', "%Y//%m")  # -> Работает потому что знаки разделители одинаковые
------------------------------------------------------------------------------------------------------------------------
 Атрибуты класса  Class attributes:

 from datetime import datetime
 Атрибуты класса  Class attributes:
 datetime.min         # -> datetime.datetime(1, 1, 1, 0, 0)
 datetime.max         # -> datetime.datetime(9999, 12, 31, 23, 59, 59, 999999)
 datetime.resolution  # -> datetime.timedelta(microseconds=1)

 Атрибуты экземпляра (только для чтения)   Instance attributes (read-only):
 datetime.year, month, day, hour, minute, second, microsecond, tzinfo, fold

 Методы экземпляра  Instance methods:

 datetime.date() - возвращает объект datetime.date() с тем же годом, месяцем и днем.
 dt = datetime.datetime.now()
 dt.date()  # -> datetime.date(2024, 5, 31)

------------------------------------------------------------------------------------------------------------------------
 datetime.time() - Получить объект datetime.time с tzinfo
 dt = datetime.datetime.now()
 dt.time()  # -> datetime.time(16, 15, 3, 832349)

------------------------------------------------------------------------------------------------------------------------
 datetime.timetz() - Получить объект datetime.time с tzinfo
 микросекунды и tzinfo.

 dt = datetime.datetime.now()
 dt.timetz()  # -> datetime.time(16, 15, 3, 832349)

 # если указать аргумент смещение `tz`   то timetz() будет присутствовать в объекте
 delta = datetime.timedelta(hours=3)
 tz = datetime.timezone(delta)
 dt = datetime.datetime.now(tz=tz)
 dt # -> datetime.datetime(2024, 5, 31, 16, 19, 33, 370192, tzinfo=datetime.timezone(datetime.timedelta(seconds=10800)))

------------------------------------------------------------------------------------------------------------------------
 datetime.replace(year=self.year, month=self.month, day=self.day, hour=self.hour, minute=self.minute,
 second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, *, fold=0) - Изменить значения элементов даты и времени

 import datetime
 dt = datetime.datetime.now()
 dt                                                         # -> datetime.datetime(2024, 5, 31, 16, 23, 31, 919525)
 dt.replace(year=2023, month=1, day=1, hour=10)             # -> datetime.datetime(2023, 1, 1, 10, 23, 31, 919525)
 dt                                                         # -> datetime.datetime(2024, 5, 31, 16, 23, 31, 919525)
 dt = dt.replace(year=2023, month=1, day=1, microsecond=10)
 dt                                                         # -> datetime.datetime(2023, 1, 1, 10, 23, 31, 10)

------------------------------------------------------------------------------------------------------------------------
 datetime.astimezone(tz=None) - Изменить атрибут tzinfo

 dt = datetime.datetime.now()
 datetime.datetime(2023, 1, 1, 10, 23, 31, 10, tzinfo=datetime.timezone(datetime.timedelta(seconds=10800), 'RTZ 2 (зима)'))

------------------------------------------------------------------------------------------------------------------------
 datetime.utcoffset() - Получить смещение времени UTC в виде timedelta

 dt = datetime.datetime.now()
 print(dt.utcoffset())  # -> None
 new_dt = dt.astimezone()
 new_dt.utcoffset()     # -> datetime.timedelta(seconds=10800)

------------------------------------------------------------------------------------------------------------------------
 datetime.dst() - Получить смещение летнего времени

 dt = datetime.datetime.now()
 print(dt.dst())      # -> None

 new_dt = dt.astimezone()
 print(new_dt.dst())  # -> None

------------------------------------------------------------------------------------------------------------------------
 datetime.tzname() - Получить название часового пояса

 dt = datetime.datetime.now()
 print(dt.tzname())  # -> None

 new_dt = dt.astimezone()
 new_dt.tzname()     # -> 'RTZ 2 (зима)'

------------------------------------------------------------------------------------------------------------------------
 datetime.timetuple() - Получить кортеж структуры времени типа time.localtime()

 dt = datetime.datetime.now()
 dt.timetuple()
 # time.struct_time(tm_year=2024, tm_mon=5, tm_mday=31, tm_hour=16, tm_min=53, tm_sec=29, tm_wday=4, tm_yday=152, tm_isdst=-1)

------------------------------------------------------------------------------------------------------------------------
 datetime.utctimetuple() - Получить кортеж структуры времени по UTC

 dt = datetime.datetime.now()
 dt.utctimetuple()
 # time.struct_time(tm_year=2024, tm_mon=5, tm_mday=31, tm_hour=16, tm_min=56, tm_sec=4, tm_wday=4, tm_yday=152, tm_isdst=0)
 dt.timetuple().tm_isdst      # -> -1
 dt.utctimetuple().tm_isdst   # -> 0

------------------------------------------------------------------------------------------------------------------------
 datetime.toordinal() - Григорианский порядковый номер даты

 dt = datetime.datetime.now()
 dt.toordinal()   # -> 739037

------------------------------------------------------------------------------------------------------------------------
 datetime.timestamp() - Получить метку времени timestamp, Возвращаемое значение аналогично float возвращаемому time.time().

 dt = datetime.datetime.now()
 dt.timestamp() 1717163877.549021

 print(datetime.datetime.now().timestamp())  # -> 1717328294.478161
 print(time.time())                          # -> 1717328294.4781613

------------------------------------------------------------------------------------------------------------------------
 datetime.weekday() - Получить день недели где понедельник = 0

 dt = datetime.datetime.now()
 dt.weekday()  # -> 4

------------------------------------------------------------------------------------------------------------------------
 datetime.isoweekday() - Получить день недели где понедельник = 1

 dt = datetime.datetime.now()
 dt.isoweekday()  # -> 5

------------------------------------------------------------------------------------------------------------------------
 datetime.isocalendar() - Получить кортеж (год, номер недели, день недели)

 dt = datetime.datetime.now()
 dt.isocalendar()  # -> datetime.IsoCalendarDate(year=2024, week=22, weekday=5)

------------------------------------------------------------------------------------------------------------------------
 datetime.isoformat(sep='T', timespec='auto') - Получить строку с датой и временем в формате ISO 8601

 dt = datetime.datetime.now()
 dt.isoformat()               # -> '2024-05-31T16:57:57.549021'

 tz = datetime.timezone.utc
 dt_utc = datetime.datetime.now(tz=tz)
 dt_utc.isoformat()           # ->  '2024-05-31T14:02:33.486344+00:00'

 dt_local = dt.astimezone()
 dt_local.isoformat(sep='|')  # -> '2024-05-31|16:57:57.549021+03:00'  sep='T' по умолчанию

------------------------------------------------------------------------------------------------------------------------
 datetime.__str__() - Получить строку с датой и временем
 dt = datetime.datetime.now()
 dt.__str__()  # -> '2024-05-31 17:06:34.559339'
 str(dt)       # -> '2024-05-31 17:06:34.559339'

------------------------------------------------------------------------------------------------------------------------
 datetime.ctime() - Получить другую строку с датой и временем

 dt = datetime.datetime.now()
 dt.ctime()   # -> 'Fri May 31 17:06:34 2024'

------------------------------------------------------------------------------------------------------------------------
 datetime.strftime(format) - Пользовательское форматирование даты и времени

 dt = datetime.datetime.now()
 dt.strftime('%H:%M - %m.%d.%Y года')             # -> '17:06 - 05.31.2024 года'
 dt.strftime('%H часов %M минут %m.%d.%Y года')   # -> '17 часов 06 минут 05.31.2024 года'
 dt.strftime('%m/%d/%y')                          # ->  '05/31/24'
 dt.strftime('%Y-%m-%d')                          # -> '2024-05-31'

 # Можно через ф-строки
 f"{dt:%Y-%m-%d}"                                 # -> '2024-05-31'
 dt.strftime('%Y-%m-%d')                          # -> '2024-05-31'

------------------------------------------------------------------------------------------------------------------------
 datetime.__format__(format) - Это позволяет указать строку формата для datetime объекта в литералах форматированной
 строки и при использовании str.format()

 today = datetime.datetime.now()
 f"{today:%B %d, %Y}"  # -> 'May 31, 2024'
------------------------------------------------------------------------------------------------------------------------

 -- Объекты  time    Создание объекта времени  --
 представляет (локальное) время суток, независимое от какого-либо конкретного дня и подлежащее настройке с помощью
 tzinf oобъекта.

 class datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)

 import datetime

 time = datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0)
 type(time)  # -> <class 'datetime.time'>

 Все аргументы являются необязательными. tzinfo может быть Noneили экземпляром подкласса tzinfo.
 Остальные аргументы должны быть целыми числами в следующих диапазонах:

 hour=0        - 0 <= hour < 24,                range(24)
 minute=0      - 0 <= minute < 60,              range(60)
 second=0      - 0 <= second < 60,              range(60)
 microsecond=0 - 0 <= microsecond < 1000000,    range(1000000)
 tzinfo=None   - может быть None или экземпляром подкласса datetime.tzinfo.
 fold=0        - [0, 1].

 Если задан аргумент вне этих диапазонов, вызывается исключение ValueError.

 Атрибуты класса  Class attributes:

 from datetime import time
 time.min         # -> datetime.time(0, 0)
 time.max         # -> datetime.time(23, 59, 59, 999999)
 time.resolution  # -> datetime.timedelta(microseconds=1)

 Атрибуты экземпляра (только для чтения)   Instance attributes (read-only):
 time.hour, minute, second, microsecond, tzinfo, fold

 -- Другие конструкторы, все методы класса  Other constructors, all class methods:


 classmethod time.fromisoformat(time_string) - Возвращает время, соответствующее строке time_string, в любом допустимом
 формате ISO 8601

 from datetime import time
 time.fromisoformat('04:23:01')          # -> 04:23:01
 time.fromisoformat('T04:23:01')         # -> 04:23:01
 time.fromisoformat('T042301')           # -> 04:23:01
 time.fromisoformat('04:23:01.000384')   # -> 04:23:01.000384
 time.fromisoformat('04:23:01,000')      # -> 04:23:01
 time.fromisoformat('04:23:01+04:00')    # -> 04:23:01+04:00
 time.fromisoformat('04:23:01Z')         # -> 04:23:01+00:00
 time.fromisoformat('04:23:01+00:00')    # -> 04:23:01+00:00

 # Python Console
 from datetime import time
 time.fromisoformat('04:23:01')        # -> datetime.time(4, 23, 1)
 time.fromisoformat('T04:23:01')       # -> datetime.time(4, 23, 1)
 time.fromisoformat('T042301')         # -> datetime.time(4, 23, 1)
 time.fromisoformat('04:23:01.000384') # -> datetime.time(4, 23, 1, 384)
 time.fromisoformat('04:23:01,000')    # -> datetime.time(4, 23, 1)
 time.fromisoformat('04:23:01+04:00')  # -> datetime.time(4, 23, 1, tzinfo=datetime.timezone(datetime.timedelta(seconds=14400)))
 time.fromisoformat('04:23:01Z')       # -> datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)
 time.fromisoformat('04:23:01+00:00')  # -> datetime.time(4, 23, 1, tzinfo=datetime.timezone.utc)

------------------------------------------------------------------------------------------------------------------------
 time.replace(hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, *, fold=0)
 Изменение значения атрибутов объекта time()

 from datetime import time

 time_time = time(hour=10, minute=20, second=50, microsecond=100)
 time_time.replace(hour=23, minute=59, second=59, microsecond=59)  # -> datetime.time(23, 59, 59, 59)   Python Console
 print(time_time)                                                  # -> 10:20:50.000100
 time_time                                                         # -> datetime.time(10, 20, 50, 100)  Python Console
 time_time = time_time.replace(hour=23, minute=59, second=59, microsecond=59)
 print(time_time)                                                  # -> 23:59:59.000059
 time_time                                                         # -> datetime.time(23, 59, 59, 59)   Python Console

------------------------------------------------------------------------------------------------------------------------
 time.isoformat(timespec='auto') - Получить строку в формате ISO 8601
 import datetime

 time = datetime.time(hour=12, minute=34, second=56, microsecond=123456)
 print(time.isoformat(timespec='minutes'))       # -> 12:34
 time = datetime.time(hour=12, minute=34, second=56, microsecond=0)
 print(time.isoformat(timespec='microseconds'))  # -> 12:34:56.000000
 print(time.isoformat(timespec='auto'))          # -> 12:34:56

------------------------------------------------------------------------------------------------------------------------
 time.__str__() - Получить строковое представление объекта time()

 dt = datetime.datetime.now()
 time = dt.time()
 print(time.__str__())  # -> '17:44:06.104203'
 print(str(time))       # -> '17:44:06.104203'

------------------------------------------------------------------------------------------------------------------------
 time.strftime(format) - Пользовательское форматирование объекта time()

 dt = datetime.datetime.now()
 time = dt.time()
 time.strftime('%H:%M:%S')                     # -> 17:45:29
 time.strftime('%H часов %M минут %S секунд')  # -> 17 часов 45 минут 29 секунд
 time.strftime('%H:%M')                        # -> 17:45

 # Можно через ф-строки
 f"{time:%H:%M}"         # -> 17:45
 time.strftime('%H:%M')  # -> 17:45

------------------------------------------------------------------------------------------------------------------------
 time.__format__(format) - Это позволяет указать строку формата для datetime объекта в литералах форматированной
 строки и при использовании str.format()

 import datetime

 today = datetime.datetime.now()
 f"{today:%B %d, %Y}"  # -> 'May 31, 2024'

------------------------------------------------------------------------------------------------------------------------
 time.utcoffset() - Получить смещение времени UTC в виде timedelta()

 import datetime
 dt = datetime.datetime.now()
 time = dt.time()
 print(time.utcoffset())  # -> None

------------------------------------------------------------------------------------------------------------------------
 time.dst() - Получить смещение летнего/зимнего времени

 import datetime
 dt = datetime.datetime.now()
 time = dt.time()
 print(time.dst())  # -> None

------------------------------------------------------------------------------------------------------------------------
 time.tzname() - Получить название часового пояса

 import datetime
 dt = datetime.datetime.now()
 time = dt.time()
 print(time.tzname())  # -> None

------------------------------------------------------------------------------------------------------------------------

 -- Объекты  tzinfo    Разница между местным временем и UTC  --

 class datetime.tzinfo
 это абстрактный базовый класс, означающий, что этот класс не должен вызываться напрямую. Необходимо определить
 свой подкласс datetime.tzinfo для сбора информации о конкретном часовом поясе.


 tzinfo.utcoffset(dt) - возвращает смещение местного времени от UTC, как объект datetime.timedelta().
 tzinfo.dst(dt)       - возвращает корректировку перехода на летнее время DST как объект datetime.timedelta().
 tzinfo.tzname(dt)    - возвращает имя часового пояса в виде строки
 tzinfo.fromutc(dt)   - вызывается из реализации по умолчанию dt.astimezone().

------------------------------------------------------------------------------------------------------------------------

 -- Объекты  timezone    Преобразовать локальное время в UTC  --

 class datetime.timezone(offset, name=None) - является подклассом datetime.tzinfo, каждый экземпляр которого
 представляет часовой пояс, определенный фиксированным смещением от UTC.

 Аргумент смещения offset должен быть указан как объект datetime.timedelta(), представляющий разницу между местным
 временем и UTC. Смещение должно быть строго между -timedelta(hours=24) и timedelta(hours=24), в противном случае
 появиться исключение ValueError.

 Аргумент name не является обязательным. Если указано, то это должна быть строка, которая будет использоваться
 в качестве значения, возвращаемого методом datetime.tzname().

 import datetime
 offset = datetime.timedelta(hours=3)
 print(datetime.timezone(offset, name='МСК'))  # -> МСК                    <-----
 print(datetime.timezone(offset))              # -> UTC+03:00              <-----

 # Python Console
 datetime.timezone(offset, name='МСК')  # ->  datetime.timezone(datetime.timedelta(seconds=10800), 'МСК')
 datetime.timezone(offset)              # ->  datetime.timezone(datetime.timedelta(seconds=10800))

 Методы экземпляра класса datetime.timezone():

------------------------------------------------------------------------------------------------------------------------
 timezone.utcoffset(dt)  - возвращает фиксированное значение, указанное при создании экземпляра часового пояса.
 timezone.tzname(dt)     - возвращает фиксированное значение, указанное при создании экземпляра часового пояса.

 import datetime

 # utcoffset
 offset = datetime.timedelta(hours=3)
 tz = datetime.timezone(offset, name='МСК')  # -> МСК
 dt = datetime.datetime.now()
 print(tz.utcoffset(dt))  # -> 3:00:00
 tz.utcoffset(dt)         # -> datetime.timedelta(seconds=10800)   Python Console
 # Или
 dt = datetime.datetime.now(tz=tz)
 print(dt.utcoffset())    # -> 3:00:00
 dt.utcoffset()           # -> datetime.timedelta(seconds=10800)   Python Console

 # tzname
 offset = datetime.timedelta(hours=3)
 tz = datetime.timezone(offset, name='МСК')  # -> МСК
 dt = datetime.datetime.now()
 print(tz.tzname(dt))  # -> МСК
 tz.tzname(dt)         # -> 'МСК'     Python Console
 # Или
 dt = datetime.datetime.now(tz=tz)
 print(dt.tzname())    # -> МСК
 dt.tzname()           # -> 'МСК'     Python Console

------------------------------------------------------------------------------------------------------------------------
 timezone.dst(dt) - всегда возвращает None.
------------------------------------------------------------------------------------------------------------------------
 timezone.fromutc(dt) -  возвращает dt + offset. Аргумент dt должен быть "осведомленным" экземпляром datetime.datetime()
 с tzinfo, установленным в self.

------------------------------------------------------------------------------------------------------------------------
 Атрибут timezone.utc() возвращает часовой пояс UTC, эквивалентно datetime.timezone(datetime.timedelta(0)).

 import datetime

 print(datetime.timezone(datetime.timedelta(0)))  # -> UTC
 datetime.timezone(datetime.timedelta(0))         # -> datetime.timezone.utc   Python Console
------------------------------------------------------------------------------------------------------------------------


 --- Format Codes  Правила форматирования strftime() и strptime()  f-stings    fstring  ---              <-----
 import datetime

 dt = datetime.datetime.now()

 print(dt)          # ->  2024-06-01 13:21:44.231479
 print(f"{dt:%a}")  # ->  Sat            %a  Сокращенное название дня недели
 print(f"{dt:%A}")  # ->  Saturday       %A  Полное название дня недели
 print(f"{dt:%w}")  # ->  6              %w  День недели как число, где 0 это Воскресение и 6 — суббота.
 print(f"{dt:%d}")  # ->  01             %d  День месяца
 print(f"{dt:%b}")  # ->  Jun            %b  Месяц как сокращенное название
 print(f"{dt:%B}")  # ->  June           %B  Месяц как полное название
 print(f"{dt:%m}")  # ->  06             %m  Месяц в виде десятичного числа с добавлением нуля.
 print(f"{dt:%y}")  # ->  24             %y  Год без столетия как десятичное число с нулем.
 print(f"{dt:%Y}")  # ->  2024           %Y  Год с веком как десятичное число.
 print(f"{dt:%H}")  # ->  13             %H  Час (24-часовой формат) в виде десятичного числа с добавлением нуля.
 print(f"{dt:%I}")  # ->  01             %I  Час (12-часовые часы) в виде десятичного числа с добавлением нуля.
 print(f"{dt:%p}")  # ->  PM             %p  AM - 00:00 до 12:00 , PM - 12:00 до 00:00
 print(f"{dt:%M}")  # ->  21             %M  Минута как десятичное число с добавлением нуля.
 print(f"{dt:%S}")  # ->  44             %S  Секунда как десятичное число с добавлением нуля.
 print(f"{dt:%f}")  # ->  231479         %f  Микросекунда как десятичное число, дополненное нулями слева.
 print(f"{dt:%z}")  # ->  ' '            %z  Смещение UTC в форме `±HHMM[SS[.ffffff]]` или пустая строка, если объект наивный.
 print(f"{dt:%Z}")  # ->  ' '            %Z  Имя часового пояса или пустая строка, если объект наивный.
 print(f"{dt:%j}")  # ->  153            %j  День года в виде десятичного числа с нулем.
 print(f"{dt:%U}")  # ->  21             %U  Номер недели в году (ВОСКРЕСЕНЬЕ - первый день недели)
 print(f"{dt:%W}")  # ->  22             %W  Номер недели в году (ПОНЕДЕЛЬНИК - первый день недели)
 print(f"{dt:%c}")  # ->  Sat Jun  1 13:21:44 2024             %c  Соответствие локали дате и времени.
 print(f"{dt:%x}")  # ->  06/01/24       %x  Представление даты
 print(f"{dt:%X}")  # ->  13:21:44       %X  Время
 print(f"{dt:%%}")  # ->  %              %%  Буквальный символ '%'.

 print(f"{dt:%G}")  # ->  2024           %G  ISO 8601 год со столетием, который содержит большую часть недели ISO (%V).
 print(f"{dt:%V}")  # ->  22             %V  ISO 8601 неделя, понедельник - 1 , Неделя 01 - неделя, содержащая 4 января
 print(f"{dt:%u}")  # ->  6              %u  ISO 8601 День недели в виде десятичного числа, где 1 - понедельник.

 # ISO 8601 - международный стандарт, выпущенный организацией ISO, который описывает форматы дат и времени

 Примеры  strftime, strptime, f-strings                                <-----

 from datetime import datetime

 print(datetime.strptime('31/01/22 23:59:59.999999', '%d/%m/%y %H:%M:%S.%f'))  # -> 2022-01-31 23:59:59.999999
 #  datetime.datetime(2022, 1, 31, 23, 59, 59, 999999)   Python console
 _.strftime('%a %d %b %Y, %I:%M%p')  # -> 'Mon 31 Jan 2022, 11:59PM'    #    _ последнее выражение в Python Console

------------------------------------------------------------------------------------------------------------------------
 # Форматирования datetime.datetime() в строку c датой и временем:

 from datetime import datetime

 dt = datetime.now()
 print(dt)                                               # -> 2024-06-01 13:40:43.842613
 print(dt.strftime("%H:%M - %m %d %Y г."))               # -> 13:40 - 06 01 2024 г.
 print(dt.strftime('%H часов %M минут %m.%d.%Y года'))   # -> 13 часов 40 минут 06.01.2024 года
 print(dt.strftime("%m/%d/%y"))                          # -> 06/01/24
 print(dt.strftime("%m-%d-%y"))                          # -> 06-01-24

 print(f"{dt:%m/%d/%y}")                                 # -> 06/01/24
 print(f"{dt:%m-%d-%y}")                                 # -> 06-01-24

 print('День: {0:%d}, Месяц: {0:%B}, время: {0:%H:%M}.'.format(dt))  # -> День: 01, Месяц: June, время: 13:40.
 print(f'День: {dt:%d}, Месяц: {dt:%B}, время: {dt:%H:%M}.')         # -> День: 01, Месяц: June, время: 13:40.

------------------------------------------------------------------------------------------------------------------------
 # Преобразование строки с датой и временем в объект datetime.datetime():
 from datetime import datetime

 date_str = 'Sat, 01 Jun 2024 12:20:20 +0000'
 format = '%a, %d %b %Y %H:%M:%S +0000'
 print(datetime.strptime(date_str, format))  # -> 2024-06-01 12:20:20
 datetime.strptime(date_str, format)         # -> datetime.datetime(2024, 6, 1, 12, 20, 20)  # Python Console

 date_str = '01.06.2024 12:20'
 format = '%d.%m.%Y %H:%M'
 print(datetime.strptime(date_str, format))  # -> 2024-06-01 12:20:20
 datetime.strptime(date_str, format)         # -> datetime.datetime(2024, 6, 1, 12, 20)      # Python Console

------------------------------------------------------------------------------------------------------------------------
 # Преобразование datetime.datetime() в строку для базы данных:

 from datetime import datetime

 print(datetime.now())                     # -> 2024-06-01 14:28:58.575580
 print(datetime.now().isoformat(sep='T'))  # -> 2024-06-01T14:28:58.575580

------------------------------------------------------------------------------------------------------------------------
 # Преобразование datetime.date() в строку для базы данных:

 from datetime import date

 print(date.today().isoformat())                     # -> 2024-06-01
 dt = date(1990, 6, 1).isoformat()
 print(dt)                                           # -> 1990-06-01

------------------------------------------------------------------------------------------------------------------------
 # Преобразование строки из базы данных в datetime.datetime():

 from datetime import datetime

 line_db = '2024-06-01'
 print(datetime.fromisoformat(line_db))  # -> 2024-06-01 00:00:00
 datetime.fromisoformat(line_db)         # -> datetime.datetime(2024, 6, 1, 0, 0)              # Python Console

 line_db = '2024-06-01T00:05:23'
 print(datetime.fromisoformat(line_db))  # -> 2024-06-01 00:05:23
 datetime.fromisoformat(line_db)         # -> datetime.datetime(2024, 6, 1, 0, 5, 23, 283000)  # Python Console

 line_db = '2024-06-01 00:05:23.283'
 print(datetime.fromisoformat(line_db))  # -> 2024-06-01 00:05:23.283000
 datetime.fromisoformat(line_db)         # -> datetime.datetime(2024, 6, 1, 0, 5, 23, 283000)  # Python Console

 line_db = '2024-06-01T00:05:23+04:00'
 print(datetime.fromisoformat(line_db))  # -> 2024-06-01 00:05:23+04:00
 datetime.fromisoformat(line_db)
 # datetime.datetime(2024, 6, 1, 0, 5, 23, tzinfo=datetime.timezone(datetime.timedelta(seconds=14400))) # Python Console

------------------------------------------------------------------------------------------------------------------------
 # Преобразование строки из базы данных в datetime.date():

 from datetime import date

 line_db = '2024-06-01'
 print(date.fromisoformat(line_db))      # -> 2024-06-01
 date.fromisoformat(line_db)             # -> datetime.date(2024, 6, 1)                        # Python Console

------------------------------------------------------------------------------------------------------------------------



 -- Модуль inspect предоставляет несколько полезных функций, помогающих получить информацию о живых объектах, таких как:
  модули, классы, методы, функции, обратные трассировки, объекты фреймов и объекты кода.

 модуль inspect предоставляет четыре основных вида услуг:
 проверка типов, получение исходного кода, проверка классов и функций и проверка стека интерпретатора.

 Обратная трассировка - это отчет, который помогает нам понять причину исключения.
 самостоятельно вызвать:  raise Exception()

 Фреймы(кадр, frame) — это объекты, представляющие области памяти, в которых сохраняются локальные переменные при вызове функции.
 Их можно хранить и манипулировать ими, что и делают отладчики. Понимание того, как Python обрабатывает кадры,
 может помочь вам избежать утечек памяти.

 frames — это настоящие объекты Python, с которыми вы можете взаимодействовать.

 from timeit import timeit     # библиотека замера скорости
 from pympler import asizeof   # библиотека замера размера структур
 import dis                    # библиотека работы с байт кодом

 a_list = list(range(100))
 print(timeit('a_list[0]', 'from __main__ import a_list'))

 print(asizeof.asizeof(a_list))

 print(timeit('list(range(10))'))
 print(timeit('tuple()'))
 print(timeit('()'))

 Функция sys.getsizeof возвращает размер переданного ей обьекта, этот размер не включает в себя сложные структуры классов и т.д.
 sys.getsizeof([1, 2, 3]) или [1, 2, 3].__sizeof__()
 Функция pympler.asizeof - рекурсивно ищет всё вложенние поля и элементы, и отображает общий размер обьекта



  --- Системы счисления. Как работают ---

 # Пример с числом 4321  в 8 системе счисления    Восьмеричная система (основание 8)
 # 4321 / 8 = 540, остаток 1
 # 540 / 8 = 67, остаток 4
 # 67 / 8 = 8, остаток 3
 # 8 / 8 = 1, остаток 0
 # 1 / 8 = 0, остаток 1


 # Пример с числом 4321  в 16 системе счисления   Шестнадцатеричная система (основание 16)
 # 4321 / 16 = 270, остаток 1
 # 270 / 16 = 16, остаток 14 (E в шестнадцатеричной системе)
 # 16 / 16 = 1, остаток 0
 # 1 / 16 = 0, остаток 1


 # Пример с числом 4321  в 2 системе счисления    Двоичная система (основание 2)
 # 4321 / 2 = 2160, остаток 1
 # 2160 / 2 = 1080, остаток 0
 # 1080 / 2 = 540, остаток 0
 # 540 / 2 = 270, остаток 0
 # 270 / 2 = 135, остаток 0
 # 135 / 2 = 67, остаток 1
 # 67 / 2 = 33, остаток 1
 # 33 / 2 = 16, остаток 1
 # 16 / 2 = 8, остаток 0
 # 8 / 2 = 4, остаток 0
 # 4 / 2 = 2, остаток 0
 # 2 / 2 = 1, остаток 0
 # 1 / 2 = 0, остаток 1


 # Пример с числом 4321  в 8 системе счисления
 print(4321-(4321//8*8))                            # -> 1
 print(4321//8 - ((4321//8//8)*8))                  # -> 4
 print((4321//8//8) - (4321//8//8//8*8))            # -> 3
 print((4321//8//8//8) - (4321//8//8//8//8*8))      # -> 0
 print((4321//8//8//8//8) - (4321//8//8//8//8//8))  # -> 1

 По умолчанию система счисления десятичная, но можно задать любое основание от 2 до 36 включительно.
 Системы счисления:
 int('0b1010', base=2)  # -> 10   int('0b1010', 2)  # -> 10              bin(10)    # -> 0b1010
 int('0o12', base=8)    # -> 10   int('0o12', 8)    # -> 10              int('10')  # -> 10
 int('10', base=10)     # -> 10   int('10', 10)     # -> 10              oct(10)    # -> 0o12
 int('0xa', base=16)    # -> 10   int('0xa', 16)    # -> 10              hex(10)    # -> 0xa



 --- Скаляр   Scalar ---
 К скалярным (простым, НЕДЕЛИМЫМ) встроенным типам данных относятся: int, float, complex,  True, False, None
 Литералы целых чисел : десятичное, двоичное, восьмеричное, шестнадцатиричное и другие системы счисления

 Скалярная структура данных — это самый простой тип данных, который одновременно содержит только одно атомарное значение.
 Скаляр - это буквально все, что представляет собой одно числовое значение, поэтому в ТЕРМИНАХ Python это будет:  <-----
 int(все системы счисления), float и, возможно, complex, decimal.Decimal и Fraction.Fraction.
 Не существует одной вещи, называемой скаляром.

 Что такое скаляр в Python?
 Короче говоря, скаляр — это одна переменная , например целое число. В разное время он может принимать разные значения,
 но в любой момент времени он имеет только одно значение.

 Скаляр:
 - Скаляр в Python относится к одному значению, например целому числу, вещественному числу или строке.
 - Скаляры представляют отдельные элементы данных, которые не являются частью коллекции.
 - Скаляры не имеют собственной размерности и обычно используются для представления отдельных значений или переменных.
 Скаляры — это атомарные значения.
 --- END Скаляр ---

 Некоторые объекты в языке программирования Python изменчивы - могут изменять свое состояние или содержимое, то есть
 позволяют удалять и добавлять элементы . Методы, которые добавляют, вычитают или переставляют свои элементы на месте
 # inplace и не возвращают определенный элемент, никогда не возвращают сам экземпляр коллекции - возвращают None

 Кроме того, все объекты в Python относятся к одной из 2-х категорий:

 - Мутирующие/Изменяемые (англ. Mutable): содержимое объекта можно изменить после создания          <-----
 НЕ СОЗДАЁМ НОВЫЙ ОБЬЕКТ В ПАМЯТИ. ИЗМЕНЯЕМ ТЕКУЩИЙ

 - Немутирующие/Неизменяемые (англ. Immutable): содержимое объекта нельзя изменить после создания.  <-----
 СОЗДАЁМ НОВЫЙ ОБЬЕКТ В ПАМЯТИ.

 Недостаток Immutable:
 большее количество потребляемой памяти на дополнительное копирование объектов при необходимости внесения изменений.

 Основные ВСТРОЕННЫЕ ТИПЫ ДАННЫХ языка Python:
  Типы данных ИЗМЕНЯЕМЫЕ(mutable) Списки(list), Словари(dict), Множества(set), Массивы байтов (bytearray)  и
  Пользовательские классы(Самописные классы Classes) (Class Instances - экземпляры классов)

  Типы данных НЕ ИЗМЕНЯЕМЫЕ(immutable): Числа (int, float, complex), Булевые (bool), Строки (str), Кортежи (tuple),
  НЕизменяемые множества (frozenset), Диапазоны (range), Байтовые строки (bytes)


 Коллекции: list(mutable), tuple(immutable), dict(mutable), set(mutable), frozenset(immutable), str(immutable) - text sequence
 Коллекции делятся на:
 - последовательности(Sequence):  list, tuple, range   Binary Sequence Types: bytes, bytearray, memoryview  Text Sequence: str
 - множества(Set):                set и frozenset
 - отображения(Mapping):          dict

 Числовые типы данных: int(immutable), float(immutable), complex(immutable)
 Строковые типы данных: str(immutable)
 Булевы типы данных: bool(immutable)


 Именно такие типы, которые невозможно изменить без создания новых объектов и называется в Python неизменяемыми.
 строки неизменяемы, каждый срез строки выделяет новый объект. tuple += (1,) - создаёт новый обьект


  В Python есть 4 (ЧЕТЫРЕ) Built-in (ВСТРОЕННЫХ) СТРУКТУРЫ ДАННЫХ, которые вы можете использовать для хранения данных:  <-----
    list(список), tuple(кортеж), dict(словарь), set(множество), frozenset(неизменяемое множество)

 Дополнительные СТРУКТУРЫ ДАННЫХ в - Модуле collections :

 - OrderedDict нужен для действий со словарем где необходим порядок элементов, например
 сравнение с учетом порядка, перестановки элементов с сохранением порядка. Платим памятью!!!

 - ChainMap нужен для логического обьединения словарей для поиска информации, но при изменениях меняется первый словарь

 - Counter нужен для подсчета элементов в последовательности, работает только с hashable

 - defaultdict нужен для создания словаря по умолчанию. Значение подставляется при обращении к несуществующему ключу
   Можно использовать свой самописный класс

 - deque(двунаправленная очередь) потокобезопасна, быстро оперирует с обеими сторонами

 - namedtuple нужен для создания структуры данных, нечто среднее между стандартными типами и самописными классом.
 Неизменяемый, позволяет обращаться по имени атрибута, позволяет использовать индексы.


  Структуры данных в языке Python:      <-----    <-----    <-----    <-----
 Список                 (list)
 Массив                 (array)
 Стек                   (LifoQueue)
 Очередь                (Queue)
 Дек                    (deque)
 Очередь с приоритетом  (heapq)
 Кортеж                 (tuple)
 Множество              (set, frozenset)
 Словарь                (dict)


 АДТ – это МАТЕМАТИЧЕСКОЕ описание некоторых данных и операций над ними (например, стек, очередь, список, множество).
 В Python АДТ может быть реализован с помощью классов и встроенных типов.  АДТ - АБСТРАКТНЫЙ ТИП ДАННЫХ

 -- Как Python ХИТРИТ С НЕИЗМЕНЯЕМЫМИ Объектами --
 # Ложь во имя спасения! -  ОНИ ЭКОНОМЯТ ПАМЯТЬ И УСКОРЯЮТ РАБОТУ ИНТЕРПРЕТАТОРА

 # Для КОРТЕЖА [:]  и tuple(t)  - Возвращает ссылку на ИСХОДНЫЙ Кортеж           # Пример с list() и [:]  ДЕЛАЕТ КОПИЮ
 t1 = (1, 2, 3)                                                                  lst1 = [1, 2, 3]
 t2 = tuple(t1)                                                                  lst2 = list(lst1)
 print(t1 is t2)  # -> True                                                      print(lst1 is lst2)  # -> False
 t3 = t1[:]                                                                      lst3 = lst1[:]
 print(t3 is t1)  # -> True                                                      print(lst3 is lst1)  # -> False


 # ТАКОЕ ЖЕ ПОВЕДЕНИЕ У frozenset, str, bytes                                    # Пример str()
 f1 = frozenset({1, 2, 3})                                                       s1 = str({1, 2, 3})
 f2 = frozenset(f1)                                                              s2 = str(s1)
 print(f1 is f2)  # -> True                                                      print(s1 is s2)      # -> True
 f3 = f1.copy()                                                                  s3 = s1[:]
 # f[:] - НЕ работает Потому что frozenset НЕ ПОСЛЕДОВАТЕЛЬНОСТЬ
 # f3 = f1[:]   # -> TypeError: 'frozenset' object is not subscriptable
 print(f3 is f1)  # -> True                                                     print(s3 is s1)       # -> True


  -- Как можно изменить ТИП ОБЪЕКТА  Атрибут  __class__   НЕ рекомендуется!!  --

 # Можно изменить тип объекта, изменив атрибут __class__
 Да, в Python можно изменить тип объекта, присвоив ему другой класс через атрибут __class__. Однако это НЕ рекомендуется,
 так как может привести к непредсказуемым последствиям и нарушению принципов объектно-ориентированного программирования.
 Лучше избегать таких подходов.

 class A:
     def greet(self):
         return "Hello from A"

 class B:
     def greet(self):
         return "Hello from B"

 # Создаем объект класса A
 obj = A()
 print(obj.greet())  # Вывод: Hello from A

 # Изменяем класс объекта на B
 obj.__class__ = B

 print(obj.greet())  # Вывод: Hello from B


 --- Sequence Types  Типы последовательностей ---

 Существует три основных типа последовательностей  Sequence Types:
 - list списки
 - tuple кортежи
 - range диапазоны.

 Дополнительные типы последовательностей предназначенные для обработки двоичных данных и текстовых строк:
 - bytes байтовые строки
 - bytearray байтовые массивы
 - str текстовые строки

 -- Binary Sequence Types  Типы двоичных последовательностей:
  bytes, bytearray, memoryview

 -- Text Sequence Type (текстовой последовательности) — str

 Тип str - текстовые строки можно создать различными способами:
 new_str  = 'Строка'        # -> 'Строка'
 new_str1 = '"Строка"'      # -> '"Строка"'
 new_str2 = "'Строка'"      # -> "'Строка'"
 new_str3 = ″″″Строка″″″    # -> 'Строка'
 new_str4 = '''Строка'''    # -> 'Строка'
 new_int = str(1)           # -> '1'
 new_list = str([1, 2, 3])  # -> '[1, 2, 3]'
 new_tuple = str((1, 2, 3)) # -> '(1, 2, 3)'
 new_set = str({1, 2, 3})   # -> '{1, 2, 3}'


 # Нет Ошибки считается как ОДНА СТРОКА
 print('HE''HE')                # -> HEHE
 print("HE""HE")                # -> HEHE
 print(f'HE'f'HE')              # -> HEHE
 print(f"HE""HE")               # -> HEHE

 # С отступами тоже самое
 print('HE'           'HE')     # -> HEHE
 print("HE"           "HE")     # -> HEHE
 print(f"HE"        f"HE")      # -> HEHE
 print(f'''HE'''    f'''HE''')  # -> HEHE


 Но в коде используем одни кавычки! '1', '2'   не нужно использовать разные  '1', "2"
 Одинарные кавычки: 'позволяет вставлять "двойные" кавычки'
 Двойные кавычки: "позволяет использовать встроенные 'одинарные' кавычки".

 В Тройных кавычках можно делать перенос на новую строку. В Одинарных/Двойных НЕЛЬЗЯ

 a_str = '''text    a_str = ″″″text     a_str = "text
 '''                ″″″                 "   # -> SyntaxError: unterminated string literal

 Тройные кавычки - Можно разделить на несколько строк, можно использовать двойные/одинарные кавычки и всё что угодно
 print('''You can 'use' 'single quotes'
          "double quotes" "inside"!      # Комментарии НЕ Работают!
       ''')
 # -> You can 'use' 'single quotes'
 # ->          "double quotes" "inside"!      # Комментарии НЕ Работают!


 # (docstrings) для функций Конечно лучше использовать Тройные-двойные кавычки!
 def foo():
     '''docstring  удобный способ добавления документации'''


 Строки(str) Python не могут быть изменены:
 word = 'Python'
 print(id(word), word)   # -> 140728151803896  Python
 word[0] = 'J'           # -> TypeError: 'str' object does not support item assignment
 del word[0]             # -> TypeError: 'str' object doesn't support item deletion
 word = word + '100'     # word += '100' аналогичная операция   Создаем новый обьект в памяти
 print(id(word), word)   # -> 1212523711600    Python100   Создался новый обьект


 -- Immutable sequences(Неизменяемые последовательности): Strings, Tuples, Bytes, Range
 Неизменяемые типы последовательностей поддерживают только общие операции с последовательностями.
 Единственная операция, которая реализована в неизменяемых типах последовательностей и которая не доступна изменяемым
 типам последовательностей - это поддержка встроенного метода hash().

 Эта поддержка позволяет использовать неизменяемые последовательности, такие как экземпляры кортежей,
 в качестве ключей словарей dict и хранить их в экземплярах множеств set и frozenset.

 -- Mutable sequences(Изменяемые последовательности): List, Byte Array
 Модуль collections и array предоставляет дополнительные примеры изменяемых типов последовательностей.

 Изменяемые типы последовательностей поддерживают общие операции с последовательностями и операции над изменяемыми последовательностями.

 Python по-разному обрабатывает изменяемые и неизменяемые объекты:

 - Доступ к неизменяемым последовательностям быстрее, чем к изменяемым.
 - Изменяемые объекты отлично подходят для использования, когда вам нужно изменить, добавить или удалить элементы последовательности.
 - Неизменяемые последовательности используются, когда вам нужно убедиться, что созданный вами объект всегда останется прежним.
 - Неизменяемые последовательности очень "дороги" для изменения, потому что для этого необходимо создать копию, а менять
   изменяемые последовательности "дешево".

 --- Общие операции с последовательностями ---

 общие операции с последовательностями, которые поддерживаются большинством типов последовательностей,
 как изменяемых, так и неизменяемых. Коллекция collections.abc.Sequence ABC обеспечивает правильную реализацию этих
 операций на пользовательских типах последовательностей.

 Общие операции с последовательности, отсортированные по возрастанию приоритета выполнения в коде:

 Проверка наличия значения элемента    - x in sequences
 Проверка отсутствия значения элемента - x not in sequences

 позволяет объединить/сложить последовательности одного типа - sequence1 + sequence2
 Если объединяемые последовательности разного типа, то поднимается исключение TypeError.
 - Диапазоны range не поддерживают конкатенацию/объединение последовательностей, т. к. последовательности
 элементов в них следуют определенным шаблонам.
 - Для того, что бы объединить множество set с последовательностью или другим множеством, необходимо использовать
 специально предназначенный для этого метод sets.union(*others).

 Повторение последовательности N раз - sequence * n
 - Диапазоны range не поддерживают добавления себя к самой себе
 - Изменяемое множество set не поддерживает операцию повторения в N раз, т.к. это неупорядоченная коллекция без повторяющихся элементов.

 Получение значения элемента по его индексу - sequence[i]
 - Множества set не поддерживает индексирование элементов, т.к. это неупорядоченная коллекция без повторяющихся элементов.
 Но если все же необходимо получить значение элемента по индексу, то множество set необходимо преобразовать в список list или кортеж tuple.

 Получение среза sequence[i:j]  - sequence[i:j]
 - Множества set не поддерживает индексирование элементов

 Получение среза с заданным шагом sequence[i:j:k] - sequence[i:j:k]
 - Множества set и frozenset не поддерживает индексирование элементов

 Количество элементов в последовательности - len(sequence)

 Минимальное значение элемента в последовательности - min(sequence)
 - При передаче в качестве аргумента текстовых строк или символов или байтовых строк, минимальное значение будет выбираться
 исходя из порядка следования символов, в таблице соответствующей кодировки.
 - Данная операция сравнивает элементы, используя оператор <. Поэтому значения в последовательности должны быть одного
 типа, иначе бросается исключение TypeError

 Максимальное значение элемента в последовательности - max(sequence)

 индекс первого вхождения метод index() - sequence.index(x[, i[, j]])
 - Множества set и frozenset не поддерживает индексирование элементов

 Количество вхождений элемента в последовательности - sequence.count(x)
 - Множества set и frozenset не поддерживает метод .count()
 или используем Класс Counter() модуля collections.

 --- Ranges  Диапазоны ---

 class range(stop)
 class range(start, stop[, step])

 Тип range - диапазон, представляет собой неизменяемую последовательность чисел и обычно используется для выполнения
 определенного количества раз циклов for.

 Для диапазонов доступны общие операции с последовательностями, кроме конкатенации и повторения, поскольку объекты
 диапазона могут представлять только последовательности, которые следуют строгому шаблону, а повторение и конкатенация
 обычно нарушают этот шаблон.

 Проверка диапазонов range на равенство с == и != сравнивает их как последовательности. То есть два объекта диапазона
 считаются равными, если они представляют одну и ту же последовательность значений.

 Обратите внимание, что два объекта диапазона, которые считаются равными, могут иметь разные атрибуты start, stop и step

 range(0) == range(2, 1, 3)        # -> True
 range(0, 3, 2) == range (0, 4, 2) # -> True

 Примеры range:
 list(range(10))          # -> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
 list(range(1, 11))       # -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 list(range(0, 30, 5))    # -> [0, 5, 10, 15, 20, 25]
 list(range(0, 10, 3))    # -> [0, 3, 6, 9]
 list(range(0, -10, -1))  # -> [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
 list(range(0))           # -> []
 list(range(1, 0))        # -> []
 [*range(10, 0, -1)]      # -> [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

 r = range(0, 20, 2)
 r               # ->  range(0, 20, 2)
 11 in r         # ->  False
 10 in r         # ->  True
 r.index(10)     # ->  5
 r[5]            # ->  10
 r[:5]           # ->  range(0, 10, 2)
 r[-1]           # ->  18

 # Так тоже можно
 x = range(5)[-1]
 print(x)  # -> 4


 Объект Python 3 range() не выдает числа сразу,  выдает числа по требованию .         <-----
 Преимущество типа range перед обычным list или tuple заключается в том, что range объект всегда будет занимать один и
 тот же (небольшой) объем памяти, независимо от размера представляемого им диапазона (поскольку он хранит только значения
 start и stop, step вычисляя отдельные элементы и поддиапазоны как нужный).           <-----


 -- Почему так нужно делать!   range(len(lst)-1) --
 `len(lst) - 1` нужно писать, чтобы избежать выхода за границы списка. Когда ты используешь `range(len(lst)-1)`,
 это означает, что цикл будет итерироваться по индексам от `0` до `len(lst) - 2`. Это позволяет безопасно обращаться к
 элементу `lst[i + 1]`, поскольку в этом случае `i + 1` всегда будет находиться в пределах существующих индексов списка.

 Индексы
 range задаётся как [начало, конец):

 range(0, 3) - это [0, 1, 2], и если вам нужны числа от 1 до 10, то выпишете range(1, 11)

 По этой же причине если вам нужно посчитать с 10 до 1 включительно, то вы пишете range(10, 0, -1) Как только нужно
 работать с индексами (что в питоне, к счастью, нечасто), то везде появляются i+1 или i-1, потому что начало включается,
 а конец - нет. Это бесит.



 class str(object='')
 class str(object=b'', encoding='utf-8', errors='strict')


 # Модуль import textwrap      - Для переформатирования текста
 import textwrap               - Для переформатирования текста


  # БАЙТОВАЯ строка и ОБЫЧНАЯ строка
 s = 'Hello World'            s = b'Hello World'
 print(s[0])  # -> H          print(s[0])  # -> 72

 # Декоде
 print(s_bytes.decode('ascii'))  # -> Hello World
 print(s_bytes)                  # -> b'Hello World'





 --- Методы строки(str) ---
 методы строк не изменяют исходную строку, а создают копию с изменениями.                    <-----
 a_str = 'NEW'
 a_str.replace('N', '')  #           Создаёт копию a_str                 <-----
 print(a_str)            # -> 'NEW'  Исходная строка НЕ ИЗМЕНИЛАСЬ       <-----

 Чтобы исходная строка изменилась нужно присовение =                                         <-----
 a_str = 'NEW'
 a_str = a_str.replace('N', '')  #  Присвоение значения =                  <-----
 print(a_str)                    #  -> 'EW'  Исходная строка ИЗМЕНИЛАСЬ!!  <-----


 replace, translate -  быстрее чем регулярные выражения для ПРОСТЫХ ЗАМЕН   -  Самый быстрый вариант нужно ТЕСТИРОВАТЬ!

 str.translate(str.maketrans(',', ' ')) - замена нескольких значений сразу
 'abab'.translate(str.maketrans('ab', 'ba'))  # -> baba

 str.replace(old, new[, count]) - Замена old на new. count ограничивает количество замен
 '1,1,2,2,3,3'.replace(',', '0', 1)  = 101,2,2,3,3,    '1,1,2,2,3,3'.replace(',', '0')  = 10102020303

 str.splitlines(keepends=False) - возвращает список строк, текста str, разделенного по универсальным разрывам строк.
 Если аргумент keepends=True, то разрывы (разделители) строк включаются в результирующий список.
 'ab c\n\nde fg\rkl\r\n'.splitlines() = ['ab c', '', 'de fg', 'kl']
 'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True) = ['ab c\n', '\n', 'de fg\r', 'kl\r\n']

 str.split(sep=None, maxsplit=-1) - Возвращает список слов в строке, используя sep в качестве строки-разделителя.
 Если задан maxsplit , будет выполнено не более maxsplit разбиений    '1,2,3'.split(',') = ['1', '2', '3']

 str.join(iterable) - объединяет список строк с выбранным разделителем ''         ''.join(['a', 'b', 'c']) = abc
 ''.join({1, '2', '3'})  # -> TypeError: sequence item 1: expected str instance, int found    Чтобы все были только str

 str.title() - Первую букву каждого слова переводит в верхний регистр, а все остальные в нижний
 'nice nice nice'.title() = Nice Nice Nice

 str.capitalize() - только первое слово в предложении а все остальные без изменений
 'nice nice nice'.capitalize() = Nice nice nice

 str.count(str, [start],[end]) - Возвращает количество непересекающихся вхождений подстроки в диапазоне [начало, конец]
 (0 и длина строки по умолчанию)  'cool'.count('o')  = 2

 str.strip([chars]) - Удаление пробельных символов или chars в начале и в конце строки '  ABC  '.strip() = ABC, 'ABC'.strip('AB') = C
 print('www.example.com'.strip('cmowz.')) # -> example ,  print('ABC'.strip('AC'))  # -> B

 str.lstrip([chars]) - символы удаляются только слева (в начале) default='Пробел'   - '  ABC  ABC'.lstrip() = ABC  ABC
 print('   spacious   '.lstrip())  # -> spacious ,  print('ABC'.lstrip('AB'))  # -> C
 print('www.example.com'.lstrip('cmowz.')) # -> example.com

 str.rstrip([chars]) - удаляются только символы справа (в конце) default='Пробел'  - '  ABC  ABC'.lstrip() =   ABC  ABC
 print('mississippi'.rstrip('ipz'))  # -> mississ ,  print('ABC'.rstrip('C'))  # -> AB
 print('Monty Python'.rstrip(' Python')) # -> M ,  print('Monty Python'.removesuffix(' Python')) # -> Monty

 str.swapcase() - Переводит символы нижнего регистра в верхний, а верхнего – в нижний   'A b C d'.swapcase()) = a B c D

 str.center(width, [fill]) - Возвращает отцентрованную строку, по краям которой стоит символ fill (пробел по умолчанию)
 'ABC'.center(5, 'H') = HABCH, 'A B C A'.center(10, 'a') = aA B C Aaa

 str.zfill(width) - Возвращает копию строки, заполненную '0' цифрами ASCII, чтобы создать строку длины width.Ведущий
 префикс знака ('+'/ '-') обрабатывается путем вставки дополнения после символа знака, а не перед ним. Исходная строка
 возвращается, если ширина меньше или равна len(s).  "42".zfill(5) = 00042, "-42".zfill(5) = -0042, "+42".zfill(5) = +0042

 str.ljust(width[, fillchar]) - Возвращает строку с выравниванием по левому краю в строке длины width.
 fillchar (default is space '').    'AAAA'.ljust(10, '+') = AAAA++++++

 str.rjust(width[, fillchar]) - Возвращает строку, выровненную по правому краю, в виде строки длины width .
 fillchar (default is space '').    'AAAA'.rjust(10, '+') = ++++++AAAA

 str.removeprefix(prefix, /) - Если строка начинается со строки префикса , верните string[len(prefix):].
 В противном случае верните копию исходной строки:
 'TestHook'.removeprefix('Test') = 'Hook', 'BaseTestCase'.removeprefix('Test') = 'BaseTestCase'            убрать начало

 str.removesuffix(suffix, /) - Если строка заканчивается строкой суффикса и этот суффикс не пуст, верните
 string[:-len(suffix)]. В противном случае верните копию исходной строки:
 'MiscTests'.removesuffix('Tests') = 'Misc',  'TmpDirMixin'.removesuffix('Tests') = 'TmpDirMixin'           убрать конец

 str.partition(sep) - Возвращает тройной кортеж, содержащий часть перед первым sep, сам sep, и часть после sep.
 Если sep не найден, возвращается кортеж, содержащий саму строку, а затем две пустых строки
 'TestHook'.partition('st') = ('Te', 'st', 'Hook'), 'TestHook'.partition('z') = ('TestHook', '', '')

 str.startswith(prefix[, start[, end]]) - Возврат True, если строка начинается с префикса, в противном случае возврат False.
 'A B C A'.startswith('A') = True, 'A B C A'.startswith('A', 1) = False, 'zzzTest'.startswith(('zzz', 'yyy', 'rrr')) = True

 str.endswith(suffix[, start[, end]]) - Возврат, True если строка заканчивается указанным суффиксом, в противном случае возврат False.
 'Testzzz'.endswith(('zzz', 'yyy', 'rrr')) = True, 'A B C A B'.endswith('A') = False, 'A B C A'.endswith('A') = True

 `startswith()` и `endswith()` в Python часто работают быстрее, чем регулярные выражения.           <-----


 str.find(sub[, start[, end]]) - Поиск подстроки в строке. Возвращает номер первого вхождения или -1
 'ABC'.find('5') = -1,  'ABCA'.find('A') = 0, 'ABCA'.find('A', 1) = 1

 str.rfind(sub[, start[, end]]) - Поиск подстроки в строке. Возвращает номер последнего вхождения или -1
 'ABCA'.rfind('5') = -1, 'ABCA'.rfind('A') = 3

 str.index(sub[, start[, end]]) - Аналогично find(), но поднимается ValueError, когда подстрока не найдена
 'ABCA'.index('5') = ValueError: substring not found, 'ABCA'.index('A') = 0, 'ABCA'.index('A', 1, 10) = 3

 str.rindex(sub[, start[, end]]) - Аналогично rfind(), но поднимается ValueError, когда подстрока не найдена

 str.upper() - Преобразование строки к верхнему регистру, 'aaaa'.upper() = AAAA, 'aaAA'.upper() = AAAA
 str.lower() - Преобразование строки к нижнему регистру, 'AAAA'.lower() = aaaa, 'aaAA'.lower() = aaaa
 str.casefold() - вернет регистр свернутой копии строки str. Свертывание регистров похоже на нижний регистр,
 но более агрессивен, потому что он предназначен для удаления всех различий регистра в строке.
 'AAAA'.casefold() = aaaa, 'aaAA'.casefold() = aaaa


 str.isalpha() - Возврат True, если все символы в строке являются буквенными и есть хотя бы один символ, False в противном случае.
 'ABCA'.isalpha() = True, 'ABCA1111'.isalpha() = False

 str.isalnum() Возвращает значение True, если все символы в строке являются буквенно-цифровыми и имеется хотя бы один
 символ False в противном случае.  'ABCA1111'.isalnum() = True, '////'.isalnum() = False, 'ABC+++'.isalnum() = False

 str.isdigit() - Возврат True, если все символы в строке являются цифрами и есть хотя бы один символ, False в противном случае.
 'AAA'.isdigit() = False, '1234'.isdigit() = True

 str.isdecimal() - Возврат True, если все символы в строке являются десятичными символами и есть хотя бы один символ,
 False в противном случае. Десятичные символы — это те символы, которые можно использовать для формирования чисел по основанию 10

 str.isnumeric() имеет еще более широкий спектр чисел чем isdigit() и isdecimal()

 str.islower() - Состоит ли строка из символов в нижнем регистре    'AAA'.islower() = False, 'aaa'.islower() = True
 str.isupper() - Состоит ли строка из символов в верхнем регистре   'AAA'.isupper() = True,  'aaa'.isupper() = False

 str.istitle() - Начинаются ли слова в строке с заглавной буквы   'Aaa Aaa'.istitle() = True, 'AAA AAA'.istitle() = False

 str.isspace() - если в строке есть только пробельные символы      print('        \t\n'.isspace())  # -> True

 str.isprintable() - если все символы в строке печатаемые или строка пустая   print('\n '.isprintable())    # -> False

 str.isidentifier() - является ли строка допустимым идентификатором
 from keyword import iskeyword

 print('hello'.isidentifier(), iskeyword('hello'))  # -> True False
 print('def'.isidentifier(), iskeyword('def'))      # -> True True
 print('\n'.isidentifier(), iskeyword('\n'))        # -> False False


 ord(символ) - Символ в его код ASCII,    ord('a') = 97, ord('A') = 65
 chr(число) - Код ASCII в символ,         chr(97) = 'a', chr(65) = 'A'


 -- split() --

 # split() без параметров разбивает по разделителям строки   пробелы/табуляции/переносы строк
 print('GoodMorning'.split())        # ->  ['GoodMorning']
 print('Good Morning'.split())       # ->  ['Good', 'Morning']
 print('Good      Morning'.split())  # ->  ['Good', 'Morning']
 print('Good\t\t\tMorning'.split())  # ->  ['Good', 'Morning']
 print('Good\n\n\nMorning'.split())  # ->  ['Good', 'Morning']
 print('Good\n \n\t   \t   Morning'.split())  # ->  ['Good', 'Morning']
 print('Good==Morning'.split('=='))  # ->  ['Good', 'Morning']
 print('Good--Morning'.split('-'))   # ->  ['Good', '', 'Morning']


 -- join() --

 # Из Строки собираем строку
 print(' '.join('GoodMorning'))          # ->  G o o d M o r n i n g

 # Из Списка собираем строку
 print(''.join(['Good', 'Morning']))     # ->  GoodMorning
 print('---'.join(['Good', 'Morning']))  # ->  Good---Morning

 # Немного про join() как склеит строку
 lst = [1, 2, 3]
 print(''.join(map(str, lst)))    # -> 123
 print(' '.join(map(str, lst)))   # -> 1 2 3
 print('\n'.join(map(str, lst)))  # Будет выводит с каждой строки    # через перенос строки \n
 # -> 1
 # -> 2
 # -> 3


 -- shielding Экранирование --

 # Экранирование Двойных кавычек '' ""
 print('Книга\'Огурец\'')    # -> Книга'Огурец'
 print("Книга\"Огурец\"")    # -> Книга"Огурец"

 # Или  Сырые строки r''
 print(r"Книга\"Огурец\"")   # -> Книга\"Огурец\"

 # Или  Тройные кавычки
 print('''Книга"Огурец"''')  # -> Книга"Огурец"

 # Не забываем про таблицу ASCII
 print('\345')    # -> å
 print(ord('å'))  # -> 229

 # Написать одну кавычку или две внутри таких-же
 print('\'')  # -> '
 print("\"")  # -> "


 -- Модуль string  - Текстовые константы и шаблоны

 import string
 string.ascii_letters   ->  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
 string.ascii_lowercase ->  'abcdefghijklmnopqrstuvwxyz'
 string.ascii_uppercase ->  'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
 string.digits          ->  '0123456789'
 string.hexdigits       ->  '0123456789abcdefABCDEF'
 string.octdigits       ->  '01234567'
 string.punctuation     ->  !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
 string.printable       ->  digits, ascii_letters, punctuation, and whitespace.
 string.whitespace      ->  Сюда входят пробелы, табуляция, перевод строки, возврат, перевод страницы и вертикальная табуляция.

 - Класс Formatter в модуле string позволяет создавать и настраивать собственное поведение форматирования строк,
 используя ту же реализацию, что и встроенный метод str.format().


 Почему многострочные строки (тройные кавычки) могут использоваться для комментариев в Python?
 Ответ - Потому что они игнорируются интерпретатором, если не присвоены переменной.


 -- Синтаксис форматирующей строки f-strings  f-строки  fstring --                          <-----      <-----
 Метод str.format() и Formatter класс используют один и тот же синтаксис для строк формата
 (хотя в случае Formatter подклассы могут определять свой собственный синтаксис строки формата).
 f-строки - нельзя использовать в качестве строк документации:
 def foo():
    f"Not a docstring"
 foo.__doc__ is None # -> True


 # Классные примеры использования
 print(f'{"quoted string"}')      # -> 'quoted string'
 print(f'{{ {4*10} }}')           # -> { 40 }
 print(f'{{{4*10}}}')             # -> {40}
 print(fr'x={4*10}\n')            # -> x=40\n
 print(f'{(lambda x: x*2)(3)}')   # -> 6


 F-строки в тройных кавычках Можно
 # Можно использовать f''''''                   <-----

 # Обрати внимание на вывод тут учитывается всё!  Тройные кавычки МНОГОСТРОЧНЫЕ
 print(f'''number:{10}\n

           str:{str(10)}
 ''')

 #    number:10
 #
 #
 #           str:10



 values = f'''
   {{
     "name": "{name}",
     "groupId": "xxxx"
   }}
 '''

 Однако нет необходимости генерировать JSON самостоятельно. requests сделает это за вас, если вы используете json
 аргумент ключевого слова:

 response = requests.post('https://xxxx',
                           json={'name': name, 'groupId': 'xxxx'},
                           headers=headers)



 # Можно использовать f''  и F''                                   Но всегда используем  f''   <-----
 print(F'number {1}')     # -> number 1
 print(f'number {1}')     # -> number 1

 # Можно использовать r''  и R''                                   Но всегда используем  r''   <-----
 print(R'Backslash \\}')  # -> Backslash \\}
 print(r'Backslash \\}')  # -> Backslash \\}
 print('Backslash \\}')   # -> Backslash \}   # Без r''  R''

 common_string = 'C:\file.txt' # Обычная строка
 raw_string = r'C:\file.txt'   # Сырая строка

 Комбинируем префиксы                                                                          <-----
 # Используем 2 префикса одновременно:
 raw_f_string = rf'C:\file.txt'
 f_raw_string = fr'C:\file.txt'

 Разница между префиксами fr и rf    Разницы НЕТ!                                               <-----
 Так как в выражениях внутри f-строк запрещено использовать обратный слеш \ (это ограничение f-строк, при нарушении
 которого появляется ошибка: SyntaxError: f-string expression part cannot include a backslash), то разницы между
 fr-строками и rf-строками НЕТ.

 Вы можете комбинировать  f-строку с r-строкой  fr''   rf''                                    <-----
 # Пример fr''
 user = 'Alex'
 dirToSee = fr'C:\Users\{user}\Downloads'                                                fr''  <-----
 print(dirToSee)  # -> C:\Users\Alex\Downloads

 Нельзя комбинировать  f-строку с 'b'                                                          <-----
 print(fb'')  # -> SyntaxError: invalid syntax

 # Но можно так
 a = 123
 print(f'{a}'.encode()) # -> b'123'

 Если вам нужно включить в обычный текст фигурную скобку, ее можно экранировать, удвоив: {{ and }}.
 key = 1
 city = 'City'
 value = 22
 f'{{\n\t {key}: {city} - {value} \n}}'     # ХОРОШИЙ ОТВЕТ  Экранированние {{  }}

 f"{{key}}: {{city}} - {{str(value)}}"      # -> {key}: {city} - {str(value)}
 f"{{1}}: {{'City'}} - {{str(22)}}"         # -> {1}: {'City'} - {str(22)}  тоже самое что и с переменными выше

 ФЛАГИ ПРЕОБРАЗОВАНИЯ: !s = str(), !r = repr(), !a = ascii()
 name = 'good'
 f"Very {0!s}"     # -> str() для аргумента 0       # -> str(int(0))
 f"Very {name!s}"  # -> str() для аргумента name    # -> Very good    разница  good
 f"Very {name!r}"  # -> repr() для аргумента name   # -> Very 'good'  разница 'good'
 f"Very {name!a}"  # -> ascii() для аргумента name  # -> Very 'good'  разница 'good'


 Пример Сокращенная запись:
 line = "he he"
 f"{line=}"        # -> line='he he'
 f"line={line}"    # -> line=he he
 f"{line = }"      # -> line = 'he he'
 f"line = {line})  # -> line = he he


 С Python 3.12:
 Разрешается повторное использование типа цитирования внешней f-строки внутри поля замены:
 a = dict(x=2)
 f"abc {a[ "x" ]} def" # -> 'abc 2 def'  Python 3.12 +
 f"abc {a[ 'x' ]} def" # -> 'abc 2 def'  До Python 3.12 Нужно экранировать "' '"

 - Template strings Строки шаблона -
 - class string.Template(template)
 Основным вариантом использования шаблонных строк - является интернационализация (i18n), поскольку более простой
 синтаксис и функциональность шаблонов упрощают перевод, чем другие встроенные средства форматирования строк в Python.

 substitute(mapping={}, /, **kwds) - выполняет подстановку шаблона, возвращая новую строку.
 safe_substitute(mapping={}, /, **kwds) - называется "безопасным", потому что он всегда пытается вернуть используемую
 строку вместо вызова исключения.

 from string import Template
 s = Template('$who likes $what')
 print(s.substitute(who='tim', what='kung pao'))        # -> tim likes kung pao

 d = dict(who='tim')
 print(Template('Give $who $100').substitute(d))        # -> ValueError: Invalid placeholder in string: line 1, col 11
 print(Template('$who likes $what').substitute(d))      # -> KeyError: 'what'

 print(Template('$who likes $what').safe_substitute(d)) # -> tim likes kung pao

 - Mini-Language Спецификация формата:
 # Работают аналогично  rjust=<, ljust=>, center=^
 pi = 3.141592
 result = 121
 print(f'{pi:.2f}')      # f'{pi:.2f <- сколько будет после запятой}'  -> 3.14
 print(f'{result:06}')   # запосление нулями                           -> 000121
 print(f'{result:^12}')  # заполение пробелы по центру                 ->    121
 print(f'{result:0^12}') # заполение нулями по центру                  -> 000012100000
 print(f'{result:h^12}') # заполение h по центру                       -> hhhh121hhhhh
 print(f'{result:>12}')  # заполение пробелами слева                   ->          121
 print(f'{result:<12}')  # заполение пробелами справа                  -> 121
 print(f'{result:+}')    # добавить знак +                             -> +121

 print(f'{12112312:,}')  # разделитель ,  -> 12,112,312
 print(f'{12112312:_}')  # разделитель _  -> 12_112_312

 print(f'{100.000:n}')   # n превратить в обычное число  -> 100  # формат целых чисел


 # Сравнение с методами строк   rjust() >     ljust() <     center() ^
 x = 15
 y = 'String'

 # rjust() >
 print(f'{x:>10}')              # ->         15  # Заполнили Пробелами Слева
 print(f'{x:!>10}')             # -> !!!!!!!!15  # Заполнили !
 # Тоже самое но с rjust()
 print(str(x).rjust(10))        # ->         15  # Заполнили Пробелами Слева
 print(str(x).rjust(10, '!'))   # -> !!!!!!!!15  # Заполнили ! Слева

 # ljust() <
 print(f'{x:<10}')              # -> 15          # Заполнили Пробелами Справа
 print(f'{x:!<10}')             # -> 15!!!!!!!!  # Заполнили ! Справа
 # Тоже самое но с ljust()
 print(str(x).ljust(10))        # -> 15          # Заполнили Пробелами
 print(str(x).ljust(10, '!'))   # -> 15!!!!!!!!  # Заполнили ! Справа

 # center() ^
 print(f'{x:^10}')              # ->     15      # Заполнили Пробелами по Центру
 print(f'{x:!^10}')             # -> !!!!15!!!!  # Заполнили ! по Центру
 # Тоже самое но с center()
 print(str(x).center(10))       # ->     15      # Заполнили Пробелами по Центру
 print(str(x).center(10, '!'))  # -> !!!!15!!!!  # Заполнили ! по Центру


 # Можно использовать внутри f'{{}}'  Разбери Пример  Заполняем по центру
 a, b, c = 10, 'z', '#'
 print((lambda N, X, Y: f'{Y}{X:{Y}^{N}}')(a, b, c))  # -> #####z#####

 # Хороший пример!!!                                                            <-----
 import datetime
 today = datetime.datetime.now()
 print(f'{today:%d-%m-%Y %H:%M:%S}')                  # -> 01-06-2024 11:12:02
 print(f'{today:%d%m%Y %H%M%S}')                      # -> 01062024 111129    # Внутри просто разделитель можно без него
 print(f'{today:%d GOOD %m GOOD %Y %H::::%M::::%S}')  # -> 01 GOOD 06 GOOD 2024 11::::11::::12
 print(today)                                         # -> 2024-06-01 11:11:29.880699


 # Считаем % от числа
 real = 50   # %
 full = 100  # от какого числа
 print(f'{real/full:.2%}')     # -> 50.00%
 print(format(50/100, '.1%'))  # -> 50.0%    # Тоже самое но с format()

 Понимание МИНИ-ЯЗЫКА формата Python :

 BNF(Backus–Naur form) grammar  BNF(Бэкуса — Наура форма) грамматика:
 format_spec     ::=  [[fill]align][sign]["z"]["#"]["0"][width]
                     [grouping_option]["." precision][type]
 fill            ::=  <any character>
 align           ::=  "<" | ">" | "=" | "^"
 sign            ::=  "+" | "-" | " "
 width           ::=  digit+
 grouping_option ::=  "_" | ","
 precision       ::=  digit+
 type            ::=  "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" |
                      "G" | "n" | "o" | "s" | "x" | "X" | "%"

 Выравнивание:
 < - Левое выравнивание результата (в пределах доступного пространства);
 > - Выравнивает результат по правому краю (в пределах доступного пространства);
 ^ - Выравнивает результат по центру (в пределах доступного пространства);
 = - Помещает результат в крайнее левое положение;

 Примеры:
 Выравнивание и заполнение вывода:
 text = "Hello!"

 # width=30
 f"{text:30}"                 # -> 'Hello!                        '

 # align="<" and width=30
 f"{text:<30}"                # -> 'Hello!                        '

 # align="^" and width=30
 f"{text:^30}"                # -> '            Hello!            '

 # align=">" and width=30
 f"{text:>30}"                # -> '                        Hello!'

 # fill="=", align="^" and width=30
 f"{text:=^30}"               # -> '============Hello!============'

 Преобразование между представлениями типов:

 f"{'42':s}"# s - строка, можно не указывать, используется по умолчанию  -> '42'

 f"{42:d}"  # d - int десятичный формат base 10                          -> '42'
 f"{42:x}"  # x - hex шестнадцатеричный формат, нижний регистр  base 16  -> '2a'  используя строчные буквы для цифр выше 9.
 f"{42:X}"  # X - hex шестнадцатеричный формат, верхний регистр base 16  -> '2A'  используя строчные буквы для цифр выше 9.
 f"{42:o}"  # o - oct Восьмеричный формат base 8                         -> '52'
 f"{42:b}"  # b - bin двоичный формат  base 2                            -> '101010'
 f"{42:f}"  # f - float формат чисел с плавающей запятой                 -> '42.000000'
 f"{42:n}"  # n - формат целых чисел                                     -> '42'

 # десятичных типов
 f"{42:e}"            # e - научный формат, со строчной буквой e               -> '4.200000e+01'
 f"{42:E}"            # e - научный формат, со строчной буквой e               -> '4.200000E+01'
 f"{float('inf'):f}"  # f - формат чисел с плавающей запятой, нижний регистр   -> 'inf'
 f"{float('inf'):F}"  # f - формат чисел с плавающей запятой, верхний  регистр -> 'INF'
 f"{1234567890:g}"    # g - общий формат, нижний регистр                       -> '1.23457e+09'
 f"{1234567890:G}"    # G - общий формат, верхний регистр                      -> '1.23457E+09'

 # Установка десятичной точности
 f"{10.000000:.1f}" # -> '10.0'
 f"{10.000000:.2f}" # -> '10.00'
 f"{10.000000:.4f}" # -> '10.0000'

 # Использование разделителей тысяч
 number = 1234567890
 f"{number:,}"     # -> '1,234,567,890'
 f"{number:_}"     # -> '1_234_567_890'
 f"{number:,.2f}"  # -> '1,234,567,890.00'
 f"{number:_.2f}"  # -> '1_234_567_890.00'

 # Добавление знаков
 positive = 42
 negative = -42
 print(f"{positive:+}")  # показать знак числа +/-   ->   '+42'
 print(f"{negative:+}")  # показать знак числа +/-   ->   '-42'
 print(f"{positive:-}")  # показать только для -     ->   '42'
 print(f"{negative:-}")  # показать только для -     ->   '-42'
 print(f"{positive: }")  # для положительных пробел  ->    '42'
 print(f"{negative: }")  # для отрицательных минус   ->   '-42'

 # Форматирование дат
 from datetime import datetime
 now = datetime.now()
 f"Today is {now:%a %b %d, %Y} and it's {now:%H:%M:%S} seconds" # -> 'Today is Tue May 07, 2024 and it's 18:29:28 seconds'

 # Выражение процентов
 wins = 25
 games = 35
 f"Team's winning percentage: {wins / games:%}"   # -> 'Team's winning percentage: 71.428571%'
 f"Team's winning percentage: {wins / games:.2%}" # -> 'Team's winning percentage: 71.43%'

 # Модификаторы  Python 3.11+

 # Опция 'z' Преобразует отрицательные нулевые значения с плавающей запятой в положительные нули после округления до
 # точности формата. Этот параметр действителен только для типов представления с плавающей запятой.
 neg_zero = -0.00000
 f"{neg_zero:z}"     # -> '0.0'
 f"{neg_zero:z.4f}"  # -> '0.0000'


 # Опция '#'  добавляет префиксы представления типа
 number = 42
 f"hex: {number:#x}, oct: {number:#o}, bin: {number:#b}" # -> 'hex: 0x2a, oct: 0o52, bin: 0b101010'
 f"hex: {number:x}, oct: {number:o}, bin: {number:b}"    # -> 'hex: 2a, oct: 52, bin: 101010'

 -- Форматировании строк в питоне --
 -- 5 способов форматирования строк:

 1) Конкатенация. Грубый способ форматирования, в котором мы просто склеиваем несколько строк с помощью операции сложения:
 name = "Sasya"
 age = 250
 "My name is " + name + " I am " + str(age) + " old."         # -> 'My name is Sasya I am 250 old.'

 2. %-форматирование. Самый популярный способ, который перешел в Python из языка С. Передавать значения в строку можно через
 списки и кортежи , а также и с помощью словаря. Во втором случае значения помещаются не по позиции, а в соответствии с именами.

 name = "Sasya"
 age = 250
 "My name is %s I am %d old." % (name, age)                    # -> 'My name is Sasya I am 250 old.'
 "My name is %(name)s I am %(age)d old." % {'name': name, 'age': age}

 3. Template-строки. Этот способ появился в Python 2.4, как замена %-форматированию (PEP 292), но популярным так и не стал.
 Поддерживает передачу значений по имени и использует $-синтаксис как в PHP.

 from string import Template
 name = "Sasya"
 age = 250
 s = Template("My name is $name I am $age old.")
 s.substitute(name=name, age=age)                               # -> 'My name is Sasya I am 250 old.'

 4. Форматирование с помощью метода format(). Этот способ появился в Python 3 в качестве замены %-форматированию.
 Он также поддерживает передачу значений по позиции и по имени.

 "My name is {} I am {} old.".format(name, age)                 # -> 'My name is Sasya I am 250 old.'
 "My name is {name} I am {age} old.".format(name=name, age=age) # -> 'My name is Sasya I am 250 old.'

 5. f-строки. Форматирование, которое появилось в Python 3.6 (PEP 498). Этот способ похож на форматирование с помощью
 метода format(), но гибче, читабельней и быстрей.

 f"My name is {name} I am {age} old."                           # -> 'My name is Sasya I am 250 old.'

 Если вы используете Python 3.6 и старше, то самое время использовать f-строки — они гибкие и быстрые.

 - F-строки всегда возвращают   str Строку:
 number = f"{123} {list()} {set()} {dict()}"  # -> '123 [] set() {}'
 number = f"{123} {list} {set} {dict}"        # -> "123 <class 'list'> <class 'set'> <class 'dict'>"
 type(number), number  # -> <class 'str'> '123 [] set() {}'
 type(f"")             # -> <class 'str'>

 Четыре способа форматирования строк:
 string.Template    from string import Template
                    s = Template('who and what')
                    s.substitute(who='spam', what='eggs')  # -> ('spam', 'eggs')

 сишный стиль      # '%s and %s' % ('spam', 'eggs')      # ->  'spam and eggs'
 f-строки          #  f'spam and eggs'                   # ->  'spam and eggs'
 str.format()      # '{} and {}'.format('spam', 'eggs')  # ->  'spam and eggs'


 # format Не работает с ф-строкой  SyntaxError: f-string: empty expression not allowed

 print('{}{}'.format('he', 'he'))   # -> hehe
 print(f'{}{}'.format('he', 'he'))  # -> SyntaxError: f-string: empty expression not allowed



 А вот метод format содержит в себе одно важное преимущество.
 Дело в том, что в модульных проектах не всегда бывает так, что переменная находится в том же окружении, что и строка-шаблон.

 # у нас нет переменной name
 s = f"Моё имя - {name}"          # -> NameError: name 'name' is not defined

 # у нас нет переменной name
 s = "Моё имя - {name}"
 print(s.format(name='Антон'))    # -> Моё имя - Антон   ошибки уже не будет


 #  Можно использовать * и **    в format()
 a_dict = {'A': '1', 'B': '2'}
 a_list = ['C', 2, 'D']

 print('Coordinates: {A} , {B} '.format(**a_dict))       # ->   Coordinates: 1 , 2
 print('Coordinates: {1} , {2} , {0} '.format(*a_list))  # ->   Coordinates: 2 , D , C


 Если форматирующие строки поступают от пользователей, то используйте  string.Template, чтобы избежать проблем с безопасностью.
 f-строки     - если Python 3.6+
 str.format() - если меньше чем Python 3.6+


 --- Кеширование небольших чисел в CPython ---
 Python кэширует целые числа в диапазоне [-5, 256], поэтому целые числа в этом диапазоне обычно, но не всегда, идентичны.
 CPython содержит небольшой целочисленный кеш в диапазоне [-5, 256], поэтому числа в диапазоне [-5, 256] будут ссылаться
 на один и тот же адрес памяти.
 Причем это касается любых значений, которые приводятся к целым числам этого диапазона. Можно завести число хоть
 в двоичном виде, хоть в hex, кеширование все равно будет работать.
 Числа ВНЕ диапазона [-5, 256] интерпретатор тоже будет пытаться оптимизировать, но только если они находятся
 в одной строке (или одном файле). В командной строке интерпретатора так не работает.
 В общем и целом то, что нужно запомнить — это что небольшие числа в интерпретаторе хранятся не так, как большие,
 и что с ними следует пользоваться оператором ==, а не is.

 Python (CPython, если быть точнее) в целях производительности кеширует короткие строки и малые целые числа, поэтому возможны такие казусы:

 a = 100000000000
 b = 'aaaaaaaaaaaaaa'
 print(a is 100000000000)      # -> True
 print(b is 'aaaaaaaaaaaaaa')  # -> True
 # SyntaxWarning: "is" with a literal. Did you mean "=="?  Но работает Просто предупреждение!

 оптимизация CPython  string interning (интернирование)               оптимизация CPython для чисел
 a = 'hello'                                                          a = 256
 b = 'hello'                                                          b = 256
 a is b       # -> True                                               a is b       # -> True
 id(a), id(b) # -> 2129013088176 2129013088176                        id(a), id(b) # -> 140728144626440 140728144626440

 a = "wtf!"; b = "wtf!"                                               a, b = 257.0, 257.0
 a is b      # -> True                                                a is b      # -> True
 print('a' * 20 is 'aaaaaaaaaaaaaaaaaaaa') #  -> True                 a = b = 25700000000000
 SyntaxWarning: "is" with a literal. Did you mean "=="?               a is b      # -> True
# Отрабатывает но выдаёт ошибку

 Еще пример!
 a = []                         a = 400                         a = dict()                    a = dict()
 b = []                         b = 400                         b = set()                     b = dict()
 a == b          # -> True      a == b          # -> True       a == b          # -> False    a == b          # -> True
 a is b          # -> False     a is b          # -> True       a is b          # -> False    a is b          # -> False
 id(a) == id(b)  # -> False     id(a) == id(b)  # -> True       id(a) == id(b)  # -> False    id(a) == id(b)  # -> False

 Интересно!

 a = 'aaaaa'                                a = 'aaaaa'                            a = 'aaaaa'
 b = ''.join(list('aaaaa'))                 b = 'aaaaa'                            b = 'a' * 5
 print(a == b)              # -> True       print(a == b)          # -> True       print(a == b)           # -> True
 print(a is b)              # -> False      print(a is b)          # -> True       print(a is b)           # -> True
 print(id(a) == id(b))      # -> False      print(id(a) == id(b))  # -> True       print(id(a) == id(b))   # -> True

 НЕИЗМЕНЯЕМЫЕ ЗНАЧЕНИЯ ИМЕЮТ ОДНУ И ТУЖЕ ССЫЛКУ НА ОБЬЕКТ!  А ИЗМЕНЯЕМЫЕ НЕТ!                               <-----
 Если будет ИЗМЕНЯЕМЫЙ Обьект, то ССЫЛКИ БУДУТ РАЗНЫЕ!!!   Работает только для tuple

 a = tuple()                           a = tuple((1, 2))                      a = tuple((1, 2, []))
 b = tuple()                           b = tuple((1, 2))                      b = tuple((1, 2, []))
 print(a == b)           # -> True     print(a == b)           # -> True      print(a == b)           # -> True
 print(a is b)           # -> True     print(a is b)           # -> True      print(a is b)           # -> False <-----
 print(id(a) == id(b))   # -> True     print(id(a) == id(b))   # -> True      print(id(a) == id(b))   # -> False <-----

 Какие встроенные типы данных дают True!!!

 a = int()             a = str()             a = bool()            a = bytes()           a = tuple()
 b = int()             b = str()             b = bool()            b = bytes()           b = tuple()
 a == b   # -> True    a == b   # -> True    a == b   # -> True    a == b   # -> True    a == b   # -> True
 a is b   # -> True    a is b   # -> True    a is b   # -> True    a is b   # -> True    a is b   # -> True

 Какие встроенные типы данных дают False!!!

 a = float()         a = complex()       a = list()           a = dict()          a = frozenset()     a = set()
 b = float()         b = complex()       b = list()           b = dict()          b = frozenset()     b = set()
 a == b  # -> True   a == b  # -> True   a == b   # -> True   a == b  # -> True   a == b  # -> True   a == b  # -> True
 a is b  # -> False  a is b  # -> False  a is b   # -> False  a is b  # -> False  a is b  # -> False  a is b  # -> False

 a = range(10)       a = bytearray()     a = tuple((10, {}))  a = tuple((10, frozenset()))  a = tuple((10, set()))
 b = range(10)       b = bytearray()     b = tuple((10, {}))  b = tuple((10, frozenset()))  b = tuple((10, set()))
 a == b  # -> True   a == b  # -> True   a == b  # -> True    a == b  # -> True             a == b  # -> True
 a is b  # -> False  a is b  # -> False  a is b  # -> False   a is b  # -> False            a is b  # -> False

 И ТУТ Я ВООБЩЕ НЕ ПОНИМАЮ КАК ОНО РАБОТАЕТ!!! Через конструктор выдает False  Наверно лучше делать без конструктора:
 Тестирую с tuple!!!
 a = (10,)         # <-----    a = (int(10),)    # <-----     a = ("A",)        # <-----    a = (str("A"),)   # <-----
 b = (10,)         # <-----    b = (int(10),)    # <-----     b = ("A",)        # <-----    b = (str("A"),)   # <-----
 a == b  # -> True             a == b  # -> True              a == b  # -> True             a == b  # -> True
 a is b  # -> True    <-----   a is b  # -> False  <-----     a is b  # -> True   <-----    a is b  # -> False  <-----
 a       # -> (10,)            a       # -> (10,)             a       # -> ('A',)           a       # -> ('A',)
 type(a) # -> <class 'tuple'>  type(a) # -> <class 'tuple'>   type(a) # -> <class 'tuple'>  type(a) # -> <class 'tuple'>



 Кэширование данных — это процесс хранения результатов выполнения функций и запросов во временном хранилище (кэше)
 с целью ускорения повторного обращения к ним. Вместо того чтобы заново выполнять те же операции, можно просто получить
 результат из кэша, что существенно экономит время и ресурсы.

 Кэш является потокобезопасным.


 --- numbers — Numeric abstract base classes ---
 Числовые типы — int, float, complex
 Numeric Types — int, float, complex

 Применить  __class__  к числу:
 1.__class__    # -> SyntaxError: invalid decimal literal
 1   .__class__ # -> <class 'int'>  #  нужно поставить ПРОБЕЛ после числа
 (1).__class__  # -> <class 'int'>

 -- Битовые операции над целыми числами:

 Побитовые операции:
 x << y - побитовый сдвиг влево
 x >> y - побитовый сдвиг вправо
 x & y  - побитовое И
 x ^ y  - побитовое исключающее ИЛИ
 x | y  - побитовое ИЛИ
 ~x     - побитовое НЕ

 Примеры использования:
 x = 5
 y = 6
 print(x & y)      -> 4
 print(x | y)      -> 7
 print(x ^ y)      -> 3
 print(x >> 2)     -> 1
 print(x << 2)     -> 20
 print(~x)         -> -6

 from numbers import Number
 подклассы Number:
 Целые числа(int)  <class 'int'>

 --- class int ---

 -- Методы типа int:

 int.bit_length() - Возвращает количество битов, необходимых для представления целого числа в двоичном виде, исключая знак и начальные нули:

 n = -37
 bin(n)
 '-0b100101'
 n.bit_length()
 # 6

 Эквивалентно:
 def bit_length(self):
    # двоичное представление: bin(-37) => '- 0b100101'
    s = bin(self)
    # удалить начальные нули и знак минус
    s = s.lstrip('-0b')
    # len('100101') => 6
    return len(s)
------------------------------------------------------------------------------------------------------------------------
 int.bit_count() - Возвращает количество единиц в двоичном представлении абсолютного значения целого числа.

 n = 19
 bin(n)
 '0b10011'
 n.bit_count()
 # 3
 (-n).bit_count()
 # 3

 Эквивалентно:
 def bit_count(self):
    return bin(self).count("1")
------------------------------------------------------------------------------------------------------------------------
 int.to_bytes(length=1, byteorder='big', *, signed=False) - Возвращает массив байтов, представляющих целое число.

 (65).to_bytes()
 # b'A'

 Эквивалентно:
 def to_bytes(n, length=1, byteorder='big', signed=False):
    if byteorder == 'little':
        order = range(length)
    elif byteorder == 'big':
        order = reversed(range(length))
    else:
        raise ValueError("byteorder must be either 'little' or 'big'")

    return bytes((n >> i*8) & 0xff for i in order)
------------------------------------------------------------------------------------------------------------------------
 classmethod int.from_bytes(bytes, byteorder='big', *, signed=False) - Возвращает целое число, которое соответствует указанному массиву байтов.
 int.from_bytes(b'\x00\x10', byteorder='big')
 # 16

 def from_bytes(bytes, byteorder='big', signed=False):
    if byteorder == 'little':
        little_ordered = list(bytes)
    elif byteorder == 'big':
        little_ordered = list(reversed(bytes))
    else:
        raise ValueError("byteorder must be either 'little' or 'big'")

    n = sum(b << i*8 for i, b in enumerate(little_ordered))
    if signed and little_ordered and (little_ordered[-1] & 0x80):
        n -= 1 << 8*len(little_ordered)

    return n
------------------------------------------------------------------------------------------------------------------------
 int.as_integer_ratio() - Возвращает пару целых чисел, отношение которых равно исходному целому числу и имеет положительный знаменатель.
 3.as_integer_ratio()    # -> SyntaxError: invalid decimal literal

 3 .as_integer_ratio()   # -> (7, 2) Добавляем пробел перед точкой .
 (3).as_integer_ratio()  # -> (7, 2) или оборачиваем ()
------------------------------------------------------------------------------------------------------------------------
 int.is_integer() - Возвращает True. Существует для совместимости типа утки (duck type) - с float.is_integer()

 (20.0).is_integer() -> True
 (19.5).is_integer() -> False
------------------------------------------------------------------------------------------------------------------------

 Вещественные числа(float) <class 'float'>

 В отличии от int, float ограничен по величине сверху и снизу.
 Слишком маленькие по модулю числа превратятся в 0, а слишком большие в inf     inf = infinity = бесконечность
 начиная с 1.8*10**308 и больше, действительные числа превращаются в inf.       1.8*10^308  ^ - возведения в степень

 print(float(1.8 * 10 ** 308))      # -> inf
 print(1.7*10**308)                 # -> 1.7e+308
 print(float(0.5 * pow(10, -234)))  # -> 5e-235     # Знак минуса есть - Отрицательное число

 Экспоненциальная запись
 # Запись 1e+100 означает, что число равно 1*10**100
 very_big_number = float(10 ** 100)
 print(very_big_number)             # -> 1e+100


 # Очень большие (>= 10**16)  или очень маленькие числа  ( < 10**-4) python записывает в Экспоненциальном виде.
 print(float(10**15))  # -> 1000000000000000.0
 print(float(10**16))  # -> 1e+16
 print(float(10**-4))  # -> 0.0001
 print(float(10**-3))  # -> 0.001


 # Интересный пример    Можно опускать   до и после   точки .
 num1 = 40.000
 num2 = 40.0
 num3 = 40.
 num4 = 0.5
 num5 = .5

 print(num1)  # -> 40.0
 print(num2)  # -> 40.0
 print(num3)  # -> 40.0
 print(num4)  # -> 0.5
 print(num5)  # -> 0.5


 -- Методы типа float:

 float.as_integer_ratio() - возвращает кортеж целых чисел, первое из которых равно числителю а второе всегда
 положительному знаменателю дроби, значение которой точно равно исходному числу типа float

 3.5.as_integer_ratio()
 # (7, 2)
------------------------------------------------------------------------------------------------------------------------
 float.is_integer() - возвращает True если дробная часть числа равна 0 и False если нет

 float(3).is_integer()
 # True
 3.0.is_integer()
 # True
 3.5.is_integer()
 # False
------------------------------------------------------------------------------------------------------------------------
 float.hex() - возвращает представление числа в шестнадцатеричной системе счисления

 3.543.hex()
 # 0x1.c5810624dd2f2p+1
------------------------------------------------------------------------------------------------------------------------
 classmethod float.fromhex(s) - преобразовывает шестнадцатеричную строку s в число типа float.
 Строка s может иметь начальные и конечные пробелы.

 float.fromhex(''0x1.9e00000000000p+6'') -> 103.5
 float.fromhex('   0x1.c587f88765ba7p+1    ') -> 3.543212
------------------------------------------------------------------------------------------------------------------------

 complex(immutable) - возвращает нам комплексное число при наличии действительной, мнимой частей.  <class 'complex'>
 Real — действительная часть, Imag — Мнимая часть. В случае если параметры не передается, то они по умолчанию равны нулю.
  complex(5) = (5+0j), type(5+0j) = <class 'complex'>


 -- Модуль math - Математические функции. Эти функции нельзя использовать с комплексными числами и другими типами не int
  TypeError: must be real number, not complex    Только для работы с числами

 -- Модуль cmath - Математические функции для комплексных чисел. Функции в этом модуле принимают в качестве аргументов:
  int, float, complex  Они также будут принимать любой объект Python c методом  __complex__() , __float__()


 class decimal.Decimal(value='0', context=None)
 Decimal – десятичное число, для выполнения точных расчетов    from decimal import Decimal
 decimal.Decimal для чисел с плавающей запятой с определяемой пользователем точностью.
 Модуль decimal обеспечивает поддержку быстрой правильно округленной десятичной арифметики с плавающей запятой.
 Полезно Decimal представлять такие вещи, как денежные суммы, где значения должны быть точными, а точность известна априори.

 Важно!!!                                               <-----     <-----
 Decimal занимает намного больше оперативной памяти
 Decimal работает намного медленнее float              float быстрее Decimal более чем в 2 раза

 Поэтому в разработке мы опираемся всегда на наши потребности – если нам важна точность, то мы используем Decimal.
 Если нам важна скорость и оптимальность по памяти, но в точности можем немного сэкономить – используем float.


 Пример использования!
 from decimal import Decimal, getcontext

 a, b = 0.12, 0.23
 print(Decimal(a).sqrt() + Decimal(b))  # -> 0.5764101615137754622876208686

 # Точность можно настроить с помощью getcontext().prec
 getcontext().prec = 20

 print(Decimal(a).sqrt() + Decimal(b))  # -> 0.57641016151377546229

 getcontext().prec = 2
 print(Decimal(a).sqrt() + Decimal(b))  # -> 0.58


 Еще пример!!! может принимать строки!
 # Точность можно настроить с помощью getcontext().prec
 getcontext().prec = 4

 a, b = Decimal("12.1"), Decimal('203.2')
 print(a / b)  # 0.05955



 class fractions.Fraction()
 Fraction – число, представляющее собой обыкновенную дробь, с заданным числителем и знаменателем
 Модуль fractions обеспечивает поддержку арифметики рациональных чисел.  from fractions import Fraction
 fractions.Fraction для рациональных чисел
 from fractions import Fraction
 print(Fraction("0.2"))  # -> 1/5

 GMPY (General Multiprecision PYthon) — модули Python, предназначенные для высокопроизводительных вычислений
 с плавающей запятой и целыми числами    from gmpy2 import mpz
 -----------------------------------------------------------------------------------------------------------------------

 bool является подклассом int: True = 1, False = 0, <class 'bool'>

 # Интересный пример
 print(max(True, 1), max(1, True))    # -> True 1
 print(min(False, 0), min(0, False))  # -> False 0

 a = 3
 print(len(True * a * str(a) + "a" * bool()))        # -> 3

 # Не забываем таблицу ASCII
 print(min("False", "True") + max("False", "True"))  # -> FalseTrue


 # Символы разных раскладок  (Слева латинская буква, а справа - русская)
 print("c" < "с")  # -> True

 # Сравнивание присходит по таблице Unicode
 print(ord("c"))  # -> 99    # (латиница)
 print(ord("с"))  # -> 1089  # (кириллица)
 # Латиница стоит меньше по номерному списку.


 # Интересные примеры
 print((6 > 5) + 5 > 2)    # ->  True
 print(6 > 5 + (5 > 2))    # ->  False
 print((6 > 5) + (5 > 2))  # ->  2

 # Обьяснение примеров
 print(3 == 5)                                                                  # -> False

 # Тоже самое
 print(2 > True >= False + True > (False > 1))                                  # -> True
 # Тоже самое  (должны быть выполнены все три условия)
 print((2 > True) and (True >= False + True) and (False + True > (False > 1)))  # -> True


 # Наследование bool
 print(bool())                        # -> False       # Конструктор (по умолчанию) выдает False

 В результате выдает 0, bool - наследует от int, отличается тем, что в классе bool допустимы всего два значения 0 и 1,
 а также тем, что 0 отображается как False, а 1 - как True. Соответственно, вызов bool() сводится к вызову int(),
 в результате возвращается 0, который отображается как False.

 # Другие Конструкторы работают также
 print(int())                         # -> 0
 print(list())                        # -> []
 print(tuple())                       # -> ()
 print(set())                         # -> set()
 print(dict())                        # -> {}
 print(str())                         # -> ''


 False:
 константы, определенные как ложные: None и False.
 ноль любого числового типа: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)
 пустые последовательности и коллекции: '', (), [], {}, set(), range(0)

 Остальное не пустое вернет True
 bool([0, False, '']) -> True,    bool([0]) -> True,   bool(-1) -> True

 -- Немного о булинах, True и False --
 - True/False это константы и создаются в единственном экземпляре при старте программы
 - True/False это наследники инт и могут быть использованы там, где ожидается целое число, например в арифметических
  выражениях. При этом True=1, False=0
 - Любой объект в питоне может быть проверен на истинность. При этом все пустое вернет False. Объект своего класса
  вернет True, если другое не прописано в логике этого класса
 - Условия проверяются по частям, отделенным операторами И и ИЛИ, при этом одна часть условия не знает о другой,
  каждая часть должна быть полноценной проверкой
 - И ломается на лжи, ИЛИ ломается на правде, под словом "ломается" имею в виду что дальше проверка не идет
 - Будьте аккуратны с оператором not, он нужен в проверках типа is not None или x not in a_list, но со сложными
  условиями его лучше не применять (инвертировать условие или явно прописать is True/False)

 Логические операции or и and всегда возвращают один из своих операндов!

 -- Важно!!! --
 Операторы and и or закорачивают вычисление своих операндов (т.е. используют замыкания): правый операнд
 вычисляется лишь в том случае, если его значение необходимо для получения истинного значения в операциях and или or.
 Другими словами, замыкания в логических операциях используются для запуска второй части или последующих частей
 логического выражения только в том случае, если это актуально!

 - Закорачивают - накоротко; вызывать короткое замыкание.

 Операторы and и or НЕ ПРИВОДЯТ свои результаты принудительно к значениям True или False, а возвращают один из своих
 операндов. Такой подход позволяет использовать эти операторы в более общих, а не только булевых операциях.
 Если другие операторы, прежде чем выполнить операцию, вычисляют все свои операнды, то в случае операторов and и or
 с их семантикой закорачивания необходимость вычисления правого операнда определяется результатом вычисления левого.

 - or - оценивает второй аргумент, только если первый равен False. Если какой либо операнд в цепочке or является истиной,
 немедленно возвращается результат - первое истинное значение.

 - and - оценивает второй аргумент, только если первый равен True. Если в цепочке and все операнды являются истиной,
 результатом будет последнее значение. А если какой-либо из операндов является False, результатом будет первое ложное значение.

 - not имеет более низкий приоритет, чем операторы сравнения, так not a == b интерпретируется как not (a == b),
 а выражение a == not b вовсе является синтаксической ошибкой. Единственный логический оператор с одним аргументом.
 Он принимает один аргумент x и возвращает противоположный результат: False для истинного значения и True для ложного значения.

 Из булевых операторов, not имеет самый высокий приоритет, а or самый низкий, так что A and not B or C эквивалентно
 (A and (not B)) or C. Как всегда, скобки могут быть использованы для выражения желаемого приоритета в операциях.
 Приоритеты: 1) not    2) and     3) or

 Логические операции, упорядоченные по приоритету выполнения:
 - not x - если x ложно, то возвращается True, иначе False.
 - x and y - если x ложно, то возвращается x, иначе у.
 - x or y - если x ложно, то возвращается у, иначе x

  Объяснение работы замыкания c оператором and:
 print(2 and 1) -> 1
 print(1 and 2) -> 2
 print(1 and 0) -> 0
 print(1 and 0.0 and 0) -> 0.0
 print(1 and 2 and 3) -> 3

 Пояснения к примеру выше с оператором and:
 - Оператор and вычисляет значения в булевом контексте слева направо. Значения 0, '', [], (), {} и None являются ложью,
 все остальное является истиной. Если у and оба операнда являются истиной, результатом будет последнее значение.

 - Если какой-либо из операндов является ложью, результатом будет первое такое значение.

 - Все значения являются истиной, так что в результате мы получаем последнее.

 Объяснение работы замыкания c оператором or:

 a = 'a'
 b = 'b'

 print(a or b)
 # 'a'
 print('' or b)
 # 'b'
 print('' or [] or {})
 # {}
 def func():
     return 1

 print(a or func())
 # 'a'
 print(func() or a)
 # 1
 Пояснения к примеру выше с оператором or:
 - Оператор or вычисляет значения в булевом контексте слева направо. Если операнд является истиной, or немедленно
 возвращает результат. В данном случае a, первое истинное значение.

 - or вычисляет выражение '', которое является ложью, затем b, которое является истиной, и возвращает его значение.

 - Если все значения являются ложью, or возвращает последнее.

 - Обратите внимание, что or вычисляет операнды до тех пор, пока не найдет истинное значение, остальное игнорируется.
 Это имеет значение, когда вычисление операнда дает сторонние эффекты. В данном случае функция func() не вызывается,
 так как для получения результата выражения с оператором or достаточно того, что первый операнд a является истиной.

 Другие примеры с and и or:
 a = 'one'
 b = 'two'
 print(1 and a or b)   # Приоритет and выше чем or
 # 'one'
 print(0 and a or b)   # Приоритет and выше чем or
 # 'two'


 a = ''
 b = 'two'
 # 'a' - пустая строка, которую Python считает ложью,
 # следовательно 1 and '' дает '', а '' or 'two' дает 'two'.
 print(1 and a or b)    # -> two
 print(10 and 20 or 30) # -> 20

 Внимание! Замыкания в операциях and и or можно использовать с пользой в вычислениях для экономии ресурсов, сокращения
 времени выполнения и т.д., только будьте осторожны! Необходимо четко понимать как работают замыкания в операторах and и or.

 - Экономия ресурсов и времени выполнения при помощи and:

 lst, valid = [0, 1, 2], []
 if lst and not valid:   # (срабатывает замыкание).
     print('Bad')
 else:
     print('Good')
 # Если порядок операндов поменять, то результат остался такой же, но было бы потрачено гораздо больше времени.

 - Проверка предварительных условий перед выражением:
 lst = [0, 1, 2]
 if lst and len(lst) >=3:
     print(lst[2])


 if isinstance(lst, list|str) and lst and isinstance(lst[0], int):
     print(lst[2])

 - Определение значения по умолчанию при помощи or:
 Замыкание с помощью логического оператора or может использоваться для присвоения переменным значений по умолчанию.

 greet = input("Ваше имя >> ") or "незнакомец"
 print(f"Привет, {greet}!")


 # Хороший пример из Книги High Performance Python   Правильно раставляем проверки! Более быструю проверку всегда ПЕРВОЙ!
 import timeit

 def check_abs():
     z = 0 + 0j
     return abs(z) < 2

 def check_n():
     n = 1
     maxiter = 300
     return n < maxiter

 # Замер времени для операции abs(z) < 2
 time_abs = timeit.timeit(check_abs, number=100000)
 print(f'abs(z) < 2: Time taken: {time_abs:.3f} seconds')  # -> abs(z) < 2: Time taken: 0.029 seconds

 # Замер времени для операции n < maxiter
 time_n = timeit.timeit(check_n, number=100000)
 print(f'n < maxiter: Time taken: {time_n:.3f} seconds')   # -> n < maxiter: Time taken: 0.010 seconds

 # Всегда ставим самый быстрый тест в Левую сторону чтобы правым не проверялся в операторе and                  <-----

 # Долгий вариант                   # Быстрый вариант
 # if abs(z) < 2 and n < maxiter:   if n < maxiter and abs(z) < 2:
 #     print(True)                      print(True)


 -- ОГРАНИЧЕНИЯ! На перегрузку Операторов  --

 В Python НЕЛЬЗЯ перегружать операторы is, and, or, not, а также нельзя создавать новые операторы.      <-----
 ОГРАНИЧЕНИЯ! запрещается перегружать операторы встроенных типов, запрещается создавать новые операторы и перегружать
 операторы is, and, or, not

 class MyClass:
     def __eq__(self, other):
         return True  # Перегрузка оператора == разрешена

     # Операторы and и or продолжают вести себя, как и всегда, независимо от определения.               <-----
     def __and__(self, other):  # Можно перегрузить, метод будет работать с &
         return 1111

     def __or__(self, other):  # Можно перегрузить, метод будет работать с |
         return 2222

     # 'is' и 'not' НЕЛЬЗЯ перегружать    # __is__ и __not__ НЕ сработают и будут игнорироваться Python. <-----
     def __is__(self, other):  # Ошибка
         return 111

     def __not__(self):        # Ошибка
         return 'HEHE'

 obj1 = MyClass()
 obj2 = MyClass()

 print(obj1 == obj2)      # Разрешено, вывод: True                                                       <-----
 print(obj1 & obj2)       # Вызов метода __and__, вывод: 1111                                            <-----
 print(obj1 | obj2)       # Вызов метода __or__, вывод:  2222                                            <-----
 print(obj1 and obj2)     # <__main__.MyClass object at 0x000001BE65B96750>                              <-----
 print(obj1 or obj2)      # <__main__.MyClass object at 0x000001BE66BE27D0>                              <-----
 print(obj1 is obj2)      # False   Это работает, но __is__  НЕ будет вызван                             <-----
 print(obj1 is not obj2)  # True    Это работает, но __not__ НЕ будет вызван                             <-----

 Методы __and__, __or__, __is__ и __not__ действительно могут быть определены в вашем классе, но это НЕ означает,
 что перегруженные версии этих операторов будут работать так же, как и у встроенных операторов.                   <-----

 -----------------------------------------------------------------------------------------------------------------------

 isinstance(True, int) Используйте isinstance, чтобы проверить, True является ли экземпляром int или подклассом int:
 Функция isinstance() в Python используется для проверки, является ли объект экземпляром указанного класса или нет.
 Встроенную isinstance() функцию рекомендуется использовать для проверки типа объекта, поскольку она учитывает подклассы.
 Другими словами, isinstance() это справедливо и для подклассов.
 isinstance(True, (int, float)), isinstance(1, int | str), isinstance(1, int)

 Обратите внимание, что isinstance() также проверяется виртуальное наследование от абстрактного базового класса .
 Чтобы проверить «истинное наследование», отсканируйте MRO класса:
 type(instance).__mro__ # -> для ЭК         type(self).__mro__ # -> для ЭК
 class.__mro__          # -> для класса

 Встроенную type() функцию используют если нужно знать точный класс экземпляра.  type(True) == bool
 type(True) == int Чтобы проверить, является ли тип True точно int, исключая подклассы int

 issubclass()  спрашивает, является ли один класс подклассом другого класса (или других классов). issubclass(bool, int)
 Функция issubclass() в Python используется для проверки, является ли класс подклассом другого класса или нет.
 TypeError: issubclass() arg 1 must be a class     - Проверяет только классы

 Функции issubclass() и isinstance() очень похожи, за исключением того, что issubclass() работают с классами, тогда как
 isinstance() работают с экземплярами классов.

 bytes – неизменяемая последовательность байтов. Представляет двоичные данные, которые необходимо хранить в неизменяемом виде.
 для создания байтовых строк нужно применить префикс    b''
 bytes — неизменяемые массивы одиночных байтов:
 Объекты bytes представляют собой неизменяемые последовательности одиночных байтов (целых чисел в диапазоне 0 <= x <= 255)
 arr = bytes((0, 1, 2, 3))
 arr[1] -> 1
 Разрешены только допустимые "байты":
 bytes((0, 300)) -> ValueError: bytes must be in range(0, 256)
 Байты неизменяемы:
 arr[1] = 23 -> TypeError: 'bytes' object does not support item assignment
 del arr[1]  -> TypeError: 'bytes' object doesn't support item deletion

 text = "Data"  - # Текстовая строка

 byte_text = b"Data" - # Байтовая строка
 encode() - преобразования обычных строк в байтовые
 decode() - преобразования байтовых строк в обычные

 'hello'.encode()    # -> b'hello'
 'Привет'.encode('utf-8')   # -> b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82'
 b'hello'.decode()   # -> b'hello'
 b'Привет'.decode()  # -> SyntaxError: bytes can only contain ASCII literal characters
 'Привет'.encode('ascii') # -> UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-5: ordinal not in range(128)
 'Привет'.encode('ascii', errors='ignore')   # -> b''
 'Привет'.encode('ascii', errors='replace')  # -> b'??????'

 class bytes([source[, encoding[, errors]]])
 bytearray – изменяемая последовательность байтов. Представляет двоичные данные, которые могут изменяться

 class bytearray([source[, encoding[, errors]]])
 Bytearray в python - массив байт. От типа bytes отличается только тем, что является изменяемым.

 class memoryview(object) - возвращает ссылку на буфер обмена памяти, в которой находится переданный в качестве
 аргумента объект object. Объект object должен поддерживать протокол буфера обмена. bytes и bytearray,  array.array

 Для многих простых типов, таких как bytes и bytearray, элементом является один байт, но другие типы, например,
 array.array могут иметь элементы большего размера.

 Класс memoryview() обеспечивает прямой доступ для чтения и записи к байтово-ориентированным данным объекта без
 необходимости их предварительного копирования. Это приводит к значительному увеличению производительности при работе
 с большими объектами, такими как двоичные данные видео или изображения, поскольку создает другой объект доступа для
 изменения больших данных без их копирования.

 class array.array(typecode[, initializer]) - создает новый массив, элементы которого ограничены typecode и
 инициализируется из необязательного значения initializer, которое должно быть списком, байтоподобным объектом
 или итерируемым по элементам объектом соответствующего типа.

 Модуль array, массивы в Python
 Модуль array определяет тип объекта, который может компактно представлять массив значений базовых типов:
 символы, целые числа, числа с плавающей запятой.

 Короче говоря : array.array полезно, когда вам нужен однородный массив данных C , Лучше использовать NumPy, SciPy

 Массивы очень похожи на списки, но с ограничением на тип данных и размер каждого элемента.

 memoryviews — это способ разрезать строки (ну, bytes в Python 3) без их копирования.
 Объекты memoryview позволяют коду Python получать доступ к внутренним данным объекта, который поддерживает
 буферный протокол, без копирования.

 memoryview, который обеспечивает доступ к буферу обмена и может менять его не создавая копии, что позволяет быстро
 работать с большими файлами изображений, видео-файлами или обрабатывать потоки видео.

 Buffer Protocol (Буферный протокол) - Некоторые объекты, доступные в Python, оборачивают доступ к базовому массиву
 памяти или буферу . К таким объектам относятся встроенные bytes и bytearray, а также некоторые типы расширений,
 например array.array. Сторонние библиотеки могут определять свои собственные типы для специальных целей, таких как
 обработка изображений или численный анализ.

 Функция bin() возвращает: двоичное представление заданного числа; ошибку TypeError для случаев передачи нецелочисленного аргумента
 Встроенная в Python функция bin() преобразует целое (десятичное) число в двоичную (бинарную) строку с префиксом '0b'.

 Парсинг — это процесс сбора, обработки и анализа данных. В качестве их источника может выступать веб-сайт.
 Парсинг — это процесс извлечения данных из веб-страниц.
 Библиотеки для парсинга: BeautifulSoup , Requests


 --- Работа с файлами ---
 Открытие/закрытие файла для чтения/записи:
 open() - Открывает файл для чтения или записи файлового потока
 Для удобной работы с путями файловой системы, рекомендуем использовать встроенный модуль pathlib.

 Обычно файлы открываются в текстовом режиме , то есть вы читаете и записываете в файл строки, закодированные в
 определенной кодировке . Если кодировка не указана, значение по умолчанию зависит от платформы.

 Поскольку UTF-8 является современным стандартом де-факто, encoding="utf-8" рекомендуется использовать его

 ВСЕГДА УКАЗЫВАЕМ КОДИРОВКУ    encoding                                                        <----- Важно

 #  'wt'  - Текстовая запись
 open ('test.txt', 'wt', encoding='utf-8').write('1, 2, 3')  - Этот код БЕЗОПАСЕН, потому что счетчик ссылок на объект
 файда будет равен НУЛЮ (0) после возврата из метода write и Python НЕМЕДЛЕННО закроет файл. Лучше Использовать - with

 # Правильный и более БЕЗОПАСНЫЙ способ
 with open('test.txt', 'wt', encoding='utf-8') as f:
    f.write('1, 2, 3')


 # ИНТЕРЕСНЫЙ ПРИМЕР  closefd=False

 # Открыть низкоуровневый файловый дескриптор
 import os
 fd = os.open('somefile.txt', os.O_WRONLY | os.O_CREAT)
 f = open(fd, 'wt')
 f.write('hello world\n')
 f.close()

 # Создать файловый объект, но НЕ закрывать дескриптор по завершении
 f = open(fd, 'wt', closefd=False)


 Данные в двоичном режиме читаются и записываются как bytes объекты.
 Вы не можете указать кодировку при открытии файла в двоичном режиме. ValueError: binary mode doesn't take an encoding argument

 with open('my_testik.txt', 'rb', encoding='utf-8') as file:
    pass   # -> ValueError: binary mode doesn't take an encoding argument

 open(filename, mode, encoding=None) mode='r', encoding="utf-8"
 fp = open('my_testik.txt', 'r')  # второй аргумент mode - режим открытия файла, на запись и другие, default='r'

 или через аблосютный путь Ctrl+Shift+C нажимаем на файл в Pycharm                              <-----
 fp = open(r'C:\PythonProjects\PythonRussian\Again\test1.txt', encoding="utf-8") #  через сырую строку 'r'

 Обычный способ open(), close():

 f = open('my_testik.txt')
 # файл НЕ был автоматически закрыт.
 print(f.closed)  # -> False
 f.read()         # -> Файл можно читать
 # Если вы не используете ключевое слово with, то вам следует вызвать f.close()
 f.close()        # Сами закрываем файл
 print(f.closed)  # -> True
 f.read()         # -> ValueError: I/O operation on closed file.

 Рекомендуется использовать контекстный менеджер with при работе с файловыми объектами. Преимущество заключается в том,
 что файл правильно закрывается после завершения, даже если в какой-то момент возникает исключение.
 Использование with также намного короче, чем писать эквивалентные try-finally блоки:

 Способ через try-finally:

 f = open('my_testik.txt')
 try:
     read_file = f.read()
 finally:
     f.close()

 print(f.closed) # -> True
 f.read()        # -> ValueError: I/O operation on closed file.


 Способ САМЫЙ ПРАВИЛЬНЫЙ - через контекстный менеджер -  with:                                  <------

 with open('my_testik.txt') as fp:
     read_data = fp.read()

 # Мы можем проверить, что файл был автоматически закрыт.
 print(fp.closed)  # -> True
 fp.read()         # -> ValueError: I/O operation on closed file.

 Позволяет читать и писать в одну строчку:   open('my_testik.txt').write('hello world)   файл НЕ закрывает автоматически


 Режимы открытия файлов:
 'r' - открывает файл только для чтения (является значением по умолчанию).
 'w' - открыт для записи (перед записью файл будет очищен),
 'x' - открытие на запись, если файла не существует, иначе исключение.
 'a' - открытие на дозапись, информация добавляется в конец файла.
 'b' - открытие в двоичном режиме.
 't' - открытие в текстовом режиме (является значением по умолчанию).
 '+' - открытие на (чтение + запись)

 Варианты использования режимов:
 'r'   - Открывает файл только для чтения. Указатель файла помещается в начале файла. Это режим "по умолчанию".
 'rb'  - тоже самое что и 'r' но в бинарном режиме
 'r+'  - Открывает файл для чтения и записи. Указатель файла помещается в начало файла.
 'rb+' - тоже самое что и 'r+' но в бинарном режиме
 'w'   - Открывает файл только для записи. Перезаписывает файл, если файл есть. Если файла нет, создает новый файл для записи.
 'wb'  - тоже самое что и 'w' но в бинарном режиме
 'w+'  - Открывает файл для записи и чтения. Перезаписывает существующий файл, если файл существует.
 Если файл не существует, создается новый файл для чтения и записи.
 'wb+' - тоже самое что и 'w+' но в бинарном режиме
 'a'   -  Открывает файл для добавления. Указатель файла находится в конце файла, если файл существует. То есть файл
 находится в режиме добавления. Если файл не существует, он создает новый файл для записи.
 'ab'  - тоже самое что и 'a' но в бинарном режиме
 'a+'  - Открывает файл для добавления и чтения. Указатель файла находится в конце файла, если файл существует. Файл
 открывается в режиме добавления. Если файл не существует, он создает новый файл для чтения и записи.
 'ab+' - тоже самое что и 'a+' но в бинарном режиме


 Разница между  "r+"  и  "w+" ,  "a+"
 "r+" - файл не будет создан, если он не существует. Запись будет производиться с начала файла, без очистки существующих данных.
 "w", "w+"  - очищают файл перед записью. Если файла нет, файл будет создан
 "a" и "a+" - добавляют данные в конец файла.

 Примеры использования режимов открытия файлов:
------------------------------------------  'w'   Только Запись + Перезапись  ------------------------------------------
 text = 'This is 1st line\nThis is 2nd line\n'
 with open('my_testik.txt', mode='w') as file:    #  режим 'w'          Можно и без mode использовать
     file.write(text)   # -> Записали файл с содержимым text
     file.read()        # -> io.UnsupportedOperation: not readable      Можно только записывать файл!!!

------------------------------------------  'wb'  Только Бинарная Запись + Перезапись  для bytes  b""  -----------------
 text = 'This is 1st line\nThis is 2nd line\n'          #    Чтобы были bytes  b""                        <-----
 with open('my_testik.txt', 'wb') as file:              #  режим 'wb'
     file.write(text)                    # -> TypeError: a bytes-like object is required, not 'str'       <-----

 text = b'This is 1st line\nThis is 2nd line\n'                                 <----- работает с bytes  b""
 with open('my_testik.txt', 'wb') as file:  #     режим 'wb'
     file.write(text)   # -> Работает, нужно добавить к строке (text) b""       <-----
     file.read()        # -> io.UnsupportedOperation: read            Только Запись

------------------------------------------  'r'   Только Чтение --------------------------------------------------------
 text = 'This is 1st line\nThis is 2nd line\n'
 with open('my_testik.txt', 'r') as file:             # режим 'r'
     file.read()        # -> Можно только Читать файл
     file.write(text)   # -> io.UnsupportedOperation: not writable

------------------------------------------  'rb'  Бинарное Чтение   bytes  b""  ----------------------------------------
 text = 'This is 1st line\nThis is 2nd line\n'          text = 'This is 1st line\nThis is 2nd line\n'
 with open('my_testik.txt', 'r') as file:  # режим 'r'  with open('my_testik.txt', 'rb') as file:  # режим 'rb'
     print(file.read())                                     print(file.read())
 # This is 1st line           <-----                    # b'This is 1st line\r\nThis is 2nd line\r\n'       <-----
 # This is 2nd line           <-----

------------------------------------------  'w+'  Запись + Чтение + Перезапись  ----------------------------------------
 text = 'This is 1st line'
 with open('my_testik.txt', mode='w+') as file:        # режим 'w+'
     file.write(text)     # -> Записали файл с содержимым text
     file.seek(0)         # -> перемещаем курсор в начало
     print(file.read())   # -> This is 1st line   Прочитали файл

------------------------------------------  'wb+'  Запись + Чтение + Перезапись  bytes b""  ----------------------------
 with open('my_testik.txt', mode='wb+') as file:        # режим 'wb+'
     file.write('hello')     # -> TypeError: a bytes-like object is required, not 'str'    # Работает только с bytes

 with open('my_testik.txt', mode='wb+') as file:        # режим 'wb+'
     file.write(b'hello')    # -> Работает только с bytes
     file.seek(0)
     print(file.read())      # -> b'hello'

------------------------------------------  'r+'  Чтение + Запись  -----------------------------------------------------
 with open('my_testik.txt', mode='r+') as file:                   # режим 'r+'
     file.write('helloaaaa')
     file.seek(0)
     print(file.read())            # -> 'helloaaaa'

------------------------------------------  'rb+' Чтение + Запись  bytes b"" -------------------------------------------
 with open('my_testik.txt', mode='rb+') as file:  # режим 'rb+'
     file.write('helloaaaa')  # -> TypeError: a bytes-like object is required, not 'str'

 with open('my_testik.txt', mode='rb+') as file:  # режим 'rb+'
     file.write(b'helloaaaa')  # Работает
     file.seek(0)
     print(file.read())        # -> b'helloaaaa'

------------------------------------------  'a' Только Дозапись --------------------------------------------------------
 with open('my_testik.txt', 'a') as file:  # режим 'a'
     file.write('HEHE')        # Работает
     print(file.read())        # -> io.UnsupportedOperation: not readable

 with open('my_testik.txt', 'a') as file:  # режим 'a'
    file.write(b'HEHE')       # -> TypeError: write() argument must be str, not bytes     Не работает с bytes  b""

------------------------------------------  'ab' Только Дозапись  bytes b"" --------------------------------------------
 with open('my_testik.txt', 'ab') as file:  # режим 'ab'
     file.write('HEHE')       # -> TypeError: a bytes-like object is required, not 'str'  Не работает с str  ""

 with open('my_testik.txt', 'ab') as file:  # режим 'ab'
     file.write(b'HEHE')       # -> Работает

------------------------------------------  'a+' Дозапись + Чтение -----------------------------------------------------
 with open('my_testik.txt', 'a+') as file:  # режим 'a+'
     file.write('HEHE')       # -> Можно Дозаписывать
     file.seek(0)
     print(file.read())       # -> HelloHEHE           Можно Читать

------------------------------------------  'ab+' Дозапись + Чтение bytes b""  -----------------------------------------
 with open('my_testik.txt', 'ab+') as file:  # режим 'ab+'
     file.write(b'Hello')       # -> Можно Дозаписывать
     file.seek(0)
     print(file.read())       # -> b'HelloHello'       Можно Читать

------------------------------------------- 'x'  FileExistsError, если файл уже существует  ----------------------------
 with open('my_testik.txt', 'x') as file:    # режим 'x'
     pass                                    # -> FileExistsError: [Errno 17] File exists: 'my_testik.txt'
------------------------------------------------------------------------------------------------------------------------


 -- Модуль shutil - операций над файлами/каталогами, Копирование, удаление и архивирования файлов и директорий/папок
 shutil— Высокоуровневые файловые операции

 Основные методы, необходимые для работы с открытыми файлами:

 file.close()          - Закрывает открытый файл, освобождая ресурсы системы
 file.flush()          - Освобождает буфер чтения и сбрасывает данные в файл
 file.fileno()         - Получает файловый дескриптор открытого файла
 file.isatty()         - Проверяет связь с терминальным устройством
 file.read([size])     - Читает сразу весь файл или делит файл на куски,          size - int, количество байтов
 file.readline([size]) - Читает файл построчно
 file.readlines([sizehint])            - Получает список строк файла
 file.seek(offset, whence=os.SEEK_SET) - Перемещает указатель чтения/записи в файле
 file.tell()           - Получает текущую позицию указателя чтения/записи файла
 file.truncate([size]) - Ограничить размер записываемого файла
 file.write(str)       - Записывает переданную строку/данные в файл
 file.writelines(sequence) - записывает последовательность (список) строк в файл
 file.writable()       - возвращает True, если файл доступен для записи, и False, если нет.
 file.readable()       - возвращает True, если файл доступен для чтения, и False, если нет.
 file.seekable()       - возвращает True, если файл доступен для поиска и поддерживает: seek(), tell(). False, если нет.


 Файловый объект (file object) - также называют файловыми объектами или потоками .
 Основной способ создания файлового объекта, это использование встроенной функции open()

 На самом деле существует три категории файловых объектов:

  - необработанные двоичные файлы
  - буферизованные двоичные файлы
  - текстовые файлы

 Их интерфейсы определены в модуле io.
 --- Модуль io - операции ввода/вывода    Ввод/вывод текста, двоичных и необработанных потоков ---

 Модуль io предоставляет основные средства Python для работы с различными типами ввода-вывода.
 Существует три основных типа ввода-вывода:

 - Text I/O - текстовый ввод-вывод
 - Binary I/O - двоичный ввод-вывод        также называемый буферизованным вводом/выводом
 - Raw I/O - необработанный ввод-вывод     также называемый небуферизованным вводом/выводом
------------------------------------------------------------------------------------------------------------------------

 Создание текстовых потоков:
 Самый простой способ создать текстовый поток — с помощью open(), при необходимости указав кодировку:
 f = open("myfile.txt", "r", encoding="utf-8")

 Текстовые потоки в памяти также доступны в виде StringIO объектов:
 f = io.StringIO("some initial text data")
 print(f)  # ->  <_io.StringIO object at 0x000002437E433BE0>

 with open('my_testik.txt', mode='r') as file: #   режимы: r+, w, w+, a, a+ тоже = <class '_io.TextIOWrapper'>
     print(type(file))  # ->   <class '_io.TextIOWrapper'>                                                   <-----
------------------------------------------------------------------------------------------------------------------------

 Создание двоичных потоков:   Буферизованные двоичные типы файлов:
 Самый простой способ создать двоичный поток — использовать open() в 'b' строке режима:
 f = open("myfile.jpg", "rb")

 Бинарные потоки в памяти также доступны в виде BytesIO объектов:
 f = io.BytesIO(b"some initial binary data: \x00\x01")
 print(f)  # ->  <_io.BytesIO object at 0x000002904E2E4C70>

 with open('my_testik.txt', mode='rb') as file:
    print(type(file))  # ->   <class '_io.BufferedReader'>                                                   <-----

 with open('my_testik.txt', mode='wb') as file:  # режимы: ab тоже = <class '_io.BufferedWriter'>
     print(type(file))  # ->   <class '_io.BufferedWriter'>                                                  <-----

 with open('my_testik.txt', mode='ab+') as file:  # режимы: wb+, ab+  тоже = <class '_io.BufferedRandom'>
     print(type(file))  # ->   <class '_io.BufferedRandom'>                                                  <-----
------------------------------------------------------------------------------------------------------------------------
 Создание необработанных потоков:
 создать необработанный поток, открыв файл в двоичном режиме с отключенной буферизацией:

 f = open("my_testik.txt", "rb", buffering=0)
 print(f)  # ->  <_io.FileIO name='my_testik.txt' mode='rb' closefd=True>

 with open('my_testik.txt', mode='rb', buffering=0) as file: # режимы: rb+, wb, wb+, ab, ab+ тоже = <class '_io.FileIO'>
    print(type(file))  # ->   <class '_io.FileIO'>                                                             <-----

 with open('my_testik.txt', mode='', buffering=0) as file:  # режимы: r, r+, w, w+, a, a+ тоже  ValueError
    pass    # ->    ValueError: can't have unbuffered text I/O                                                 <-----
------------------------------------------------------------------------------------------------------------------------

 Атрибуты файлового обьекта:
------------------------------------------------------------------------------------------------------------------------
 closed, mode, name, buffer, encoding, errors, line_buffering, newlines, __class__

 with open('my_testik.txt', 'w') as file:
     print(file.closed)          # -> False  # Файл НЕ закрыт <--- # Возвращает True, если файл закрыт, иначе False.
     print(file.mode)            # -> 'w'                          # Возвращает режим доступа, с которым файл был открыт
     print(file.name)            # -> my_testik.txt                # Возвращает путь до файла с именем файла.
     print(file.buffer)          # -> <_io.BufferedWriter name='my_testik.txt'>
     print(file.encoding)        # -> cp1251                       # Текущая кодировка файла
     print(file.errors)          # -> strict
     print(file.line_buffering)  # -> False
     print(file.newlines)        # -> None
     print(file.__class__)       # -> <class '_io.TextIOWrapper'> # Класс файла

 print(file.closed) # -> True  # Файл ЗАКРЫТ                 <-----


 Примеры методов для открытых файлов:
------------------------------------------  close()  -------------------------------------------------------------------
 Чтобы каждый раз, не закрывать файл в ручную, используйте контекстный менеджер  with

 f = open('my_testik.txt', mode='w')                    with open('my_testik.txt', mode='w') as file:
 print(f.name)  # -> my_testik.txt                      print(file.name)                      # -> my_testik.txt
 f.close()      # -> закрыть файл

------------------------------------------  flush()  -------------------------------------------------------------------
 text = 'This is 1st line\nThis is 2nd line\'
 with open('my_testik.txt', 'r+') as file:
     file.write(text)
     file.flush()    # -> сбрасываем буфер в файл

------------------------------------------  fileno()  ------------------------------------------------------------------
 with open('my_testik.txt', 'w') as file:
     file_id = file.fileno()
     print(file_id)  # -> 3   целочисленный файловый дескриптор

------------------------------------------  isatty()  ------------------------------------------------------------------
 with open('my_testik.txt', 'w') as file:
     ret = file.isatty()
     print(ret)  # -> False   #  Показывает связан с терминальным устройством или нет


------------------------------------------  read([size]) Чтение сразу всего файла --------------------------------------
 Чтение сразу всего файла.
 При таком подходе, если файл большой, то может не хватить оперативной памяти:

 text = 'This is 1st line\nThis is 2nd line\nThis is 3rd line\nThis is 4th line\nThis is 5th line'

 # Подготовим файл
 with open('my_testik.txt', 'w') as file:
     file.write(text)                        # ->  Записали файл

 with open('my_testik.txt', 'r') as file:
     data = file.read()                      # ->  Считываем сразу весь файл

 for i in data.splitlines():                 # ->  Делим текст на список строк по разрывам строк  \n, \r, \r\n ...
     print(i)

------------------------------------------  read([size]) Чтение файла частями/кусками. ---------------------------------
 Чтение файла частями/кусками.

 text = 'This is 1st line\nThis is 2nd line\nThis is 3rd line\nThis is 4th line\nThis is 5th line'

 with open('my_testik.txt', 'r') as file:                  with open('my_testik.txt', 'r') as file:
     print(file.read(10))  # ->  This is 1s                    chunk = file.read(10)
     print(file.read(5))   # ->  t li                          while chunk:
     print(file.read(19))  # -> This is 2nd line                   print(chunk)
     print(file.read(8))   # -> This is                            chunk = file.read(10)

------------------------------------------  readline()  читает файл построчно  -----------------------------------------
 text = 'This is 1st line\nThis is 2nd line\nThis is 3rd line\n'
 with open('my_testik.txt', 'r') as file:                 with open('my_testik.txt', 'r') as file:
     file.seek(0)                                             file.seek(0)
     print(file.readline())  # -> This is 1st line            print(next(file)) # -> This is 1st line       <------
     print(file.readline())  # -> This is 2nd line            print(next(file)) # -> This is 2nd line
     print(file.readline(4)) # -> This  # Лимит Символов      print(next(file)) # -> This is 3rd line

 Чтение строк файла кусками при помощи цикла while:       Чтение файла при помощи цикла for:

 with open('my_testik.txt', 'r') as file:                 with open('my_testik.txt', 'r') as file:
     line = file.readline(10)                                 for n, line in enumerate(file, 1):
     while line:                                                  line = line.rstrip('\n')
         line = line.rstrip('\n')                                 print(f"Вывод строки: {n}) - {line}")
         print(line)
         line = file.readline(10)

------------------------------------------  readlines()  получает список строк файла  ----------------------------------
 with open('my_testik.txt', 'r') as file:                with open('my_testik.txt', 'r') as file:
     for line in file:                                       data = file.readlines()
         print(line.rstrip('\n'))                            print(data)


 with open('my_testik.txt', 'r') as file:
     file.seek(0)
     print(file.readlines())   # -> ['This is 1st line\n', 'This is 2nd line\n', 'This is 3rd line\n']
     print(file.readlines())   # -> []
     file.seek(0)
     print(file.readlines(10)) # -> ['This is 1st line\n']

------------------------------------------  seek()  перемещает указатель в файле  --------------------------------------
 Для более точного понимания как работает метод file.seek() для файлов, открытых в двоичном режиме  bytes  b""
 f.seek(0)	    Переместить указатель в начало файла
 f.seek(5)	    Переместить указатель на пять символов вперед от начала файла.
 f.seek(0, 2)	Переместить указатель файла в конец файла
 f.seek(5, 1)	Переместить указатель файла на пять символов вперед от текущей позиции.
 f.seek(-5, 1)	Переместить указатель файла на пять символов назад от текущей позиции.
 f.seek(-5, 2)	Переместить указатель файла на пять символов назад от конца файла.

 text = b'This is 1st line\nThis is 2nd line\nThis is 3rd line\nThis is 4th line\nThis is 5th line'   #   b""   <-----

 with open('my_testik.txt', mode='bw+') as file:   #  mode='bw+' файл записывается в бинарном/двоичном режиме   <-----
     file.write(text)
     file.seek(20, 0)
     print(file.read(10))
     file.seek(10, 1)
     print(file.read(10))
     file.seek(-11, 2)
     print(file.read(10))

 Для файлов, открытых в текстовом режиме: без 'b' в строке mode функции open().
 Допустимыми значениями смещения offset от начала файла являются те, которые возвращаются из fp.tell() или 0. Любое
 другое значение смещения приводит к неопределенному поведению. io.UnsupportedOperation: can't do nonzero cur-relative seeks

 text = 'This is 1st line\nThis is 2nd line\nThis is 3rd line\n'
 with open('my_testik.txt', mode='w+') as file:
     file.write(text)
     file.seek(0, 0)
     print(file.read(10))  # -> This is 1s
     file.seek(0, 2)       # ->  В конец файла перемещение
     file.seek(10, 1)      # -> io.UnsupportedOperation: can't do nonzero cur-relative seeks

------------------------------------------  tell()  позиция указателя в файле  -----------------------------------------
 text = 'This is 1st line\nThis is 2nd line\nThis is 3rd line\n'
 with open('my_testik.txt', mode='w+') as file:
     file.write(text)
     file.seek(0)
     print(file.tell())  # -> 0      Текущая позиция курсора/указателя
     file.seek(10)
     print(file.tell())  # -> 10     Текущая позиция курсора/указателя

------------------------------------------  truncate()  усекает размер файла  ------------------------------------------
 text = 'This is 1st line\nThis is 2nd line\nThis is 3rd line\n'
 with open('my_testik.txt', mode='w+') as file:
     file.write(text)
     print(file.truncate(10))  # -> Ограничиваем размер файла до 5 байт
     file.flush()              # -> сбрасываем буфер в файл
     file.seek(0)              # -> указатель чтения/записи в начало файла
     print(file.readline())    # -> This is 1s

 with open('my_testik.txt', 'r') as file:
     for line in file:
         print(line)           # -> This is 1s

------------------------------------------  write()  пишет данные в файл  ----------------------------------------------
 # пишем в файл
 with open('my_testik.txt', mode='w') as file:
     file.write(text)

 # читаем, что получилось
 with open('my_testik.txt', 'r') as file:
     print(file.read())  # -> This is 1st line

------------------------------------------  writelines()  пишет список строк в файл  -----------------------------------
 # пишем в файл                                        # читаем, что получилось
 text = ['This is 1st line\n',                         with open('my_testik.txt', 'r') as file:
         'This is 2nd line\n',]                            print(file.read())

 with open('my_testik.txt', mode='w') as file:         # This is 1st line
     file.writelines(text)                             # This is 2nd line
------------------------------------------  writable()   доступен ли файл для Записи?  ---------------------------------
 with open('my_testik.txt', mode='w') as file: # -> режим "w"         w+, wb, wb+ тоже True
     print(file.writable())  # -> True

 with open('my_testik.txt', mode='r') as file: # -> режим "r", rb     r+, rb+  будет True
     print(file.writable())  # -> False

 with open('my_testik.txt', mode='a') as file: # -> режим "a"         ab, a+, ab+ тоже True
     print(file.writable())  # -> True

------------------------------------------  readable()   доступен ли файл для Чтения?  ---------------------------------
 with open('my_testik.txt', mode='wb') as file: # -> r, rb, r+, rb+, w+, wb+, a+ = True   w, wb, a, ab = False
     print(file.readable())  # -> True

------------------------------------------  seekable()   поддерживает ли seek(), tell()?  ------------------------------
with open('my_testik.txt', mode='r') as file: # -> режимы:   w, w+, wb, wb+, r, r+, rb, rb+, a, ab, a+ , ab+  тоже True
    print(file.seekable())  # -> True
------------------------------------------------------------------------------------------------------------------------

 --- Открыть сразу Несколько файлов через запятую ---                                                     <-----

 with open('first_file.json') as file_1, open('second_file.txt') as file_2:                               <-----
    ...

 Вариант 2!
 with open(''first_file.txt', 'r') as file_1:
    ...
    with open('second_file.txt', 'r') as file_2:
        ...

 Можно отдельными блоками!

 with open(''first_file.txt', 'r') as file_1:
    ...

 with open('second_file.txt', 'r') as file_2:
    ...


 --- Просмотр и выбор в какой файл записать ---

 with open('first_file.json') as file_1, open('second_file.txt') as file_2:                               <-----
    ...
    print(c, file=file_1)  #  file=Имя файла -  куда записывать                              <-----       <-----



 --- JSON (JavaScript Object Notation) - простой формат ОБМЕНА ДАННЫМИ, основанный на подмножестве синтаксиса JavaScript.
 Модуль json позволяет кодировать и декодировать данные в удобном формате.

 BSON - Двоичный JSON   - расширение JSON
 JSON - тот же словарь пайтон, обращайтесь к нему по ключам:
 import json
 Конвертировать из Python в JSON:
 json.dump() - метод записывает объект Python в файл в формате JSON  - сериализации
 json.dumps() - метод возвращает строку в формате JSON - сериализации
 Конвертировать из JSON в Python:
 json.load() - метод считывает файл в формате JSON и возвращает объекты Python - десериализации
 json.loads() - метод считывает строку в формате JSON и возвращает объекты Python - десериализации

 Что делать если нужно сериализовать данные, которые не поддерживаются стандартным модулем json?
 - Можно использовать pickle или расширить классы JSONEncoder и JSONDecoder.

 Одинарные кавычки '' в json НЕ работают нужны  двойные ""  также null false true с маленькой и без лишних ,     <-----
 Ctrl+Alt+L чтобы отформатировать json и увидеть вложенности

 Black — это автоматический форматировщик кода для Python.  pip install black                                    <-----

 Много параметров dump, dumps, load, loads !                                                                     <-----

 json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None,
 separators=None, default=None, sort_keys=False, **kw)

 json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None,
 separators=None, default=None, sort_keys=False, **kw)

 json.load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)

 json.loads(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)


 Encoders and Decoders  Преобразование
 По умолчанию выполняет следующие преобразования при декодировании:

 Не все форматы преобразуются Например datetime НЕ сериализуется Нужно преобразовать к формату которые сериализуються:

 JSON               Python

 object             dict
 array              list
 string             str
 number (int)       int
 number (real)      float
 true               True
 false              False
 null               None


 # Совместимые с json ПСЕВДОНИМЫ   Можно копировать json прямо в консоль
 true, false, null = True, False, None

 fruit = {
     'hehe': true,
     'AAA': false,
     'BBB': null,
 }

 print(fruit)              # -> {'hehe': True, 'AAA': False, 'BBB': None}
 print(true, false, null)  # -> True False None


 Пример Работа с файлами в формате JSON:

 Десериализация json.loads:                                Десериализация json.load:                        <-----
 Считывание строки в формате JSON в obj Python json.loads: Чтение файла в формате JSON в объект Python json.load:

 import json                                               import json

 with open('my_json.json') as f:                           with open('my_json.json') as f:
     file = f.read()                                           templates = json.load(f)
     templates = json.loads(file)

 print(templates)                                          print(templates)

 for section, commands in templates.items():               for section, commands in templates.items():
     print(section)                                             print(section)
     print('\n'.join(commands))                                 print('\n'.join(commands))

 Сериализация json.dumps:                                   Сериализация json.dump:                          <-----
 Объект python в строку в формате JSON json.dumps:          Запись объекта Python в файл в формате JSON  json.dump:

 import json                                                import json

 my_learning = ['my_learning']                              my_learning = ['my_learning']

 to_json = {"cool": my_learning}                            to_json = {"cool": my_learning}

 with open('my_json.json', 'w') as f: # считываем файл      with open('my_json.json', 'w') as f:  # считываем файл
     f.write(json.dumps(to_json))                               json.dump(to_json, f)             # добавляем  f <-----

 with open('my_json.json') as f:      # открываем файл      with open('my_json.json') as f:       # открываем файл
     print(f.read())                                            print(f.read())
------------------------------------------------------------------------------------------------------------------------
 indent     - Отступы красивые                                                  <-----        <-----
 separators - Разделители                                                       <-----        <-----

 # Вывод с indent, separators                                      # Обычный Вывод
 import json                                                       import json
 a_dict = {1: 2, 2: 3}                                             a_dict = {1: 2, 2: 3}
 c = json.dumps(a_dict, indent=3, separators=('WWW', '----'))      c = json.dumps(a_dict)
 print(c)                                                          print(c)   # -> {"1": 2, "2": 3}
 {
    "1"----2WWW
    "2"----3
 }

 Примеры JSON:

 # Компактная сериализация:
 import json
 json.dumps([1, 2, 3, {'4': 5, '6': 7}])                         # -> [1, 2, 3, {"4": 5, "6": 7}]
 json.dumps([1, 2, 3, {'4': 5, '6': 7}], separators=(',', ':'))  # -> [1,2,3,{"4":5,"6":7}]
 # Красивое представление JSON формата:
 json.dumps([1, 2, 3, {'4': 5, '6': 7}], sort_keys=True, indent=2)  # indent = Уровни отступа

 # Парсинг/разбор строки JSON в структуру Python:
 x = json.loads('["foo", {"bar":["baz", null, 1.0, 2]}]')
 print(x)               # -> ['foo', {'bar': ['baz', None, 1.0, 2]}]
 print(x[0])            # -> foo
 print(x[1]['bar'])     # -> ['baz', None, 1.0, 2]
 print(x[1]['bar'][0])  # -> baz
 print(x[1]['bar'][2])  # -> 1.0

 # Парсинг/разбор файла JSON в структуру Python:
 import json
 data = ['foo', {'bar': ['baz', None, 1.0, 2], 'key': 'value', '10': 'ten'}, [3, 4, 5, 6]]

 # Открываем файл на запись
 with open('my_json.json', 'w') as file:
     # Преобразование объекта Python в данные
     # формата JSON, а так же запись в файл 'my_json.json'
     json.dump(data, file)

 # теперь прочитаем данные из файла 'my_json.json'
 with open('my_json.json', 'r') as file:
     # Чтение файла 'my_json.json' и преобразование данных JSON в объект Python
     new_data = json.load(file)

 print(new_data)           # -> ['foo', {'bar': ['baz', None, 1.0, 2], 'key': 'value', '10': 'ten'}, [3, 4, 5, 6]]
 print(new_data[0])        # -> foo
 print(new_data[1]['bar']) # -> ['baz', None, 1.0, 2]


 --- Pickle – это модуль Python, который предоставляет возможность сериализовать и десериализовать объекты Python. ---
 Также для работы с бинарными файлами Python предоставляет специальный встроенный модуль pickle
 Pickle – сериализация, превращение обьектов python в байты и наоборот байтов в обьекты python десериализации
 "Pickling" - процесс преобразования объекта Python в поток байтов
 "unpickling" - обратная операция, в результате которой поток байтов преобразуется обратно в Python-объект.
 Сериализация – это процесс преобразования объекта в поток байтов, который затем может быть сохранен в файл или передан через сеть.
 import pickle
 сериализация обьекта: pickle.dumps()
 десериализации объекта: pickle.loads()
 pickle.dump() - записывает сериализованный объект в файл.
 pickle.load() - загружает объект из файла.

 Примеры Работа с обьектами    dumps(), loads():
 import pickle
 data = {"key": "value"}
 # Сериализация объектов python в поток байтов
 serialized_data = pickle.dumps(data)
 print(serialized_data)   #  ->  b'\x80\x04\x95\x12\x00\x00\x00\x00\x00\x00\x00}\x94\x8c\x03key\x94\x8c\x05value\x94s.'
 # Десериализация объектов pickle в обьекты python
 deserialized_data = pickle.loads(serialized_data)
 print(deserialized_data) # -> {'key': 'value'}

 Примеры Работа с файлами      dump(), load():
 import pickle
 data = {"key": "value"}
 # Сохранить сериализованные данные в файл
 with open('my_testik.txt', 'wb') as fileb:  # поддерживает только бинарные режимы: rb, rb+, wb, wb+, ab, ab+
     pickle.dump(data, fileb)

 # Загружаем обьект из файла
 with open('my_testik.txt', 'rb') as fileb:  # режим: rb
     deserialized_data = pickle.load(fileb)
 print(deserialized_data)  # -> {'key': 'value'}

 Ошибка   EOFError: Ran out of input                                                                 <-----
 with open('my_testik.txt', 'wb+') as bfile:     # Режим перезаписал файл и сделал его пустым!       <-----
    print(pickle.load(bfile))  # -> EOFError: Ran out of input   Ошибка если файл Пуст               <-----

 Еще Пример:
 import pickle
 # используемый протокол по умолчанию
 print(pickle.DEFAULT_PROTOCOL) # -> 4
 # создадим данные для записи
 data1 = {'a': [1, 2.0, 3, 4+6j], 'b': ('string', u'Unicode string'), 'c': None}
 selfref_list = [1, 2, 3]
 selfref_list.append(selfref_list)

 # открываем файл для записи
 with open('my_testik.txt', 'wb') as output:  # режимы только бинарные
     pickle.dump(data1, output)
     # список запишем по протоколу 5
     pickle.dump(selfref_list, output, 5)

 import pprint, pickle                          # pprint ->  Красивый вывод
 with open('my_testik.txt', 'rb') as pkl_file:
     data1 = pickle.load(pkl_file)
     pprint.pprint(data1, width=60) # -> {'a': [1, 2.0, 3, (4+6j)], 'b': ('string', 'Unicode string'), 'c': None}
     data = pickle.load(pkl_file)
     pprint.pprint(data, width=60)  # -> [1, 2, 3, <Recursion on list with id=1870550008000>]

 --- Чтобы красиво вывести ---
 from pprint import pprint
 pprint()

 --- Модуль marshal ---
 примитивный модуль сериализации. Этот модуль существует главным образом для поддержки файлов Python .pyc

 --- Модуль shelve в Python, key/value хранилище ---
 shelve — Сохранение объектов Python
 Модуль shelve реализует постоянное хранилище для произвольных объектов Python, значения которого можно извлекать,
 используя словарные методы, что облегчает переход от сценариев на основе словаря к тем, которые требуют постоянного
 хранения. В качестве ключей хранилища shelve используются обычные строки.

 Под понятием произвольных объектов Python понимается - все, что может обрабатывать модуль pickle. Это включает в себя
 большинство экземпляров классов, рекурсивных типов данных и объектов, содержащих множество общих подобъектов.

 Какая разница между модулями pickle и JSON в Python?
 pickle отличается от модуля json тем, что сериализует объекты в двоичном виде. То есть результат не может быть прочитан
 человеком. Кроме того, pickle работает быстрее и позволяет сериализовать многие другие типы Python, включая пользовательские.

 -- JSON - это текстовый формат сериализации, а pickle - это двоичный формат сериализации.              <-----


 В Python есть ЧЕТЫРЕ ВСТРОЕННЫХ СТРУКТУРЫ ДАННЫХ, которые вы можете использовать для хранения данных:  <-----
    list(список), tuple(кортеж), dict(словарь), set(множество), frozenset(неизменяемое множество)


 Пинг может влиять на скорость запроса   <-----


 -- Pydantic  - упрощает процесс проверки данных тесно связана с FastAPI --
 Pydantic - это библиотека для валидации данных, сериализации и документирования (используя JSON Schema),
 основываясь на подсказках типов Python и аннотациях переменных.

 Pydantic построен на основе `dataclasses` из стандартной библиотеки Python. Он использует их для создания моделей
 данных, добавляя валидацию и аннотации типов.

 **Валидация данных**: Проверяет, соответствуют ли данные заданным типам и требованиям.
 2. **Оптимизация кода**: Упрощает работу с данными, минимизируя ошибки и улучшая читаемость кода.
 3. **Поддержка сериализации/десериализации**: Позволяет легко преобразовывать данные из форматов (например, JSON)
    в Python-объекты и наоборот.
 4. **Сложные структуры**: Поддерживает вложенные модели и сложные типы данных.

 Pydantic часто используется в веб-фреймворках, таких как FastAPI, для работы с запросами и ответами.


 # Использование sys.path.extend() позволяет динамически добавлять дополнительные директории в sys.path
 # в Python используется для изменения списка путей, по которым интерпретатор Python ищет модули для импорта
 import sys
 sys.path.extend(['foo-package', 'bar-package'])


 Модули в Python являются полноправными объектами!                                                                <-----
 Модуль — это файл, содержащий определения функций, классов и переменных, а также исполняемый код
 Модуль — это файл с расширением .py
 В частности, любой модуль, содержащий __path__ атрибут, считается пакетом.

 Пакет - набор модулей
 Пакеты пространства имен (Namespace packages) - пакеты неявного пространства имен
 Все, что требуется для создания собственного пакета пространства имен, — это просто исключить __init__.py
 namespace package - Пакет PEP 420 , который служит только контейнером для подпакетов. Пакеты пространства имен могут
 не иметь физического представления и, в частности, не похожи на обычный пакет , поскольку у них нет__init__.py файла.
 Атрибут пакета __path__ используется при импорте его подпакетов.
 __init__.py если есть то это ПАКЕТ(regular package - обычный пакет)

 Это правда, что Python 3.3+ поддерживает пакеты неявного пространства имен , что позволяет создавать пакеты
 без __init__.py файла. Это называется пакетом пространства имен в отличие от обычного пакета , в котором есть
 __init__.py файл (пустой или непустой).


 -- В Python сторонние библиотеки обычно импортируются после встроенных и отделяются пустой строкой. --

 # Встроенные библиотеки
 import os
 import sys

 # Сторонние библиотеки
 import requests
 import httpx               # Поддерживает как Синхронный так Асинхронный API
 import numpy as np


 -- Система импорта в Python --
 Оператор import является наиболее распространенным способом вызова определений модуля, но это не единственный способ.
 Такие функции, как importlib.import_module() и встроенная функция __import__() также могут быть использованы для
 вызова механизма импорта.


 -- Пакет importlib в Python  - Расширение оператора import   importlib - для взаимодействия с системой импорта
 Назначение пакета importlib заключается в том, чтобы обеспечить реализацию оператора импорта import и следовательно,
 расширение функции __import __() в исходном коде Python. Это обеспечит реализацию импорта, которая будет переносима
 на любой интерпретатор Python.
 Модуль importlib предоставляет богатый API для взаимодействия с системой импорта. Например, importlib.import_module()
 предоставляет рекомендуемый, более простой API, чем встроенный __import__(), для вызова механизма импорта.

  -- Перезагрузка модуля в Python --
 Если в модуль вносятся изменения то модуль нужно перезагружать, что бы изменения вступили в силу. Для этого нужно либо
 перезапустить интерпретатор, либо использовать функцию importlib.reload() из модуля importlib

 from importlib import reload
 import module_name
 reload(module_name)

 -- Управление импортом модулей из пакета  __all__
 __all__ -  используется как пакетами, так и модулями для управления тем, что импортируется при использовании конструкции import *.
 Но поведение по умолчанию отличается:
 - Для пакета, когда __all__ не определен, import * ничего не импортирует.
 - Для модуля, когда __all__ не определен, import * импортирует все, кроме имен, начинающихся с символа подчеркивания.


 -- Абсолютный импорт может использовать синтаксис import <> или from <> import <>
 Относительный импорт может использовать только вторую форму from <> import <>
 Количество точек указывает на сколько (обьектов) мы поднимаемся от исходного.
 from .. import
 from .  import
 from math import *    -  * импорт всего из math

 Абсолютный импорт надежен как топор, но нужно указывать все пакеты от корня до нужного модуля.
 Относительный импорт прост, понятен и короток, но не сработает в запускаемом файле.

 from mymod import *     Имена с префиксом _ не будут импортироваться из mymod                      <-----

 # МОЖНО ИМПОРТИРОВАТЬ В СКОБКАХ
 # импорт в скобках соответствует стилю «PEP 8» и улучшает организацию кода.                        <-----
 from itertools import (groupby, product, pairwise)
 from itertools import groupby, product, pairwise


 # Порядок импортов в вашем коде правильный и соответствует общепринятым рекомендациям PEP 8. Согласно этим
 # рекомендациям, импорты следует группировать в следующем порядке:

 # 1) Импорты стандартных библиотек.
 # 2) Импорты сторонних библиотек.
 # 3) Импорты собственных модулей.

 # ПРИМЕР: ПРАВИЛЬНОСТЬ ПОРЯДКА ИМПОРТОВ!!!    РАЗДЕЛИТЬ ПРОБЕЛАМИ ГРУППЫ И СДЕЛАТЬ В АЛФАВИТНОМ ПОРЯДКЕ
 # Внутри каждой группы импорты можно отсортировать в алфавитном порядке.

 # Оба варианта допустимы!                                    # Оба варианта допустимы!
 # Тоже самое                                                 # Тоже самое
 # Импорт стандартных библиотек                               # Импорт стандартных библиотек
 import datetime                                              import datetime
 import io                                                    from datetime import datetime, timedelta   #     <-----
 import re                                                    import io
 from datetime import datetime, timedelta                     import re
 from enum import Enum                                        from enum import Enum
 from itertools import chain, zip_longest                     from itertools import chain, zip_longest
 from typing import Any, Dict, List, Optional, Tuple          from typing import Any, Dict, List, Optional, Tuple

 # Импорт сторонних библиотек                                 # Импорт сторонних библиотек
 import numpy as np                                           import numpy as np
 from numpy import average, median                            from numpy import average, median
 import pandas as pd                                          import pandas as pd
 from pandas import DataFrame                                 from pandas import DataFrame
 import requests                                              import requests

 # Импорт собственных модулей                                 # Импорт собственных модулей
 from mymodule import MyClass, my_function                    from mymodule import MyClass, my_function

 # Вы правильно сгруппировали импорты и разделили их пустыми строками для улучшения читаемости.
 Отсортирован в алфавитном порядке. Это делает код более  организованным и понятным.                            <-----


 Контейнеры — Iterable, Sequence, Mapping, кастомные (самописные) и другие.

 increment «увеличение» - операция во многих языках программирования, увеличивающая значение переменной
 Обратную операцию называют decrement(уменьшения)
 В Python += используется для incrementing(увеличения), а -= для decrementing(уменьшения)

 Операнд – объект, которым можно манипулировать через оператор. Он участвует в тех или иных операциях

 Оператор – символьное выражение, задающее то или иное действие. Запись, которая позволяет манипулировать так называемыми операндами

 Бинарная операция – предусматривает работу с двумя операндами

 Унарная операция – операция, в которой есть только один операнд


 # Очень интересный пример Унарный Плюс (+) Унарный минус (-)      Протестируй с какими типами будет работать   <-----

 from collections import Counter
 ct = Counter('abc')
 ct['a'] = -3
 ct['b'] = 0
 print(ct)            # -> Counter({'c': 1, 'b': 0, 'a': -3})

 print(+ct)           # -> Counter({'c': 1})  # Тоже самое
 print(ct.__pos__())  # -> Counter({'c': 1})  # Тоже самое

 print(-ct)           # -> Counter({'a': 3})  # Тоже самое
 print(ct.__neg__())  # -> Counter({'a': 3})  # Тоже самое


 Инфиксные операторы в Python — которые используются между двумя операндами для выполнения операций, таких как
 арифметические (например, +, -) и логические (например, and, or).

 ТЕРНАРНЫЙ ОПЕРАТОР(Python условие в одну строку) — единственный оператор в Python, который требует три операнда
 Тернарный оператор был представлен в Python 2.5.
 Тернарный оператор в Python предлагает способ проверки условия в одной строке.
 Заметьте, что тернарный оператор — это выражение (expression), а не инструкция (statement)
 Условные выражения (тройные операторы)
 # Условия работают как в тернарном операторе
 value = 123
 print('even' if value % 2 == 0 else 'odd')                  # -> odd
 print(['even' if i % 2 == 0 else 'odd' for i in range(3)])  # -> ['even', 'odd', 'even']

 Выражение (expression) - это цепочка операций, может содержать числа, переменные, вызовы функций и другое.
 Инструкции могут быть простыми (например del или return) или compound statements (например, while или If).
 statement – это как команда, которая говорит компьютеру, что делать, но не обязательно сообщает, что получится в итоге

 Выражение (expression) - Arithmetic conversions, Atoms, Primaries, Await, Unary arithmetic, Binary, Shifting operations,
 Comparisons, Boolean operations, Assignment, Conditional, Lambdas, Expression lists, Evaluation order, Operators precedence

 Основное различие между ними заключается в том, что expression всегда возвращает значение и может быть частью
 statement, в то время как statement выполняет действие и не обязательно возвращает значение. Это как разница между
 задачей (statement) и решением задачи (expression).

 Выражение(expression) — это комбинация значений, операторов и литералов, которая что-то дает.
 Инструкция(statement) — это действие или команда, которая что-то делает. Пример: If-Else, циклы... и т. д.

 Simple statements(Простые инструкции) - состоит из одной логической строки. Несколько простых операторов могут
 находиться в одной строке, разделенной точкой с запятой.

 Simple statements:     Expression, Assignment(Присвоение +), Augmented assignment(Дополненые операторы присвоение +=),
 Annotated assignment, Future, assert, pass, del, return, yield, raise, break, continue, import, global, nonlocal, type

 __future__ - поддержка обратной совместимости. Обеспечивает гладкий переход от старых версий языка к новым.
 включения новых функций языка, несовместимых с текущим интерпретатором .

 Compound statements(Составные инструкции) - состоят из нескольких других инструкций. Состоят из одного или нескольких
 блоков (clause). Каждый блок составной инструкции состоит из заголовка (header) и телом (suite).

 Compound statements: if, while, for, try, except, except*, else, finally, with, match,
 Function definitions, Class definitions, Coroutines, async with, Type parameter lists.

 top-level statement in Python? - Это практически все, что начинается с уровня отступа 0

 Модуль keyword - Проверка имен переменных на ключевые слова Python
 Этот модуль позволяет программе Python определить, является ли строка ключевым словом или мягким ключевым словом .

 Функции Модуля keyword:

 keyword.iskeyword(s) - Функция keyword.iskeyword() возвращает True, если s является ключевым словом Python.

 import keyword
 keyword.iskeyword('true') -> False
 keyword.iskeyword('True') -> True
 keyword.iskeyword('for')  -> True
 keyword.iskeyword('list') -> False
 keyword.iskeyword('def')  -> True

 keyword.kwlist - Функция keyword.kwlist возвращает последовательность, содержащую все ключевые слова, определенные для интерпретатора.
 Когда действуют модуль __future__, то ключевые слова определенные этим модулем также будут включены в итоговую последовательность.

 import keyword
 keyword.kwlist -> Список всех ключевых слов Python

 keyword.issoftkeyword(s) - Возврат True, если s — мягкое ключевое слово Python .  Добавлено в версии 3.9.

 keyword.softkwlist - возвращает последовательность, содержащую все мягкие ключевые слова.  Добавлено в версии 3.9.
 Когда действуют модуль __future__, то мягкие ключевые слова определенные этим модулем также будут включены в итоговую последовательность.

 Ключевые слова (Keywords) - идентификаторы используются как зарезервированные слова или ключевые слова языка и не могут
 использоваться как обычные идентификаторы. Проще сказать - Нельзя использовать в качестве имени переменной

 def = 10, class = 10, break = 10, and = 10 и все остальные ключевые:
 SyntaxError: invalid syntax

 try = 10           -> SyntaxError: expected ':'
 yield = 10         -> SyntaxError: assignment to yield expression not possible
 False, None, True  -> SyntaxError: cannot assign to False

 Мягкие ключевые слова (Soft Keywords) - Могут быть Ключевыми словами и можно использовать в качестве имени переменной:
 match = 10
 type = 10
 print(_)  # -> NameError: name '_' is not defined
 _ = 10
 print(_)  # -> 10
 print(type)  # -> 10
 print(type(int))  # -> TypeError: 'int' object is not callable


 -- Ключевое слово break, как и в C, прерывает выполнение блока for или while с выходом из него.
 -- Ключевое слово continue, заимствован из языка C. Если ход цикла встречает это ключевое слово,
    то будет пропущен один шаг. Другими словами, цикл продолжится со следующей итерации:

 Пример for continue, break:
 for i in range(5):     # -> 0, 1, 2, 3, 4          for i in range(5):     # -> 0, 1, 2, 3, 4
     if i in (2, 3):                                    if i in (2, 3):
         continue                                           break
     print(i, end=' ')  # -> 0 1 4                      print(i, end=' ')  # -> 0, 1

 Пример while continue, break:
 numbers = list(range(5))  # -> [0, 1, 2, 3, 4]      numbers = list(range(5))  # -> [0, 1, 2, 3, 4]
 while numbers:                                      while numbers:
     numbers.pop()                                       numbers.pop()
     if 2 in numbers:                                    if 2 in numbers:
         break                                               continue
 print(numbers)            # -> [0, 1, 2, 3]         print(numbers)            # -> []

 Нельзя использовать continue, break в list comprehensions, generator expressions:
 [i if i != 2 else break for i in list(range(5))]   ->  SyntaxError: invalid syntax
 (i if i != 2 else break for i in list(range(5)))   ->  SyntaxError: invalid syntax

 Нельзя использовать в list comprehensions, generator expressions Ключевые слова (Keywords) - del, pass, break, continue

 Нет break(2)   - В ДРУГИХ ЯЗЫКАХ break имеет параметр, который определяет, из скольких вложенных циклов нужно выйти.
 Реально, вы не можете просто взять и выбраться из вложенного цикла for:  break выходит только из 1 цикла

 Такое не сработает!                break может помочь выйти только из внутреннего цикла.
 for item in items:                 for a in list_a:
    # ... more code here               for b in list_b:
     for element in item.elements:          if condition(a,b):
        # ... more code here                    break
         if is_ok:
            break(2)

 5 простых способов выйти из вложенных циклов в Python:

 1) Добавьте флаг:                          2. Бросить исключение                   3. Проверьте то же условие еще раз
 # add a flag variable                      # raise an exception                    # check the same condition again
 break_out_flag = False                     try:                                    for i in range(5):
 for i in range(5):                             for i in range(5):                      for j in range(5):
     for j in range(5):                             for j in range(5):                      if j == 2 and i == 0:
         if j == 2 and i == 0:                          if j == 2 and i == 0:                   break
             break_out_flag = True                          raise StopIteration         if j == 2 and i == 0:
             break                          except StopIteration:                           break
     if break_out_flag:                         pass
         break

 4) Используйте синтаксис For-Else                                      5. Поместите циклы в функцию
 # use the for-else syntax                                              # make it as a function
 for i in range(5):                                                     def check_sth():
     for j in range(5):                                                     for i in range(5):
         if j == 2 and i == 0:                                                  for j in range(5):
             break                                                                  if j == 2 and i == 0:
     else:  # only execute when it's no break in the inner loop                         return
         continue                                                       check_sth() # Run the function when needed
     break

 Можно использовать itertools.product                                                   <-----
 # Avoid nested loops
 import itertools
 for i, j in itertools.product(range(5), range(5)):
     if j == 2 and i == 0:
         break

 Прикольная задачка:
 # Найти "o"
 board = [                              for row in board:          А если пойти дальше, то и фильтровать можно сразу:
  ["x", "x", "x", "x", "x"],                if "o" in row:
  ["x", "x", "x", "x", "x"],                  break                print(next(row for row in board if "o" in row))
  ["x", "x", "x", "o", "x"], # тут o        else:                  # ['x', 'x', 'x', 'o', 'x']
  ["x", "x", "x", "x", "x"],                    continue
  ["x", "x", "x", "x", "x"],                break
 ]                                      print(row)  # -> ['x', 'x', 'x', 'o', 'x']



 -- командная строка cmd   Terminal commands --
 dir - Отображение файлов и папок в текущем каталоге
 cd - Изменить каталог, если нажать Tab будет автодополнение
 cd .. - переход на 1 папку назад
 cd ..\.. - переход на 2 папки назад
 cd \ - Переход в корневую директорию
 cd . - Переход в текущую директорию (никаких изменений)
 mkdir - создание папки

 python --version           - Посмотреть версию Python
 python -V                  - Тоже самое сокращенная команда
 python3.12 -m venv venv    - Установка python и запуск локального окружения

 Активировать venv  (Виртуальное окружение)        .\venv\Scripts\activate       # venv\Scripts\activate   # Тоже самое
 ДЕ-Активировать venv  (Виртуальное окружение)     .\venv\Scripts\deactivate
 Чтобы деактивировать активное виртуальное окружение, просто введите команду deactivate в командной строке.   <-----

  source venv/bin/activate - Активировать venv  (Виртуальное окружение)  в Linux
 .\venv\Scripts\activate  - Активировать venv  (Виртуальное окружение)  в Windows

 $env:Path -split ';'     - разбивает строку переменной окружения Path на массив строк, используя символ ; в качестве разделителя.

 # Команда используется в PowerShell для добавления пути к установленному Python
 [Environment]::SetEnvironmentVariable("Path", $Env:Path + ";C:\Program Files\Python312", [EnvironmentVariableTarget]::User)

 Ctrl + Z выйти из терминала или   exit()


 cd папка\папка\папка   -  Быстрый переход за одну операцию
 cd "имя имя"  - если между именами пробел
 cd "Абсолютный путь" - Сразу перейдем туда куда нужно
 Название_Диска: - чтобы сменить диск  - Примеры C:  D:  Только название диска и двоеточие в терминале(командной строке)



 Команды для Unix/Linux/macOS:

 1. **`ls`**     - Показать список файлов и папок в текущем каталоге.
 2. **`cd`**     - Перейти в указанный каталог. Пример: `cd /path/to/directory`.
 3. **`pwd`**    - Показать текущий рабочий каталог.
 4. **`mkdir`**  - Создать новый каталог. Пример: `mkdir new_directory`.
 5. **`rm`**     - Удалить файл или каталог. Пример: `rm file.txt` (для удаления каталога используйте `rm -r directory_name`).
 6. **`cp`**     - Копировать файлы или каталоги. Пример: `cp source.txt destination.txt`.
 7. **`mv`**     - Переместить или переименовать файл или каталог. Пример: `mv old_name.txt new_name.txt`.
 8. **`touch`**  - Создать новый пустой файл или обновить дату и время существующего файла.
 9. **`cat`**    - Показать содержимое файла. Пример: `cat file.txt`.
 10. **`grep`**  - Поиск строк в файлах, содержащих заданный шаблон. Пример: `grep 'search_term' file.txt`.  GREP <-----

 grep(global regular expression print) - При этом с ее помощью можно не просто находить куски текста, но и с высокой
 эффективностью фильтровать вывод другой команды.

 ls -a           - Отображения списка файлов и директорий в текущем каталоге включая скрытые файлы
 Команда `ls -a` в Unix-подобных системах используется для отображения списка файлов и директорий в текущем каталоге,
 включая скрытые файлы, имя которых начинается с точки (`.`). Флаг `-a` означает "all" (все).


 11. **`chmod`** - Изменить права доступа к файлу или каталогу. Пример: `chmod +x script.sh`.
 12. **`man`**   - Показать руководство по использованию команды. Пример: `man ls`.

 **`uname`**       - Показывает информацию о системе. Этот вариант выводит полную информацию о системе,
 включая имя хоста, версию ядра и тип операционной системы.

 **`lsb_release`** - Показывает информацию о дистрибутиве (если доступно).

 **Bash** (Bourne Again SHell) — это командный интерпретатор и оболочка для UNIX и UNIX-подобных операционных систем,
 таких как Linux и macOS. Он является улучшенной версией оригинальной оболочки Bourne shell (sh) и включает множество
 дополнительных функций  Аналогом Bash в Windows является **PowerShell**

 bash
     uname -a        - Показывает информацию о системе.

 bash
     lsb_release -a  - Показывает информацию о дистрибутиве (если доступно).

 При вводе пароля в терминале Linux сочетание `Shift + Insert` вставляет содержимое буфера обмена. ИЛИ  ПКМ
 Однако в большинстве случаев символы не отображаются на экране.         Shift + Insert ИЛИ  ПКМ


 ### Команды для Windows:

 1. **`dir`**    - Показать список файлов и папок в текущем каталоге.
 2. **`cd`**     - Перейти в указанный каталог. Пример: `cd C:\path\to\directory`.
 3. **`mkdir`**  - Создать новый каталог. Пример: `mkdir new_directory`.
 4. **`del`**    - Удалить файл. Пример: `del file.txt`.
 5. **`copy`**   - Копировать файлы. Пример: `copy source.txt destination.txt`.
 6. **`move`**   - Переместить или переименовать файл. Пример: `move old_name.txt new_name.txt`.
 7. **`type`**   - Показать содержимое текстового файла. Пример: `type file.txt`.
 8. **`find`**   - Поиск строк в файлах. Пример: `find "search_term" file.txt`.
 9. **`attrib`** - Изменить атрибуты файла. Пример: `attrib +r file.txt` (для установки файла как только для чтения).
 10. **`help`**  - Показать доступные команды и их короткие описания.

 **`systeminfo`** - Показывает подробную информацию о системе.

 Аналогом Bash в Windows является **PowerShell**

 Чтобы открыть PowerShell в Windows, выполните следующие шаги:

 ### Способ 1: Поиск в меню

 1. Нажмите **Windows** на клавиатуре или щелкните на кнопку **Пуск**.
 2. Введите **PowerShell** в строке поиска.
 3. Выберите **Windows PowerShell** из результатов.

 ### Способ 2: Сочетание клавиш

 1. Нажмите **Win + X** на клавиатуре.
 2. Выберите **Windows PowerShell** или **Windows PowerShell (Администратор)** в открывшемся меню.

 ### Способ 3: Выполнение команды

 1. Нажмите **Win + R** для открытия окна "Выполнить".
 2. Введите `powershell` и нажмите **Enter**.

 Чтобы выйти обратно в командную строку вводим команду     exit

 Эти методы позволяют быстро открыть PowerShell для выполнения команд и сценариев.


 Эти команды являются базовыми, и существуют более продвинутые команды и параметры. Выбор команд зависит от конкретной
 задачи, которую вы хотите выполнить

 curl - `curl` — это командная строка и библиотека для передачи данных с использованием различных протоколов,
 таких как HTTP, HTTPS, FTP и многих других. Он позволяет отправлять запросы к серверам и получать ответы,
 что делает его полезным инструментом для разработчиков и системных администраторов.

 `curl` — мощный инструмент для работы с сетевыми запросами. Он поддерживает множество опций и позволяет
 взаимодействовать с API, загружать и отправлять данные, а также осуществлять диагностику сетевых проблем.

 ### Полезные опции

 - `-o` или `--output`: сохранять вывод в файл.
 - `-O` или `--remote-name`: сохранять файл с оригинальным именем.
 - `-I` или `--head`: запрашивать только заголовки.
 - `-H`: добавлять дополнительные заголовки.
 - `-d`: отправлять данные в теле запроса (обычно используется с POST).
 - `-X`: указывать метод запроса (GET, POST, PUT, DELETE и т.д.).
 - `-v` или `--verbose`: выводить подробную информацию о запросе и ответе.

 # Простой пример POST-запроса
 # По умолчанию curl использует метод POST, когда вы указываете данные с помощью флага -d.
 curl -H "Accept: application/json" -d '{"key":"value"}' https://api.example.com/data           # Тоже самое

  # Объяснение запроса
 -H "Content-Type: application/json" указывает, что вы отправляете данные в формате JSON.

 -d '{"key":"value"}' содержит данные, которые вы хотите отправить на сервер.

 # явно указываем метод POST с помощью флага -X POST.
 curl -X POST -H "Accept: application/json" -d '{"key":"value"}' https://api.example.com/data   # Тоже самое

 # GET-запрос   убрать флаг -X POST и флаг -d, так как GET-запросы не содержат тела запроса.
 curl -H "Accept: application/json" "https://api.example.com/data?key=value"


 - **cURL** лучше подходит для разработчиков, которые предпочитают работать в терминале и нуждаются в автоматизации.
 - **Postman** удобнее для визуального тестирования API и разработчиков, которые хотят более простой и наглядный интерфейс.

 Swagger - Использует CURL  <-----                                                                           <-----


 GRUB (Grand Unified Bootloader) — это загрузчик операционных систем, используемый в Linux и Unix-подобных системах.
 Он позволяет запускать разные операционные системы на одном компьютере, предоставляет меню для выбора ОС при загрузке
 и обеспечивает конфигурацию параметров загрузки.

 GRUB (также известный как GNU GRUB или GNU Grand Unified Bootloader) — загрузчик и менеджер загрузки для
 Linux и других ОС на базе Unix .


 Модуль tokenize - предоставляет лексический сканер исходного кода Python, реализованный на Python. Сканер в этом модуле
 также возвращает комментарии в виде токенов, что делает его полезным для реализации «красивых принтеров»,
 включая раскраски для экранных дисплеев.
 tokenize — Токенизатор для исходного кода Python

 Работа токенизатора, лексера или сканера заключается в преобразовании потока символов или байтов в поток слов или «токенов»

 Модуль token - Константы, используемые с деревьями синтаксического анализа Python
 Этот модуль предоставляет константы, которые представляют числовые значения конечных узлов дерева разбора (токены терминала).

 Программа Python читается парсером . Входными данными для синтаксического анализатора является поток токенов ,
 сгенерированный лексическим анализатором .

 Парсеры Python:
 PEG (Parsing Expression Grammars, грамматике по парсингу выражений) синтаксический анализатор грамматики выражений (PEG)
 PEP 617 - новый парсер PEG для CPython
 Фундаментальное техническое отличие от LL(1) состоит в том, что оператор выбора является упорядоченным.

 Старый парсер Python LL(1)
 LL(1) — LL-анализатор, нисходящий алгоритм синтаксического разбора. deterministic LL(1) - Детерминированного LL(1)
 Детерминированность в решении какой-либо практической задачи или в алгоритме означает, что способ решения задачи
 определён однозначно в виде последовательности шагов. На любом шаге не допускаются никакие двусмысленности или недомолвки.

 Самое простое определение Детерминированный:

 Детерминированный - Учитывая одни и те же входные данные, вы всегда получаете одни и те же результаты.

 Детерминированный означает, что результат предсказуем.
 Недетерминированный означает, что не существует ни одного результата, который можно было бы вычислить заранее.

 В чем разница между LL(1) и PEG?
 анализатор контекстно-свободной грамматики (например, анализатор LL(1)) будет генерировать конструкции, которые
 по входной строке определяют, какая альтернатива ( A , B или C ) должна быть расширена, в то время как анализатор PEG
 проверит, успешна ли первая альтернатива. и только в случае неудачи продолжится со второго или третьего по порядку.

 --- Compiler design  Дизайн компилятора   Жизненный цикл кода на Python – модель выполнения CPython ---
 В CPython компиляция исходного кода в байт-код включает в себя несколько шагов:

 - Парсинг и токенизация:
 - Трансформация в AST;
 - Граф потока управления (CFG);
 - Байткод;
 - Выполнение на стековой виртуальной машине CPython

 - Токенизация (Лексический разбор) - это процесс получения текстового потока данных и разбиения на токены значащих
 (для интерпретатора) слов с дополнительными метаданными (например, где токен начинается и кончается, и каково
 строковое значение этого токена).

 Токены:  import token
          token.tok_name

 - Парсинг:
 Начиная с Python 3.9, парсер Python представляет собой парсер PEG несколько необычной конструкции. Это необычно в том смысле,
 что входные данные анализатора представляют собой поток токенов, а не поток символов, что более характерно для анализаторов PEG.

 - Абстрактные синтаксические деревья (AST, Abstract syntax trees) - это структурное представление исходного кода в виде
 дерева, где каждая вершина обозначает различные типы конструкций языка (выражение, переменную, оператор и т.п.)

 - Граф потока управления (Control Flow Graph, CFG) — это ориентированный граф, который моделирует поток программы.
 Узел CFG не является отдельной инструкцией байт-кода, а представляет собой последовательность инструкций байт-кода,
 которые всегда выполняются последовательно.

 NetworkX - Библиотека для работы с графами и  сетевыми структурами.

 Граф состоит из отдельных точек (вершин) и соединяющих их линий (ребер).
 Граф – это просто набор взаимосвязанных элементов.

 5 типов графов, которые должен знать каждый Data Scientist
 - Разбивка вершин на группы
 - Поиск кратчайшего пути
 - Поиск оптимального пути
 - Рейтинг вершин графа
 - Центральность вершин

 Дерево
 Как и связный список, дерево (tree) использует элементы, которым для хранения объектов НЕ нужно располагаться в
 физической памяти непрерывно. Ячейки здесь тоже имеют указатели на другие ячейки, однако, в отличие от связных списков,
 они располагаются не линейно, а в виде ветвящейся структуры. Деревья особенно удобны для иерархических данных,
 таких как каталоги с файлами или система субординации.


 Двоичное дерево поиска   - Сложность алгоритма - O(log n)
 Двоичное дерево поиска (binary search tree) — это особый тип дерева, поиск в котором выполняется особенно эффективно.
 Узлы в двоичном дереве поиска могут иметь не более двух дочерних узлов. Кроме того, узлы располагаются согласно их
 значению/ключу. Дочерние узлы слева от родителя должны быть меньше него, а справа — больше.


 Сложность операций с бинарным деревом зависит от его структуры:                                        <-----  <-----

 1. **Вставка, удаление и поиск**:
 - В худшем случае (разреженное дерево или не сбалансированное): O(n)
 - В среднем и лучшем случае (сбалансированное дерево): O(log n)

 2. **Обход дерева (инордер, префиксный, постфиксный)**: O(n)

 Таким образом, сложность зависит от того, насколько сбалансировано дерево.

 Балансировка дерева в Python — это процесс, который помогает поддерживать структуру дерева в равновесии, чтобы операции,
 такие как добавление, удаление и поиск элементов, выполнялись быстро.
 Балансировка дерева в Python (и в других языках программирования) помогает поддерживать структуру дерева в равновесии,
 что позволяет выполнять операции добавления, удаления и поиска элементов эффективно. Это достигается за счет
 поддержания небольшой высоты дерева, что обеспечивает логарифмическое время выполнения этих операций.
 Примеры сбалансированных деревьев включают AVL-деревья и красно-черные деревья. Они автоматически поддерживают балансировку,
 чтобы высота дерева оставалась логарифмической относительно количества элементов, что обеспечивает быструю работу с данными.


 Балансировка дерева. Если вставить в двоичное дерево поиска слишком много узлов, в итоге получится очень высокое
 дерево, где большинство узлов имеют всего один дочерний узел. Например, если последовательно вставлять узлы с
 ключами/значениями, которые всегда больше предыдущих, в итоге получится нечто, похожее на связный список. Однако мы
 можем перестроить узлы в дереве так, что его высота уменьшится. Эта процедура вызывается балансировкой дерева.

 Большинство операций с деревом требует обхода узлов по ссылкам, пока не будет найден конкретный узел. Чем больше высота
 дерева, тем длиннее средний путь между узлами и тем чаще приходится обращаться к памяти. Поэтому важно уменьшать высоту
 деревьев.

 Однако балансировка дерева — дорогостоящая операция, поскольку требует сортировки всех узлов. Если делать балансировку
 после каждой вставки или удаления, операции станут значительно медленнее. Обычно деревья подвергаются этой процедуре
 после нескольких вставок и удалений. Но балансировка от случая к случаю является разумной стратегией только в отношении
 редко изменяемых деревьев.     Идеально сбалансированное дерево имеет минимальную высоту   <-----

 Для эффективной обработки двоичных деревьев, которые изменяются часто, были придуманы сбалансированные двоичные
 деревья(self-balancing binary tree) . Их процедуры вставки или удаления элементов гарантируют,
 что дерево остается сбалансированным.


 Красно-черное дерево (red-black tree) — это хорошо известный пример сбалансированного дерева, которое окрашивает узлы
 красным либо черным цветом в зависимости от стратегии балансировки . Красно-черные деревья часто используются для
 реализации словарей: словарь может подвергаться интенсивной правке, но конкретные ключи в нем по-прежнему будут
 находиться быстро вследствие балансировки.


 AVL-дерево (AVL tree) — это еще один подвид сбалансированных деревьев. Оно требует немного большего времени для вставки
 и удаления элементов, чем красно-черное дерево, но, как правило, обладает лучшим балансом. Это означает, что оно
 позволяет получать элементы быстрее, чем красно-черное дерево. AVL-деревья часто используются для оптимизации
 производительности в сценариях, для которых характерна высокая интенсивность чтения.

 Данные часто хранятся на магнитных дисках, которые считывают их большими блоками. В этих случаях используется
 обобщенное двоичное B-дерево (B-tree). В таких деревьях узлы могут хранить более одного элемента и иметь более двух
 дочерних узлов, что позволяет им эффективно оперировать данными в больших блоках.
 B-деревья обычно используются в системах управления


 Двоичная куча
 Двоичная куча (binary heap) — особый тип двоичного дерева поиска, в котором можно мгновенно найти самый маленький
 (или самый большой) элемент.

 Кучи подчиняются тем же правилам размещения узлов, что и двоичные деревья поиска, но есть одно ограничение:
 родительский узел должен быть больше (либо меньше) обоих своих дочерних узлов


 Граф (graph) аналогичен дереву. Разница состоит в том, что у него нет ни дочерних, ни родительских узлов (вершин) и,
 следовательно, нет корневого узла. Данные свободно организованы в виде узлов (вершин) и дуг (ребер) так, что любой
 узел может иметь произвольное число входящих и исходящих ребер. Это самая гибкая из всех структур, она используется
 для представления почти всех типов данных.

 Например, графы идеальны для социальной сети, где узлы — это люди, а ребра — дружеские связи.

 Смежность — непосредственная близость, примыкание, тесное соприкосновение.
 Матрица смежности — один из способов представления графа в виде матрицы.
 Список смежности — один из способов представления графа в виде коллекции списков вершин. Каждой вершине графа
 соответствует список, состоящий из «соседей» этой вершины.


 Обход Графа - процесс систематического просмотра всех вершин или рёбер графа, чтобы найти некоторые вершины,
 удовлетворяющие определённым условиям.

 Простыми словами, обход графа — это переход от одной его вершины к другой в поисках свойств связей этих вершин. Связи
 (линии, соединяющие вершины) называются направлениями, путями, гранями или ребрами графа. Вершины графа также именуются узлами.

 Какие бывают алгоритмы обхода графа?
 - Поиск в глубину (Depth-First Search, DFS) - находит такой путь от данной вершины, до нужной, что этот путь содержит
   МИНИМАЛЬНУЮ СУММУ ребер графа.
 - Поиск в ширину (Breadth-First Search, BFS) - В результате поиска в ширину находится путь кратчайшей длины в
   невзвешенном графе, т.е. путь, содержащий НАИМЕНЬШЕЕ ЧИСЛО рёбер. Это один из основных алгоритмов на графах.

 Алгоритм Дейкстры — это метод нахождения кратчайших путей от одной вершины графа ко всем остальным.
 Алгоритм работает только для графов без рёбер отрицательного веса.
 В отличие от BFS, для запоминания просматриваемых вершин алгоритм Дейкстры использует очередь с приоритетом.  <----

 --- END Compiler design  Дизайн компилятора ---


 Обработка естественного языка (NLP, Natural Language Processing) – это технология машинного обучения, которая дает
 компьютерам возможность интерпретировать, манипулировать и понимать человеческий язык.

 import nltk
 NLTK – это библиотека Python, которую можно использовать в любом приложении для обработки естественного языка - NLP.

 NLTK предлагает удобные инструменты для множества задач NLP: токенизация, стемминг, лемматизация, морфологический
 и синтаксический анализ, а также анализ настроений.

 Перед созданием любого приложения, основанного на обработке естественного языка, нам необходимо обработать данные,
 которые мы используем. Ниже приведены некоторые шаги, которые всегда необходимы при создании приложения NLP:
 Анализ текстовых данных с помощью NLTK и Python:

 - Токенизация: разделение фрагмента текста на токены или слова называется токенизацией.
 Токенизация — это процесс разбиения текста на более мелкие части

 - Удаление стоп-слов: стоп-слова – это самые распространенные слова в любом языке. Нет правильного определения
 игнорируемых слов, вы можете думать об этих словах как о словах, которые используются для создания значимого предложения.
 Например, такие слова, как «the», «is», «a», «as», представляют собой определенный тип стоп-слов, которые необходимо
 удалить из текстовых данных, которые вы используете, иначе это может повлиять на производительность вашей модели.

 - Стемминг — это процесс сведения слов к их основной (корневой) форме, удаляя окончания и суффиксы.
 Это помогает уменьшить сложность текста и улучшить производительность алгоритмов анализа.

 - Лемматизация - В отличие от стемминга, лемматизация сводит слова к их лемме — это более сложный процесс,
 который учитывает морфологический анализ слов. Лемматизация более точно обрабатывает слова, приводя их к словарной форме.

 - Анализ настроений (или сентимент-анализ) в NLTK часто сводится к классификации текста на позитивный или негативный.
------------------------------------------------------------------------------------------------------------------------

 Основные типы литералов – это ЧИСЛОВЫЕ, СТРОКОВЫЕ, ЛОГИЧЕСКИЕ литералы, а также литералы для КОЛЛЕКЦИЙ и ОБЪЕКТОВ.

 Литералы — это фиксированные значения, которые напрямую встроены в код. Примеры:  1, 'hi', True, [], {}, (), set() ...
 Переменные же — это имена, которые относятся к значениям и могут изменяться во время выполнения программы.

 Константы. Неизменяемые значения.
 В отличие от некоторых других языков, в Pyhton нет возможности объявить неизменяемую переменную.
 Для обозначения переменных, значения которых не должны меняться существует договорённость именовать их ЗАГЛАВНЫМИ буквами.
 MEMORY_MAX = 1024     визуально предупреждая, что данное значение менять не следует.                          <-----

 Константа - это переменная, содержащая фиксированное значение
 Константа - это данные, которые нельзя изменять
 Литерал - это само фиксированное значение, которое присваивается переменной-константе
 Литералы - это некоторые числовые или цифровые префиксы и суффиксы, которые описывают данные, хранящиеся в переменных и константах
 Свертывание констант — это метод оптимизации. Движок находит и оценивает константные выражения во время компиляции,
 а не вычисляет их во время выполнения, что делает среду выполнения более компактной и быстрой:

 day_sec = 24 * 60 * 60 # -> day_sec = 86400             что сворачивается а что нет  можно посмотреть через:   dis
 a = "-" * 4096   # folded          свернутый            a = "-" * 4096 ,   dis.dis('a')
 a = "-" * 4097   # not folded      не свернутый         dis.dis('a = "-" * 4096'), dis.dis('"-" * 4096')
 a = "--" * 4096  # not folded      не свернутый         dis.dis('a = "-" * 4097'), dis.dis("'-'*4097")


 Тернарный оператор(Ternary Operator) — способ превратить простую условную инструкцию в выражение:
 x = 4 if b > 8 else 9
 произносится как x будет равно 4, если b больше чем 8, в противном случае 9

 Примеры:
 1) x = a if True else b

 def abs(number):
    return number if number >= 0 else -number

 def my_max(a, b):
    return a if a > b else b

 Специальные атрибуты Встроенные    Special Attributes Built-in:
 object.__dict__ - Атрибут dict содержит словарь, который хранит атрибуты объекта в виде пар ключ-значение.
 Этот словарь заполняется значениями при создании объекта и может быть изменен позже

 instance.__class__ - Класс, которому принадлежит экземпляр класса.

 class.__bases__ - кортеж, содержащий базовые классы, в порядке их появления. Кортеж будет пустым, если наследование не было.

 definition.__name__ - Полное имя класса, функции, метода, дескриптора или экземпляра генератора.

 definition.__qualname__ - Содержит полное имя класса, метода, функции.

 definition.__type_params__ - Определение списка параметров типа.          Добавлено в версии 3.12.

 class.__mro__ - Порядок разрешения методов в множественном наследовании.

 class.mro() - Этот метод может быть переопределен метаклассом, чтобы настроить порядок разрешения методов для его
 экземпляров. Он вызывается при создании экземпляра класса, а его результат сохраняется в файле __mro__.

 class.__subclasses__() - Каждый класс хранит список слабых ссылок на свои непосредственные подклассы. Этот метод
 возвращает список всех живых ссылок. Список приведен в порядке определения. Пример:
 int.__subclasses__()

 __doc__ - строка документации модуля, функции, класса, ЭК, метода экземпляра класса. None если, документация отсутствует.

 __module__ - имя модуля, в котором определяется класс, функция, метод, экземпляр класса.



 --- Вызываемые типы  Callable types ---
 Это типы, к которым может быть применена операция вызова функции ()

 -- Специальные атрибуты, доступные только для чтения,  Работают с функциями + некоторыми другими callable:

 function.__globals__   - Словарь(глобальных переменных), определяющий глобальное пространство имен
 function.__closure__   - None или tuple ячеек замыкания  (связанные с вложенными областями видимости)
 Объект ячейки имеет атрибут cell_contents. Это можно использовать для получения значения ячейки, а также для установки значения.
 some_func.__closure__[0].cell_contents = 20,    some_func.__closure__[-1].cell_contents

 -- Специальные записываемые атрибуты  Работают с Функциями + некоторые работают с Классами, ЭК, ЭК.методами, built-in:

 function.__doc__         - Строка документации функции или, None если она недоступна. Не наследуется подклассами.
 function.__name__        - Имя функции.
 function.__qualname__    - Полное имя функции .
 function.__module__      - Имя модуля, в котором была определена функция, или, None  если оно недоступно.
 function.__defaults__    - кортеж любых значений по умолчанию для позиционных параметров или параметров ключевых слов
 function.__kwdefaults__  - Сопоставление любых значений по умолчанию для параметров, содержащих только ключевые слова.
 function.__code__        - Объект кода , представляющий тело скомпилированной функции.
 function.__dict__        - Словарь атрибутов функции.
 function.__annotations__ - Словарь Аннотации типов.
 function.__type_params__ - Содержит параметры tuple типа универсальной функции Generic function:  def func[T](arg: T):

 -- Методы экземпляра  Instance methods   Работают не только с МЕТОДАМИ(Функциями) экземпляров классов:
 method.__self__   - Ссылается(Ссылка) на объект экземпляра класса, к которому привязан метод.
 method.__func__   - Ссылается на исходный объект функции.
 method.__doc__    - Док метода (аналог method.__func__.__doc__).Док, если исходная функция имела docstring, иначе None.
 method.__name__   - Имя метода (то же, что и method.__func__.__name__)
 method.__module__ - Имя модуля, в котором был определен метод, или, None если оно недоступно.
 Методы также поддерживают доступ (но не установку): __globals__, __closure__
 method.__qualname__    - Полное имя класса, метода
 method.__defaults__    - кортеж любых значений по умолчанию для позиционных параметров или параметров ключевых слов
 method.__kwdefaults__  - Сопоставление любых значений по умолчанию для параметров, содержащих только ключевые слова.
 method.__code__        - Объект кода , представляющий тело скомпилированной функции.
 method.__dict__        - Словарь атрибутов функции.
 method.__annotations__ - Словарь Аннотации типов.
 method.__type_params__ - Содержит параметры tuple типа универсальной функции Generic functions:  def func[T](arg: T):...

 -- Встроенные функции  Built-in functions --
 Специальные атрибуты, доступные только для чтения:
 __doc__ , __name__ , __self__ , __module__

 -- Модули  Module --
 Объект модуля имеет пространство имен, реализованное объектом dictionary(это словарь, на который ссылается __globals__
 атрибут функций, определенных в модуле). Ссылки на атрибуты преобразуются в поиск в этом словаре, например,
 m.x эквивалентно m.__dict__["x"]. Объект модуля не содержит объект кода, используемый для инициализации модуля
 (поскольку он не нужен после завершения инициализации).

 Предопределенные (доступные для записи) атрибуты:
 __name__        - Имя модуля. Пишем Только __name__ без ничего и получим имя модуля.
 __doc__         - Строка документации модуля или, None если она недоступна.  Docsting ПИШЕМ СВЕРХУ (СНАЧАЛА С 1 СТРОКИ)
 __file__        - Путь к файлу, из которого был загружен модуль, если он был загружен из файла.
 __annotations__ - Словарь, содержащий аннотации переменных , собранные во время выполнения тела модуля.
 __dict__        - Специальный атрибут, доступный только для чтения: это пространство имен модуля как объект словаря.

 -- Пользовательские классы   Custom classes       Самописные классы --
 class.__name__         - Имя класса
 class.__qualname__     - Полное имя класса
 class.__module__       - Имя модуля, в котором был определен класс.
 class.__dict__         - Словарь, содержащий пространство имен класса.
 class.__bases__        - Кортеж, содержащий базовые классы в порядке их появления в списке базовых классов.
 class.__doc__          - Строка документации класса или, None если она не определена.
 class.__annotations__  - Словарь, содержащий аннотации переменных
 class.__type_params__  - Кортеж, содержащий параметры типа универсального класса Generic class:  class Bag[T]:  версия 3.12

 -- Экземпляры классов   Class instances --
 Экземпляр класса создается путем вызова объекта класса:  instance = Class()
 Экземпляры классов могут притворяться числами, последовательностями или отображениями, если у них есть методы
 с определенными специальными именами -> Магические методы (Dunder Mathods)
 Специальные атрибуты:
 instance.__dict__   - Словарь атрибутов Экземпляра класса(ЭК)
 instance.__class__  - Имя класса экземпляра.
 instance.__module__ - Имя модуля, в котором был определен Экземпляр класса

 -- Объекты кода  Code objects --
 Объекты кода представляют собой скомпилированный в байтах исполняемый код Python или байт-код . Разница между объектом
 кода и объектом функции заключается в том, что объект функции содержит явную ссылку на глобальные переменные функции
 (модуль, в котором он был определен), тогда как объект кода не содержит контекста; также значения аргументов по умолчанию
 хранятся в объекте функции, а не в объекте кода (поскольку они представляют значения, рассчитанные во время выполнения).
 В отличие от объектов-функций, объекты кода неизменяемы и не содержат ссылок (прямых или косвенных) на изменяемые объекты.

 Специальные атрибуты, доступные только для чтения:
 codeobject.co_name             - Имя функции
 codeobject.co_qualname         - Полное имя функции   Добавлено в версии 3.11.
 codeobject.co_argcount         - Общее количество позиционных параметров , которые имеет функция.
 codeobject.co_posonlyargcount  - Количество позиционных параметров , которые имеет функция.
 codeobject.co_kwonlyargcount   - Количество параметров , содержащих только ключевые слова которые имеет функция.
 codeobject.co_nlocals          - Количество локальных переменных , используемых функцией (включая параметры)
 codeobject.co_varnames         - tuple содержащий имена локальных переменных в функции (начиная с имен параметров).
 codeobject.co_cellvars         - Содержит tuple имена локальных переменных , на которые ссылаются вложенные функции внутри функции.
 codeobject.co_freevars         - tuple содержащий имена свободных переменных в функции
 codeobject.co_code             - Строка, представляющая последовательность инструкций байт-кода в функции.
 codeobject.co_consts           - tuple содержащий литералы, используемые байт-кодом в функции
 codeobject.co_names            - tuple содержащий имена, используемые байт-кодом в функции
 codeobject.co_filename         - Имя файла, из которого был скомпилирован код
 codeobject.co_firstlineno      - Номер первой строки функции
 codeobject.co_lnotab           - Строка, кодирующая сопоставление смещений байт-кода с номерами строк. Устарело с версии 3.12:
 codeobject.co_stacksize        - Требуемый размер стека объекта кода
 codeobject.co_flags            - Кодирование integer ряда флагов для интерпретатора.

 -- Методы объектов кода  Methods on code objects --
 codeobject.co_positions()    - Возвращает итерацию по позициям исходного кода каждой инструкции байт-кода в объекте кода.
 codeobject.co_lines()        - Возвращает итератор, который возвращает информацию о последовательных диапазонах байт-кодов .
 codeobject.replace(**kwargs) - Верните копию объекта кода с новыми значениями для указанных полей.

 Пример хороший об Обьектах кода  __code__.+ использование атрибутов codeobject
 import inspect
 class A:
     def __init__(self, a):
         self.a = a
     def foo(self, b):
         pass
 A.__init__.__code__.co_stacksize     # ->  2 Размер стека объекта кода
 A.__init__.__code__                  # ->  <code object __init__ at 0x000001E3D15C0100, file "...", line ..>
 A.foo.__code__                       # ->  <code object foo at 0x000001FC01E17930, file "...", line ..>
 len(inspect.signature(A).parameters) # ->  1 количество параметров конструктора

 Поскольку вы не определили a __init__самостоятельно, A.__init__это (по крайней мере, в эталонном интерпретаторе CPython)
 __init__ функция по умолчанию уровня C, а не функция уровня Python вообще. __code__— скомпилированный байт-код функции
 уровня Python ; если функция не определена на уровне Python, у нее вообще нет байт-кода.   <-----

 -- Объекты фрейма  Frame objects --
 Объекты фреймов представляют собой фреймы выполнения. Они могут встречаться в объектах трассировки , а также передаются
 зарегистрированным функциям трассировки.

 Специальные атрибуты, доступные только для чтения:
 frame.f_back      - Указывает на предыдущий кадр стека (в сторону вызывающего объекта) или, None если это нижний кадр стека.
 frame.f_code      - Объект кода , выполняемый в этом кадре.
 frame.f_locals    - Словарь, используемый фреймом для поиска локальных переменных.
 frame.f_globals   - Словарь, используемый фреймом для поиска глобальных переменных.
 frame.f_builtins  - Словарь, используемый фреймом для поиска встроенных (внутренних) имен.
 frame.f_lasti     - Точная инструкция» объекта кадра (это индекс в строке байт-кода объекта кода)

 Специальные записываемые атрибуты:
 frame.f_trace          - Это функция , вызываемая при различных событиях во время выполнения кода.
 frame.f_trace_lines    - Установка значения: False чтобы отключить запуск события трассировки для каждой исходной строки.
 frame.f_trace_opcodes  - Установка значения: True разрешить запрашивание событий для каждого кода операции.
 frame.f_lineno         - Текущий номер строки кадра — запись в него изнутри функции трассировки переходит к заданной строке

 -- Методы объекта фрейма  Frame object methods --
 Объекты фреймов поддерживают один метод:
 frame.clear()  - Этот метод удаляет все ссылки на локальные переменные , хранящиеся во фрейме.

 -- Объекты трассировки  Traceback objects --
 Объекты Traceback представляют собой трассировку стека исключения . Объект трассировки создается неявно при
 возникновении исключения, а также может быть создан явно путем вызова types.TracebackType.
 Изменено в версии 3.7: объекты Traceback теперь можно явно создавать из кода Python.

 Специальные атрибуты, доступные только для чтения:
 traceback.tb_frame   - Указывает на кадр выполнения текущего уровня.
 traceback.tb_lineno  - Дает номер строки, в которой произошло исключение.
 traceback.tb_lasti   - Указывает на «точную инструкцию».
 traceback.tb_next    - Специальный записываемый атрибут tb_next — это следующий уровень в трассировке стека.


 -- Генераторные функции Generator functions - yield --
  Функция или метод, использующие  yield называется функцией-генератором. Когда вызывается функция генератора, то она
 не возвращает единственное значение, как это делает оператор return. Вместо этого она возвращает объект генератора,
 который поддерживает протокол итератора.

 def generate_ints(N):
   for i in range(N):
       yield i

 -- Функции сопрограммы Coroutine functions Асинхронные функции (сопрограммы) - async def await --
 Асинхронные функции (сопрограммы) являются более обобщенной формой подпрограмм. Возвращат обьект coroutine.
 Функция или метод, определенный с помощью  async def - coroutine function(асинхронная функция, сопрограмма)

 Внутри тела функции сопрограммы идентификаторы await и async становятся зарезервированными ключевыми словами.
 Выражения await, async for и async with могут использоваться только в телах функций сопрограмм.

 Подпрограммы вводятся в одной точке и выходят в другой точке. Выполнение сопрограмм в Python может быть приостановлено
 и возобновлено в разных точках. Они могут быть реализованы с помощью оператора async def.

 import asyncio

 async def ticker(delay, to):
     for i in range(to):
         yield (i, delay)
         await asyncio.sleep(delay)

 async def run(k):
     async for i in ticker(k, 5):
         print(i)

 async def main():
     task1 = asyncio.create_task(run(0.5))
     task2 = asyncio.create_task(run(1))
     # планируем одновременные вызовы:
     await asyncio.gather(task1, task2)

 if __name__ == '__main__':
     asyncio.run(main())

 -- Функции асинхронного генератора Asynchronous generator functions  - async def yield --
 Наличие выражения yield в функции или методе, определенных с помощью async def, дополнительно определяет функцию
 как функцию асинхронного генератора. Возвращает асинхронный итератор, известный как объект асинхронного генератора.

 async def g(x):
    yield x  # OK - this is an async generator


 import asyncio

 async def async_generator():
     for x in range(10):
         await asyncio.sleep(0.5)
         print(f"{x} - submitted record")
         yield x

 async def process_record(x):
     await asyncio.sleep(1)
     print(f"{x} - record processed")

 async def my_f():
     tasks = []
     async for x in async_generator():
         tasks.append(asyncio.create_task(process_record(x)))
         print(f"{x} - record processing submitted")
     await asyncio.gather(*tasks)

 if __name__ == "__main__":
     event_loop = asyncio.get_event_loop()
     event_loop.run_until_complete(my_f())


 Теперь - внимание - я хочу два генератора! Вспомним про itertools.chain:           Вот простой генератор:
 import asyncio                                                                     import asyncio
 from itertools import chain
                                                                                    async def generator():
 async def generator():                                                                 for i in range(10):
     for i in range(10):                                                                    yield i
         yield i                                                                            await asyncio.sleep(0.1)
         await asyncio.sleep(0.1)
                                                                                    async def main():
 async def main():                                                                      async for value in generator():
     async for value in chain(generator(), generator()):                                    print(value)
         print(value)
                                                                                    if __name__ == '__main__':
 if __name__ == '__main__':                                                             asyncio.run(main())
     asyncio.run(main())
 # TypeError: 'async for' requires an object with __aiter__ method, got itertools.chain   <-----

   -- Отличие Функции генератора от Функции сопрограммы   Generator function vs Coroutine function --
 Функции генератора, с выражением yield from <expr> внутри него, являются почти сопрограммами, но не совсем.

 Единственное отличие состоит в том, что функция генератор не может контролировать где продолжиться выполнение после
 ее завершения, при этом дальнейшее управление всегда передается вызывающей стороне.

 -- Сопрограммы также имеют перечисленные ниже методы, аналогичные методам генераторов (Generator-iterator methods) --
 Однако, в отличие от генераторов, сопрограммы не поддерживают итерацию напрямую.

 Coroutine                                    Generator-iterator                          Asynchronous generator-iterator
                                              generator.__next__()                        coroutine agen.__anext__()
 coroutine.send(value)                        generator.send(value)                       coroutine agen.asend(value)
 coroutine.throw(value)                       generator.throw(value)                      coroutine agen.athrow(value)
 coroutine.throw(type[, value[, traceback]])  generator.throw(type[, value[, traceback]]) coroutine agen.athrow(type[, value[, traceback]])
 coroutine.close()                            generator.close()                           coroutine agen.aclose()


 Ах, да... Магические методы не предусматривают работы с async
 Большинство магических методов не предназначены для работы с async def/ await— как правило, вам следует использовать
 только await внутри выделенных асинхронных магических методов — __aiter__, __anext__, __aenter__и __aexit__.


 async и await всего лишь синтаксический сахар вокруг генераторов!                                              <-----

 # До появления ключевых слов async и await в версии Python 3.5 связь между сопрограммами и генераторами были очевидной.
 # Старый синтаксис с декораторами и генераторами.

 # В таком стиле писать код НЕ СТОИТ! Старый стиль с использованием декораторов и генераторов в asyncio
 # использование `@asyncio.coroutine` более НЕ поддерживается.
 # 3.11 и более поздних версиях действительно была удалена поддержка декоратора `@asyncio.coroutine`

 import asyncio

 Старый стиль/синтаксис                             # Тоже самое Новый стиль/синтаксис  async и await  с версии Python 3.5
 @asyncio.coroutine                                 async def coroutine():
 def coroutine():                                       print('Засыпаю!')
     print('Засыпаю!')                                  await asyncio.sleep(1)
     yield from asyncio.sleep(1)                        print('Проснулась!')
     print('Проснулась!')
                                                    asyncio.run(coroutine())

 asyncio.run(coroutine())  # AttributeError: module 'asyncio' has no attribute 'coroutine'. Did you mean: 'coroutines'?


 -- Нарезка объектов  Slice objects --
 Объекты срезов используются для представления срезов для __getitem__() методов. Они также создаются встроенной slice()функцией.

 slice.indices(self, length) - Аналог Срезов   slice(None, None, -1) - аналогично [::-1] , slice(1, 5) -> [1:5]

 slice_slice = list(range(8))       # -> [0, 1, 2, 3, 4, 5, 6, 7]
 new_slice = slice(None, 4)         # -> None == :                 #  None замена : в срезах
 slice_slice[new_slice]             # -> [0, 1, 2, 3]              #  slice_slice[:4]
 slice_slice[slice(None, 4)]        # -> [0, 1, 2, 3]              #  slice_slice[:4]
 slice_slice[slice(None, None, -1)] # -> [7, 6, 5, 4, 3, 2, 1, 0]  #  slice_slice[::-1]


 # Как метод indices()   Обрабатывает ИНДЕКСЫ которые выходят за границы    Возвращает - НОРМАЛИЗИРОВАННЫЕ  Кортежи
 # indices(start, end, step)     или как в Книге   S.indices(len)  -> (start, end, stride)  stride - Расширенный срез

 res = 'ABCDE'
 s = slice(None, 10, 2)
 print(s.start, s.stop, s.step)  # -> None 10 2

 print(slice(None, 10, 2).indices(5))              # -> (0, 5, 2)
 print(slice(None, 100, 2).indices(5))             # -> (0, 5, 2)
 print(slice(None, 100, 2).indices(len(res)))      # -> (0, 5, 2)

 print(res[slice(None, 100, 2)])                   # -> ACE

 print(slice(-3, None, None).indices(len(res)))    # -> (2, 5, 1)
 print(slice(-300, None, None).indices(len(res)))  # -> (0, 5, 1)

 print(res[slice(-300, None, None)])               # -> ABCDE


 Интроспекция — это способность программы исследовать тип или свойства объекта во время работы программы. - inspect
 Вы можете поинтересоваться, каков тип объекта, является ли он экземпляром класса
 Интроспекция позволяет вам изучать атрибуты объекта во время выполнения программы, а РЕФЛЕКСИЯ — манипулировать ими.
 В Python самой распространённой формой интроспекции является использование метода dir() , .__dir__()

 dir() , .__dir__()  -  Чтобы посмотреть все методы и атрибуты, связанные с определенным объектом в Python
 import datetime
 [_ for _ in dir(datetime) if 'date' in _.lower()]

 Python поддерживает полную интроспекцию времени исполнения. Это означает, что для любого объекта можно получить
 всю информацию о его внутренней структуре.
 Примеры: __dict__ , __class__ ,    type() , dir() или встроенного модуля inspect

 Интроспекция функций:
 функция dir, объект type, функция isinstance, функция issubclass, функция id, модуль inspect


 globals() и locals() - это встроенные функции в Python, которые возвращают словари глобальных и локальных переменных соответственно.

 --- Менеджер пакетов: pip, conda, poetry - новый менеджер пакетов ---
 Менеджер пакетов - это инструмент, который позволяет управлять установкой, обновлением и удалением библиотек
 и зависимостей в проектах на языке Python.
 pip - это стандартный менеджер пакетов Python. Он позволяет устанавливать пакеты из Python Package Index (PyPI)
 и других источников, а также управлять зависимостями проекта
 Pip - стандартный менеджер пакетов питона, позволяет устанавливать бинарные wheel сборки пакетов. Если их нет
 (ни в самом Pip, ни где-то еще), Pip компилирует пакеты локально. При этом могут возникнуть проблемы при сложных
 зависимостях, когда требуются сторонние не питон библиотеки. В этом случае удобно использовать Conda.

  В общем, Poetry предлагает более мощные и удобные возможности для работы с проектами на Python по сравнению с pip.

 В Python wheels и eggs - это форматы пакетов для установки и дистрибуции пакетов с помощью управления пакетами pip.
 Wheel - это современный формат распространения пакетов в Python среде, который пришел на замену eggs.
 whl (Wheel). Это бинарный формат дистрибутива, который позволяет устанавливать Python пакеты без компиляции исходного
 кода и не требует наличия всех библиотек, необходимых для сборки пакета.

 Формат файла WHL представляет собой архив ZIP (.zip), который содержит все установочные файлы и метаданные, необходимые
 установщикам для установки пакета. Эти файлы WHL можно извлечь с помощью функции распаковки или стандартных приложений
 для распаковки, таких как WinZIP и WinRAR.

 conda — это кросс-платформенный менеджер пакетов, который может устанавливать пакеты для любого языка, не только Python.
 Conda является частью дистрибутива Anaconda, который активно используется в научных исследованиях и анализе данных.
 Conda - менеджер пакетов питона, позволяет устанавливать уже скомпилированные пакеты (может работать и в режиме
 компиляции пакетов перед установкой). Также Conda - менеджер окружений системы, позволяет создавать окружения
 с разными версиями чего угодно (библиотеки C, низкоуровневые библиотеки и т.д.).
 Conda бывает в двух версиях:
 - Анаконда - более 150 предустановленных пакетов (около 3 Гб) + более 250 пакетов, готовых к установке командой
 conda install package_name
 - Миниконда - более 400 пакетов, готовых к установке командой conda install package_name
 Анаконда и Миниконда включают:
 - conda
 - интерпретатор питона
 - pip
 Anaconda — это дистрибутив Python, ориентированный на обработку и анализ данных. Он включает в себя предустановленные
 библиотеки и инструменты, такие как NumPy, Pandas, Jupyter и многие другие, что делает его мощным инструментом для
 работы в области науки о данных.

 ЗАВИСИМОСТИ в проекте Python — это внешние библиотеки и модули, которые используются для решения определенных задач
 pip freeze > requirements - посмотреть зависимости

 requirements. txt — это простой текстовый файл, который содержит перечень всех модулей и пакетов,
 необходимых для корректной работы вашей программы.

 Чтобы получить список пакетов в проекте выполняем команду:
 pip freeze
 Для записи вывода в requirements.txt дополняем следующим образом:
 pip freeze > requirements.txt
 Установка:
 pip install -r requirements.txt

 pip help - помощь по доступным командам.
 pip install package_name - установка пакета(ов).
 pip uninstall package_name - для удаления пакета

 Если необходимо удалить несколько пакетов, их можно перечислить через пробел:
 pip uninstall пакет1 пакет2 пакет3

 Чтобы избежать постоянного запроса подтверждения от пользователя при удалении библиотек, используется ключ -y или --yes:
 pip uninstall -y пакет1 пакет2

 При установке нового пакета или его обновлении старая версия автоматически удаляется из библиотеки конкретного окружения.
 В этом процессе ключ -y позволяет избежать ручного подтверждения действия удаления.
 pip uninstall -r requirements.txt -y


 Указать версию вместе с именем модуля:
 pip uninstall package_name==2.26.0     # Удалить
 pip install package_name==2.26.0       # Установить

 Это установит package_name версии 2.26.0 или более новую.
 pip install package_name>=2.26.0

 Это установит package_name версии 2.26.0 или более старую.
 pip install package_name<=2.26.0

 Это установит requests в диапазоне от 2.25.0 до 2.26.0 включительно.
 pip install package_name>=2.25.0,<=2.26.0

 Для обновления уже установленного модуля до последней версии используйте команду:
 pip install --upgrade package_name

 Если пакет уже установлен и работает некорректно можно принудительно его переустановить:
 pip install --force-reinstall package_name


 constraints.txt, в котором прописываются дополнительные зависимости,
 а в файле requirements.txt перечислить основные библиотеки.

 На практике constraints.txt используется лишь в крупных проектах, а для небольших разработок можно обойтись
 простым перечислением зависимостей  - requirements.txt


 -- Как правильно начать писать свой проект --
 1. Устанавливайте пайтон в папку на диске С, не содержащую кириллические символы (не на рабочий стол!)
 2. Создайте папку для своих проектов на диске С, она тоже не должна содержать кириллицы (не на рабочем столе!)
 3. Ничего не создаем в папке venv, не трогаем ее
 4. Создаем пакеты по правилам наименования, с читаемым, понятным названием
 5. Модули создаем внутри пакетов, по правилам наименования, с понятными именами

 -- Работа с Git в PyCharm. Без терминалов и головной боли.
 Инструкция по работе с гит в PyCharm:
 1) включаем систему контроля версий VCS- Enable Version Control Integration  выбираем Git
 2) в корне проекта создаем файл .gitignore  добавляем туда venv и .idea
 3) во вкладке гит нажимаем обновить, выделяем нужные файлы и выбираем Add to VCS (добавляем в отслеживание)
 4) когда код написан выделяем нужные файлы и выбираем Commit (Сохранить локально)
 5) если хотим увидеть изменения выбираем Show Diff или смотрим лог гита
 6) если хотим откатить то выбираем Rollback
 7) для сохранения на удаленный сервер выбираем Push
 8) для подтягивания изменения  с сервера выбираем Pull

 Правило 1: перед коммитом убеждаемся что код работает, пробегаем глазами по всем измененным файлам (Show Diff),
 чтобы убедиться в том, что не забыли удалить отладочные и временные вещи. Запускаем тесты (как это их нет???)
 и убеждаемся что они зеленые. Пишем грамотный текст в коммите!

 Правило 2: 10 мелких коммитов лучше 1 большого!


 --- Какие есть ветки в Git ---

 Вот основные ветки, которые часто используются в Git:

 1. **`master` (или `main`)** - Основная ветка, содержащая стабильную и готовую к производству версию проекта.

 2. **`develop`** - Ветка для разработки, в которую интегрируются новые функции и изменения перед слиянием с
 `master` или `main`.

 3. **`feature/*`** - Ветки для разработки конкретных функций, которые создаются от `develop` и сливаются обратно
 после завершения.

 4. **`bugfix/*`** или **`hotfix/*`** - Ветки для исправления ошибок, которые могут создаваться как от `develop`,
 так и от `master`, в зависимости от ситуации.

 5. **`release/*`** - Ветки, предназначенные для подготовки к выпуску новой версии, где проводятся финальные тесты и
 фиксации изменений перед слиянием с `master`.

 Эти ветки помогают организовать процесс разработки и управления версиями в проекте.


 В Git команды `merge` и `rebase` используются для интеграции изменений из одной ветки в другую, но они делают это по-разному.

 -- В чем разница между git rebase и git merge? --

 merge  - Добавляет коммит мержа и сохраняет историю коммитов
 rebase - Применяет все коммиты на целевую ветку и удаляет историю коммитов

 Git Merge - Объединение веток
 - Команда `git merge` объединяет две ветки, создавая новый коммит, который включает изменения из обеих веток.
 В результате появляется так называемый "мердж-коммит".

 Git Rebase - Перемещение коммитов     "перезаписывает" историю.

 **Merge:** Используйте `merge`, когда хотите сохранить всю историю изменений, включая ветвление и слияния. Это особенно
 полезно в больших проектах с несколькими разработчиками.
 **Rebase:** Используйте `rebase`, чтобы иметь более чистую и понятную историю, особенно при работе с локальными
 ветками перед отправкой (push) на удалённый репозиторий.

  -- git stash --
 Команда git stash позволяет на время «сдать в архив» (или отложить) изменения, сделанные в рабочей копии,
 чтобы вы могли применить их позже.
 Откладывание изменений полезно, если вам необходимо переключить контекст и вы пока не готовы к созданию коммита.


 `git stash` — это команда в системе контроля версий Git, которая позволяет временно сохранить текущие изменения в
 рабочем каталоге и индексе (stage), чтобы вы могли вернуться к чистому состоянию репозитория. Это может быть полезно,
 если вы хотите переключиться на другую ветку или выполнить какую-либо другую задачу, не теряя незавершенные изменения.

 Когда вы выполняете `git stash`, Git делает следующее:

 1. Сохраняет ваши изменения (как отслеживаемые, так и неотслеживаемые файлы) в специальном хранилище (stash).
 2. Возвращает ваш рабочий каталог и индекс к состоянию последнего коммита.

 После этого вы можете переключаться на другие ветки, выполнять коммиты или любые другие действия, не беспокоясь о том,
 что потеряете ваши изменения.

 Для восстановления ваших изменений из стека вы можете использовать команду `git stash pop` или `git stash apply`.
 Первая команда удаляет сохранённые изменения из стека после их применения, а вторая — применяет изменения, оставляя их в стеке.

 git stash apply "stash@{3}"     - Выбор нужного stash  "stash@{1}", "stash@{2}", "stash@{3}"
 git stash apply                 - Выбор ПОСЛЕДНЕГО stash

 Некоторые часто используемые подкоманды:

 - `git stash list` — показывает список всех сохранённых изменений.
 - `git stash show` — отображает изменения, сохранённые в последнем хранилище (по умолчанию).
 - `git stash drop` — удаляет указанный элемент из стека.
 - `git stash clear` — очищает весь стек сохранённых изменений.

 Таким образом, `git stash` предоставляет удобный способ временно "отложить" изменения, чтобы вы могли продолжить
 работу с чистым состоянием репозитория.


 Посмотреть изменения файла - Нажимаем на файлик и выбираем Show diff

  -- cherry-picking --
 В GitLab (и Git) **cherry-picking** — это процесс выбора отдельных коммитов из одной ветки и применения их в другую ветку.
 Это позволяет перенести конкретные изменения или исправления без слияния всей ветки. Обычно используется для быстрого
 исправления ошибок или выборочного внедрения функций.

 Cherry-picking — это выборочное применение изменений из одной ветки репозитория в другую.
 1. Найдите нужный коммит:

    git log

 2. Перейдите на целевую ветку:

    git checkout target-branch

 3. Примените коммит:

    git cherry-pick <commit-hash>

 Это добавит изменения из указанного коммита в текущую ветку.


 -- Как создать ветку в Git --
 git branch имя_ветки

 Например:
 git branch feature/new-feature

 **Переключитесь на эту ветку**
 git checkout имя_ветки             git switch имя_ветки     # Лучше использовать switch  для переключения между ветками

 **Создание новой ветки и переключение на нее**
 git checkout -b имя_ветки

 **Просмотреть все ветки** в репозитории:
 git branch

 **Удалить ветку** (если требуется):
 git branch -d имя_ветки


 -- Pull request --

 Pull request (PR) — это функция в системах управления версиями, таких как Git, которая позволяет разработчикам
 сообщать о том, что они внесли изменения в код и предлагают интегрировать эти изменения в основную ветку проекта.
 Pull request обычно создаётся, когда разработчик завершает работу над какой-либо задачей в отдельной ветке и хочет,
 чтобы другие участники проекта просмотрели, обсудили и, при необходимости, внесли изменения, прежде чем эти изменения
 будут объединены (или «вмержены») в основную ветку (например, `main` или `master`).

 Процесс работы с pull request обычно включает следующие шаги:

 1. **Создание ветки**: Разработчик создаёт новую ветку для выполнения своей работы.
 2. **Внесение изменений**: Проделываются необходимые изменения в коде.
 3. **Коммит и пуш**: Изменения коммитятся в локальной ветке и отправляются (push) на удалённый репозиторий.
 4. **Создание Pull request**: Через интерфейс удалённого репозитория (например, GitHub, GitLab, Bitbucket и др.)
 создаётся pull request на слияние созданной ветки с основной.
 5. **Код-ревью**: Другие разработчики или участники проекта могут просмотреть изменения, оставить комментарии,
 предложить улучшения или задать вопросы.
 6. **Слияние**: После обсуждения и одобрения изменений pull request может быть объединён с основной веткой.

 Pull request не только упрощает процесс интеграции кода, но и способствует улучшению качества кода благодаря код-ревью
 и обсуждениям среди команды.

 Pull request (PR) — это запрос на слияние изменений из одной ветки кода в другую в системе контроля версий Git.
 Он позволяет разработчикам предложить свои изменения, получить отзывы от команды и обсудить их, прежде чем объединить
 с основной веткой проекта. PR включает описание изменений, обсуждения и возможность проведения код-ревью.

 **Создание Pull Request**:
 - Перейдите в ваш репозиторий на GitHub (или другой платформе).
 - В разделе "Pull requests" нажмите на кнопку "New pull request".
 - Выберите вашу ветку (`feature/my-feature`) и основную ветку (`main`).
 - Заполните заголовок и описание PR, объясняя изменения и их цель.
 - Нажмите на кнопку "Create pull request".


  -- Команды GIT --
 Основные команды для работы с состояниями файлов

 1. git status: Показывает текущее состояние репозитория, включая изменения, которые были сделаны, но еще не
    зафиксированы, и файлы, готовые к коммиту.

 2. git add: Добавляет изменения в указанных файлах в индекс (staging area) для последующего коммита.

 3. git commit: Фиксирует изменения в локальном репозитории с соответствующим сообщением о коммите.

 4. git diff: Показывает различия между файлами: изменения в рабочем каталоге, разницу между индексом и
    последним коммитом или между двумя коммитами.

 5. git reset: Отменяет изменения в индексе или в рабочем каталоге; может быть использована с разными уровнями
    "жесткости" (например, --soft, --mixed, --hard) в зависимости от того, что нужно сбросить.


 -- ПОДТЯНУТЬ ИЗМЕНЕНИЯ --
 1) git stash
 2) git checkout main
 3) git pull origin main
 4) git checkout имя_ветки
 5) git rebase main
 6) git status
 7) git stash apply


 -- Сделать Pull Request --
  Переходим в папку проекта через cd
 1) git checkout -b имя_ветки
 2) git push   или   Команда git push --set-upstream origin имя_ветки
 3) Переходим по ссылке на Pull Request

 Команда git push --set-upstream origin имя_ветки используется для отправки локальной ветки имя_ветки на
 удалённый репозиторий origin и установки её в качестве "отслеживаемой" ветки.
 Это означает, что в дальнейшем вы сможете использовать просто git push и git pull без указания имени ветки,
 и Git будет знать, что работать нужно с этой веткой на удалённом репозитории.


 Команда git rebase -i HEAD~4 используется в Git для интерактивного перебазирования (interactive rebasing)
 последних 4 коммитов, находящихся в истории вашей текущей ветки. Вот более подробное объяснение:


 -- Отменить commit --
 Сверху Pycharm выбираем Git -> VCS Operations -> Show History -> Другой кнопкой мышки -> Revert commit   или Alt + 9
 (Файлы должны быть в git stash)

 Git Stash: Перед отменой коммита вам не обязательно помещать файлы в git stash, если вы просто хотите отменить
 последний коммит и оставить изменения в рабочем каталоге. Однако, если вы хотите сохранить текущие изменения,
 которые не были добавлены в коммит, тогда использование git stash может быть хорошей идеей.

 Шаги для отмены коммита:

 В верхнем меню PyCharm выберите Git -> VCS Operations Popup (можно также использовать комбинацию клавиш Alt + 9).
 Далее выберите Show History, чтобы открыть историю коммитов.
 Найдите нужный коммит в списке, щелкните по нему правой кнопкой мыши.
 Выберите Revert Commit, чтобы отменить изменения, внесенные в этом коммите.
 Результат: После выполнения этих шагов изменения, сделанные в отмененном коммите,
 будут добавлены обратно в ваш рабочий каталог, и вы сможете их отредактировать или создать новый коммит.

 Если у вас есть какие-то изменения в рабочем каталоге, которые вы не хотите потерять, используйте git stash перед
 отменой коммита. Если вы хотите просто отменить коммит, можно обойтись и без этого шага.


 -- Отменить commit через Терминал --

 Проверьте статус репозитория (необязательно, но полезно):
 git status

 Отмените последний коммит: Чтобы отменить последний коммит, оставив изменения в рабочем каталоге, используйте следующую команду:
 git reset --soft HEAD~1

 Если вы хотите удалить коммит и убрать изменения из рабочего каталога, используйте:
 git reset --hard HEAD~1

 (Опционально) Использование git stash: Если вы хотите сохранить текущие изменения перед отменой коммита,
 вы можете использовать команду git stash:
 git stash

 Затем выполните команду для отмены коммита:
 git reset --soft HEAD~1

 После этого вы можете вернуть изменения из stash:
 git stash pop


 --- Работа с git на реальном проекте, используя PyCharm ---
 Рутинные операции любого программиста в его рабочем процессе.
 Большую часть этих действий вы будете повторять раз за разом в течение своей карьеры.

 При старте проекта:
 - клонировать проект
 - прочесть README
 - установить виртуальное окружение
 - установить все зависимости (requirements.txt)
 - настроить проект для запуска или прогона тестов.

 На регулярной основе:
 - создаем ветку с названием нашей задачи
 - реализуем задачу =)
 - проверяем наши правки и прогоняем тесты
 - заливаем код в ветку
 - создаем мерж-реквест (пулл-реквест)
 - проходим настроенные пайплайны
 - проходим код-ревью, исправляем замечания
 - заливаем нашу ветку в основную ветку разработки
 - повторяем до пенсии...


  -- Редактор Vim (ТЕКСТОВЫЙ РЕДАКТОР)--

 Основные команды:
 dd - удалить текущую строку.
 i - войти в режим вставки (insert mode).
 d30 - удалить 30 строк, начиная с текущей (вводится как d30 + Enter). Вместо 30 можно указать любое другое число.
 Сохранение и выход из редактора
 :w - сохранить файл.
 :q - выйти из Vim (если не было изменений).
 :q! - выйти из Vim без сохранения изменений.
 :wq - сохранить файл и выйти из Vim.


 Редактирование текста    Выход из режима РЕДАКТИРОВАНИЯ: Esc или Ctrl + C.
 i - вставить текст перед курсором.
 a - вставить текст после курсора.
 o - вставить новую строку после текущей строки и перейти в режим вставки.
 yy - скопировать текущую строку.
 p - вставить скопированный или вырезанный текст после курсора.
 u - отменить последнее действие.
 Ctrl + r - повторить последнее отмененное действие.


 Дополнительные команды
 h - показать справку с командами редактора (в режиме команд).
 x - удалить текущий символ (не строку).
 j - перейти к следующей строке.
 k - перейти к предыдущей строке.
 gg - перейти к первой строке.
 G - перейти к последней строке.
 :set number - включить отображение номеров строк.
 :set nonumber - отключить отображение номеров строк.
 /текст - найти строку (поиск по тексту, после / вводите текст для поиска).
 c - изменить текущую строку (входит в режим вставки).
 P - вставить строку перед текущей.

 Все эти команды относятся к редактору Vim, который является мощным инструментом для редактирования текста в Unix-подобных системах.

 git bash
 squash - в режиме редактирования (i) pick меняем на squash
 squash - сжатие или объединение данных


 -- Модуль site  - перехватчик конфигурации Python
 Этот модуль автоматически импортируется во время инициализации. Автоматический импорт можно отключить с помощью опции интерпретатора -S.
 Исполняемая строка в .pth файле запускается при каждом запуске Python, независимо от того, будет ли фактически
 использоваться конкретный модуль.

 Что такое файлы .pth?
 Файлы с расширением .pth - это файлы, которые показывают Python в каких директориях искать МОДУЛИ Python
 Если нужно импортировать из не стандартных директорий.
 Довольно часто используются с PyTorch.
 PyTorch - это библиотека машинного обучения. 1) Динамические вычисления. 2) Автоматическое дифференцирование.
 Дифференциация (от лат. differentia — «различие») - разделение, разведение процессов или явлений на составляющие части.

 Динамические вычисления. PyTorch динамически пересчитывает граф вычислений «на лету», и это удобно.

 Автоматическое дифференцирование. Дифференцированием называют нахождение производной функции. Это математическая операция,
 важная для машинного обучения — с помощью дифференцирования как раз пересчитывают веса. Так работает алгоритм обратного
 распространения ошибки, ключевой в обучении нейронных сетей.

 PyTorch поддерживает автоматическое дифференцирование. Совместно с динамическими вычислениями выходит так, что фреймворк
 строит граф и вычисляет веса «на лету», а человеку достаточно написать пару строк кода. Это удобно и позволяет реализовать
 более сложные проекты.


 ЭКСТРАПОЛЯЦИЯ и ИНТЕРПОЛЯЦИЯ — это методы прогнозирования и оценки значений функций или данных.

 1. **Интерполяция** - это процесс оценки значений функции на основе известных данных в пределах заданного диапазона.
 Например, если у вас есть набор точек, интерполяция позволяет определить значения между этими точками.

 2. **Экстраполяция** - это метод предсказания значений функции за пределами известных данных. Это более рискованная
 операция, так как предполагает, что тенденции, наблюдаемые в имеющихся данных, будут продолжаться и за их пределами.

 В итоге, ИНТЕРПОЛЯЦИЯ работает внутри диапазона данных, а ЭКСТРАПОЛЯЦИЯ — за его пределами.


 Модуль struct
 struct .Struct — сериализованные С-структуры
 Выполняет преобразования между значениями Python и структурами языка C, представленными в виде байтовых объектов Python.
 Это может быть использовано при обработке двоичных данных, хранящихся в файлах, из сетевых подключений или среди других
 источников. Модуль использует формат строки в качестве компактного описания структур языка C и предполагаемого
 преобразования в/из значений Python.

 REPL (Read–eval–print loop)  - Цикл «чтение—вычисление—вывод» - Read(Чтение) Evaluate(Оценка) Print(Печать) Loop(Цикл)
 также называемый интерактивной оболочкой верхнего уровня или языковой оболочкой
 Python поставляется со встроенным REPL – это программа, которая работает как командная оболочка. Программу REPL еще
 называют интерактивным интерпретатором Python. Эта программа предназначена для ввода и выполнения кода на языке Python.

 REPL, или Read-Evaluate-Print Loop, - это способ прямого взаимодействия с интерпретатором Python. Он называется REPL,
 поскольку считывает, оценивает и печатает вводимые данные, а затем возвращается к началу цикла, позволяя ввести другую команду.

 Он предоставляет интерфейс через оболочку Python Shell для ввода кода и немедленного получения результата. Это позволяет
 проверять код, отлаживать его в режиме реального времени и создавать интерактивные тесты. Как правило, вы поймете,
 что имеете дело с Python REPL, как только увидите эти три стрелки: >>>   Пример Python Console
 Строки с >>> — это код, введенный программистом. Сам символ >>> называется приглашением
 Строки без >>> — это результат выполнения введенного кода
 Пример: >>> 1 + 2      >>> len("Thomas")
         3              6

 Термины "оболочка Python" и "интерпретатор Python" иногда используются как взаимозаменяемые, однако между ними
 существует тонкая разница. Под интерпретатором Python понимается собственно программа или программное обеспечение,
 выполняющее код Python. Оболочка же Python Shell - это интерфейс, позволяющий взаимодействовать с интерпретатором
 в режиме реального времени.

 IDLE — редактор, поставляемый вместе с Python. Это базовый, упрощенный режим программирования на Python.
 Существует много IDE (Integrated Development Environment) - PyCharm, Jupyter Notebook, Visual Studio Code...
 IDE отличается от обычного редактора именно тем, что предоставляет более расширенный набор опций, предоставляют
 возможность создавать крупные проекты.

 Буквально не существует другого способа выполнить часть кода Python, кроме как преобразовать его в байт-код и затем
 выполнить виртуальной машиной Python.

 -- Консоль Python и с чем её едят
 1. Не путаем консоль/терминал нашей ОС и консоль питона!
 2. Не забываем про отступы
 3. Ошибки SyntaxError и IndentationError почти всегда связаны с прослойкой между креслом и клавиатурой,
 обращаться с ними на форум или чат - позор! (как спросить что не так в слове "чящя")
 4. Не используйте имена, совпадающие с названием структур данных, функций, библиотек (len, list, dict, string и т.п)
 5. Всегда читаем ошибку, стараемся понять что именно нам говорит интерпретатор, много думаем.
 6. Используем атрибуты с подчеркиванием на свой страх и риск (не рекомендуется)
 7. Нужно прочесть и соблюдать Дзен Питона



 dir - вернет список всех атрибутов объекта (в пайтон все является объектом)
 help - вернет документацию, если она есть
 _ - ссылка на результат последнего вычисления/выражения
 import this - получить дзен и просветление
 [e for e in dir(str) if '_' not in e] - получить все атрибуты без подчеркиваний
 python -i module.py - запустить интерпретатор с загруженным модулем
 builtins - встроенные функции
 keyword.kwlist  - ключевые слова

 --- Мутанты Python ---
 Cython - Python+C/C++(Cтатическая типизация) статически компилируемый, ускоряющий выполнение кода на языке Python
 Из-за этих явных указаний типов в переменной и происходит ускорение кода

 Cython позволяет разработчикам оптимизировать код Python, используя функциональность языка C и библиотек CPython

 IronPython — одна из основных реализаций языка Python, предназначенная для платформы Microsoft .NET
 .NET - Современная разработка может проходить на нескольких языках одновременно.

 CPython является интерпретатором байт-кода, написан на C
 CPython написан на языке C, отсюда и его название
 для CPython id(x)— это адрес памяти, в которой x хранится.
 id(x) В CPython это указатель на объект PyObject представляющий объект в интерпретаторе, и это то же самое, что и object.__repr__

 Обратите внимание: если вы пишете расширение C, у вас есть полный доступ ко внутреннему устройству интерпретатора Python,
 включая прямой доступ к адресам объектов.

 Как узнать, какой интерпретатор Python я использую
 import platform
 platform.python_implementation()


 Байт код — это промежуточный язык программирования, предназначенный для исполнения виртуальной машиной.
 Он получается в результате компиляции исходного кода программы и представляет собой последовательность инструкций,
 записанных в виде байтовых кодов.
 байт-код представляет собой машинно-независимый код низкого уровня, генерируемый транслятором из исходного кода
 байт-код для облегчения и ускорения работы интерпретатора
 Виртуальная машина Python — это виртуальная машина на основе стека , поэтому значения операций и результаты операций находятся в стеке.

 Компиляция в байт-код CPython проходит только через небольшой (Peephole Optimizer) оптимизатор-глазок , предназначенный
 для выполнения только базовых оптимизаций .

 В Python 3.7 свертывание констант было перенесено из оптимизатора глазка в новый оптимизатор AST с некоторыми изменениями в логике
 Peephole Optimizer(оптимизатор-глазок) - который не может выполнять оценку более высокого уровня, а просто перезаписывает байт-код
 оптимизатор AST (Абстрактное синтаксическое дерево) - который может выполнять оптимизацию более последовательно.

 Чтобы посмотреть, что на самом деле произойдет, используйте dis*, чтобы просмотреть сгенерированные инструкции.
 1) Для первой функции, содержащей присвоение:                2) А для второй функции:
 from dis import dis                                          import dis
 def func():                                                  def func2():
    a = 42                                                        return 42
    return a
 dis(func)                                                    dis.dis(func2)

 2    0 LOAD_CONST     1 (42)                                 2    0 LOAD_CONST     1 (42)
      2 STORE_FAST     0 (a)                                       2 RETURN_VALUE

 3    4 LOAD_FAST      0 (a)
      6 RETURN_VALUE
 В первой используются еще две (быстрые) инструкции: STORE_FAST и LOAD_FAST. Они позволяют быстро сохранить и получить
 значение в fastlocals массиве текущего кадра выполнения. Затем в обоих случаях RETURN_VALUE выполняется а.
 Итак, второй немного быстрее из-за меньшего количества команд, необходимых для выполнения.


 Что касается того, как стек и куча сосуществуют вместе, теперь должно быть ясно: виртуальная машина и стек размещаются
 в памяти кучи. Использование LOAD_FAST помещает объект на вершину стека с точки зрения виртуальной машины
 и та же самая инструкция помещает объект в кучу с точки зрения ОС .

 Начиная с Python 3.7, dis.dis дизассемблирует функции и делает это рекурсивно.
 dis — Дизассемблер для байт-кода Python, dis — Disassembler for Python bytecode
 Вы можете использовать встроенный модуль dis, чтобы заглянуть за кулисы и проинспектировать байткод.

 def f(num):
    if num == 42:
        return True
    return False

 import dis
 dis.dis(f)

 (1)|(2)|(3)|(4)|          (5)         |(6)|  (7)
 ---|---|---|---|----------------------|---|-------
   2|   |   |  0|LOAD_FAST             |  0|(num)
    |-->|   |  2|LOAD_CONST            |  1|(42)
    |   |   |  4|COMPARE_OP            |  2|(==)
    |   |   |  6|POP_JUMP_IF_FALSE     | 12|
    |   |   |   |                      |   |
   3|   |   |  8|LOAD_CONST            |  2|(True)
    |   |   | 10|RETURN_VALUE          |   |
    |   |   |   |                      |   |
   4|   |>> | 12|LOAD_CONST            |  3|(False)
    |   |   | 14|RETURN_VALUE          |   |

 Каждый столбец имеет определенное назначение:
 1. Соответствующий номер строки в исходном коде
 2. Необязательно указывает текущую выполненную инструкцию ( например, когда байт-код поступает из объекта кадра )
 3. Метка, обозначающая возможность перехода JUMPот предыдущей инструкции к этой.
 4.  Адрес в байт-коде, который соответствует индексу байта (он кратен 2, поскольку Python 3.6 использует 2 байта для
 каждой инструкции, хотя в предыдущих версиях он мог отличаться )
 5. Имя инструкции (также называемое opname ), каждая из них кратко объясняется в модуле dis , а их реализацию можно
 найти в ceval.c(основном цикле CPython).
 6. Аргумент (если есть) инструкции , который используется Python внутри для извлечения некоторых констант или переменных,
 управления стеком, перехода к определенной инструкции и т. д.
 7. Удобная для человека интерпретация аргумента инструкции

 СPython исполняет программы, сначала транслируя их в промежуточный байткод, а затем выполняя байткод на
 виртуальной машине со стековой архитектурой.

 кэшируется на диске в файлах .pyc и .pyo, чтобы во второй раз исполнение того же самого файла Python проходило быстрее.

 Python компилирует исходный код в байт-код для внутреннего использования, который затем интерпретируется
 виртуальной машиной Python. Этот байт-код сохраняется в .pyc файлах.

 __pycache__ — это папка, содержащая скомпилированный и готовый к выполнению байт-код (в *.pyc файлах)
 Когда вы запускаете программу на Python, интерпретатор сначала компилирует ее в байт-код и сохраняет в папке __pycache__.


 Стек является структурой данных, которая используется в качестве внутренней рабочей памяти виртуальной машины.
 Существуют разные классы виртуальных машин, и один из них называется стековой машиной. Виртуальная машина Python
 является реализацией такой стековой машины.

 На минимальном уровне она поддерживает всего две операции: вталкивание (push) и выталкивание (pop).
 Вталкивание добавляет значение на вершину стека, а выталкивание удаляет и возвращает самое верхнее значение.
 В отличие от массива, в стеке отсутствует способ получить доступ к элементам «ниже» верхнего уровня.

 Python является интерпретируемым языком, он использует компиляцию в байт-код для увеличения эффективности своего выполнения.

 Исходный код Python компилируется в байт-код — внутреннее представление программы Python в интерпретаторе CPython.
 Байт-код также кэшируется в .pyc  файлах, чтобы второй раз выполнить тот же файл быстрее          <-----

 Вкратце, байт тип — это такая последовательность данных, которая уже готова тут же для сохранения в память.

 Машинный код – это низкоуровневый язык программирования, который понимает компьютер
 Байт код прослойка между Машинным кодом и языком программирования

 # Пример из книги High Performance Python
 # Большее количество строк байт-кода будет выполнятся медленнее, чем меньшее количество эквивалентных строк байт-кода
 def fn_expressive(upper=1_000_000):
     total = 0
     for n in range(upper):
         total += n
     return total

 # функция sum оптимизирована для таких операций                                                        <-----
 def fn_terse(upper=1_000_000):
     return sum(range(upper))

 # Замеряем время выполнения
 expressive_time = timeit.timeit('fn_expressive()', globals=globals(), number=100)
 terse_time = timeit.timeit('fn_terse()', globals=globals(), number=100)

 print(f'fn_expressive: {expressive_time:.3f} секунд')  # -> fn_expressive: 6.497 секунд
 print(f'fn_terse:      {terse_time:.3f} секунд')       # -> fn_terse:      4.697 секунд


 PyPy – использует Just-In-Time (JIT) компилятор - обходит GIL для ускорения кода Python
 PyPy для ускорения и оптимизации работы кода Python
 Сборщик мусора PyPy по умолчанию называется incminimark это инкрементальный сборщик мусора с перемещением поколений.
 JIT (Just-In-Time) компилятор – это инструмент, который компилирует код Python в машинный код «на лету», во время выполнения программы.

 Jython (Python для Java),  IronPython (Python для .NET)

 В CPython используется механизм сборки мусора на основе счётчиков ссылок, который сразу освобождает память,
 как только объект становится недоступным. В PyPy используется алгоритм "Mark and Sweep", который работает реже и может
 удалять неиспользуемые объекты позже, что позволяет более эффективно управлять памятью в долгосрочных запусках программы.


 Параметры — это значения, которые принимает функция при создании.   где значения всегда является ссылкой на объект
 Аргументы – это конкретные значения, которые передаются в функцию при её вызове в программе
 Формальные параметры — это имена аргументов функции, за которыми могут скрываться произвольные значения
 Фактические параметры — это конкретные значения, которые связываются с формальными параметрами при вызове функции

 Википедия:
 Формальный параметр — аргумент, указываемый при объявлении или определении функции
 Фактический параметр — аргумент, передаваемый в функцию при её вызове

 Следует иметь в виду, что встречается иная терминология. Например, формальные параметры и фактические параметры.
 В Python же обычно все называют аргументами. Параметры и Аргументы

 Функции могут не только возвращать данные, но также принимают их, что реализуется с помощью так называемых параметров,
 которые указываются в скобках в заголовке функции.
 Параметры (аргументы) функции передаются в локальную область видимости с использованием вызова по значению,
 где значение всегда является ссылкой на объект, а не значением объекта.

 def foo(a, b=5):    # a - ФОРМАЛЬНЫЙ ПАРАМЕТР  # b - ФОРМАЛЬНЫЙ ПАРАМЕТР  # Параметры или Формальные параметры
     return

 foo(4, b=2   ,   )  # 4 - ПОЗИЦИОННЫЙ АРГУМЕНТ  2 - ИМЕНОВАННЫЙ АРГУМЕНТ  # Аргументы или Фактические параметры

 При вызове функции может присутствовать необязательная конечная запятая после позиционных и ключевых аргументов,
 что не влияет на семантику.
 Семантика — это соответствие между синтаксически правильными программами, то есть это смысл синтаксических конструкций.
 ПОЗИЦИОННЫЕ ВСЕГДА ИДУТ РАНЬШЕ KEYWORD(ИМЕНОВАННЫХ)

 Посмотри примеры ПРОЧИТАЙ ОШИБКИ и ВНИМАНИЕ НА ЗАПЯТЫЕ , их можно так использовать:
 def foo(a, b=5  ,  ):                                         def foo(b=5, a   ,  ):  # <-----
     return                                                        return
 foo(b=2, 4   ,   )   # <----                                  foo(4, b=2   ,   )
 # SyntaxError: positional argument follows keyword argument   # SyntaxError: non-default argument follows default argument



 -- Это происходит из-за того, что определения функций загружаются в память при интерпретации всего модуля, и функции
    становятся доступными для вызова в любом месте, даже до их определения в коде. --

 #  Функция f1 видит f2, потому что Python загружает все определения функций при интерпретации модуля, независимо
 # от их порядка. Поэтому вызов f2() в f1() работает, даже если f2 определена ниже.                               <-----

 # Тоже самое            # Тоже самое  # ПОМЕНЯЛИ ФУНКЦИИ МЕСТАМИ  # Классы должны быть определены ПЕРЕД использованием
 def f1():               def f2():                                 class F1(F):
     return f2()             return 'hehe'                             pass

 def f2():               def f1():                                 class F:
     return 'hehe'           return f2()                               pass

 print(f1())  # -> hehe  print(f1())  # -> hehe                    F1()  # Ошибка: NameError: name 'F' is not defined

 # В Python функции могут быть вызваны до их определения, поскольку интерпретатор загружает все определения функций
 в память при выполнении модуля. Поэтому, когда вы вызываете f1(), интерпретатор уже знает о существовании f2(), даже
 если она определена ниже в коде. Это позволяет функции f1() корректно вызывать f2() и возвращать её результат.   <-----



 --- Что происходит в момент вызова функции? ---
 Если в функцию при вызове передаются ключевые аргументы, то они сначала преобразуются в позиционные аргументы, затем
 создается список незаполненных слотов для формальных параметров/аргументов (которые определялись при написании кода функции).

 Когда все аргументы обработаны, начинается заполнение оставшихся пустых слотов соответствующим значением по умолчанию
 из определения функции.


 ВАЖНО!!!      Значения по умолчанию вычисляются один раз при определении функции!
 Обратите внимание, на то, что изменяемый объект используемый в качестве значения по умолчанию, будет использоваться всеми вызовами
 Изменяемые объекты как значения по умолчанию: потенциально не безопасно, так как их состояние сохраняется между вызовами функции.

 Значения по умолчанию вычисляются в точке выполнения инструкции def, а не в точке ее вызова, так что:
 i = 5
 def f(arg=i):        # точка вызова инструкции def
     print(arg)
 i = 6
 print(i) # -> 6      # точка выполнения инструкции def     Значения по умолчанию вычисляются тут!

 Аргументы по умолчанию в функциях:
 Пример с list(список)                 Пример с set(множество)               Пример с dict(словарь)
 def f(a, L=[]):                       def f(a, L=set()):                    def f(key, value, L={}):
     L.append(a)                             L.add(a)                              L[key] = value
     return L                                return L                              return L
 print(f.__defaults__) # -> ([],)      print(f.__defaults__) # -> (set(),)   print(f.__defaults__) # -> ({},)
 print(f(1))           # -> [1]        print(f(1))           # -> {1}        print(f(1, 'A'))      # -> {1: 'A'}
 print(f.__defaults__) # -> ([1],)     print(f.__defaults__) # -> ({1},)     print(f.__defaults__) # -> ({1: 'A'},)
 print(f(2))           # -> [1, 2]     print(f(2))           # -> {1, 2}     print(f(2, 'B'))      # -> {1: 'A', 2: 'B'}
 print(f.__defaults__) # -> ([1, 2],)  print(f.__defaults__) # -> ({1, 2},)  print(f.__defaults__) # -> ({1: 'A', 2: 'B'},)

 Способ обойти это - использовать None по умолчанию и явно проверить его в теле функции:

 def f(a, L=None):                    def f(a, L=None):                       def f(key, value, L=None):
     if L is None:                        if L is None:                           if L is None:
         L = []                               L = set()                               L = {}
     L.append(a)                          L.add(a)                                L[key] = value
     return L                             return L                                return L
 print(f.__defaults__) # -> (None,)   print(f.__defaults__) # -> (None,)      print(f.__defaults__) # -> (None,)
 print(f(1))           # -> [1]       print(f(1))           # -> {1}          print(f(1, 'A'))      # -> {1: 'A'}
 print(f.__defaults__) # -> (None,)   print(f.__defaults__) # -> (None,)      print(f.__defaults__) # -> (None,)
 print(f(2))           # -> [2]       print(f(2))           # -> {2}          print(f(2, 'B'))      # -> {2: 'B'}
 print(f.__defaults__) # -> (None,)   print(f.__defaults__) # -> (None,)      print(f.__defaults__) # -> (None,)

 С помощью id легко убедиться, что вы всегда будете иметь дело с одним и тем же объектом по умолчанию при вызове функции.

 # Так будет работать со всеми изменяемымы обьектами set() dict() list()

 def append_to_list(value, my_list = []):                def add_to_dict(key, value, my_dict={}):
     my_list.append(value)                                   my_dict[key] = value
     print(my_list, id(my_list))                             print(my_dict, id(my_dict))

 # Одинаковые id                                         # Одинаковые id
 append_to_list(10)  # -> [10]          2131360334720    add_to_dict(1, 10)  # -> {1: 10}                1781083624832
 append_to_list(25)  # -> [10, 25]      2131360334720    add_to_dict(2, 20)  # -> {1: 10, 2: 20}         1781083624832
 append_to_list(37)  # -> [10, 25, 37]  2131360334720    add_to_dict(3, 30)  # -> {1: 10, 2: 20, 3: 30}  1781083624832


 -- Mutable defaults --
 У меня горит! Нельзя просто взять и задать, скажем, пустой список как значение по умолчанию для аргумента:

 def foo(items: list[str] = []):
    items.append(1)
    print(items)

 foo()  # [1]
 foo()  # [1, 1]
 foo()  # [1, 1, 1]

 Значение по умолчанию создаётся в единственном экземпляре, так что если вы планируете модифицировать аргумент,
 то добро пожаловать в паттерн "я хочу mutable default":

 def foo(items: list[str] | None = None):
     items = items or []  # или if items is None: items = []
     items.append(1)
     print(items)

 foo()  # [1]
 foo()  # [1]
 foo()  # [1]

 В датаклассах это выглядит ещё ужаснее, только взгляните:

 from dataclasses import dataclass, field

 @dataclass
 class Foo:
     items: list[str] = field(default_factory=list)  # <-- и всё это - чтобы по умолчанию был пустой список

 Сравните это с пидантиком (Pydantic), в котором, кажется, думают о людях:

 from pydantic import BaseModel

 class Foo(BaseModel):
     items: list[str] = []

 Недавно я осознал, что если функция "чистая", то есть не модифицирует входные аргументы, то такой код абсолютно нормальный:

 def foo(var: int, checks: list[Callable] = []):
    for check in checks:
        check(var)

 Но есть несколько "но":
 - Линтеру это может не понравиться
 - Кто-нибудь решит, что ему хочется изменять список в момент выполнения функции, и всё сломается
 - Другой разраб может это увидеть и не понять, прям как в меме

 Нет const
 Проблемы выше не было бы, если бы был const, который бы говорил: вот эту штуку изменять нельзя.
 Но в питоне так не принято. В питоне кто угодно может изменять что угодно когда угодно.

 -- Аргументы --
 Я люблю, когда аргументы задают по имени:

 call(me='maybe')   Сразу понятно, что, кого и как.
 Я также не против позиционных аргументов, когда это просто, ну например:  max([1, 2, 3, 4, 5])

 Но в целом именные аргументы (kwargs) всегда лучше позиционных (args):
 - При рефакторинге ничего не поломается: я могу менять местами и добавлять аргументы, и всё будет работать
 - Лучше читается, даже если вы называете ваши переменные как гоблин: сравните
 display(hehe, trololo) vs display(num_per_page=hehehe, items=trololo) - всё равно второй вариант понятнее

 Но теперь в питоне придумали * и /, чтобы запретить юзать args или kwargs!

 lst = [{'name': 'Bob'}, {'name': 'Alice'}]

 lst.sort(itemgetter('name'))  # TypeError: sort() takes no positional arguments
 lst.sort(key=itemgetter('name'))  # works

 sorted(lst, itemgetter('name'))  # TypeError: sorted expected 1 argument, got 2
 sorted(lst, key=itemgetter('name'))  # works
 sorted(iterable=lst, key=itemgetter('name'))  # TypeError: sorted expected 1 argument, got 0

 list(map(str.upper, 'abc'))  # works
 list(map(function=str.upper, iterable='abc'))  # TypeError: map() takes no keyword arguments

 open('docker-compose.yml')  # works
 open(file='docker-compose.yml')  # works

 Я не понимаю, почему где-то мне можно использовать имена аргументов, а где-то нельзя, и почему в разных случаях
 по-разному. Можно, пожалуйста, я буду писать так, как считаю нужным?

 -- Аргументы по умолчанию в функциях. --
 1) значение аргументу по умолчанию присваивается один раз при интерпретации кода. Только 1 раз! Сколько бы мы ни
 вызывали функцию, она будет использовать ссылку на один и тот же объект.
 2) в аргументах по умолчанию используем только неизменяемые типы, например строки, числа, None
 3) если по логике нашей функции все же нужен изменяемый тип (список, сет, словарь, объект нашего класса),
 то в аргументе приравниваем к None, а уже внутри функции прописываем логику.

 Атомарные операции — операции, выполняющиеся как единое целое либо не выполняющиеся вовсе
 Атомарная операция - одно действие
 не атомарная операция - два действия и более

 --- Что за звери *args и **kwargs ---
 1) args и kwargs в параметрах функции - общепринятые имена, но можно использовать и другие
 2) * позволяет распаковать iterable/sequence, а ** распакуют словарь
 2) Итерируемый объект (iterable) - это объект, который способен возвращать элементы по одному
 2) Кроме того, это объект, из которого можно получить итератор. Примеры итерируемых объектов:
 все последовательности: список, строка, кортеж
 2) Таким образом, получается, что итерируемый объект это любой объект который реализует метод __iter__
 2) Последовательность (sequence) - это итерируемый объект, к элементам которого можно обратиться по целочисленному
 индексу, а также можно узнать общее количество элементов (длину последовательности)
 2) Последовательность (sequence) - можно вызвать метод __getitem__() и __len__() ---> list, tuple, range, str и bytes.
 3) если нет никаких спецсимволов, то аргументы функции можно передавать как позиционно, так и keyword (то есть ключ=значение).
 Важно помнить, что позиционные всегда идут раньше keyword(именованных),
 при этом keyword аргументы между собой не обязаны хранить порядок.
 4) спецсимвол / в параметрах функции говорит, что все, что ДО него должно передаваться как позиционные аргументы
 5) спецсимвол * (без указания переменной), говорит о том что все, что ПОСЛЕ него должно передаваться как keyword аргумент
 6) *args в параметрах функции соберет все позиционные аргументы в кортеж (tuple)
 7) **kwargs в параметрах функции соберет все keyword (именованные) аргументы в словарь (dict)


 # Интересный момент   Можно НЕ передавать аргументы при вызове функции
 def ff(*args, **kwargs):          def ff(*args, **kwargs):       def ff(*args, **kwargs):      def ff(*args, **kwargs):
     return args, kwargs               pass                           return args                   return kwargs

 print(ff())  # -> ((), {})        print(ff())   # -> None        print(ff())  # -> ()          print(ff())  # -> {}


 # В вызовах функций можно использовать * НЕСКОЛЬКО РАЗ      Оператор *
 def fun(a, b, c, d, *rest):
     return a, b, c, d, rest

 print(fun(*[1, 2], 3, *range(4, 7)))     # -> (1, 2, 3, 4, (5, 6))
 print(fun(*[1, 2], *[3, 4], *range(2)))  # -> (1, 2, 3, 4, (0, 1))


 # В вызовах функций можно использовать ** НЕСКОЛЬКО РАЗ     Оператор **
 def fun(a, b, c, d, **rest):
     return a, b, c, d, rest

 print(fun(*[1, 2, 3, 4], **{'2': '2'}, **{'1': '2'}))  # -> (1, 2, 3, 4, {'2': '2', '1': '2'})


 # Можно использовать много раз ** если ключи НЕ повторяются и КЛЮЧИ = СТРОКИ    Работает так в функциях
 def fun(**kwargs):
     return kwargs

 print(fun(**{'x': 1}, y=2, **{'z': 2}))  # -> {'x': 1, 'y': 2, 'z': 2}
 print(fun(**{'x': 1}, y=2))              # -> {'x': 1, 'y': 2}
 print(fun(**{'x': 1}, y=2, **{1: 2}))    # -> TypeError: keywords must be strings

 # Пример без функции МОЖНО ЛЮБЫЕ КЛЮЧИ ИСПОЛЬЗОВАТЬ
 print({**{'x': 1}, 1: 2, **{1: 2}})  # -> {'x': 1, 1: 2}


    Оператор is Оператор  ==
 оператор is сравнивает ссылку (не содержимое обьекта)
 == проверяет содержимое обьекта

 Оператор == используется для сравнения значений двух переменных
 Оператор is используется для проверки, являются ли две переменные одним и тем же объектом

 a = 1000                       a = []
 b = 500                        b = []
 c = b + 500                    print(a is b)  # -> False
 print(a is c) # -> False       print(a == b)  # -> True
 print(a == c) # -> True

 is вернет результат True, если две переменные указывают на один и тот же объект (в памяти),
 == если объекты, на которые ссылаются переменные, равны.

 Заметным исключением является nan:
 NaN НЕ равен ничему, в том числе и самому себе.
 a = 10
 nan = float('nan')
 print(nan is nan)   # -> True
 print(a is a)       # -> True
 print(nan == nan)   # -> False   <---- !!!!!
 print(a == a)       # -> True
 'a' is 1            # -> Работает при ошибке SyntaxWarning: "is" with a literal. Did you mean "=="?


 # Пример l2 = list(l1)    Объекты РАЗНЫЕ                       # Пример l2 = l1    Объекты ОДИНАКОВЫЕ
 l1 = [3, [55, 44], (7, 8, 9)]                                  l1 = [3, [55, 44], (7, 8, 9)]
 l2 = list(l1)                                                  l2 = l1
 print(l2 == l1)   # -> True                                    print(l2 == l1)   # -> True
 print(l2 is l1)   # -> False                                   print(l2 is l1)   # -> True

 # Ссылки внутри ОДИНАКОВЫЕ                                     # Ссылки внутри ОДИНАКОВЫЕ
 print(id(l1[1]), id(l1[2]))  # -> 2018437580864 2017853012992  print(id(l1[1]), id(l1[2]))  # -> 3024612180992 3024027483136
 print(id(l2[1]), id(l2[2]))  # -> 2018437580864 2017853012992  print(id(l2[1]), id(l2[2]))  # -> 3024612180992 3024027483136

 # Объекты РАЗНЫЕ                                               # Объекты ОДИНАКОВЫЕ
 print(id(l1), id(l2))        # -> 2018437200960 2018418215616  print(id(l1), id(l2))        # -> 3024611801216 3024611801216


 # Интересный пример
 a = {'A': 1}
 c = a
 print(c is a)       # -> True

 c['B'] = 2
 print(a)            # {'A': 1, 'B': 2}
 b = {'A': 1, 'B': 2}
 print(b == c)       # -> True                   # Тоже самое
 print(b.__eq__(c))  # -> True                   # Тоже самое
 print(b is c)       # -> False
 print(b is not c)   # -> True

 # is Работает быстрее чем == потому что его НЕвозможно перегрузить  Интерпретатор НЕ ищет и НЕ вызывает   Спец. методы
 #    ==  синтаксический сахар метода __eq__()      a.__eq__(b)

 res = [1, 2]
 res.append(3)

 res_2 = [1, 2, 3]
 print(res, res_2)         # -> [1, 2, 3] [1, 2, 3]
 print(res == res_2)       # -> True
 print(res.__eq__(res_2))  # -> True
 print(res is res_2)       # -> False


 Скорость   ==,    is,    in   Объяснение почему in быстрее ==      Why is 'x' in ('x',) faster than 'x' == 'x'?
 Проверка is может быть гораздо более быстрой, чем проверка на == (которая может потребовать рекурсивной проверки членов).

 from timeit import timeit
 a = 10
 timeit('a == a', 'from __main__ import a')  # -> 0.04304959997534752
 timeit('a is a', 'from __main__ import a')  # -> 0.02880209987051785

 timeit("'x' in ('x',)")  # -> 0.030266999965533614
 timeit("'x' == 'x'")     # -> 0.04658919991925359

 Как работают  in ,  ==
 Оба метода отправляются в is; вы можете доказать это, сделав
 from timeit import Timer

 print(min(Timer("x == x", setup="x = 'a' * 1000000").repeat(10, 10000)))
 # 0.00045456900261342525

 print(min(Timer("x == y", setup="x = 'a' * 1000000; y = 'a' * 1000000").repeat(10, 10000)))
 # 0.5256857610074803

 TL;DR: - too long; didn't read (слишком долго; не читал):

 Оба (in, ==) отправляются в if (left_pointer == right_pointer); разница лишь в том, сколько работы они прикладывают,
 чтобы достичь этой цели. in просто делает меньше.

 Реализации контейнеров иногда требуют дополнения тестов на равенство тестами на идентичность. Это предотвращает
 путаницу в коде из-за объектов, float('NaN') не равных самим себе.
 Например, вот реализация collections.abc.Sequence.__contains__():
 def __contains__(self, value):
    for v in self:
        if v is value or v == value:
            return True
    return False

 В большинстве других случаев тесты на идентичность(is) нежелательны, а тесты на равенство(==) предпочтительнее.

 -- Модуль ctypes в Python, интеграция с языком C , Использование функции, написанных на языке C в коде Python
 ctypes позволяет создавать указатели вызываемых C-функций из вызываемых объектов Python.
 Иногда их называют функциями обратного вызова.
 from ctypes import *

 ctypes — это внешняя библиотека функций для Python. Он предоставляет типы данных, совместимые с C, и позволяет
 вызывать функции в DLL или общих библиотеках. Его можно использовать для обертывания этих библиотек в чистый Python.

 DLL — это библиотека, содержащая код и данные, которые могут использоваться несколькими программами одновременно.

 DLL — Dynamic Link Library — динамическая подключаемая библиотека в операционной системе (ОС) Windows. Динамические библиотеки
 позволяют сделать архитектуру более модульной, уменьшить количество используемых ресурсов и упрощают модификацию системы.

 Kernel - ядро операционной системы. Оно есть не только в Windows но и вообще в любой ОС. Это самая важная программа
 системы. Вернее не одна программа, а целая куча. И они всегда находятся в памяти, когда система работает. Программы
 обычно предназначены для ввода-вывода. Все прочие приложения обращаются к ядру для этой цели. Вот нажали вы клавишу,
 и на экране появилась буква. Как она туда попала? Это компьютер связался с ядром, ядро прочитало клавиатуру и послало на экран символ.


 --- Коллбэки – Callback-функции в Python ---
 callback - Подпрограмма, которая передается в качестве аргумента для выполнения в какой-то момент в будущем.

 Коллбэк — это функция, которая передаётся на вход другой функции (или другому участку кода), чтобы её запустили
 в ответ на какое-то событие. С помощью этого приёма работают чатботы и интерактивные веб-странички: пользователь
 нажимает на кнопку, его действие генерирует событие и на событие реагирует коллбек (функция-обработчик).

 Функция обратного вызова передается как аргумент для другой функции, которая будет вызывать callback функцию каждый раз
 в своем определении. Обычно такие операции выполняются с асинхронными функциями.

 callbacks function - map(), filter(), functools.reduce(), functools.partial(), apply_async() ...

 Пример 1:
 def callback_function():
     print("Я коллбэк")

 callback = callback_function

 callback() # Я коллбэк

 Пример 2:
 def double_map(func, iter):
   my_map = map(func, iter)
   return list(my_map)

 def double(element):
   return element*2

 nums = [1,2,3,4]

 print(double_map(double, nums))  # [2, 4, 6, 8]

 ХОРОШАЯ ФУНКЦИЯ:
 - имеет читаемое название, нужную информацию получает в аргументах
 - короткая/читаемая
 - возвращает результат (NO PRINT!)
 - независима (NO GLOBAL!!!), и не меняет ничего вне себя
 - умеет делать что-то одно, но умеет это хорошо и знает все для этого
 - если меняет пришедший аргумент, то возвращает None
 - Тестируема!

 Отличие функции от метода:
 Метод — это функция определенная внутри тела класса.

 Методы отличаются от обычных функций только тем, что экземпляр объекта (self) добавляется к другим аргументам.

 Функции Python — это объекты первого класса
 Функции Python — это Дескрипторы.

 # Пример
 def func():
     '''my func'''

 print(type(func))            # -> <class 'function'>

 # Если вызывать через ЭК  будет метод.  Если через Класс функция                                                <-----
 class Func:
     def class_fun(self):
         '''my func'''

 f = Func()
 print(type(Func.class_fun))  # -> <class 'function'>                                                          # <-----
 print(type(f.class_fun))     # -> <class 'method'>                                                            # <-----
 Благодаря протоколу дескрипторов присоединенная к классу функция становиться методом при обращении через ЭК     <-----


 Любой тип данных (int, list, str, tuple и т.д.) является примером объекта первого класса в python.
 Объект называют «объектом первого класса» (first-class object, first-class entity, first-class citizen) если:
 - С ним можно работать как с переменными
 - Он может быть передан в функцию как аргумент
 - Он может быть возвращен из функции как результат
 - Он может быть включен в другие структуры данных. Например, быть элементом словаря или списка

 Функции как объекты первого класса:
 - можете использовать функции в качестве аргументов других функций
 - сохранять функции как значения словаря или возвращать функцию из другой функции

 Функции Python относятся к объектам первого класса. Их можно присваивать переменным, хранить их в структурах данных,
 передавать их в качестве аргументов другим функциям и даже возвращать их в качестве значений из других функций.

 def yell(text):
    return text.upper() + '!'

 yell('привет') -> 'ПРИВЕТ!'

 Все данные в программе Python представляются объектами или связями между объектами.
 Символьные последовательности (строки), списки, модули и функции — все эти явления языка представляют собой объекты.
 Что касается функций, то в Python они ничем не отличаются. Они — тоже объекты.

 bark = yell
 bark('гав') -> 'ГАВ!'

 Объекты-функции и их имена — это две отдельные компетенции.

 del yell
 yell('Привет?') -> NameError: name 'yell' is not defined
 bark('эй')      -> ЭЙ!'
 bark.__name__   -> yell

 Функции могут храниться в структурах данных
 funcs = [bark, str.lower, str.capitalize]
 for f in funcs:
     print(f, f('всем привет'))

 funcs[0]('приветище') -> 'ПРИВЕТИЩЕ!'

 Объекты могут вести себя как функции: -> нужен метод __call__
 Безусловно, не все объекты будут вызываемыми: -> Проверить можно функцией callable()

 # Интересный пример  __call__                                                                      <-----
 def turtle():
     print('eggs')

 turtle()                             # -> eggs
 turtle.__call__()                    # -> eggs
 turtle.__call__.__call__()           # -> eggs
 turtle.__call__.__call__.__call__()  # -> eggs


 Можно ли передавать функцию в качестве аргумента другой функции?
 - Можно, функция в Питоне объект первого порядка: допускает ПРИСВАИВАНИЕ, ПЕРЕДАЧУ В ФУНКЦИЮ, УДАЛЕНИЕ.

 Можно ли объявлять функцию внутри другой функции. Где она будет видна?
 - Можно. Такая функция будет видна только внутри первой функции.

 Функции высшего порядка — это функции, которые принимают другие функции в качестве аргументов или возвращают функции как результат
 В Python встроены несколько функций высшего порядка, таких как - map(), filter(), reduce(), decorator

 key function Ключевая функция или функция сопоставления - это вызываемый объект, который возвращает значение,
 используемое для сортировки или упорядочивания.
 Ряд инструментов Python поддерживают ключевые функции для управления упорядочением или группировкой элементов.
 К ним относятся min(), max(), sorted(), list.sort(), heapq.merge(), heapq.nsmallest(), heapq.nlargest(), и itertools.groupby().
 Альтернативно, ключевая функция может быть построена из lambda

 --- Сравнение объектов ---
 # Если объекты не могут быть сравниваемы (например, если они разных типов), то произойдет ошибка типа `TypeError`.

 # В Python функции `max()`, `min()` и `sorted()` и другие подобные функции используют стандартные методы сравнения
 # объектов, такиме как `__lt__`, `__le__`, `__gt__`, `__ge__`, и `__eq__`.

 print(sorted([1, 2, 'a']))  # -> TypeError: '<' not supported between instances of 'str' and 'int'   Тут метод __lt__
 print(min([1, 2, 'a']))     # -> TypeError: '<' not supported between instances of 'str' and 'int'   Тут метод __gt__
 print(max([1, 2, 'a']))     # -> TypeError: '>' not supported between instances of 'str' and 'int'   Тут метод __gt__


 # Чтобы можно было сравнивать ЭК нужно прописать методы         по умолчанию будет ошибка
 class Person:
     def __init__(self, name, age):
         self.name = name
         self.age = age

     def __lt__(self, other):
         return self.age < other.age

 p1 = Person("Alice", 30)
 p2 = Person("Bob", 25)

 print(max(p1, p2).name)  # Вывод: Alice (поскольку Alice старше)
 print(min(p1, p2).name)  # Вывод: Bob (поскольку Bob младше)

 # Без методов будет ошибка
 class Person:
     def __init__(self, name, age):
         self.name = name
         self.age = age

 p1 = Person("Alice", 30)
 p2 = Person("Bob", 25)

 print(p1 > p2)           # -> TypeError: '>' not supported between instances of 'Person' and 'Person'
 print(max(p1, p2).name)  # -> TypeError: '>' not supported between instances of 'Person' and 'Person'
 print(min(p1, p2).name)  # -> TypeError: '<' not supported between instances of 'Person' and 'Person'


 # __eq__ по умолчанию сравнивает адрес в памяти

 # В dataclass eq встроен сразу           # В обычном классе Сравниваем адрес в памяти
 from dataclasses import dataclass

 @dataclass                               class Person:
 class Person:                                def __init__(self, name, age):
     name: str                                    self.name = name
     age: int                                     self.age = age

 p1 = Person("Bob", 25)                   p1 = Person("Bob", 25)
 p2 = Person("Bob", 25)                   p2 = Person("Bob", 25)
 print(p1 == p2)  # -> True               print(p1 == p2)  # -> False


 Карринг — это преобразование функции от многих аргументов в набор вложенных функций, каждая из которых является
 функцией от одного аргумента:
 def greet_deeply_curried(greeting):
    def w_separator(separator):
        def w_emphasis(emphasis):
            def w_name(name):
                print(greeting + separator + name + emphasis)
            return w_name
        return w_emphasis
    return w_separator

 greet = greet_deeply_curried("Hello")("...")(".")
 greet('German')
 greet('Ivan')

 Или вариант с lambda Каррирование:
 greet_deeply_curried = lambda greeting: lambda separator: lambda emphasis: lambda name: \
    print(greeting + separator + name + emphasis)

 Мемоизация — это техника оптимизации, которая позволяет сохранять результаты функций с целью избежать повторных вычислений.
 Мемоизация довольно простая и эффективная практика. Благодаря functools.lru_cache, ей удобно пользоваться в Python.
 Под капотом у нее словарь в виде хэш-таблицы, соответственно ключ должен реализовать хеширование


 --- ДЕКОРАТОР (ФУНКЦИЯ ВЫСШЕГО ПОРЯДКА) СТРУКТУРНЫЙ ПАТТЕРН ПРОЕКТИРОВАНИЯ ---
 ДЕКОРАТОР — это ФУНКЦИЯ ВЫСШЕГО ПОРЯДКА, которая принимает другую функцию в качестве аргумента,
 добавляет к ней некоторую дополнительную функциональность и возвращают функцию с измененным поведением.
 Функция - полноправный обьект
 внутренняя функция может захватывать переменные из внешней
 Суть декоратора в том, что мы можем менять поведение декорируемого объекта,
 при этом не меняя его собственную реализацию, его код.

 Для написания декоратора нужно понимать:
 функция полноправный объект, который можно передавать, возвращать, хранить в коллекции и  делать все то, что с другими объектами
 внутренняя функция может захватывать значения переменных из внешней

 В своей основе декораторы Python позволяют расширять и изменять поведение вызываемых(Callable) объектов
 (функций, методов и классов) без необратимой модификации самих вызываемых объектов.

 Проще говоря: декораторы обертывают функцию, изменяя ее поведение.

 ФАБРИКА ДЕКОРАТОРОВ - функция которая возвращает декоратор

 Декораторы в Python выполняются сразу после загрузки модуля, когда интерпретатор встречает их.    <-----
 Декораторы выполняются при импорте модуля, тогда как декорируемые функции вызываются только в момент их использования.
 Это и демонстрирует различие между ЭТАПОМ ИМПОРТА (где работают декораторы) и ЭТАПОМ ВЫПОЛНЕНИЯ
 (где вызываются декорируемые функции).


 Синтаксический сахар(Syntactic sugar) - Делает использование языка более удобным.  Не влияет на поведение программы
 Примеры: Декораторы @, срезы [i:n], += , set/list/dict comprehensions, Тернарный оператор, if, a=b=c, и другие...

 вешаем @ - синтаксический сахар

 from time import time, sleep, perf_counter, perf_counter_ns
 from functools import wraps

 def timer(func):
     # @wraps(func)
     def wrapper(*args, **kwargs):
         start = time()
         result = func(*args, **kwargs)
         finish = time()
         print(f'Work Time {finish - start} sec')
         return result
         # return func(*args, **kwargs)

     wrapper.__name__ = func.__name__
     wrapper.__doc__ = func.__doc__
     return wrapper


 @timer  # синтаксический сахар
 def summa(a, b):
     sleep(1)
     return f'GOOD, {a + b}'


 if __name__ == '__main__':
     # print(timer(summa)())
     # summa = timer(summa)
     # print(summa())
     print(summa(2, 2))
     print(summa.__name__)

 @decorate_function
 def function(*args, **kwargs):
    # Тело декорируемой функции

 В языке Python существует особый синтактис для «оборачивания» функций с помощью функций-декораторов.

 Пример:

 # Декорирующая функция (декоратор)
 def decorate_function(func):
    # Функция-обёртка
    def wrapper():
        print('До вызова функции')
        func()
        print('После вызова функции')
    return wrapper

# Класс как ДЕКОРАТОР

from time import perf_counter

class Timer:
    def __init__(self, func):
        self.fn = func

    def __call__(self, *args, **kwargs):
        start = perf_counter()
        print(f"Вызывается функция {self.fn.__name__}")
        result = self.fn(*args, **kwargs)
        finish = perf_counter()
        print(f"Функция {self.fn.__name__} отработала за {finish - start}")
        return result

@Timer
def fact(n):
    pr = 1
    for i in range(1, n + 1):
        pr *= i
    return pr

import math
@Timer
def factorial(n):
    return math.factorial(n)

@Timer
def fib(n):
    if n <= 1:
        return n
    else:
        return fib(n - 1) + fib(n - 2) - хвостовя рекурсия

fact(20)
fact(30)

 Декоратор класса — это функция, которая принимает класс в качестве аргумента и возвращает новый класс
 с модифицированными или расширенными свойствами и методами.
 Декораторы классов позволяют изменять поведение класса без изменения его исходного кода.

 Декорирование класса в Python:

 # Самописный пример:
 def add_calc(target):
    def calc(self):
        return 42

    target.calc = calc
    return target

 @add_calc
 class MyClass:
     def __init__(*args, **kwargs):
         print("MyClass __init__")

 my_obj = MyClass()     # -> MyClass __init__
 print(my_obj.calc())   # -> 42


 # Модуль dataclasses
 from dataclasses import dataclass

 @dataclass
 class InventoryItem:
     name: str
     unit_price: float
     quantity: int = 0

 item = InventoryItem(name="HEHE", unit_price=12, quantity=100)
 print(item.__dict__)  # -> {'name': 'HEHE', 'unit_price': 12, 'quantity': 100}

 @dataclasses.dataclass(*, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True,
 kw_only=False, slots=False, weakref_slot=False)


 Новое в Python 3.9:
 Декораторы теперь можно хранить в словаре, списке или другом контейнере. Обращение осуществляется согласно синтаксису контейнера:

  # декораторы хранятся в словаре
 decorators = {'dec': dec}

 @decorators['dec']
 def foo(x):
     print('Hello')

 # или списке
 decorators = [dec1, dec2, dec3]

 @decorators[0]
 def foo(x):
     print('Hello')
------------------------------------------------------------------------------------------------------------------------

 --- Декораторы с параметрами или аргументами     можно и так и так говорить ---

 ДЕКОРАТОР С ПАРАМЕТРАМИ - ЭТО ДОБАВЛЕНИЕ ЕЩЕ ОДНОГО УРОВНЯ ВЛОЖЕННОСТИ - чтобы передать параметр             <------


 Пример Декоратор с аргументами в виде ФУНКЦИЙ:

 import functools                                       import functools
 import time                                            def repeater(repeat=1):              # Добавление вложенности
                                                             'Повторение выполнения кода'
 def delayed(delay=1):                                       def decorator(func):
     'Задержка перед вызовом функции'                            @functools.wraps(func)
     def decorator(func):                                        def wrapper(*args, **kwargs):
         @functools.wraps(func)                                      for i in range(repeat):
         def wrapper(*args, **kwargs):                                   print(f'{i+1}: ', end='')
             print(f'Спим {delay} сек.')                                 val = func(*args, **kwargs)
             time.sleep(delay)                                       return val
             val = func(*args, **kwargs)                         return wrapper
             return val                                      return decorator

         return wrapper                                 @repeater(repeat=3)
                                                        def say(name):
     return decorator                                       print (f'Hello {name}!')
                                                        say('10')
 @delayed(delay=0.5)                                    # -> 1: Hello 10!
 def countdown(int_num):                                # -> 2: Hello 10!
     if int_num < 1:                                    # -> 3: Hello 10!
         exit(0)
     else:
         print(int_num)
     countdown(int_num - 1)

 countdown(3)
------------------------------------------------------------------------------------------------------------------------
 Пример Декоратор с аргументами в виде КЛАССА:                                                   <-----

 from functools import wraps
 from time import sleep

 class Delayed:
     # запоминаем аргументы декоратора
     def __init__(self, delay=1):
         self._delay = delay

     # декоратор общего назначения
     def __call__(self, func):
         @wraps(func)
         def wrapper(*args, **kwargs):
             print(f'Спим {self._delay} сек.')
             sleep(self._delay)
             val = func(*args, **kwargs)
             return val

         return wrapper

 @Delayed(delay=0.5)
 def countdown(int_num):
     if int_num < 1:
         exit(0)
     else:
         print(int_num)
     countdown(int_num - 1)

 countdown(3)
------------------------------------------------------------------------------------------------------------------------
 Еще Пример Обычного Декоратора БЕЗ параметров:                                                           <-----

 def typed_int(funcion):
    def wrapper(*args):
        for arg in args:
            if not isinstance(arg, int):
                raise ValueError('Тип должен быть int')
        return funcion(*args)
    return wrapper

 @typed_int #@real_decorator
 def calculate(a, b, c):
     # Logic
     return a + b + c

 if __name__ == '__main__':
     # calculate = typed_int(calculate) # Под капотом работает так! Ручное декорирование без @             <-----
     print(calculate(1, 2, 3)) # -> 6
------------------------------------------------------------------------------------------------------------------------
 Еще Пример Декоратора с параметрами:                                                                       <-----
 ДЕКОРАТОР С ПАРАМЕТРАМИ - ЭТО ДОБАВЛЕНИЕ ЕЩЕ ОДНОГО УРОВНЯ ВЛОЖЕННОСТИ ДЛЯ ТОГО ЧТОБЫ ПЕРЕДАТЬ КАКОЙ-ТО ПАРАМЕТР А
 ВНУТРИ ЛЕЖИТ ОБЫЧНЫЙ ДЕКОРАТОР.                                                                            <-----

 def typed(type_):                    # ->   Добавили уровень вложенности
    def real_decorator(function):     # ->   Внутри обычный декоратор
        def wrapper(*args):
            for arg in args:
                if not isinstance(arg, type_):
                    raise ValueError(f'Тип должен быть {type_}')
            return function(*args)

        return wrapper

    return real_decorator             # ->   нужно вернуть еще одну функцию как и другие вложенности

 @typed(int)         # @real_decorator
 def calculate(a, b, c):
     # Logic
     return a + b + c

 @typed(str)         # @real_decorator
 def convert(a, b):
     # Logic
     return a + b

 if __name__ == '__main__':
     # calculate = typed(int)(calculate) # Под капотом работает так! Ручное декорирование без @             <-----
     print(calculate(2, 2, 2))
     print(convert('1', 'hello'))
     # convert = typed(str)(convert)     # Под капотом работает так! Ручное декорирование без @             <-----
------------------------------------------------------------------------------------------------------------------------

 -- Вложенные декораторы --                                                                                 <-----
 Вложение декораторов один в другой

 В Python можно применить несколько декораторов к функции, укладывая их друг на друга. При использовании этой
 возможности каждый декоратор должен указываться в отдельной строке:

 @decorator1    # -> Будет работать Третим
 @decorator2    # -> Будет работать Вторым
 @decorator3    # -> Будет работать ПЕРВЫМ
 def func():
      ...
 Для более детального понимания, что происходит в примере выше, запишем его следующим образом:
 func = decorator1(decorator2(decorator3(func)))                                                            <-----

 Они изменяют функцию и ее измененный вариант в качестве аргумента передают друг другу в порядке следования.

 Пример Вложенных декораторов:
 def bold(func):
    def wrapper():
        val = func()
        # Вставка HTML кода до и после 'val'
        # return '<b>' + func() + '</b>'       # тоже самое
        return '<b>' + val + '</b>'            # тоже самое
    return wrapper

 def italic(func):
     def wrapper():
         val = func()
         # Вставка HTML кода до и после 'val'
         return '<i>' + val + '</i>'
     return wrapper

 @bold         #   Второй    2
 @italic       #   Первый    1
 def say():
     return "hello"

 print(say())   # ->      <b><i>hello</i></b>
------------------------------------------------------------------------------------------------------------------------

 --- ДЕКОРАТОРЫ на МАКСИМАЛКАХ ---
 Декоратор - это функция, принимающая на вход функцию, и возвращающая (другую) функцию
 P.S. На самом деле, это может быть и не функция, а любой Callable объект, да и декорировать классы тоже можно.

 -- Простейший декоратор --                                                                     <-----
 Итак, давайте напишем самый-самый простой декоратор исходя из его определения.

 def decorator(     # это функция
     call           # принимает на вход функцию
 ):
     def wrapper(*args, **kwargs):
         # код до оригинальной функции
         r = call(*args, **kwargs)
         # код после оригинальной функции
         return r
     return wrapper # возвращает другую функцию         Однако, в Python есть немного сахара и на этот случай:
                                                        @decorator
 def call(a: int) -> str:                               def call(a: int) -> str:
     return str(a)                                          return str(a)

 decorated_call = decorator(call)

 print(decorated_call(1)) # -> 1
 # вызов как обычной функции
 assert decorated_call(1) == "1"

 Данный код также применяет декоратор к объявленной функции, однако присутствуют некоторые нюансы, о которых стоит знать:

 - ваша оригинальная функция call замещается функцией wrapper, и вы больше не можете получить доступ к call в глобальной видимости;
 - в ваш декоратор передается ровно один аргумент - декорируемая функция. Если вы хотите передавать дополнительные
 аргументы, нужно использовать другие приемы.

 Небольшой совет: возьмите в привычку всегда декорировать ваш wrapper с помощью functools.wraps. Эта функция копирует
 всю служебную метаинформацию о декорируемой функции в функцию-декоратор (название функции, докстринги, список входящих
 аргументов, их типы и тд

 Это нужно как минимум для того, чтобы библиотеки, получающие информацию о ваших функциях через модуль inspect работали
 корректно (тот же FastAPI не сможет распознать аргументы вашей функции без этого).

 Всего пара "лишних" строк кода, не ленитесь:
 from functools import wraps

 def decorator(func):
     @wraps(func)
     def wrapper(*args, **kwargs):
         return func(*args. **kwargs)
     return wrapper


 -- Декоратор с параметрами --                                                                     <-----

 процесс декорирования (без сахара) на самом деле выглядит немного по другому:

 # обычный декоратор
 decorated_func = decorator(call)

 # декоратор с параметрами
 decorator_wrapper = decorator(arg1, arg2)
 decorated_func = decorator_wrapper(call)

 # или в одну строку
 decorated_func = decorator(arg1, arg2)(call)

 Надеюсь, вы уже догадались, как пишется подобный декоратор, но я все-таки приведу пример:

 def decorator_wrapper(arg1, arg2):
     def real_decorator(func): # объявляем декоратор
         @wraps(func)
         def wrapper(*args, **kwargs):
             return func(*args, **kwargs)
         return wrapper

     return real_decorator     # возвращаем декоратор

 @decorator_wrapper(1, 2)
 def func():
    ...

 Так как декоратор в этом случае - замыкание, то вы имеете доступ к arg1 и arg2 на любом уровне вложенности.

 Еще одно важное уточнение: процесс декорирования происходит на этапе первого прохождения интерпретатором Python вашего
 кода (когда Python получает представление об объектах, которыми он может оперировать в рантайме).

 Т.е. в самом рантайме (процесс вызова функции) во всех сценариях декорирования будет выполнен только код, находящийся внутри wrapper'а.

 Сам же код декоратора будет выполнен сразу при старте вашего приложения, как только интерпретатор дойдет до строки
 @decorator. Именно поэтому все декораторы должны быть объявлены как синхронные функции. Даже если они являются
 декораторами для асинхронных функций (в таком случае асинхронным будет объявлен wrapper).


 -- Декоратор 4 вложенности  --                                                                     <-----

 @pytest.fixture
 def simple_fixture(): ...

 @pytest.fixture(scope="session")
 def session_fixture(): ...

 @dataclass
 class SimpleDataclass: ...

 @dataclass(slots=True)
 class SimpleDataclass: ...

 На самом деле, никакой магии здесь тоже нет. Проблема решается добавлением четвертого уровня вложенности (а то 3ех нам "мало").
 таким образом в ваш декоратор передается ровно один аргумент - декорируемая функция
 Совмещаем обычный декоратор и декоратор с параметрами вместе и получаем что-то такое:

 def schrodinger_decorator(
     call = None,
     *,
     arg1 = None,
     arg2 = None,
 ): ...

 При этом все аргументы должны иметь значения по умолчанию так как в одном случае у нас будет передаваться только call,
 в другом - только дополнительные аргументы.

 Затем мы отдельно пишем декоратор с параметрами еще раз:

 def decorator_wrapper(arg1, arg2):
    def real_decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper
    return real_decorator

 Теперь нам осталось только разрешить два наших сценария проверкой if call is None.

 def schrodinger_decorator(
     call = None,
     *,
     arg1 = None,
     arg2 = None,
 ):
     wrap_decorator = decorator_wrapper(arg1, arg2)

     # если мы использовали декоратор
     # как декоратор с параметрами
     if call is None:
         return wrap_decorator

     # если мы использовали декоратор как обычный
     ## arg1 и arg2 при этом принимают
     ## значения по умолчанию
     else:
         return wrap_decorator(Call)

 И использование:

 # call=func, arg1=None, arg2=None
 @schrodinger_decorator
 def func(): ...

 # call=None, arg1=1, arg2=2
 @schrodinger_decorator(arg1=1, arg2=2)
 def func(): ...

 -- Аннотирование декораторов --
 Современный синтаксис Python невозможно представить без аннотации типов. Аннотация обеспечивает работу автодополнения,
 а других разработчиков - информацией о типах входящих и исходящих параметров, да и вообще дает много других плюшек,
 значительно повышающих Developer Experience.

 Однако, балуясь с декораторами, эти аннотации очень легко сломать. Поэтому давайте разбираться, как не прострелить себе и другим ноги.
 Нам понадобятся следующие братья:

 - typing.Callable - базовый тип любого вызываемого объекта в Python (функции в том числе)
 - typing.TypeVar - переменная типа, позволяет синхронизировать аннотации различных параметров функции друг с другом
 - typing.ParamSpec (до py3.10 использовать из typing_extensions) - общая аннотация произвольных аргументов функции

  from typing import Callable                     # Лучше используем    from collections.abc import Callable

 # typing.TypeVar Механизм, который позволяет создавать обобщенные типы, что упрощает создание ФУНКЦИЙ и КЛАССОВ,
   которые могут работать с различными типами данных.

 # Пример TypeVar:

 from typing import TypeVar, List

 T = TypeVar('T')   # Создаём обобщённый тип T

 # def get_first_element(elements: List[T]) -> T:  # Тоже самое
 def get_first_element(elements: list[T]) -> T:    # Тоже самое
     return elements[0]

 # Используем функцию с разными типами
 first_number = get_first_element([1, 2, 3])        # Здесь T - int
 first_string = get_first_element(['a', 'b', 'c'])  # Здесь T - str

 print(first_number)  # Вывод: 1
 print(first_string)  # Вывод: 'a'

 # В этом примере функция get_first_element может принимать список любого типа и возвращать первый элемент этого списка,
 # ПРИ ЭТОМ ТИП ВОЗВРАЩАЕМОГО ЗНАЧЕНИЯ БУДЕТ ТАКИМ ЖЕ, КАК И У ЭЛЕМЕНТОВ СПИСКА.                             <-----


 -- Class-based декораторы --
 Как мы все уже точно знаем, процесс декорирования выглядит следующим образом
 decorated_func = decorator(func)
 result = decorated_func(*args, **kwargs)

 А что если мы хотим сделать что-то такое?

 decorated_func = DecoratorClass(func)
 result = decorated_func(*args, **kwargs)

 Никаких проблем, давайте сделаем!
 class DecoratorClass:
     def __init__(self, func):
         # выполняется при декорировании
         self.original_call = func

     def __call__(self, *args, **kwargs):
         # выполняется при вызове
         return self.original_call(*args, **kwargs)

 Отладка – это процесс поиска и исправления ошибок или неполадок в исходном коде какого-либо программного обеспечения
 Используем отладку PyCharm для всего!
                                             <-----          <-----

 --- Compare with Clipboard   PyCharm  Как сравнить текст или файл ---
 Ctrl + C или Ctrl + Х   и выделяем другой текст  и нажимаем ЛКМ и выбираем Compare with Clipboard
 Можно сравнивать и файлы.  Текст должен быть в тройных кавычках


 Принципы написания кода
 DRY - don't repeat yourself  - не повторяйся
 YAGNI - You aren't gonna need it  - это не понадобится
 KISS - Keep it simple, stupid  - будь проще
 POLA - Principle Of Least Astonishment  - не удивляй пользователя
 EAFP - Easier to Ask for Forgiveness than Permission  - проще извиниться, чем просить разрешения (сначала действуй)
 EAFP - Оптимистичное программирование   Optimistic Programming  'Python Way'
 LBYL - Look Before You Leap - смотри, прежде чем прыгнуть (сначала спроси)
 LBYL - Defensive programming  Защитное программирование
 Помните, что нет правил без исключений, все принципы и даже дзен - рекомендации, а не неоспоримый закон!
 Дзен Python - философии программирования от Тима Петерса (PEP20), состоит из 19 «руководящих принципов» написания
 компьютерных программ, влияющих на структуру языка программирования Python.
 команда - import this

 1) Красивое лучше, чем уродливое.
 2) Явное лучше, чем неявное.
 3) Простое лучше, чем сложное.
 4) Сложное лучше, чем запутанное.
 5) Плоское лучше, чем вложенное.
 6) Разреженное лучше, чем плотное.
 7) Читаемость имеет значение.
 8) Особые случаи не настолько особые, чтобы нарушать правила.
 9) При этом практичность важнее безупречности.
 10) Ошибки никогда не должны замалчиваться.
 11) Если они не замалчиваются явно.
 12) Встретив двусмысленность, отбрось искушение угадать.
 13) Должен существовать один и, желательно, только один очевидный способ сделать это.
 14) Хотя он поначалу может быть и не очевиден, если вы не голландец.
 15) Сейчас лучше, чем никогда.
 16) Хотя никогда зачастую лучше, чем прямо сейчас.
 17) Если реализацию сложно объяснить — идея плоха.
 18) Если реализацию легко объяснить — идея, возможно, хороша.
 19) Пространства имён — отличная штука! Будем делать их больше!


 GRASP (General Responsibility Assignment Software Patterns) — это набор шаблонов проектирования, используемых для
 распределения обязанностей между классами в ОБЪЕКТНО-ОРИЕНТИРОВАННОМ программировании. Он помогает создать более
 гибкую и поддерживаемую архитектуру, определяя, какие классы должны выполнять определённые функции.

 GRASP — это принципы, помогающие правильно распределять задачи между классами в программировании, чтобы сделать код
 более понятным и удобным для поддержки.


 --- pattern matching  match/case ---

 Sequence Types в match case - list, tuple, range
 Строка(str) - Не относиться к Последовательностям/Sequences

 Правила работы с ПМ:
 1) несмотря на возможность - не стоит давать своим объектам имена match и case
 2) _ - универсальный символ (wildcard), может быть добавлен в конце для отработки всех остальных вариантов
 3) [a,b], (a,b) и a,b равнозначны, ожидается последовательность (кроме строки и байтов), но не set или dict
 4) допустим вызов только типов (float(), str(), MyClass() и т.д.), обращения по индексу недопустимы
 5) после паттерна может быть добавлен guard начинающийся с if, он сработает только при удачном сравнении шаблона
 6) последовательности (sequence) проверяются строго по содержимому и размеру, маппинги (dict) проверяют только конкретные вхождения ключей
 7) имена привязываются (bind) локально, они доступны вне контекста match, для использования внешних констант нужно использовать точку
 8) применяются правила распаковки
 9) для OR случаев должны быть привязаны одинаковые имена
 10)  AS позволит привязать имя даже внутри паттерна
 11)  проверять типы можно даже внутри паттерна и при привязке имени

 НЕЛЬЗЯ:
 1) писать **_ для маппингов (dict)
 2) вызывать свои функции или обращаться к какой то коллекции по индексу (a_list[x]) в блоке case
 3) привязывать разные имена при использовании OR (|)


 Оператор match case был добавлен в Python 3.10 и предоставляет альтернативу условным операторам if-elif-else и
 конструкции switch-case.
 Во многих случаях конструкция match/case, может упростить и повысить читабельность кода Python.
 Structural pattern matching (соответствие структуре шаблона).

 Очень важно не путать pattern matching и switch/case, их главное отличие состоит в том,
 что pattern matching - это не просто оператор для сравнения некоторой переменной со значениями, это целый механизм
 для проверки данных, их распаковки и управления потоком выполнения.

 Следует отметить лишь разницу: проверки if-else вызывают __eq__()метод объектов, а match-case выполняет внутренние сравнения.

 Пример match case:                                  Пример if-elif-else:

 def my_match_case(n):                               def my_if_elif_else(n):
     match n:                                            if n == 10 or n == 20:
         case 10 | 20:                                       return 100
             return 100                                  elif isinstance(n, int | str):
         case int(n) | str(n):                               return True
             return True                                 elif isinstance(n, list) and len(n) > 3:
         case list(n) if len(n) > 3:                         return 'List'
             return "List"                               else:
         case _:                                             return False
             return False
 print(my_match_case(10))         # -> 100           print(my_if_elif_else(10))         # -> 100
 print(my_match_case(100))        # -> False         print(my_if_elif_else(100))        # -> True
 print(my_match_case([1, 2, 3]))  # -> False         print(my_if_elif_else([1, 2, 3]))  # -> False

 # Примеры Документация PEP 622

 # Возьмем, к примеру, этот фрагмент веб-фреймворка Django:

 if (                                                        match value:
     isinstance(value, (list, tuple)) and                        case [*v, label := (Promise() | str())] if v:
     len(value) > 1 and                                              value = tuple(v)
     isinstance(value[-1], (Promise, str))                       case _:
 ):                                                                  label = key.replace('_', ' ').title()
     *value, label = value
     value = tuple(value)
 else:
     label = key.replace('_', ' ').title()


 # Пример из стандартной библиотеки Python

 def is_tuple(node):
     if isinstance(node, Node) and node.children == [LParen(), RParen()]:
         return True
     return (isinstance(node, Node)
             and len(node.children) == 3
             and isinstance(node.children[0], Leaf)
             and isinstance(node.children[1], Node)
             and isinstance(node.children[2], Leaf)
             and node.children[0].value == "("
             and node.children[2].value == ")")

 # Тоже самое с match case

 def is_tuple(node: Node) -> bool:
     match node:
         case Node(children=[LParen(), RParen()]):
             return True
         case Node(children=[Leaf(value="("), Node(), Leaf(value=")")]):
             return True
         case _:
             return False



 --- Паттерны ---
 Паттерны или ШАБЛОНЫ разработки - это общие способы решения частых задач и проблем

 Паттерны в Python – это шаблоны для решения задач, которые часто встречаются в практике программиста.
 Паттерны — это типовые решение для типовых задач.
 Существует три основные разновидности паттернов:
 1) архитектурные паттерны, 2) паттерны проектирования, 3) идиомы
 ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ:
 1) Порождающие паттерны — отвечают за процесс создания объектов.
 2) Структурные паттерны — определяют отношения между объектами, облегчая их взаимодействие
 3) Поведенческие паттерны — определяют способы коммуникации между объектами

 «Шаблон проектирования» — это конструкция относительно «высокого уровня»
 «Идиома» — это относительно «низкоуровневая» конструкция

 Идиомы — это низкоуровневые шаблоны, специфичные для языка программирования. Идиома описывает, как реализовать
 определенные аспекты компонентов или отношения между ними с учетом особенностей данного языка.
 примеры идиом: lambda, enumerate, yield, set, dict, with, тернарный оператор, zip, Listcomps, genexp  и другие
 from collections import Counter, OrderedDict, ChainMap, deque, defaultdict, namedtuple    и другие
 from itertools import chain, combinations, permutations, groupby, zip_longest             и другие
 CamelCase: OrderedDict, ChainMap   если в формате(стиле) CamelCase то значит написано на чистом  Python

 АРХИТЕКТУРНЫЕ ПАТТЕРНЫ - Определяет архитектуру приложения, задают его логику
 отвечает на вопрос «как будет устроен продукт»
 ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ - предоставляют решения на уровне кода
 отвечает на вопрос «как лучше организовать составные части продукта»:
 как эффективнее создавать объекты, настраивать обмен данными между ними и их взаимодействие.

 Книга о разработке и алгоритмах. Банда Четырех Паттерны Проектирования.
 Авторы: Гамма Эрих, Хелм Ричард, Джонсон Роберт, Влиссидес Джон


 --- Анти-паттерны — полная противоположность паттернам ---
  Если паттерны проектирования — это примеры практик хорошего программирования, так называемые шаблоны решения определённых
 задач, то антипаттерны — их полная противоположность. Это шаблоны ошибок, которые совершаются при решении различных задач.

 Анти-паттерны -     Божественный обьект(God object) , Singleton Одиночка

 Божественный объект — анти-паттерн, который довольно часто встречается у ООП разработчиков. Такой объект берет на себя
 слишком много функций и/или хранит в себе практически все данные. В итоге мы имеем непереносимый код, в котором,
 к тому же, сложно разобраться. Также подобный код довольно сложно поддерживать, учитывая, что вся система зависит
 практически только от него.

 Бороться с анти-паттерном «Божественный объект» следует путем разбивания одного большого класса на несколько небольших.


 --- стиль написания составных слов ---

 CamelCase(ВерблюжийРегистр) - стиль написания составных слов, при котором несколько слов пишутся слитно без пробелов,
 при этом каждое слово внутри фразы пишется с прописной буквы.

 lowerCamelCase (все слова кроме первого начинаются с прописной буквы)
 UpperCamelCase (все слова, в том числе и первое пишутся с большой буквы)

 under_score (snake_case) (змеиный_регистр) - стиль написания составных слов, при котором несколько слов разделяются
 символом подчеркивания (_), и не имеют пробелов в записи, причём каждое слово обычно пишется с маленькой буквы  —
 «foo_bar», «hello_world» и т. д. Такой стиль написания используется для именования переменных и функций
 в исходном коде, и иногда для именования файлов на компьютере.

 kebab-case - который похож на under_score, но вместо знака подчеркивания "_" в нем используется тире "-".


 --- Регулярные выражения (регулярки, regexp, Regular expression) ---

 бибилотека регулярки:     import re

 Плюсы регулярных выражений:
 1) Python очень быстро и эффективно работает с регулярками, быстрее многих других ЯП, в том числе компилируемых
 2) могут помочь там, где иначе пришлось бы предпринять много лишних действий (разбить текст, вырезать знаки препинания и т.п.)
 3) при определенных условиях могут быть короткими и читаемыми

 Минусы:
 синтаксис! Он не связан с языком программирования, не всегда понятен, для сложных шаблонов может быть большая строка,
 состоящая из набора разных символов, что не добавляет оптимизма.

 Где регулярки выигрывают - там где большой текст или сложный шаблон для поиска. Понятно что фразу из 3 слов
 проще и быстрее обработать методами строки, но по мере роста  объемов текста и сложности шаблона регулярки выходят
 на первый план и по скорости и по краткости.

 Совет из практики: если регулярка(само выражение) большая, то вынесите ее в константы с понятным именем и
 напишите коммент с примером ее работы.

 Каждому питонисту советую прочесть документацию библиотеку re чисто для ознакомления, чтобы было представление
 о том, что там есть. Тем, кто парсит сайты и работает с текстами -регулярки нужно просто знать!

 Если у тебя есть одна проблема и ты начал решать её регулярками, то теперь у тебя две проблемы)

 # Интересный пример  РАЗБЕРИ ПОЧЕМУ ТАК РАБОТАЕТ      # Без ОШИБКИ Работает text[0].aaaaaaaaaa()  - Подумай ПОЧЕМУ!
  def matchcase(word):
     def replace(m):
         text = m.group()
         if text.isupper():
             return word.upper()                # Так будет ОШИБКА!
         elif text.islower():                   # elif text.bbb():  # AttributeError: 'str' object has no attribute 'bbb'
             return word.lower()                # Если вставить такую строку будет работать О_о  ОШИБКИ НЕ БУДЕТ!
         elif text[0].isupper():                # elif text[0].aaaaaaaaaa():
             return word.capitalize()
         else:
             return word
     return replace

 res = 'UPPER PYTHON, lower python, mixed python'
 print(re.sub(r'python', matchcase('shake'), res, flags=re.IGNORECASE))  # -> UPPER SHAKE, lower shake, mixed shake


 -- ПРЕФИКСНЫЕ и СУФФИКСНЫЕ алгоритмы --
 Префиксные и суффиксные алгоритмы используются для эффективного сопоставления строк и обработки регулярных выражений.
 Префиксные алгоритмы (например, алгоритм Кнута-Морриса-Пратта) используют информацию о совпадениях в начале строки
 для ускорения поиска. Они позволяют избежать повторного сравнения символов, которые уже были проверены.

 Суффиксные алгоритмы (например, суффиксные деревья и суффиксные массивы) хранят все суффиксы строки, что позволяет
 быстро находить подстроки и выполнять операции, такие как поиск, подсчет и сравнение.

 Префиксные алгоритмы: Эти алгоритмы используют информацию о совпадениях в начале строки для ускорения поиска. Примером
 является алгоритм Кнута-Морриса-Пратта (KMP), который избегает повторного сравнения символов, которые уже были проверены.

 Суффиксные алгоритмы: Эти алгоритмы хранят все суффиксы строки, что позволяет быстро находить подстроки.
 Примеры включают суффиксные деревья и суффиксные массивы, которые используются для эффективного поиска и анализа строк.

 Оба типа алгоритмов значительно повышают эффективность обработки строковых данных.



 --- Closure Замыкание ---
 Замыкание(Closure) - Внутренняя функция которая возвращается из внешней и при этом
 использует переменные из внешнего Scope(Область видимости)
 каждое замыкание хранит своё состояние, они не пересекаются
 хранит состояние(данные), предоставляет интерфейс для работы с ними,
 "скрывает" данные и помогает избегать global

 По сути замыкание - это внутренняя функция, которая возвращается из внешней и использует переменные из внешнего скоупа
 (которые ей не принадлежат). Функция как бы "замыкает", захватывает переменные из внешней функции. Вы могли встречать
 такое например в декораторах.

 Каждый объект замыкания независим, они не пересекаются, у каждого свои данные.
 Замыкания это еще один шаг в сторону ООП, так как тут мы имеем некоторое состояние (данные)
 сокрытое от посторонних глаз и с которым можно взаимодействовать только с помощью заранее написанного интерфейса (функция).
 Замыкания могут быть полезны для того чтобы избегать использования global, а также и в других случаях,
 когда нам важно, чтобы наши данные не изменили невалидным способом, чтобы с данными работали только через нашу логику.
 НО(!) до этих данных тоже можно добраться при определенном желании, нужно понимать что нет полного сокрытия данных.
 boys.__closure__[0].cell_contents

 def names():
    all_names = []

    def inner(name: str) -> list:
        all_names.append(name)
        return all_names

    return inner

 boys = names()
 boys('Vasya')
 boys('Sasya')
 print(boys.__closure__[0].cell_contents)  # -> ['Vasya', 'Sasya']

 Замыкание lambda
 def pow_(base):
    return lambda value: value**base


 # Интересный пример     При изменении   переменной Видит её как локальную!
 # Всякая переменная, которой присваивается значение в теле Функции считается ЛОКАЛЬНОЙ                       <-----

 b = 6                      b = 6                                   b = 6
 def func(a):               def func(a):                            def func(a):
     print(a, end=' ')          print(a, end=' ')                       global b
     print(b)                   print(b)                                print(a, end=' ')
                                b = 9                                   print(b)
                                                                        b = 9
 func(3)  # -> 3 6          func(3)  # -> 3  UnboundLocalError       func(3)  # -> 3 6



 # Замыкание class vs def    Реализация своей функции avg
 # Функция НЕЭФФЕКТИВНА              # ЭФФЕКТИВНА                               # Через КЛАСС
 def make_averager():                def make_averager():                       class Averager:
     series = []                         total = 0                                  def __init__(self):
                                         count = 0                                      self.series = []
     def averager(new_value):
         series.append(new_value)        def averager(new_value):                   def __call__(self, new_value):
         total = sum(series)                 nonlocal total, count                      self.series.append(new_value)
         return total / len(series)          count +=1                                  total = sum(self.series)
     return averager                         total += new_value                         return total / len(self.series)
                                             return total/count
 avg = make_averager()                   return averager                        avg = Averager()
 print(avg(10))  # -> 10.0                                                      print(avg(10))  # -> 10.0
 print(avg(11))  # -> 10.5                                                      print(avg(11))  # -> 10.5
 print(avg(12))  # -> 11.0                                                      print(avg(12))  # -> 11.0

 # __code__ Откомпилированное ТЕЛО ФУНКЦИИ
 print(avg.__code__.co_varnames)          # -> ('new_value', 'total')  # Локальные переменные функции
 print(avg.__code__.co_freevars)          # -> ('series',)             # Свободные переменные замыкания
 print(avg.__closure__[0].cell_contents)  # -> [10, 11, 12]            # Текущее содержимое



     __main__
 если ты запущен напрямую а не импортирован
 у каждого модуля есть __name__
 __main__ - это имя среды, в которой выполняется код верхнего уровня. «Код верхнего уровня» - это первый
 пользовательский модуль Python, который начинает выполняться. Он «верхнеуровневый», потому что импортирует все
 остальные модули, необходимые программе. Иногда «код верхнего уровня» называют точкой входа в приложение.

 __main__ - используется для предоставления локального и глобального пространства имен для выполнения всей программы.
 Но когда Python запускает сценарий, он сначала компилирует его в байт-код и сохраняет в объекте кода.
 Код верхнего уровня ( __main__ модуль) имеет объект кода, но он не отображается напрямую, поэтому вам нужно
 использовать inspect модуль, чтобы копнуть глубже.

 Способы получить объект кода кода верхнего уровня: In Python is there a way to get the code object of top level code:
 - Вы всегда можете создать объект кода из исходного кода модуля, используя compile.
 - inspect модуль
 - «нестандартный» способ - намеренно вызывая исключение внутри модуля и обрабатывая его.
 - Система импорта кэширует байт-код импортированного исходного файла при создании экземпляра модуля. Вариант
 предполагает загрузку байт-кода импортированного модуля из этого кэша.

 -- Конструкция __MAIN__ для чего и кому нужна. --
 1) любой код на питоне лежит в модуле (файл с расширением py)
 2) любой модуль при запуске программы получает атрибут __name__
 3) один(!) модуль, с которого программа началась (точка входа) получает имя __main__, все остальные
 (которые импортированы) получают имя, равное имени в файловой системе, без расширения. Например first
 4) Крайне важное для понимания! Любой модуль при импорте выполняется, как если бы мы его запустили отдельно.
 То есть все принты будут напечатаны(если они не в функциях), любой вызов функции выполнен.

 if __name__=='__main__' означает  "если этот модуль НЕ был импортирован, а запущен напрямую,
 то..." и все действия в данном блоке НЕ будут выполнены при импорте модуля.

 Для чего это нужно в том числе новичку:
 - группировать все наши действия, имеющие эффект, потом их просто найти и менять
 - отладка, тесты, ассерты, при импорте они не выполнятся
 - специфичные настройки для запуска

 Подчеркну, что блок мейн вовсе не обязателен, это просто возможность что-то выполнять в модуле скажем для отладки так,
 чтобы не получить ненужные эффекты при импорте, если мы забыли отладочные вещи убрать.


  --- lambda ---
 в lambda можно написать всё ,то что можно написать после return в обычной функции
 аналог def!!
 можно писать всё что допустимо после return в def
 не выполняется до вызова ()!!!
 значения по умолчанию вычисляются в момент создания функции (аргумент функции)
 lambda не сериализуется pickle
 AttributeError: Can't pickle local object 'run.<locals>.<listcomp>.<lambda>'

 Аргумент по умолчанию будет создан 1 раз при интерпретации

 lambda-функции - это анонимные функции, которые могут включать только одно выражение.
 lambda - Анонимная встроенная функция, состоящая из одного выражения , которое вычисляется при вызове функции.

 Лямбды в Питоне могут состоять только из одного выражения. Используя синтаксис скобок, можно оформить тело лямбды в несколько строк.
 lambda НЕ поддерживает аннотацию и нет return   <----

 # Допустимы ли следующие выражения?

 # nope = lambda: pass                   # -> SyntaxError: invalid syntax
 # riser = lambda x: raise Exception(x)  # -> SyntaxError: invalid syntax
 # no_return = lambda x: return 10       # -> SyntaxError: invalid syntax

 # Нет, при загрузке модуля выскочит исключение SyntaxError.
 # В теле лямбды может быть только выражение. pass и raise являются операторами.    <-----


 Всегда используйте оператор def вместо оператора присваивания, который связывает лямбда-выражение непосредственно с идентификатором:

 # Correct:                     # Wrong:
 def f(x): return 2*x           f = lambda x: 2*x


 a_dict = {'a':3, 'b':2, 'd':1, 'c':4}
 sorted(a_dict.items(), key=lambda x:x[1])

 from operator import itemgetter, attrgetter # Работает быстрее lambda
 sorted(a_dict.items(), key=itemgetter(1))

 если вам нужно получить несколько элементов одновременно. Например:
 operator.itemgetter(1,3,5)
 lambda s: (s[1], s[3], s[5])

 Почему лямбды, определенные в цикле с разными значениями, возвращают один и тот же результат?
 squares = []
 for x in range(5):
     squares.append(lambda: x**2)
 print(squares)      # -> [содержащий 5 лямбда-выражений, которые вычисляют x**2]
 print(squares[0])   # -> <function <lambda> at 0x000001997F2D7600>
 print(squares[0]()) # -> 16
 print(squares[4]()) # -> 16

 Это происходит потому, что x он не является локальным по отношению к лямбда-выражениям, а определен во внешней области
 видимости, и доступ к нему осуществляется при вызове лямбды, а не при его определении. В конце цикла значение x равно 4,
 поэтому все функции теперь возвращают 4**2, 16 т.е. Вы также можете убедиться в этом, изменив значение x и посмотреть,
 как изменяются результаты лямбд:
 x = 8
 print(squares[2]()) # -> 64

 Чтобы избежать этого, вам необходимо сохранить значения в переменных, локальных для лямбда-выражений, чтобы они не
 зависели от значения global x:
 squares = []
 for x in range(5):
     squares.append(lambda n=x: n**2)
 print(squares[0]()) # -> 0
 print(squares[1]()) # -> 1

 Lambda function in list comprehensions  Лямбда+ф-строка в Listcomps:
 f = lambda x: x*x
 [f(x) for x in range(5)]                # -> [0, 1, 4, 9, 16]
 [f"{f(x)}" for x in range(5)]           # -> ['0', '1', '4', '9', '16']  ПРИМЕР с   f-string

 [(lambda x: x**2)(i) for i in range(5)] # -> [0, 1, 4, 9, 16]
 [i**2 for i in range(5)]                # -> [0, 1, 4, 9, 16]



 # x - в lambda-выражении, является СВОБОДНАЯ ПЕРЕМЕННАЯ которая связывается во время выполнения, а НЕ вовремя определения

 x = 10
 a = lambda y: x + y
 x = 20
 b = lambda y: x + y
 print(a(10))  # -> 30
 print(b(10))  # -> 30

 x = 15
 print(a(10))  # -> 25
 print(b(10))  # -> 25

 # Чтобы lambda ЗАХВАТИЛА ЗНАЧЕНИЕ  нужно использовать значение по-умолчанию      x=x
 x = 100
 a = lambda y, x=x: x + y
 x = 200
 b = lambda y, x=x: x + y

 print(a(10))  # -> 110
 print(b(10))  # -> 210


 # Хороший пример  ЗАХВАТИТЬ ПЕРЕМЕННУЮ

 funcs = [lambda x: x+n for n in range(5)]
 for f in funcs:
     print(f(0), end=' ')  # -> 4 4 4 4 4

 print()

 funcs = [lambda x, n=n: x+n for n in range(5)]
 for f in funcs:
     print(f(0), end=' ')  # -> 0 1 2 3 4

------------------------------------------------------------------------------------------------------------------------
 --- Классное обьяснение работы лямбды и обычной функции!!! ---                                       <----   <-----

 def square(x):      # Интерпретатор проведет СИНТАКСИЧЕСКИЙ РАЗБОР что внутри функции
     return x ** 2

 # Интерпретатор доходит до строки находит обьект функции - ДЕЛАЕТ СИНТАКСИЧЕСКИЙ РАЗБОР но код не выполняет
 # РАБОТА Интерпретатора: Когда тебя вызовут ты пожалуйста верни значение этой переменной. Ему На остальное наплевать
 # Почему наплевать? Потому что сейчас эта функция не вызывается .

 _any = lambda: abracadabra       # не выполняется до вызова ()!!! Pycharm подчеркивает красным знает что переменных  НЕТ
 _any2 = lambda: square(use(it))  # не выполняется до вызова ()!!! Pycharm подчеркивает красным знает что переменных  НЕТ

 if __name__ == '__main__':
     # Пока не вызвали lambda или любую другую функцию def - Код будет работать!!!  <-----
     # Без вызова функции ()   lambda и def - не будут выполнять то что внутри!     <-----
     print(_any) # -> <function <lambda> at 0x00000223AF4404A0>  Нет ошибки
     _any() # -> NameError: name 'abracadabra' is not defined

 Пример 1:
 def square(x):
     return x ** 2

 # Интерпретатор не ищет значение по всем scope(областям видимости)
 _any = lambda: abracadabra # КОГДА ТЕБЯ ВЫЗОВУТ, ВЕРНИ ЗНАЧЕНИИ ПЕРЕМЕННОЙ, ГДЕ ОНА Я ФИГ ЗНАЕТ НАЙДЕШЬ КОГДА ВЫЗОВУТ =)
 _any2 = lambda: square(use(it))

 if __name__ == '__main__':
     abracadabra = 100
     print(_any()) # -> 100  В этой строке Интерпретатор начал искать переменную

 Пример 2:                                                                                              <-----

 x=2
 result = lambda: x**2
 x=3
 result2 = lambda: x**2
 print(result())   # -> 9
 print(result2())  # -> 9


 x=2
 result = lambda n=x: n**2  # Захватили значение x   Когда вызовут или возведи в квадрат то что дадут при вызове() или 2
 x=3
 result2 = lambda n=x: n**2 # Значение вычисляется в момент создания функции                             <-----
 print(result(10))   # -> 100
 print(result())     # -> 4
 print(result2(10))  # -> 100
 print(result2())    # -> 9

   Факториал лямбда+рекурсия
 fact = lambda x: x * fact(x - 1) if x > 1 else (1 if x == 0 else x)
 fact = lambda x: 1 if x == 0 else x * fact(x - 1)
 fact = lambda number: number * fact(number - 1) if number > 1 else number
 print(fact(5))                                   # -> 120
 from functools import reduce
 print(reduce(lambda x, y: x*y, range(1, 6), 1))  # -> 120


 # Будет последнее значение выводить 10 раз    ПОСМОТРИ ВНИМАТЕЛЬНО КОД  Обрати внимание на    x         <-----

 fun = [lambda x: a for a in range(10)]
 for f in fun:
     print(f(20), end=' ')               # -> 9 9 9 9 9 9 9 9 9 9


 # ВСЕ лямбда-функции ссылаются на одну и ту же переменную a, которая в конце цикла равна 9.
 fun = [lambda x: a for a in range(10)]
 for f in fun:
     print(f(20), end=' ')  # -> 9 9 9 9 9 9 9 9 9 9


 # Используем аргумент по умолчанию a=a . Это позволяет каждой функции сохранить текущее значение a на момент создания.
 fun = [lambda x, a=a: a for a in range(10)]
 for f in fun:
     print(f(20), end=' ')  # -> 0 1 2 3 4 5 6 7 8 9


 Python поддерживает символы Unicode и Цветные иконки и смайлики Unicode:
 from random import choice

 # Функция choice возвращает случайный элемент из списка    # поддержка юникода в питоне
 iterator = iter(lambda: choice(["🐼", "🐧", "💩💩💩", "💩", "🙈"]), "🙈")
 print(list(iterator)) # -> ['💩', '💩💩💩', '🐧', '💩💩💩', '🐼']

 # Итератор будет работать пока вызов лямбды не вернёт "🙈"
 iterator = iter(lambda: choice(["🐼", "🐧", "💩💩💩", "💩", "🙈"]), "🙈")
 print("".join(iterator))  # Например ->  '💩🐼🐼🐧🐧💩💩💩'
------------------------------------------------------------------------------------------------------------------------

 -- Модуль secrets   Генерация безопасных случайных чисел --

 # use secrets to generate random password
 def generate_random_password(secrets: str) -> str:         import secrets
     import secrets
     return secrets.token_urlsafe(10)                       password = secrets.token_urlsafe(length)


 --- Hash ---
 Hashable - обьект является Hashable если у него есть Hash и за время жизни обьекта этот Hash никогда не меняется
 Hashable Строки, Числа, Кортежи(если они состоят из неизменяемых обьектов, строк, чисел)
 Hashable != Immutable
 Для встроенных типов Hashable == Immutable
 Hashable - (int, float, bool, str, frozenset, tuple(если он состоит из неизменяемых обьектов), bytes, complex, range)
 unhashable type - (list, set, dict, tuple(если есть хоть 1 изменяемый обьект), bytearray)

 Функция hash() в Python позволяет генерировать уникальные хеш-коды для объектов.
 Hash-коды используются для быстрого сравнения и поиска объектов.
 Hash используются для быстрого сравнения ключей словаря во время поиска по нему.

 Модуль hashlib реализует общий интерфейс для множества различных безопасных алгоритмов хеширования и дайджеста сообщений..
 import hashlib

 Термины "безопасный хеш (“secure hash”)" и "дайджест сообщения (“message digest”)" являются взаимозаменяемыми:
 - Старые алгоритмы назывались дайджестами сообщений (message digests).
 - Современный термин - безопасный хеш (secure hash).
 Для лучшей производительности многопоточности, Python GIL запускается для данных размером более 2047 байт
 при создании объекта или при обновлении методом HASH.update().

 Хэш-алгоритмы:
 Все функции возвращают хеш-объект с одинаковым простым интерфейсом. Этот объект можно "кормить" байтоподобными
 объектами, используя метод HASH.update(). В любой момент можно запросить дайджест(хеш) о конкатенации данных,
 переданных в него, используя методы HASH.digest() или HASH.hexdigest().

 Объект является хешируемым, если он имеет хэш-значение, которое никогда не меняется в течение его существования
 (для него нужен __hash__() метод) и его можно сравнивать с другими объектами (для него нужен __eq__() метод).
 Хешируемые объекты, которые сравниваются равными, должны иметь одинаковое значение хеш-функции.

 Хешируемость делает объект пригодным для использования в качестве КЛЮЧА СЛОВАРЯ И ЧЛЕНА МНОЖЕСТВА, поскольку эти
 структуры данных внутренне используют хеш-значение.

 Большинство НЕИЗМЕНЯЕМЫХ встроенных объектов Python являются хешируемыми. ИЗМЕНЯЕМЫЕ контейнеры
 (такие как списки или словари) — нет. НЕИЗМЕНЯЕМЫЕ контейнеры (такие как кортежи и frozenset) хешируются только в том
 случае, если их элементы хешируются. Объекты, являющиеся экземплярами пользовательских классов, по умолчанию хешируются.
 Все они сравниваются неодинаково (кроме самих себя), а их хеш-значение получается из их id().

 Как понять хешируемый ли объект
 Объект называется хешируемым, если он имеет хеш-значение (целое число), которое никогда не изменяется на протяжении
 его жизненного цикла и возвращается методом __hash__(), и может сравниваться с другими объектами (реализует метод __eq__()).
 Равные хешируемые объекты должны иметь равные хеш-значения. Все стандартные неизменяемые объекты хешируемые.
 Все стандартные изменяемые объекты не хешируемые.


 --- Рекурсия Recursion   Рекурсивная функция ---
 Рекурсия - функция которая вызывает сама себя - Рекурсия не очень оптимизирована
 Хвостовая Рекурсия - функция вызывает сама себя в самом конце программы - Не отимизирована
 вместо Хвостовой Рекурсии - используем for или while
 Множественная рекурсия - это когда функция вызывает саму себя несколько раз в своем теле.
 Множественная рекурсия возникает, когда в теле функции происходит более одного рекурсивного вызова.
 Изменение лимита рекурсия по умолчанию глубина рекурсии = 1000

 import sys
 sys.setrecursionlimit(4000) - Эта функция устанавливает максимальную глубину рекурсии на указанное значение.

 # Показать глубину рекурсии
 print(sys.getrecursionlimit())  # -> 1000

 # Рекурсия в Python никак не оптимизирована
 # в Python - то как вы пишите рекурсивную функцию влияет только на её читаемость
 # в Других языках то как вы напишите рекурсивную функцию может повлиять и на скорость, будет ли она оптимизорована


 # НЕ ЯВЛЯЕТСЯ ХВОСТОВОЙ РЕКУРСИЕЙ   ХВОСТОВОГО ВЫЗОВА НЕТ       # ХВОСТОВАЯ РЕКУРСИЯ   ХВОСТОВОЙ ВЫЗОВ ЕСТЬ
 def factorial(n):                                               def factorial_tc(n, product=1):
     if n < 2:                                                       if n < 1:
         return 1                                                        return product
     return n * factorial(n - 1)                                     return factorial_tc(n - 1, product * n)

 print(factorial(5))  # -> 120                                   print(factorial_tc(5))  # -> 120

 # factorial - результат рекурсивного вызова нужно умножить на n после возвращения.
 # factorial_tc - рекурсивный вызов является последним выражением, и результат может быть возвращен напрямую
   БЕЗ дополнительных операций.


 -- Как работает РЕКУРСИЯ??? --                                                                            <----   <----
 Стек сначала накапливает вызовы рекурсивной функции, потом как только мы дошли до первого условия выхода(BASE CASE)
 Стек обратно разматывает вызовы рекурсивной функции и получает результат.
 (СНАЧАЛА ВСЕ НАКАПЛИВАЕТСЯ ПОТОМ ВСЕ РАСКРУЧИВАЕТСЯ НА СТЕКЕ ВЫЗОВОВ И МЫ ПОЛУЧАЕМ ГОТОВЫЙ РЕЗУЛЬТАТ)

 Предназначение рекурсии - разбивать/уменьшать поступившие данные до тех пор, пока не будет выполнено условие выхода.
 Рекурсивная функция всегда представлена комбинацией основного случая (base case) и рекурсивного вызова
 В Python рекурсия ограничена глубиной стека (по умолчанию - 1000) и не оптимизирована

 Частые ошибки:
 - нет условия выхода (base case)
 - нет return
 - нет уменьшения данных

 Пример Рекурсия со Списком(list):

 def my_sum(a_list: list) -> int:
    if not a_list:
        return 0
    if len(a_list) == 1:
        return a_list[0]
    return a_list[0] + my_sum(a_list[1:])


 if __name__ == '__main__':
     print(my_sum([10, 20, 30]))  # -> 60
     assert my_sum([]) == 0
     assert my_sum([1]) == 1
     assert my_sum([-1]) == -1
     assert my_sum([2, 2]) == 4
     assert my_sum([1, 2, 3]) == 6

 Пример Рекурсия со Строкой(str):                       Пример Рекурсия со Строкой(str) Мой вариант:

 def my_reverse(value : str) -> str:                    def my_reverse(value : str) -> str:
     if not value:                                          if not value:
         return ''                                              return ''
     if len(value) == 1:                                    if len(value) == 1:
         return value                                           return value
     if len(value) == 2:                                    if len(value) == 2:
         return f"{value[1]}{value[0]}"                         return f"{value[1]}{value[0]}"
     return my_reverse(value[1:]) + value[0]                return value[-1] + my_reverse(value[:-1]) # Мой вариант

 if __name__ == '__main__':                             if __name__ == '__main__':
     assert my_reverse('') == ''                            print(my_reverse('a'))       # -> a
     assert my_reverse('a') == 'a'                          print(my_reverse('1'))       # -> 1
     assert my_reverse('1') == '1'                          print(my_reverse('10'))      # -> 01
     assert my_reverse('10') == '01'                        print(my_reverse('hello'))   # -> olleh
     assert my_reverse('abc') == 'cba'
     assert my_reverse('hello') == 'olleh'

 Пример Рекурсия со Числом(int):                  # от перестановки мест слагаемых сумма не меняется

 def my_pow(x: int, y:int) -> int:                def my_pow(x: int, y:int) -> int:
     if y == 0:                                       if y == 0:
         return 1                                         return 1
     if y == 1:                                       if y == 1:
         return x                                         return x
     if y == 2:                                       if y == 2:
         return x * x                                     return x * x
     return x * my_pow(x, y - 1)                      return my_pow(x, y - 1) * x  # ПОМЕНЯЛИ МЕСТАМИ

 if __name__ == '__main__':                       if __name__ == '__main__':
     assert my_pow(100, 0) == 1                       print(my_pow(100, 0)) # -> 1
     assert my_pow(5, 1) == 5                         print(my_pow(5, 1))   # -> 5
     assert my_pow(7, 1) == 7                         print(my_pow(7, 1))   # -> 7
     assert my_pow(7, 2) == 49                        print(my_pow(7, 2))   # -> 49
     assert my_pow(2, 3) == 8                         print(my_pow(2, 3))   # -> 8
     assert my_pow(3, 3) == 27                        print(my_pow(3, 3))   # -> 27


  --- Exceptions try except finally    raise ---
 1) исключения это нормальный и важный механизм в питоне, не нужно стесняться его использовать,
 бросать и перехватывать исключения, писать свои типы исключений. К сожалению, по ряду причин не редко вижу,
  что программисты не кидают исключений в своих функциях
 2) когда пишем функции, то стараемся думать не в позитивном ключе, а в плане того, что может пойти не так.
  В таких случаях бросаем исключения, делаем это как можно раньше (в начале функции)
 3) Механизм по-умолчанию в питоне просто выведет текст исключения и завершит работу программы,
 если нам нужно другое поведение то используем try/except/finally
 4) блоков except может быть несколько, каждый со своим типом исключения и логикой,
 но важно чтобы исключение было конкретным, и в блоке всегда делаем хоть что-то. НЕ проглатываем исключения!
 5) finally выполняется в любом случае, даже если исключения не упало, НО важно понимать,
 что файналли это не какой то волшебный блок, исключение может упасть и там, нужно обдумывать логику этого блока
  (например не использовать переменные, которые могли не быть созданы)
 6) raise используем чтобы бросить исключение самостоятельно, при этом можно указать какое конкретно исключение бросить.
  Если не указать то будет брошено последнее упавшее исключение (важно чтобы оно было!)
 7) не стесняемся писать свои классы исключений,
 главное давать им понятные имена и прописываем в доке случаи, когда они могут быть выброшены

  В общем не боимся и не стесняемся работать с исключениями!

 try:
     2 / 0
 except ZeroDivisionError as z:
     print(f"You can't divide by zero   {z}")

 def divide(a: int, b: int) -> int:
    if not isinstance(a, int) or not isinstance(b, int):
        raise ArgumentIsNotIntegerError('Must be ints')
    if b == 0:
        raise ArgumentEqualZeroError("No ZERO")
    return a // b


 # Интересный пример Присвоения
 try:
     a = 'a' + 10
 except TypeError:
     a = 1000
 print(a)  # -> 1000


 except* - используются для обработки ExceptionGroups.

 exception ExceptionGroup(msg, excs) - может обертывать только подклассы Exception.
 exception BaseExceptionGroup(msg, excs) - может обертывать любое исключение.
 ExceptionGroup, BaseExceptionGroup - заключают исключения в последовательность excs.

 try:
     raise ExceptionGroup("eg",
         [ValueError(1), TypeError(2), OSError(3), OSError(4)])
 except* TypeError as e:
     print(f'caught {type(e)} with nested {e.exceptions}')
 except* OSError as e:
     print(f'caught {type(e)} with nested {e.exceptions}')

 Что такое сцепление исключений?
 старое исключение сохраняется в атрибуте данных __context__
 Также, можно связывать исключения в одну цепь или заменять старые новыми.
 Для этого используется конструкция raise новое_исключение from старое_исключение либо raise новое_исключение from None

 Когда будет выполнена ветка else в конструкции  try  except  else?
 Ветка else будет выполнена только в том случае, если исключения не было возбуждено в блоке try
 Блок else выполняется, если в процессе выполнения блока try не возникло исключений

 `try` и `except` занимают немного ресурсов, НО ИХ ИСПОЛЬЗОВАНИЕ ДОБАВЛЯЕТ НАКЛАДНЫЕ РАСХОДЫ ПРИ ВОЗНИКНОВЕНИИ ИСКЛЮЧЕНИЙ.
  В нормальных условиях их влияние незначительно.

 В каких случаях можно обработать SyntaxError?
 существуют ситуации, когда оно может возникнуть во время исполнения и быть обработано, а именно:
 ошибка синтаксиса в импортируемом модуле;
 ошибка синтаксиса в коде, который представляется строкой и передаётся функции eval или exec.

 Функция exec - Она принимает строку, в которой содержится код, и выполняет ее сразу же - может создать перменные (globals,locals)
 Функция eval - вычисляет строковое выражение и возвращает его значение. Например, eval("1 + 1") возвращает 2
 Функция compile - принимает строку с кодом Python и преобразует ее в объект кода.Который затем можно выполнить
 с помощью exec() или eval().
 eval() - подходит для вычисления простых выражений, exec() используется для выполнения сложных конструкций
 eval() - принимает только одно выражение , exec() может принимать блок кода,
 compile() - позволяет гибко управлять процессом выполнения кода, выбирая нужный режим работы.
 Например, exec(compile('for i in range(5): print(i)', '', 'exec')) также напечатает числа от 0 до 4.


 Функции eval() и ast.literal_eval() интерпретируют строки как код Python.
 ast.literal_eval() - обрабатывает только строки, представляющие литералы, более безопасный в применении.
 eval()             - функция способна выполнить любые команды. Более Производительный

 # Наглядный пример
 import ast

 s = "deque([1, 2, 3])"
 print(eval(s))              # -> deque([1, 2, 3])
 print(ast.literal_eval(s))  # -> ValueError: malformed node or string on line 1: <ast.Call object at 0x000001ED2A76A470>


 exec предназначен для оператора и ничего не возвращает. eval предназначен для выражения и возвращает значение выражения.
 выражение означает «что-то», а утверждение означает «сделать что-то».

 exec не является выражением: оператор в Python 2.x и функция в Python 3.x. Он компилирует и немедленно оценивает
 оператор или набор операторов, содержащийся в строке. Пример:

 exec('print(5)')  # prints 5.
 #exec 'print 5'     # if you use Python 2.x, nor the exec neither the print is a function there
 # если вы используете Python 2.x, ни exec, ни print там не является функцией
 exec('print(5)\nprint(6)')  # prints 5{newline}6.
 exec('if True: print(6)')  # prints 6.
 exec('5')  # does nothing and returns nothing. ничего не делает и ничего не возвращает.

 eval— это встроенная функция ( не оператор), которая оценивает выражение и возвращает значение, которое возвращает выражение. Пример:
 x = eval('5')  # x <- 5
 x = eval('%d + 6' % x)  # x <- 11
 x = eval('abs(%d)' % -100)  # x <- 100
 x = eval('x = 5')  # INVALID; assignment is not an expression.
 x = eval('if 1: x = 4')  # INVALID; if is a statement, not an expression.

 What's the difference between eval, exec, and compile?   -> stackoverflow
 Короткий ответ:
 eval используется для оценки одного динамически сгенерированного выражения Python.
 exec используется для выполнения динамически сгенерированного кода Python только из-за его побочных эффектов.

 eval и exec имеют эти два различия:

 1) eval принимает только одно выражение , exec может принимать блок кода, содержащий операторы Python:
 циклы, try: except: инициализации class функций/методов def и т. д.

 Выражение в Python — это все, что вы можете иметь в качестве значения при назначении переменной:

 a_variable = (anything you can put within these parentheses is an expression)
 Переменная = все, что вы можете поместить в эти круглые скобки, является выражением

 2) eval возвращает значение данного выражения, тогда как exec игнорирует возвращаемое значение из своего кода и всегда
 возвращает None(в Python 2 это оператор и его нельзя использовать как выражение, поэтому он действительно ничего не возвращает).

 В версиях 1.0–2.7 exec это было утверждением, поскольку CPython требовалось создать другой тип объекта кода для функций,
 который использовался exec для побочных эффектов внутри функции.

 В Python 3 exec — это функция; его использование не влияет на скомпилированный байт-код функции, в которой он используется.

 Таким образом, в основном:
 a = 5
 eval('37 + a')   # it is an expression
 # 42
 exec('37 + a')   # it is an expression statement; value is ignored (None is returned)
 exec('a = 47')   # modify a global variable as a side effect
 print(a) -> 47
 eval('a = 48')  # you cannot evaluate a statement
 a = 48
      ^
 SyntaxError: invalid syntax

 Режим compile in 'exec' компилирует любое количество операторов в байт-код, который неявно всегда возвращает None,
 тогда как в 'eval' режиме он компилирует одно выражение в байт-код, который возвращает значение этого выражения.

 eval(compile('42', '<string>', 'exec'))           # code returns None
 # print(eval(compile('42', '<string>', 'eval')))  # code returns 42
 # 42
 exec(compile('42', '<string>', 'eval'))           # code returns 42,
 # None                                            # but ignored by exec

 В 'eval' режиме (и, следовательно, с eval функцией, если передается строка), compile вызывает исключение, если исходный
 код содержит операторы или что-либо еще, кроме одного выражения:

 compile('for i in range(3): print(i)', '<string>', 'eval')
 # for i in range(3): print(i)
 #     ^^^
 # SyntaxError: invalid syntax

 На самом деле утверждение «eval принимает только одно выражение» применяется только тогда, когда строка
 (содержащая исходный код Python ) передается в eval. Затем он внутренне компилируется в байт-код с использованием.
 compile(source, '<string>', 'eval') Вот в чем действительно разница.

 Если code объект (который содержит байт-код Python ) передается в exec или eval, они ведут себя одинаково ,
 за исключением того факта, что exec игнорируется возвращаемое значение, все равно возвращает None всегда.
 Таким образом, можно использовать eval для выполнения чего-то, что имеет операторы, если вы просто compile
 передадите это в байт-код вместо передачи в виде строки:

 eval(compile('if 1: print("Hello")', '<string>', 'exec')) -> Hello

 Работает без проблем, хотя скомпилированный код содержит операторы. Он все равно возвращает результат None,
 поскольку это возвращаемое значение объекта кода, возвращенного из compile.

 PyEval_EvalCode   Python C API: PyObject *PyEval_EvalCode(PyObject *co, PyObject *globals, PyObject *locals)
 Если взглянуть на исходный код eval и exec в CPython 3, это совершенно очевидно; они оба вызывают PyEval_EvalCode
 с одинаковыми аргументами, с той лишь разницей, что exec явно возвращает None.


 --- модуль warning ---
 В модуле warning собраны функции для работы с предупреждениями.

 Предупреждения обычно выводятся на экран в ситуациях, когда не гарантируется ошибочное поведение и программа,
  как правило, может продолжать работу, однако пользователя следует уведомить о чём-либо.
  Базовым классом для предупреждений является Warning, который наследуется от Exception.
  Базовым классом-наследником Warning для пользовательских предупреждений является UserWarning.

  Python отображает трассировку (traceback) при возникновении исключения в вашем коде
  Traceback (трассировка) — это отчет, который содержит вызовы выполненных функций в вашем коде в определенный момент.

  --- Exceptions   Исключения ---
  Исключение — это событие, возникающее во время исполнения программы, нарушающее нормальный ход выполнения

  BaseException - Базовый класс для всех встроенных исключений. Есть 4 его подкласса исключений:

  SystemExit - исключение, порождаемое функцией sys.exit при выходе из программы. Вызывается функцией sys.exit()
  KeyboardInterrupt - порождается при прерывании программы пользователем (обычно сочетанием клавиш Ctrl+C).
  GeneratorExit - порождается при вызове метода close объекта generator.
  Exception - является родителем всех основных исключений, с которыми мы сталкивается при написании программ.

  Exception:
  ArithmeticError: возникающих при различных арифметических ошибках:
  -- OverflowError, ZeroDivisionError(деление на ноль), FloatingPointError
  AssertionError - выражение в функции assert ложно.
  AttributeError - объект не имеет данного атрибута (значения или метода).
  BufferError - операция, связанная с буфером, не может быть выполнена.
  EOFError - функция наткнулась на конец файла и не смогла прочитать то, что хотела.
  ImportError - не удалось импортирование модуля или его атрибута.
  -- ModuleNotFoundError -   когда модуль не может быть найден
  LookupError - некорректный индекс или ключ.
  -- IndexError - когда индекс последовательности выходит за пределы допустимого диапазона.
  -- KeyError - Возникает, когда ключ сопоставления (словаря) не найден в наборе существующих ключей.
  MemoryError - недостаточно памяти.
  NameError - не найдено переменной с таким именем.
  -- UnboundLocalError - сделана ссылка на локальную переменную в функции, но переменная не определена ранее.
  OSError - ошибка, связанная с системой.
  -- BlockingIOError - блокировка ввода-вывода. Когда операция блокируется на объекте (например, сокете).
  -- ChildProcessError - неудача при операции с дочерним процессом
  -- ConnectionError - базовый класс для исключений, связанных с подключениями.
     -- BrokenPipeError - в случае ошибок соединения при работе с каналами.
     -- ConnectionAbortedError - когда попытка соединения прерывается узлом.
     -- ConnectionRefusedError - когда одноранговый узел отклоняет попытку соединения.
     -- ConnectionResetError - при сбросе соединения партнером.
  -- FileExistsError - при попытке создать файл или каталог, который уже существует.
  -- FileNotFoundError - файл или директория не существует.
  -- InterruptedError  - когда системный вызов прерывается входящим сигналом.
  -- IsADirectoryError - ожидался файл, но это директория.
  -- NotADirectoryError - ожидалась директория, но это файл.
  -- PermissionError - не хватает прав доступа.
  -- ProcessLookupError - указанного процесса не существует.
  -- TimeoutError - закончилось время ожидания.
  -- ReferenceError - попытка доступа к атрибуту со слабой ссылкой.
  -- RuntimeError - возникает, когда исключение не попадает ни под одну из других категорий.
     -- NotImplementedError - возникает, когда абстрактные методы класса требуют переопределения в дочерних классах.
     -- RecursionError - когда интерпретатор обнаруживает sys.getrecursionlimit() превышение максимальной глубины рекурсии
  -- StopAsyncIteration - Должен быть вызван __anext__() методом объекта асинхронного итератора, чтобы остановить итерацию.
  -- StopIteration - порождается встроенной функцией next, если в итераторе больше нет элементов.
  -- SyntaxError - Возникает, когда синтаксический анализатор обнаруживает синтаксическую ошибку.
     -- IndentationError - неправильные отступы.
     -- TabError - смешивание в отступах табуляции и пробелов.
  -- SystemError - внутренняя ошибка.
  -- TypeError - операция применена к объекту несоответствующего типа.
  -- ValueError - функция получает аргумент правильного типа, но некорректного значения.
     -- UnicodeError - при возникновении ошибки кодирования или декодирования, связанной с Unicode.
        -- UnicodeEncodeError - исключение, связанное с кодированием unicode.
        -- UnicodeDecodeError - исключение, связанное с декодированием unicode.
        -- UnicodeTranslateError - исключение, связанное с переводом unicode.
  -- Warning - предупреждение.
     -- BytesWarning - для предупреждений, связанных с bytes и bytearray.
     -- DeprecationWarning - для предупреждений об устаревших функциях
     -- EncodingWarning - для предупреждений, связанных с кодировками.
     -- FutureWarning - об устаревших функциях, если эти предупреждения предназначены для конечных пользователей.
     -- ImportWarning - для предупреждений о возможных ошибках при импорте модулей.
     -- PendingDeprecationWarning - станут устаревшими в будущем, но не устарели в данный момент.
     -- ResourceWarning - для предупреждений, связанных с использованием ресурсов.
     -- RuntimeWarning - для предупреждений о сомнительном поведении во время выполнения.
     -- SyntaxWarning - для предупреждений о сомнительном синтаксисе.
     -- UnicodeWarning - для предупреждений, связанных с Unicode.
     -- UserWarning - для пользовательских предупреждений

 -- BaseException Базовый класс для всех встроенных исключений --
 Атрибуты и методы BaseException:
 args               - Кортеж аргументов, передаваемых конструктору исключения.
 with_traceback(tb) - устанавливает аргумент tb в качестве новой обратной трассировки для исключения и возвращает объект исключения.
 __traceback__      - Доступное для записи поле, содержащее объект трассировки, связанный с этим исключением.
 add_note           - добавляет строку примечания к примечаниям исключения.
 __notes__          - это список заметок этого исключения, которые были добавлены add_note

 -- Контекст исключения Exception context --
 Три атрибута объектов исключений предоставляют информацию о контексте, в котором возникло исключение:

 BaseException.__context__ - используется при множественном вызове исключений и содержит в себе прямую ссылку на то
 исключение, которое возникло первым.

 BaseException.__cause__  - содержит в себе прямую ссылку на то исключение, по причине которого оно возникло (from cause).

 BaseException.__suppress_context__ - отвечает за подавление значения __context__ и используется в конструкции raise from.

 Пример 1:
 Вызов одного исключения, во время обработки другого исключения (контекст, который содержит в себе атрибут __context__):

 try:
    raise ValueError
 except ValueError:
    raise TypeError

 В тексте ошибки -> During handling of the above exception, another exception occurred:
 Таким образом, отображается весь необходимый контекст: изначально обрабатывалось исключение ValueError и во время
 его обработки возникло другое исключение TypeError.

 Пример 2:
 При использовании конструкции raise from (контекст, который содержит в себе атрибут __cause__):

 try:
    raise ValueError
 except ValueError as e:
    raise TypeError from e

 В тексте ошибки -> The above exception was the direct cause of the following exception:
 Благодаря чему мы понимаем, что исключение ValueError, которое было выброшено, возникло по причине другого исключения TypeError.

 - Однако, что же это за конструкция raise from None?
 raise from None - На самом деле, эта конструкция применяется для того, чтобы скрыть (подавить) остальной контекст исключения.

 try:
    raise ValueError
 except ValueError:
    raise TypeError from None
 В которой не содержится никакой информации об исходном исключении ValueError - оно было скрыто.

 Итоги:
 И если говорить на более глобальном уровне, который виден при запуске кода:
 - Конструкция raise <ExceptionType> from <cause> используется для того, чтобы сохранить дополнительный контекст исключения.
 - Конструкция raise <ExceptionType> from None используется для того, чтобы показать только последнее исключение,
 и скрыть весь остальной контекст.

 -- Модуль traceback в Python, трассировки стека --
 Печать или извлечение обратной трассировки стека

 Модуль traceback предоставляет стандартный интерфейс для извлечения, форматирования и вывода на печать трассировок
 стека программ Python. Модуль точно имитирует поведение интерпретатора Python при печати трассировки стека.

 Модуль traceback полезен, когда появляется необходимость распечатать трассировку стека под управлением программы.

 Модуль использует объекты трассировки — это объекты типа types.TracebackType, которые присваиваются полю
 __traceback__ экземпляров BaseException.

 Модуль использует объекты трассировки - это тип объекта, который сохраняется в переменной sys.last_traceback
 и возвращается как третий элемент из sys.exc_info().

 Модуль определяет следующие функции:
 traceback.print_tb() - печать трассировки стека,
 traceback.print_exception() - печать исключения и трассировку стека,
 traceback.print_exc() - сокращение для вызова traceback.print_exception(),
 traceback.print_last() - еще одно сокращение для вызова print_exception(),
 traceback.print_stack() - печатает записи трассировки, начиная с точки вызова,
 traceback.format_exc() - похожа на traceback.print_exc(limit) но возвращает строку вместо печати,

 Пример  различные способы печати и форматирования стека:
 import traceback
 def another_function():
     lumberstack()

 def lumberstack():
     traceback.print_stack()
     print(repr(traceback.extract_stack()))
     print(repr(traceback.format_stack()))

 another_function()

 Модуль также определяет следующие классы:
 TracebackException Objects - создаются на основе реальных исключений для упрощенного сбора данных для последующей печати.
 StackSummary Objects       - стек вызовов, готовый к форматированию.
 FrameSummary Objects       - Объект FrameSummary представляет один кадр в трассировке .

 --- set (Множество) ---
 set - множество, хешсет, ИЗМЕНЯЕМЫЙ, НЕУПОРЯДОЧЕННЫЙ набор hashable объектов, доступ и проверка наличия O(1)
 Элементами множества может быть любой неизменяемый тип данных: числа, строки, кортежи, frozenset.
 Изменяемые типы данных не могут быть элементами множества, в частности, нельзя сделать элементом множества список
 (вместо этого используйте неизменяемый кортеж), словарь или другое множество
 frozenset - неизменяемый брат множества
 Класс frozenset() преобразует строку или любую последовательность(итерацию) "хешируемых" объектов в неизменяемое
 множество frozenset (неупорядоченная, неизменяемая последовательность с исключением дубликатов элементов в последовательности).

 set может хранить - { hashable }  {НЕИЗМЕНЯЕМЫЕ}  {Immutable}

 Множество в python - "контейнер", содержащий не повторяющиеся элементы в случайном порядке. Без дубликатов.

 УПОРЯДОЧЕННЫЙ - означает, что элементы структуры хранятся в том порядке, в котором они были добавлены
 НЕ УПОРЯДОЧЕННЫЙ - означает, что элементы структуры хранятся в случайном порядке.

 Тип set  изменчив — содержимое можно изменить с помощью таких методов, как add() и remove().

 только одно из них может быть в set - {1, 1.0, True} -> 1, {0, 0.0, False} -> 0

 -- Что такое коллизия? --
 Когда хеш-функция возвращает один и тот же ответ для разных данных.

 Коллизия - если у двух не равных элементов hash одинаковый(больше относиться к самописным классам)
 Коллизия - Событие, когда два хеша совпали, а не должны, называется коллизией

 Зондирование - это технология, используемая в хэш-таблицах для нахождения свободных ячеек в случае коллизий. Когда два
 ключа имеют одинаковый хэш и пытаются занять одно место, применяется зондирование для поиска следующего доступного места.

 Зондирование — это метод разрешения коллизий в хэш-таблицах. Когда два ключа имеют одинаковый хэш и пытаются занять
 одно и то же место, зондирование помогает найти следующую свободную ячейку, проверяя соседние индексы.
 Существует несколько стратегий зондирования, включая линейное и квадратичное.


 -- Как решить проблему коллизии? --
 Проблемы коллизии в Python, связанные с хешированием объектов (например, при использовании СЛОВАРЕЙ или МНОЖЕСТВ),
 разрешаются с помощью следующих методов:

 1. **Хеш-функция**: Python использует хеш-функцию для преобразования объектов (как правило, неизменяемых) в хеш-значения.
 Если два объекта имеют одинаковое хеш-значение, это называется коллизием.

 2. **Методы разрешения коллизий**:
 - **Метод цепочек**: Каждое ведро (или ячейка) хеш-таблицы может содержать список или другой контейнер для хранения
 всех элементов, имеющих одно и то же хеш-значение.

 - **Линейное или квадратичное пробирование**: Используется для поиска следующей пустой ячейки в случае коллизии.
 При этом происходит последовательная проверка ячеек в хеш-таблице.

 - **Удвоение размера хеш-таблицы**: Когда хеш-таблица достигает определенного уровня заполненности, её размер может
 быть увеличен, чтобы уменьшить количество коллизий.

 3. **Кастомизация хешей и сравнений**: Можно переопределить методы `__hash__()` и `__eq__()` в пользовательских классах,
 чтобы изменить способ, которым определяются хеши и равенства объектов, также что может помочь избежать коллизий.

 Эти подходы помогают эффективно управлять хеш-значениями и минимизировать влияние коллизий на производительность операций.


 -- Проблему коллизии в Python можно решить с помощью следующих подходов --:

 1. **Метод цепочек**: Каждый элемент, имеющий одинаковый хеш, хранится в виде списка (или других контейнеров)
  внутри одной ячейки хеш-таблицы.

 2. **Линейное пробирование**: При коллизии проверяется следующая ячейка последовательно, пока не найдется пустая.

 3. **Квадратичное пробирование**: Аналогично линейному, но шаг увеличивается квадратично (1, 4, 9 и т. д.) для поиска
  свободной ячейки.

 4. **Пересчитывание хеш-таблицы**: Если таблица становится слишком заполненной, её размер можно увеличить
  (реализация ресайза) и перераспределить элементы по новым хеш-значениям.

 5. **Переопределение методов**: В пользовательских классах можно переопределить методы `__hash__()` и `__eq__()`,
  чтобы управлять хешированием и сравнением объектов, уменьшая вероятность коллизий.

 Эти стратегии помогают эффективно справляться с коллизиями и обеспечивают быструю работу хеш-таблиц.

  На практике вам не нужно беспокоиться о коллизиях в Python, так как встроенные структуры данных, такие как словари,
 множества уже эффективно обрабатывают их.


 set и dict используют один и тот же алгоритм хэширования

 O(1) - значит за постоянное время
 скорость(время) доступа к элементам одинаковая, скорость не зависит от количества элементов

 Сложность получения элемента в Dict и Set в наилучшем случае составляет O(1),
 поскольку элемент может быть получен просто с помощью хэш-функции в качестве индекса массива.
 Однако в худшем случае, когда возникают хэш-коллизии, сложность может вырасти до O(n), где n - количество элементов в таблице.

 Ну и сложность операций добавления, удаления и поиска элементов в Set и Dict также составляет O(1) в наилучшем случае
 и O(n) в худшем случае.


 # Словари и множества очень зависят от своих хэш-функций. Если хэш-функция некоторого типа данных не дает скорость О(1),
 # любой словарь или набор содержащий этот тип, больше не будет иметь гарантии скорость О(1)             <-----  <-----

 Зависимость от хэш-функций: Таким образом, эффективность словарей и множеств действительно сильно зависит от качества
 и производительности их хэш-функций. Если хэш-функция для определенных типов данных не обеспечивает быстрое построение
 хэш-значений или если она ведет к множеству коллизий, производительность структуры данных может упасть,
 и доступ к элементам перестанет быть O(1).
 В заключение, правильные хэш-функции критически важны для достижения оптимальной производительности словарей и множеств.


 для самописных классов если мы не переопределяем __hash__
 hash будет равен адрес в памяти // поделенный на 16
 class Cat:
     pass

 tom = Cat()
 print(hash(tom))      # ->  151995328801
 print(id(tom))        # ->  2431925260816
 print(id(tom)//16)    # ->  151995328801

           !!!Вопросы!!!
 Вопрос 1: tuple можно положить в dict или в set?
 Ответ 1: Tuple можно положить в dict или в set, но только если он содержить ХЭШИРУЕМЫЕ элементы

 Вопрос 2: А можно ли set или dict положить в set или dict?
 Ответ 2: Нет Нельзя!!!

 Единственное отличие set от frozenset заключается в том, что set - изменяемый тип данных, а frozenset - нет.
 Примерно похожая ситуация с списками и кортежами.

 class set([iterable])
 class frozenset([iterable])

 Множество, Набор(set) - это неупорядоченная коллекция без повторяющихся элементов.
 Множество(set) можно создавать несколькими способами:

 Используйте список элементов, разделенных запятыми, в фигурных скобках:        a_set = {1, 2, 3}
 Используйте set comprehension:                                  a_set = {c for c in 'abracadabra' if c not in 'abc'}
 Используя конструктор типа:                                     a_set = set() или a_set = set(iterable)
 Создаём множество: set(), set('foobar'), set(('a', 'b', 'foo')), set(['a', 'b', 'foo']),  set({'a', 'b', 'foo'})

 Примечание: чтобы создать пустое Множество(set) - нужно использовать set(), а не {}
  {} - создаст пустой словарь(dict)

 Элементы Множества(set), как и Ключи словаря(dict), должны быть хешируемыми .

 С множествами можно выполнять множество операций: находить объединение, пересечение, разница, симметричная разница


 # Устранить дубликаты и оставить Порядок элементов                 <-----
 my_lst = [10, 10, 10, 2, 3]
 # Порядок НЕ УПОРЯДОЧЕННЫЙ!!!
 print(set(my_lst))                          # -> {3, 10, 2}

 # Сохраняем порядок
 print(dict.fromkeys(my_lst).keys())        # -> dict_keys([10, 2, 3])
 print(list(dict.fromkeys(my_lst).keys()))  # -> [10, 2, 3]


 Instances of set and frozenset provide the following operations:
 Экземпляры set и frozenset поддерживают следующие операции:   Общие операции с множествами set и frozenset

 -- Методы множества:
 len(s) - вернет количество элементов в множестве s(размер множества).
 x in s - принадлежит ли x множеству s.
 x not in s - Не принадлежит ли x множеству s.
 set.isdisjoint(other) - True, если set и other не имеют общих элементов. Если set и other имеют общие элементы = False
 set == other - все элементы set принадлежат other, все элементы other принадлежат set.
 set.issubset(other) или set <= other - True если все элементы set принадлежат other иначе False
 set < other - является ли set подмножеством other, то есть выполняются ли условия set <= other и set != other.
 set.issuperset(other) или set >= other - True, множество set является надмножеством other, если нет вернет False.
 set > other - является ли set надмножеством other, то есть выполняются ли условия set >= other.
 set.union(*others) или set | other | ... - вернет объединение set и *others
 set.intersection(*others) или set & other & ... - вернет пересечение set и *others
 set.difference(*others) или set - other - ... - вернет set элементов, которых нет во всех *others
 set.symmetric_difference(other) или set ^ other - вернет set, симметричная разность.  ^ оператор крышка или домик - ^
 симметричная разность - элементы встречающиеся в set и other, но не встречающиеся в обоих. {1, 2} ^ {2, 3} = {1, 3}
 set.copy() - вернет неглубокую копия множества.

 Операции ТОЛЬКО с изменяемым множеством set:   НЕЛЬЗЯ применить к неизменяемым множествам frozenset:

 set.update(*others) или set |= other | ... - добавит в set объединение set и *others                          # inplace
 set.intersection_update(*others) или set &= other & ... - добавит в set пересечение set и *others             # inplace
 set.difference_update(*others) или set -= other | ... - вычитание. Удалит элементы в set которые есть в *others # inplace
 set.symmetric_difference_update(other) или set ^= other - добавит в set симметрическую разность set и other     # inplace
 set.add(elem) - добавляет элемент в множество.                                                                # inplace
 set.remove(elem) - удаляет элемент из множества. KeyError, если такого элемента не существует.                # inplace
 set.discard(elem) - удаляет элемент, если он находится в множестве, не поднимая исключений                    # inplace
 set.pop() - удаляет произвольный элемент множества                                                            # inplace
 set.clear() - удаляет все элементы из множества                                                               # inplace


 -- Примеры: Общие операции с множествами set и frozenset которые только возвращают результат:
 ---------------------------  len(s)  ----------------------------------------------------------------------------------
 a_set = {1, 1, 2, 3}                                     a_set = {1, 1, 1, 1, 1, 1, 1, 1, 1}
 a_frozenset = frozenset((1, 1, 2, 3))                    a_frozenset = frozenset({1, 1, 1, 1, 1, 1, 1, 1, 1})
 print(len(a_set))         # -> 3                         print(len(a_set))        # -> 1 <----
 print(len(a_frozenset))   # -> 3                         print(len(a_frozenset))  # -> 1 <----
 print(type(a_set))        # -> <class 'set'>             print(a_set)             # -> {1}             <----
 print(type(a_frozenset))  # -> <class 'frozenset'>       print(a_frozenset)       # -> frozenset({1})  <----

 ---------------------------  x in s  ----------------------------------------------------------------------------------
 a_set = {1, 1, 2, 3}                        a_set = {1, 1, 2, 3}
 a_frozenset = frozenset((1, 1, 2, 3))       a_frozenset = frozenset((1, 1, 2, 3))
 print(1 in a_set)          # -> True        print(100 in a_set)         # -> False
 print(1 in a_frozenset)    # -> True        print(100 in a_frozenset)   # -> False

 ---------------------------  x not in s  ------------------------------------------------------------------------------
 a_set = {1, 1, 2, 3}                        a_set = {1, 1, 2, 3}
 a_frozenset = frozenset((1, 1, 2, 3))       a_frozenset = frozenset((1, 1, 2, 3))
 print(1 not in a_set)          # -> False   print(a_frozenset not in a_set)   # -> True
 print(100 not in a_frozenset)  # -> True    print(a_set not in a_frozenset)   # -> True

 ---------------------------  isdisjoint(other)  -----------------------------------------------------------------------
 a_set = {1, 1, 2, 3}                                        a_set = {1, 1, 2, 3}
 a_frozenset = frozenset((1, 1, 2, 3))                       a_frozenset = frozenset([1, 1, 2, 3])
 print(a_set.isdisjoint([2, 3, 4]))        # -> False        print(a_set.isdisjoint(a_frozenset)) # -> False
 print(a_frozenset.isdisjoint({100, 200})) # -> True         print(a_frozenset.isdisjoint(a_set)) # -> False
 print(a_set, a_frozenset) # {1, 2, 3} frozenset({1, 2, 3})  print(a_set, a_frozenset) # {1, 2, 3} frozenset({1, 2, 3})

 ---------------------------  issubset(other)  set1 <= set2  -----------------------------------------------------------
 a_set = {1, 1, 2, 3}
 a_frozenset = frozenset((1, 1, 2, 3))
 print(a_set.issubset((1, 2, 3, 4, 5))) # -> True
 print(a_frozenset.issubset([1, 2]))    # -> False
 print(a_set)       # -> {1, 2, 3}
 print(a_frozenset) # -> frozenset({1, 2, 3})

 Пример <= Работает только с set и frozenset
 print(a_set <= a_frozenset) # -> True
 print(a_set <= (1, 2, 3, 4, 5))    # -> TypeError: '<=' not supported between instances of 'set' and 'tuple' <-----
 print(a_set <= [1, 2, 3, 4, 5])    # -> TypeError: '<=' not supported between instances of 'set' and 'list'  <-----
 print(a_set <= {'one':1, 'two':2}) # -> TypeError: '<=' not supported between instances of 'set' and 'dict'  <-----
 print(a_set <= "ABC")              # -> TypeError: '<=' not supported between instances of 'set' and 'str'   <-----
 print(a_set <= 100)                # -> TypeError: '<=' not supported between instances of 'set' and 'int'   <-----

 ---------------------------  set < other, set <= other and set != other -----------------------------------------------
 a_set = {1, 1, 2, 3}
 a_frozenset = frozenset((1, 1, 2, 3))
 print(a_set < a_frozenset) # -> False
 a_set.add(10)
 print(a_frozenset < a_set) # -> True
 print(a_set < a_frozenset) # -> False
 print(a_frozenset)         # -> frozenset({1, 2, 3})
 print(a_set)               # -> {10, 1, 2, 3}

 Пример set < other Работает только с set и frozenset
 print(a_set < (10, 20)) # -> TypeError: '<' not supported between instances of 'set' and 'tuple'

 ---------------------------  issuperset(other)  set1 >= set2  ---------------------------------------------------------
 a_set = {1, 1, 2, 3}                              a_set = {1, 1, 2, 3}
 a_frozenset = frozenset((1, 1, 2, 3))             a_frozenset = frozenset((1, 1, 2, 3))
 print(a_set.issuperset(a_frozenset)) # -> True    print(a_set >= a_frozenset)  # -> True
 print(a_set.issuperset([100, 200]))  # -> False   print(a_set >= frozenset([1, 2, 3, 4]))  # -> False
 print(a_set.issuperset("abc"))       # -> False   print(a_set >= (1, 2)) # TypeError  Работает только с set и frozenset

 ---------------------------  set > other, set >= other and set != other  ----------------------------------------------
 a_set = {1, 1, 2, 3}
 a_frozenset = frozenset((1, 1, 2, 3))
 print(a_set > a_frozenset) # -> False
 a_set.remove(1)
 print(a_frozenset > a_set) # -> True
 print(a_set > a_frozenset) # -> False
 print(a_frozenset)         # -> frozenset({1, 2, 3})
 print(a_set)               # -> {2, 3}

 Пример set > other Работает только с set и frozenset
 print(a_set > "AAA") # -> TypeError: '>' not supported between instances of 'set' and 'str' <-----

 ---------------------------  union(*others)  set1 | set2 | ... --------------------------------------------------------
 a_set = {1, 1, 2, 3}
 a_frozenset = frozenset((1, 1, 2, 3))
 print(a_set.union(['a', 'b']))    # -> {1, 2, 3, 'b', 'a'}
 print(a_frozenset.union(("XY")))  # -> frozenset({1, 2, 3, 'X', 'Y'})
 print(a_set)                      # -> {1, 2, 3}
 print(a_frozenset)                # -> frozenset({1, 2, 3})

 Пример set1 | set2 | ... Работает только с set и frozenset
 print(a_set | a_frozenset)  # -> {1, 2, 3}
 print(a_frozenset | a_set)  # -> frozenset({1, 2, 3})
 print(a_set | list())       # -> TypeError: unsupported operand type(s) for |: 'set' and 'list' <-----

 ---------------------------  intersection(*others)  set & other & ... -------------------------------------------------
 a_set = {1, 1, 2, 3}
 a_frozenset = frozenset((1, 1, 2, 3))
 print(a_set.intersection([1, 2])) # -> {1, 2}
 print(a_frozenset.intersection("ABC")) # -> frozenset()
 print(a_set.intersection(a_frozenset)) # -> {1, 2, 3}

 Пример set & other & ... Работает только с set и frozenset
 a_set = {1, 1, 2, 3}
 a_frozenset = frozenset((1, 1, 2, 3))
 print(a_set & a_frozenset) # -> {1, 2, 3}
 print(a_set & {10, 1})     # -> {1}
 print(a_set & {"A": []})   # -> TypeError: unsupported operand type(s) for &: 'set' and 'dict' <-----

 ---------------------------  difference(*others)  set - other - ... ---------------------------------------------------
 a_set = {1, 1, 2, 3}
 a_frozenset = frozenset((1, 1, 2, 3))
 print(a_set.difference([1, 2], (10, 20))) # -> {3}

 Пример set - other - ... Работает только с set и frozenset
 print(a_set - a_frozenset) # -> set()
 print(a_frozenset - a_set) # -> frozenset()
 print(a_set - [1, 2])      # -> TypeError: unsupported operand type(s) for -: 'set' and 'list'

 ---------------------------  symmetric_difference(other)  set ^ other -------------------------------------------------
 a_set = {1, 1, 2, 3}
 a_frozenset = frozenset((1, 1, 2, 3))
 print(a_set.symmetric_difference([1, 20])) # -> {2, 3, 20}

 Пример set ^ other ^ ... Работает только с set и frozenset
 print(a_set ^ a_frozenset) # -> set()
 print(a_frozenset ^ a_set) # -> frozenset()
 print(a_set ^ (1, 2))      # -> TypeError: unsupported operand type(s) for ^: 'set' and 'tuple'

 ---------------------------  copy()  ----------------------------------------------------------------------------------
 # Обрати внимание id Разные               # Обрати внимание id Одинаковые  Возвращает один и тот же обьект
 a_set = {1, 1, 2, 3}                      a_frozenset = frozenset({1, 1, 2, 3})
 new_set = a_set.copy()                    new_set = a_frozenset.copy()
 print(id(new_set))  # -> 1707266272704    print(id(new_set))        # -> 2306884693888
 print(id(a_set))    # -> 1707266271136    print(id(a_frozenset))    # -> 2306884693888

 a_set.remove(1)                           del a_frozenset
 print(new_set)  # -> {1, 2, 3}            print(new_set)      # -> frozenset({1, 2, 3})
 print(a_set)    # -> {2, 3}               print(a_frozenset)  # -> NameError: name 'a_frozenset' is not defined.

------------------------------------------------------------------------------------------------------------------------
 # Математический оператор работает ТОЛЬКО для set и frozenset
 a = set('AABC')
 b = frozenset('BBDD')

 # вхождение элементов в множество issubset() <=
 b <= a  # False
 # вхождение элементов в множество issuperset() =>
 b >= a  # False
 # объединение union(*others) |
 b | a  # -> frozenset({'B', 'C', 'D', 'A'})
 # пересечение intersection(*others) &
 b & a  # -> frozenset({'B'})
 # разность difference(*others) -
 b - a  # -> frozenset({'D'})
 # симметричная разница symmetric_difference(other) ^
 b ^ a  # -> frozenset({'C', 'D', 'A'})

 Краткий обзор примеров!!!
 a = set('AABC')      # Можно использовать только set
 b = tuple('BBDD')    # Можно использовать любой iterable
 # не имеет общих элементов c other isdisjoint(other)
 a.isdisjoint(b)                                         # -> False  <-  a.isdisjoint(b)
 # вхождение элементов в set issubset(other)   <=
 a.issubset(b)                                           # -> False  <-  a.issubset(b)
 # вхождение элементов в set issuperset(other) =>
 a.issuperset(b)                                         # -> False  <-  a.issuperset(b)
 # объединение union(*others) |
 a.union(b)                                              # -> {'C', 'B', 'A', 'D'}  <-  a.union(b)
 # пересечение intersection(*others) &
 a.intersection(b)                                       # -> {'B'}  <-  a.intersection(b)
 # разность difference(*others) -
 a.difference(b)                                         # -> {'A', 'C'} <-  a.difference(b)
 # симметричная разница symmetric_difference(other) ^
 a.symmetric_difference(b)                               # -> {'D', 'C', 'A'} <-  a.symmetric_difference(b)


 -- Примеры: Операции которые работают ТОЛЬКО ИЗМЕНЯЕМЫМ set  и НЕ работают с НЕИЗМЕНЯЕМЫМ frozenset. Многие # inplace
 - frozenset поддерживает ТОЛЬКО БИНАРНЫЕ ОПЕРАЦИИ: set1 |= set2 | ... set &= other & ... set -= other | ... set ^= other

 ---------------------------  update(*others)  set1 |= set2 | ... # inplace  -------------------------------------------
 sets = {0, 1, 2, 3}                                       sets = {0, 1, 2, 3}
 fset = frozenset({3, 4, 7, 10})                           fset = frozenset({3, 4, 7, 10})
 lists = [3, 5, 6, 7]                                      lists = [3, 5, 6, 7]
 tuples = (0, 1, 7, 8, 9)                                  tuples = (0, 1, 7, 8, 9)
 sets.update(lists, tuples)                                sets = sets.update(lists, tuples)
 fset.update(lists, tuples) # -> AttributeError:           print(sets) # -> None              <-----
 print(sets)  # -> {0, 1, 2, 3, 5, 6, 7, 8, 9}             fset = fset.update(lists, tuples) # -> AttributeError:

 Пример set |= other | ... Работает только с set и frozenset
 sets = {0, 1, 2, 3}
 fset = frozenset({3, 4, 7, 10})
 fset |= frozenset(lists) | set(tuples) | sets
 sets |= frozenset(lists) | set(tuples) | fset
 print(sets)  # -> {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
 print(fset)  # -> frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
 sets |= lists | tuples # -> TypeError: unsupported operand type(s) for |: 'list' and 'tuple'

 ---------------------------  intersection_update(*others)  set &= other & ... # inplace  ------------------------------
 sets = {0, 1, 2, 3}                                       sets = {0, 1, 2, 3}
 fset = frozenset({3, 4, 7, 10})                           fset = frozenset({3, 4, 7, 10})
 lists = [3, 5, 6, 7]                                      lists = [3, 5, 6, 7]
 tuples = (0, 1, 7, 8, 9)                                  tuples = (0, 1, 7, 8, 9)
 sets.intersection_update(lists)                           sets = sets.intersection_update(lists)
 print(sets)  # -> {3}                                     print(sets) # -> None    <-----
 fset.intersection_update(lists) # -> AttributeError:

 Пример set &= other & ... Работает только с set и frozenset
 sets = {0, 1, 2, 3}
 fset = frozenset({3, 4, 7, 10})
 fset &= frozenset(lists) & set(tuples) & sets
 sets &= frozenset(lists) & set(tuples) & fset
 print(sets)  # -> set()
 print(fset)  # -> frozenset()
 sets &= lists & tuples  # -> TypeError: unsupported operand type(s) for &: 'list' and 'tuple'

 ---------------------------  difference_update(*others)  set -= other | ... # inplace  --------------------------------
 sets = {0, 1, 2, 3}                                        sets = {0, 1, 2, 3}
 fset = frozenset({3, 4, 7, 10})                            fset = frozenset({3, 4, 7, 10})
 lists = [3, 5, 6, 7]                                       lists = [3, 5, 6, 7]
 tuples = (0, 1, 7, 8, 9)                                   tuples = (0, 1, 7, 8, 9)
 sets.difference_update(lists)                              sets = sets.difference_update(lists)
 print(sets)  # -> {0, 1, 2}                                print(sets)  # -> None    <-----
 fset.difference_update(lists, tuples) # -> AttributeError:

 Пример set -= other | ... Работает только с set и frozenset
 sets = {0, 1, 2, 3}
 fset = frozenset({3, 4, 7, 10})
 fset -= frozenset(lists) | set(tuples) | sets
 sets -= frozenset(lists) | set(tuples) | fset
 print(sets)  # -> {2}
 print(fset)  # -> frozenset({10, 4})
 sets -= lists | tuples  # -> TypeError: unsupported operand type(s) for |: 'list' and 'tuple'

 ---------------------------  symmetric_difference_update(other)  set ^= other # inplace  ------------------------------
 sets = {0, 1, 2, 3}                                        sets = {0, 1, 2, 3}
 fset = frozenset({3, 4, 7, 10})                            fset = frozenset({3, 4, 7, 10})
 lists = [3, 5, 6, 7]                                       lists = [3, 5, 6, 7]
 tuples = (0, 1, 7, 8, 9)                                   tuples = (0, 1, 7, 8, 9)
 sets.symmetric_difference_update(lists)                    sets = sets.symmetric_difference_update(lists)
 print(sets)  # -> {0, 1, 2, 5, 6, 7}                       print(sets)  # -> None   <-----
 fset.symmetric_difference_update(lists, tuples) # -> AttributeError:

 Пример set ^= set1 Работает только с set и frozenset
 sets = {0, 1, 2, 3}
 fset = frozenset({3, 4, 7, 10})
 fset ^= frozenset(lists)
 sets ^= frozenset(lists)
 print(sets)    # -> {0, 1, 2, 5, 6, 7}
 print(fset)    # -> frozenset({4, 5, 6, 10})
 sets ^= lists  # -> TypeError: unsupported operand type(s) for ^=: 'set' and 'list'

 ---------------------------  add(elem) # inplace ----------------------------------------------------------------------
 sets = {0, 1, 2, 3}                                                                   sets = {0, 1, 2, 3}
 fset = frozenset({3, 4, 7, 10})                                                       sets = sets.add(999)
 sets.add(999)                                                                         print(sets) # -> None   <-----
 sets.add([])  # -> TypeError: unhashable type: 'list'  Нельзя добавить ИЗМЕНЯЕМЫЕ объекты   <-----
 fset.add(999) # -> AttributeError: 'frozenset' object has no attribute 'add'
 print(sets)   # -> {0, 1, 2, 3, 999}


 ОЧЕНЬ ИНТЕРЕСНЫЙ ПРИМЕР ПОДУМАЙ ПОЧЕМУ!!!       <-----
 sets = {0, 1, 2, 3}
 sets.add((frozenset(('a', 'b'))))                                # <-----
 print(sets)           # -> {0, 1, 2, 3, frozenset({'a', 'b'})}
 sets.add({'a', 'b'})  # -> TypeError: unhashable type: 'set'     # <-----

 ---------------------------  remove(elem) # inplace -------------------------------------------------------------------
 sets = {0, 1, 2, 3}                                                                    sets = {0, 1, 2, 3}
 fset = frozenset({3, 4, 7, 10})                                                        sets = sets.remove(3)
 sets.remove(3)                                                                         print(sets) # -> None   <-----
 sets.remove(100) # -> KeyError: 100
 fset.remove(3)   # -> AttributeError: 'frozenset' object has no attribute 'remove'
 print(sets)      # -> {0, 1, 2}

 ОЧЕНЬ ИНТЕРЕСНЫЙ ПРИМЕР ПОДУМАЙ ПОЧЕМУ!!!       <-----
 sets = {0, 1, 2, 3}
 sets.add((frozenset(('a', 'b'))))
 print(sets)           # -> {0, 1, 2, 3, frozenset({'a', 'b'})}
 sets.remove( {'a', 'b'} )                      #  <-----   Можно удалить множество set из set
 print(sets)           # -> {0, 1, 2, 3}

 ---------------------------  discard(elem) # inplace ------------------------------------------------------------------
 sets = {0, 1, 2, 3}                                                                    sets = {0, 1, 2, 3}
 fset = frozenset({3, 4, 7, 10})                                                        sets = sets.discard(3)
 sets.discard(3)                                                                        print(sets) # -> None   <-----
 # fset.discard(3)  # -> AttributeError: 'frozenset' object has no attribute 'discard'
 print(sets)  # -> {0, 1, 2}
 sets.discard({'a', 'b'})  # НЕТ ОШИБКИ!                    <-----
 sets.remove({'a', 'b'})   # ОШИБКА!  KeyError: {'a', 'b'}  <-----
 print(sets)  # -> {0, 1, 2}

 ---------------------------  pop() # inplace --------------------------------------------------------------------------
 sets = {0, 1, 2, 3}                        sets = {0, 1, 2, 3}
 sets.pop()                                 sets = sets.pop()
 print(sets)  # -> {1, 2, 3}                print(sets)  # -> 0   <-----
 sets.pop()
 print(sets)  # -> {2, 3}
 sets.pop()
 print(sets)  # -> {3}
 sets.pop()
 print(sets)  # -> set()
 sets.pop()   # -> KeyError: 'pop from an empty set'

 fset = frozenset({3, 4, 7, 10})
 fset.pop() # -> AttributeError: 'frozenset' object has no attribute 'pop'

 ---------------------------  clear() # inplace ------------------------------------------------------------------------
 sets = {0, 1, 2, 3}                                      sets = {0, 1, 2, 3}
 sets.clear()  # ->  НЕ вызывает исключений.              sets = sets.clear()
 print(sets)   # ->  set() # пустое множество             print(sets)          # -> None    <-----
 sets = set()
 sets.clear()                                             fset = frozenset({3, 4, 7, 10})
 print(sets)   # ->  set() # пустое множество             fset.clear() # -> AttributeError:
------------------------------------------------------------------------------------------------------------------------

 # Бинарный оператор работает ТОЛЬКО для set и frozenset
 a = set('AABC')
 b = frozenset('BBDD')
 # объединение множеств update(*others) set |= other | ...
 b |= a
 b # -> frozenset({'B', 'C', 'D', 'A'})
 # пересечение intersection_update(*others) set &= other & ...
 b &= a
 b # -> frozenset({'B'})
 # разность difference_update(*others) set -= other | ...
 b -= a
 b # -> frozenset({'D'})
 # симметричная разница symmetric_difference_update(other) set ^= other
 b ^= a
 b # -> frozenset({'C', 'D', 'A'})
------------------------------------------------------------------------------------------------------------------------
 # Краткий обзор примеров!!! НЕ Работат с неизменяемым frozenset. # inplace
 a = set('AABC')                                                         a = set('AABC')
 b = list('BBDD')                                                        # ДОБАВЛЯЕТ элемент в множество set
 # ОБЪЕДИНЕНИЕ множеств update(*others) set |= other | ...               a.add(99999)
 a.update(b)                                                             a # -> {'A', 99999, 'B', 'C'}
 a # -> {'C', 'A', 'B', 'D'}                                             # УДАЛЯЕТ элемент из множества set по значению
 # ПЕРЕСЕЧЕНИЕ intersection_update(*others) set &= other & ...           a.remove(99999) # -> KeyError: 99999
 a.intersection_update(b)                                                a # -> {'B', 'C'}
 a # -> {'B'}                                                            # Удаляет элемент  не поднимая исключений
 # РАЗНОСТЬ difference_update(*others) set -= other | ...                a.discard(99999) # НЕТ ОШИБКИ!
 a.difference_update(b)                                                  a # -> {'B', 'C'}
 a # -> {'C', 'A'}                                                       a.pop()
 # СИММЕТРИЧНАЯ РАЗНИЦА symmetric_difference_update(other) set ^= other  a # -> 'C', 'B'}
 a.symmetric_difference_update(b)                                        a.clear()
 a # -> {'D', 'C', 'A'}                                                  a # -> set()  пустое множество
------------------------------------------------------------------------------------------------------------------------

 Создание Множества(set) с аннотациями:
 s: set[int] = {2, 1, 3}
 s: set['str'] = {'2', '1', '3'} # -> использовать '', "", ''' ''', ``` ```` в аннотациях можно


 --- dict (Словарь) ---
 dict (Словари)  — это ИЗМЕНЯЕМЫЕ УПОРЯДОЧЕННЫЕ коллекции без повторяющихся элементов,
 где каждый элемент представляет собой пару «ключ-значение»
 1) dict - словарь, отображение, хеш-мап, ассоциативный массив, коллекция пар ключ-значение,
 где ключом может быть только hashable тип, доступ по ключу и проверка наличия ключа O(1),
 с питона 3.7 хранит порядок вставки
 2) пустой словарь создавать лучше через {},а не dict(), под капотом сразу будет создано 8 элементов
 3) Hashable != Immutable, эти понятия часто путают, помните что это не одно и то же.
 4) Значения по ключу могут быть любого типа данных. Чтобы взять значение по ключу,
 необходимо указать ключ в квадратных скобках после имени словаря
 a_dict = {'good': 'a', 2: 'b'}, a_dict['good']
 5) алгоритм работы словаря и сета: Получаем хеш -} высчитываем позицию в массиве -} если элемента нет
 то действуем соответственно задаче -} если элемент есть то сравниваем ключ == тому что ищем -}
 если ключ не равен искомому то ищем дополнительный бакет
 Бакет — это просто номер в массиве элементов
 6) По умолчанию самописные классы возвращают хеш основанный на id, если переопределяете хеш, то всегда проверяйте,
 что у равных объектов одинаковый хеш
 7) За скорость словаря и сета мы платим большей памятью и тем, что положить туда можно не любые элементы
 используй {} для создания пустого dict

 dict может хранить - { hashable: hashable/unhashable }  {НЕИЗМЕНЯЕМЫЕ: ИЗМЕНЯЕМЫЕ/НЕИЗМЕНЯЕМЫЕ}  {Immutable: Mutable/Immutable}

 Числовые ключи в словарях подчиняются правилам сравнения чисел. Таким образом, int(1) и float(1.0) и True
 считаются одинаковым ключом. Однако из-за того, что значения типа float сохраняются приближенно,
 не рекомендуется использовать их в качестве ключей
 dict  также поддерживает __getitem__() и __len__(), но считается отображением, а не последовательностью, поскольку
 при поиске используются произвольные неизменяемые ключи, а не целые числа.

 class dict(**kwargs)
 class dict(mapping, **kwargs)
 class dict(iterable, **kwargs)
 Словари можно создавать несколькими способами:

 Используйте список пар, разделенных запятыми, в фигурных скобках: или key: value  a_dict = {'one':1, 'two':2, 'three':3}
 {'jack': 4098, 'sjoerd': 4127} or {4098: 'jack', 4127: 'sjoerd'}
 Используйте dict comprehension:  {x: x ** 2 for x in range(10)}
 Создаём словарь: {}, dict(), dict([('foo', 100), ('bar', 200)]), dict(foo=100, bar=200), dict({'one': 1}, two=2)

 Варианты создания словаря:
 new = dict({'one': 1, 'three': 3}, two=2) # -> {'one': 1, 'three': 3, 'two': 2}
 a_dict = {1: 1, 2: 2}               # -> {1: 1, 2: 2}
 a_dict1 = dict({1: 1, 2: 2})        # -> {1: 1, 2: 2}
 a_dict2 = dict(one=1, two=2)        # -> {'one': 1, 'two': 2}
 # a_dict2 = dict(1=1, 2=2)        # -> SyntaxError: expression cannot contain assignment, perhaps you meant "=="?
 a_dict3 = dict([(1, 1), (2, 2)])    # -> {1: 1, 2: 2} # iterable ()
 a_dict4 = dict(((1, 1), (2, 2)))    # -> {1: 1, 2: 2} # iterable []
 a_dict5 = dict({(1, 1), (2, 2)})    # -> {1: 1, 2: 2} # iterable {}
 a_dict7 = dict(zip((1, 2), (1, 2))) # -> {1: 1, 2: 2} # zip
 a_dict8 = dict.fromkeys((1, 2))     # -> {1: None, 2: None}

 Обьяснение ключей и значений ПОСМОТРИ!
 a_dict = {"A": 2}           # -> {'A': 2} ключи могут быть только НЕИЗМЕНЯЕМОГО типа -  hashable
 a_dict = {[]: 2}            # -> TypeError: unhashable type: 'list'  ИЗМЕНЯЕМОГО типа НЕ МОГУТ
 a_dict1 = {1: []}           # -> {1: []}            значения могут быть любого типа hashable и unhashable
 a_dict2 = {1: 500, 1: 200}  # -> {1: 200}           ключи перезатираются, остается только последний ключ
 a_dict3 = {1: 500, 2: 500}  # -> {1: 500, 2: 500}   значения могут повторяться
 a = {}                      # -> {} пустой словарь
 a['new'] = frozenset()      # -> {'new': frozenset()}                если ключа нет, он создается в словаре
 a['cool'] = set()           # -> {'new': frozenset(), 'cool': set()} если ключа нет, он создается в словаре
 a['cool'] = 'NO'            # -> {'new': frozenset(), 'cool': 'NO'}  новый ключ заменяет старый


 хэш-таблицы (hash-table) - позволяет находить элементы за O(1).   НО с  хэш-коллизиями за O(n)
 Поиск занимаем постоянное время - ищете вы в 10 млн элементов  или среди 10

 Хеш-таблица (hash table) — это структура данных, которая позволяет находить элементы за O(1). Поиск занимает постоянное
 время вне зависимости от того, ищете вы среди 10 млн элементов или всего среди 10.
 Так же, как массив, хеш для хранения данных требует предварительного выделения большого блока последовательной памяти.
 Но, в отличие от массива, его элементы хранятся не в упорядоченной последовательности. Позиция, занимаемая элементом,
 «волшебным образом» задается хеш-функцией. Это специальная функция, которая на входе получает данные, предназначенные
 для хранения, и возвращает число, кажущееся случайным. Оно интерпретируется как позиция в памяти, куда будет помещен
 элемент. Это позволяет нам получать элементы немедленно. Заданное значение сначала пропускается через хеш-функцию.
 Она выдает точную позицию, где элемент должен находиться в памяти. Если элемент был сохранен, то вы найдете его в этой
 позиции.

 Нужно гарантировать, чтобы в хэш-таблице оставалось незанятым по крайней мере 50% пространства.    <-----
 В противном случае коллизии начнут происходить слишком часто и производительность хэш-таблица значительно упадет!

 Для корректной работы работы хэш-таблицы требуют выделения очень большого блока непрерывной памяти <-----


 # .keys() и .items() объекта  dict()  Удивительно похожи на frozenset()
 # .keys() и items() -  Поддерживают наиболее полезные операторы и методы класса frozenset()   <-----
 d1 = dict(a=1, b=2, c=3, d=4)
 d2 = dict(b=20, d=40, e=50)

 # Легко получить пересекающиеся ключи
 print(d1.keys() & d2.keys())     # ->  {'d', 'b'}

 print(d1.keys() - d2.keys())     # ->  {'a', 'c'}
 print(d1.keys() | d2.keys())     # ->  {'c', 'e', 'd', 'a', 'b'}

 print(d1.items() & d2.items())   # ->  set()
 print(d1.items() - d2.items())   # ->  {('b', 2), ('d', 4), ('a', 1), ('c', 3)}
 print(d1.items() | d2.items())   # ->  {('b', 2), ('b', 20), ('a', 1), ('e', 50), ('c', 3), ('d', 40), ('d', 4)}


 -- Методы словарей:
 list(d) - Возвращает список всех ключей, используемых в словаре d .
 len(d) -  Возвращает количество элементов в словаре d .
 d[key] -  Вернет элемент d с помощью ключа key . Вызывает ошибку KeyError, если ключа нет в словаре d.
 d[key] = value  - Добавит в словарь d новый элемент - пару ключ-значение. Если key есть то перезаписывает value
 del d[key] - Удалить d[key] из d. Вызывает ошибку KeyError, если ключа нет в словаре.
 key in d - Вернет, True если у d ЕСТЬ  ключ key, иначе False.
 key not in d - Вернет True, если у словаря d НЕТ ключа key, иначе False.
 iter(d) - Возвращает итератор по ключам словаря. Это ярлык для iter(d.keys()).  <dict_keyiterator
 dict.clear() - Удалить все элементы из словаря.  # inplace
 dict.copy() - возвращает неглубокую копию словаря.
 classmethod dict.fromkeys(seq[, value]) - создает словарь с ключами из seq и значением value, default=None.   # inplace
 dict.get(key[, default]) - возвращает значение ключа , если ключ есть в словаре, иначе - default=None, НЕ вызывает KeyError.
 dict.items() - возвращает список кортежей пар  [ (ключ, значение) ] .
 dict.keys() - возвращает список всех ключей [keys] в словаре.
 dict.values() - возвращает список всех значения [values] в словаре.
 dict.pop(key[, default]) - удаляет ключ и возвращает значение. Если ключа нет, вернет default=KeyError.  # inplace
 dict.popitem() - удаляет и возвращает пару кортеж(ключ, значение) в порядке LIFO. Если словарь пуст - KeyError. # inplace
 reversed(d) - Вернет обратный итератор по ключам словаря. Это ярлык для reversed(d.keys()).
 dict.update([other]) - обновляет/дополняет словарь dict, ключами и значениями other словаря или iterable [[]], (())   # inplace
 dict.setdefault(key[, default]) - возвращает значение ключа, или если его нет создаст key:value=default, default=None  # inplace


 # Предупреждение Всегда создает новый экземпляр первоначального значения при каждом вызове  ЛУЧШЕ  использовать defauldict
 d = {}
 d.setdefault('a', set()).add(1)
 d.setdefault('b', set()).add(2)
 d.setdefault('c', set()).add(4)
 print(d)  # -> {'a': {1}, 'b': {2}, 'c': {4}}

 d = {}
 d.setdefault('a', []).append(1)
 d.setdefault('b', []).append(2)
 d.setdefault('c', []).append(4)
 print(d)  # -> {'a': [1], 'b': [2], 'c': [4]}

 # Более ЧИСТЫЙ код  при использовании  defaultdict
 from collections import defaultdict
 d = defaultdict(list)
 d['a'].append(1)
 d['b'].append(2)
 d['c'].append(4)
 print(d)  # -> defaultdict(<class 'list'>, {'a': [1], 'b': [2], 'c': [4]})

 # Автоматически создаст записи словаря  для  ключей, к которым позже будет доступ(даже если их в данный момент нет в словаре)
 d = defaultdict(set)
 d['a'].add(1)
 d['b'].add(2)
 d['c'].add(4)
 print(d)  # -> defaultdict(<class 'set'>, {'a': {1}, 'b': {2}, 'c': {4}})





 Выражение {**dict1, **dict2} создает НОВЫЙ СЛОВАРЬ с объединенными ключами и значениями из dict1 и dict2,оба должны быть словарями.
 Способ объединения произвольного количества словарей **:    работает быстрее чем метод update()
 zs = {**{'a': 1, 'b': 2}, **{'b': 3, 'c': 4}}

 d | other    - аналог dict = {**dict1, **dict2} в Python 3.9+
 Создайте новый словарь с объединенными ключами и значениями d и other , которые оба должны быть словарями.
 Значения other имеют приоритет, когда d и other общие ключи.
 d |= other   - аналог dict.update([other]) в Python 3.9+
 Обновите словарь d ключами и значениями из other , которые могут быть либо отображением, либо итерацией
 пар ключ/значение. Значения other имеют приоритет, когда d и other общие ключи.

 -- отличие  объединения/слияния словарей vs обновления/дополнения.   {**dict1, **dict2}, |  vs  dict.update(), |=
 - объединения/слияния {**dict1, **dict2} ОБРАЗУЕТСЯ НОВЫЙ СЛОВАРЬ (ИСХОДНЫЕ СЛОВАРИ НЕ ИЗМЕНЯЮТСЯ)
 - обновления/дополнения ИЗМЕНЯЕТСЯ ИСХОДНЫЙ СЛОВАРЬ dict.

 Динамически изменяемые представления словарей:
 Объекты, возвращаемые методами словарей dict.keys(), dict.values() и dict.items() являются объектами-представлениями (view).
 Они обеспечивают динамическое представление записей словаря. Другими словами, при изменении словаря dict соответствующие
 представление будет отражать эти изменения.

 Порядок ключей dict.keys() и значений dict.values() словаря гарантированно являются порядком вставки в словарь.
 Это позволяет создавать такие пары как (value, key):

 # С помощью функции `zip()`                        # С помощью выражения списка
 pairs = zip(d.values(), d.keys())                  pairs = [(v, k) for (k, v) in d.items()]

 Представления словарей поддерживают операции:

 len(dictview) - вернет количество записей в словаре.

 iter(dictview) - возвращает итератор по ключам dict.keys(), значениям dict.values() или элементам dict.items().
 В последнем случае представление будет в виде списка кортежей (key, value).
 Итераторы представлений при добавлении или удалении записей в словаре могут вызвать ошибку RuntimeError или не
 выполнить итерацию по всем записям.

 x in dictview - вернет, True если значение элемента x присутствует в представлении ключей, значений или элементов словаря.
 В последнем случае x должен быть кортежем (key, value).

 reversed(dictview) - вернет обратный итератор по ключам, значениям или элементам словаря. Представление будет
 повторяться в обратном порядке вставки.

 dictview.mapping - Атрибут представления словаря dictview.mapping возвращает types.MappingProxyType, который обертывает
 исходный словарь, на который ссылается представление.

 d: dict[str, int] = {'A': 20, 'B': 30}
 print(d.values().mapping['A'])  # -> прокси доступный только для чтения, для исходного словаря
 print(d.keys().mapping['A'])    # -> 20
 print(d.items().mapping)        # -> {'A': 20, 'B': 30}

 types.MappingProxyType — обертка для создания словарей только для чтения

 Mappingproxy — это просто словарь без __setattr__метода.

 Это помогает интерпретатору гарантировать, что ключи для атрибутов и методов уровня класса могут быть только строками.
 Если ключи являются строками, мы можем упростить и ускорить код общего случая для поиска атрибутов и методов на уровне
 класса. В частности, логика поиска __mro__ для классов нового стиля упрощается и ускоряется за счет предположения,
 что ключи dict классов являются строками.

 # Небольшой пример!
 class A: pass

 a = A()

 print(type(a.__dict__))      # -> <class 'dict'>
 print(type(A.__dict__))      # -> <class 'mappingproxy'>

 # У Экземпляра класса обычный словарь                                                                 <-----
 print(a.__dict__)            # -> {}
 a.__dict__['a'] = 1
 a.__dict__.update({'a': 1})
 a.__setattr__('b', 20)
 print(a.__dict__)            # -> {'a': 1, 'b': 20}

 # У Класса словарь только для чтения                                                                  <-----
 A.__dict__['a'] = 1          # -> TypeError: 'mappingproxy' object does not support item assignment
 A.__dict__.update({'a': 1})  # -> AttributeError: 'mappingproxy' object has no attribute 'update'


 -- Примеры методов словаря(dict) c Присваиванием значений. Многие # inplace:
 ---------------------------  list(d)  ---------------------------------------------------------------------------------
 a_dict = {'one':1, 'two':2}
 print(list(a_dict))  # -> ['one', 'two']
 print(a_dict)        # -> {'one': 1, 'two': 2}

 ---------------------------  len(d)  ---------------------------------------------------------------------------------
 a_dict = {'one':1, 'two':2}
 print(len(a_dict))  # -> 2

 ---------------------------  d[key]  ----------------------------------------------------------------------------------
 a_dict = {'one': 1, 'two': 2}                          a_dict = {'one': 1, 'two': 2}
 print(a_dict['one'])  # -> 1                           a_dict = a_dict['one']
 print(a_dict)         # -> {'one': 1, 'two': 2}        print(a_dict)           # -> 1
 print(a_dict[1000])   # -> KeyError: 1000              print(a_dict[1000])     # -> KeyError: 1000

 ---------------------------  __missing__  -----------------------------------------------------------------------------
 class My_Counter(dict):                 class My_Counter(dict):
     def __missing__(self, key):             pass
         return 'NO'                     c = My_Counter()
 c = My_Counter()                        print(c['new'])  # -> KeyError: 'new'
 print(c['new'])  # -> NO
 c['new'] += '+100'
 print(c['new'])  # -> NO+100

 ---------------------------  d[key] = value  --------------------------------------------------------------------------
 a_dict = {'one': 1, 'two': 2}
 a_dict['new'] = []
 print(a_dict)        # -> {'one': 1, 'two': 2, 'new': [] }
 a_dict['new'] = 100
 print(a_dict)        # -> {'one': 1, 'two': 2, 'new': 100 }

 ---------------------------  del d[key]  ------------------------------------------------------------------------------
 a_dict = {'one': 1, 'two': 2}             a_dict = {'one': 1, 'two': 2}
 del a_dict['two']                         a_dict = del a_dict['two']   # -> SyntaxError: invalid syntax
 print(a_dict)     # -> {'one': 1}
 del a_dict[100]   # -> KeyError: 100
 del a_dict
 print(a_dict)     # -> NameError: name 'a_dict' is not defined. Did you mean: 'dict'?

 ---------------------------  key in d  --------------------------------------------------------------------------------
 a_dict = {'one': 1, 'two': 2}               a_dict = {'one': 1, 'two': 2}
 print(1 in a_dict)      # -> False          print(1 in a_dict.values())    # -> True
 print('one' in a_dict)  # -> True           print('one' in a_dict.keys())  # -> True

 ---------------------------  key not in d  ----------------------------------------------------------------------------
 a_dict = {'one': 1, 'two': 2}              a_dict = {'one': 1, 'two': 2}
 print(1 not in a_dict)      # -> True      print(1 not in a_dict.values())    # -> False
 print('one' not in a_dict)  # -> False     print('one' not in a_dict.keys())  # -> False

 ---------------------------  iter(d)  ---------------------------------------------------------------------------------
 a_dict = {'one': 1, 'two': 2}                                  a_dict = {'one': 1, 'two': 2}
 next(a_dict) # -> TypeError: 'dict' object is not an iterator  a_dict = iter(a_dict)
 a = iter(a_dict)                                               print(a_dict) # <dict_keyiterator object at 0x000002DF29755490>
 print(a) # -> <dict_keyiterator object at 0x0000021E6F3B5490>  print(list(a_dict)) # -> ['one', 'two']
 print(list(a))  # -> ['one', 'two']

 ---------------------------  clear()  # inplace  ----------------------------------------------------------------------
 a_dict = {'one': 1, 'two': 2}      a_dict = {'one': 1, 'two': 2}
 a_dict.clear()                     a_dict = a_dict.clear()
 print(a_dict)  # -> {}             print(a_dict)  # -> None   <-----

 ---------------------------  copy()  ----------------------------------------------------------------------------------
 a_dict = {'one': 1, 'two': 2}                  a_dict = {'one': []}
 y = a_dict.copy()                              y = a_dict.copy()
 a_dict['one'] = 100                            a_dict['one'].append(10)
 print(a_dict)  # -> {'one': 100, 'two': 2}     print(a_dict)       # -> {'one': [10] }
 print(y)       # -> {'one': 1, 'two': 2}       print(y)            # -> {'one': [10] }
 del a_dict['two']                              del a_dict['one']
 print(a_dict)  # -> {'one': 100}               print(a_dict)       # -> {}
 print(y)       # -> {'one': 1, 'two': 2}       print(y)            # -> {'one': [10] }

 ---------------------------  classmethod fromkeys(iterable[, value])  # inplace  --------------------------------------
 a_dict = dict.fromkeys([1, 2])                        a_dict = {key:value for key, value in {'one':1, 'two':2}.items()}
 print(a_dict)              # -> {1: None, 2: None}    print(a_dict)  # -> {'one': 1, 'two': 2}
 a_dict = dict.fromkeys((1, 2), 'NEW')                 a_dict = {key:value for key, value in [('one', 1), ('two', 2)]}
 print(a_dict)              # -> {1: 'NEW', 2: 'NEW'}  print(a_dict)  # -> {'one': 1, 'two': 2}
 a_dict = dict.fromkeys('aaa')                         a_dict = {key:value for key, value in zip(['one', 1], ['two', 2])}
 print(a_dict)              # -> {'a': None}           print(a_dict)  # -> {'one': 'two', 1: 2}    <-----
 a_dict = dict.fromkeys(1)  # -> TypeError: 'int' object is not iterable


 # Интересный момент с fromkeys При создании можно указать любой словарь  даже НЕ пустой
 a_dict = dict.fromkeys('abc', 1)
 print(a_dict)  # -> {'a': 1, 'b': 1, 'c': 1}

 a_dict = {}.fromkeys('abc', 1)
 print(a_dict)  # -> {'a': 1, 'b': 1, 'c': 1}

 a_dict = {1: 2}.fromkeys('abc', 1)
 print(a_dict)  # -> {'a': 1, 'b': 1, 'c': 1}


 ---------------------------  get(key[, default])  ---------------------------------------------------------------------
 a_dict = {'one': 1, 'two': 2}
 print(a_dict.get('one'))         # -> 1
 print(a_dict.get('one', 'GOOD')) # -> 1
 print(a_dict.get(1000))          # -> None
 print(a_dict.get(1000, 'GOOD'))  # -> GOOD
 print(a_dict)                    # -> {'one': 1, 'two': 2}

 ---------------------------  items()  ---------------------------------------------------------------------------------
 a_dict = {'one': 1, 'two': 2}                                    a_dict = {'one': 1, 'two': 2}
 print(a_dict.items()) # dict_items([ ('one', 1), ('two', 2) ])   a_dict = a_dict.items()
 print(a_dict)         # -> {'one': 1, 'two': 2}                  print(a_dict) # dict_items([ ('one', 1), ('two', 2)] )
 print( {}.items() )   # -> dict_items( [] )

 ---------------------------  keys()  ----------------------------------------------------------------------------------
 a_dict = {'one': 1, 'two': 2}                              a_dict = {'one': 1, 'two': 2}
 print(a_dict.keys())  # -> dict_keys( ['one', 'two'] )     a_dict = a_dict.keys()
 print(a_dict)         # -> {'one': 1, 'two': 2}            print(a_dict)  # -> dict_keys( ['one', 'two'] )
 print( {}.keys() )    # -> dict_keys( [] )

 ---------------------------  values()  --------------------------------------------------------------------------------
 a_dict = {'one': 1, 'two': 2}                              a_dict = {'one': 1, 'two': 2}
 print(a_dict.values())  # -> dict_values( [1, 2] )         a_dict = a_dict.values()
 print(a_dict)           # -> {'one': 1, 'two': 2}          print(a_dict)  # -> dict_values( [1, 2] )
 print( {}.values() )    # -> dict_values( [] )

 ---------------------------  pop(key[, default])  # inplace  ----------------------------------------------------------
 a_dict = {'one': 1, 'two': 2}                              a_dict = {'one': 1, 'two': 2}
 print(a_dict.pop('one'))     # -> 1                        a_dict = a_dict.pop('one')
 print(a_dict)                # -> {'two': 2}               print(a_dict)  # -> 1    <-----
 print(a_dict.pop(100))       # -> KeyError: 100
 print(a_dict.pop(100, 150))  # -> 150
 print( {}.pop(200) )         # -> KeyError: 200

 ---------------------------  popitem()  # inplace  --------------------------------------------------------------------
 a_dict = {'one': 1, 'two': 2}                              a_dict = {'one': 1, 'two': 2}
 print(a_dict.popitem())        # -> ('two', 2)             a_dict = a_dict.popitem()
 print(a_dict)                  # -> {'one': 1}             print(a_dict)  # -> ('two', 2)
 print( {}.popitem() )          # -> KeyError: 'popitem(): dictionary is empty'

 ---------------------------  reversed(d)  -----------------------------------------------------------------------------
 a_dict = {'one': 1, 'two': 2}
 print(reversed(a_dict)) # -> <dict_reversekeyiterator object at
 print(list(reversed(a_dict)))          # -> ['two', 'one']
 print(list(reversed(a_dict.keys())))   # -> ['two', 'one']
 print(list(reversed(a_dict.values()))) # -> [2, 1]
 print(dict(reversed(a_dict.items())))  # -> {'two': 2, 'one': 1}
 print(a_dict)                          # -> {'one': 1, 'two': 2}

 ---------------------------  setdefault(key[, default])  # inplace  ---------------------------------------------------
 a_dict = {'one': 1}                                               a_dict = {'one': 1, 'two': 2}
 print(a_dict.setdefault('one'))  # -> 1                           a_dict = a_dict.setdefault('one')
 print(a_dict)                    # -> {'one': 1}                  print(a_dict)  # -> 1
 a_dict.setdefault('A')                                            a_dict = a_dict.setdefault(100)
 print(a_dict)        # -> {'one': 1, 'A': None}                   print(a_dict) # -> None    <-----
 a_dict.setdefault('BB', 100)
 print(a_dict)        # -> {'one': 1, 'A': None, 'BB': 100}

 ---------------------------  update([other])  |=  # inplace  ----------------------------------------------------------
 a_dict = {'one': 1}                                a_dict = {'one': 1}
 new_dict = {1: []}                                 new_dict = {1: []}
 a_dict.update(new_dict)                            a_dict = a_dict.update(new_dict)
 print(a_dict)   # -> { 'one': 1, 1: [] }           print(a_dict)   # ->  None    <-----
 new_dict.update(a_dict)                            new_dict = new_dict.update(a_dict)
 print(new_dict) # -> { 1: [], 'one': 1 }           print(new_dict) # -> None     <-----

 Пример   |=   c Python 3.9+:

 a_dict = {'one': 1}
 new_dict = {1: []}
 a_dict |= new_dict
 print(a_dict)   # -> { 'one': 1, 1: [] }
 new_dict = new_dict | a_dict
 print(new_dict) # -> { 1: [], 'one': 1 }


 # Интересный пример так тоже можно делать

 a_dict = {'one': 1}
 a_dict.update([['a', 2], ['b', 3]])
 print(a_dict)  # -> {'one': 1, 'a': 2, 'b': 3}

 # Но только по 2 элемента внутри
 a_dict.update([[3], ['b', 3]])    # -> ValueError: dictionary update sequence element #0 has length 3; 2 is required
 a_dict.update([[3, 4], ['b', 3]]) # -> ValueError: dictionary update sequence element #0 has length 3; 2 is required

 # Так тоже можно
 a_dict = {'one': 1}
 a_dict.update([['a', 2], ['b', 3], ['c', 4], ['d', ('hehe')], [lambda :5, lambda :10]])
 print(a_dict)
 # {'one': 1, 'a': 2, 'b': 3, 'c': 4, 'd': 'hehe', <function <lambda> at 0x0000022B2D60BBA0>: <function <lambda> at \
                                                                                                0x0000022B2D60BC40>}

 a_dict = {'one': 1}
 a_dict.update([[(lambda: 5)(), (lambda: 10)()]])
 print(a_dict)

 ---------------------------  {**dict1, **dict2}   dict1 | dict2  # inplace  -------------------------------------------
 a_dict = {'one': 1}
 new_dict = {1: []}
 c_dict = {**a_dict, **new_dict}
 print(c_dict)      # -> {'one': 1, 1: []}
 c_dict = {**new_dict, **a_dict}
 print(c_dict)      # -> { 1: [], 'one': 1 }

 Пример   |   c Python 3.9+:

 a_dict = {'one': 1}
 new_dict = {1: []}
 c_dict = a_dict | new_dict
 print(c_dict)      # -> {'one': 1, 1: []}
 c_dict = new_dict | a_dict
 print(c_dict)      # -> { 1: [], 'one': 1 }

 ---------------------------  {**dict1, **dict2}, |  vs  dict.update(), |=  --------------------------------------------
 Пример объединения/слияния словарей    {**dict1, **dict2}    |
 a_dict = {'one': 1}
 new_dict = {1: []}
 print(id(a_dict), id(new_dict)) # -> 2068796177216 2068795777280
 print(a_dict, new_dict)         # -> {'one': 1}    {1: []}
 c_dict = {**a_dict, **new_dict}
 c_dict = a_dict | new_dict
 print(id(a_dict), id(new_dict)) # -> 2068796177216 2068795777280
 print(a_dict, new_dict)         # -> {'one': 1}    {1: []}                    <----- Отличие

 Пример обновления/дополнения    dict.update()     |=
 a_dict = {'one': 1}
 new_dict = {1: []}
 print(id(a_dict), id(new_dict)) # -> 2068796177216 2068795777280
 print(a_dict, new_dict)         # -> {'one': 1}    {1: []}
 a_dict.update(new_dict)
 a_dict |= new_dict
 new_dict.update(a_dict)
 new_dict |= a_dict
 print(id(a_dict), id(new_dict)) # -> 2068796177216        2068795777280
 print(a_dict, new_dict)         # -> {'one': 1, 1: []}    {1: [], 'one': 1}    <----- Отличие
------------------------------------------------------------------------------------------------------------------------


 {True: 'да', 1: 'нет', 1.0: 'возможно'} -> {True: 'возможно'}
 эквивалентно приведенной ниже последовательности инструкций:
 xs = dict()
 xs[True] = 'да'
 xs[1] = 'нет'
 xs[1.0] = 'возможно'
 xs -> {True: 'возможно'}
 True == 1 == 1.0 -> True

 когда с объектом-ключом ассоциируется новое значение, словари Python сам этот объект-ключ не обновляют:
 ys = {1.0: 'нет'}
 ys[True] = 'да'
 ys -> {1.0: 'да'}

 Словари рассматривают ключи как идентичные, если результат их сравнения методом __eq__ говорит о том, что они
 эквивалентны, и если их хеш-значения одинаковы.

 Создание Словаря(dict) с аннотациями:
 d: dict[str, str] = {'A': "first", 'B': 'second'}
 d: dict[str, int] = {'A': 1, 'B': 'second'}


 -- Что еще может быть в словаре ключем и значением
 def func(): return 200

 x = lambda x: x

 a_dict = {lambda x: x * 2: x(10), func: func(),}         # в словаре может быть функция, lambda-функция
 print(a_dict)  # -> {<function <lambda> at 0x0000026691F499E0>: 10, <function func at 0x0000026691C50D60>: 200}
 b_dict = {(i for i in range(3)): [i for i in range(2)]}  # в словаре может быть genexp, listcomps
 print(b_dict)  # -> {<generator object <genexpr> at 0x0000020C6C2A0040>: [0, 1]}


 # ЭК - может быть ключом в словаре!

 class Foo:
     ...

 data = {
     Foo(): 1,
     Foo(): 2,
 }

 print(data)  # {<__main__.Foo object at 0x000001EFEDCF5610>: 1, <__main__.Foo object at 0x000001EFED985410>: 2}



 --- list (Список) ---
 list (Список) - список, ИЗМЕНЯЕМЫЙ УПОРЯДОЧЕННЫЙ, обычно хранит значения одного типа, О(1) доступ к элементу
 используй [] для создания пустого списка
 если заранее известен размер, то НЕ используй append (для 8000 добавлений выделяется 8600 ячеек памяти)
 используй листкомпс
 не пытайся заменять список кортежом, там где идет изменение размера

 У list и tuple скорость(время) доступа к элементам одинаковая, скорость не зависит от количества элементов

 Python когда стартует он сразу при старте в ОС (операционной системе)
 резервирует место под tuple. Python не ходит в ОС и не просит дай мне еще памяти как это происходит со списками

 каждый раз когда мы создаем список Python обращается к ОС и просит место

 list может хранить - [unhashable, hashable]  [ИЗМЕНЯЕМЫЕ и НЕИЗМЕНЯЕМЫЕ]  [Mutable,  Immutable]

 -- Модуль copy --
 copy.copy(x)             - возвращает мелкую НЕглубокую(shallow) копию x
 copy.deepcopy(x[, memo]) - возвращает глубокую(deep) копию x

 Разница между поверхностным и глубоким копированием актуальна только для составных объектов
 (объектов, которые содержат другие объекты, например списки или экземпляры классов):
 - Неглубокая копия создает новый составной объект, а затем (насколько это возможно) вставляет в него ссылки на объекты,
 найденные в оригинале.
 - Глубокая копия создает новый составной объект, а затем рекурсивно вставляет в него копии объектов, найденных в оригинале.

 При операциях глубокого копирования часто возникают две проблемы, которых нет при операциях поверхностного копирования:
 - Рекурсивные объекты (составные объекты, которые прямо или косвенно содержат ссылку на себя) могут вызывать рекурсивный цикл.
 - Потому что глубокое копирование копирует все, что может копировать слишком много, например данные, которые
  предназначены для совместного использования между копиями.

 Функция copy.deepcopy() позволяет избежать этих проблем:
 - ведет memo-словарь объектов, уже скопированных во время текущего прохода копирования;
 - позволяет пользовательским классам переопределять операцию копирования или набор копируемых компонентов.

 Модуль copy не копирует такие типы, как модуль, метод, трассировка стека, кадр стека, файл, сокет, окно, массив
 или любые подобные типы. Он “копирует" функции и классы (неглубоко и глубоко), возвращая исходный объект без изменений,
 что совместимо с тем, как они обрабатываются модулем pickle.

 Чтобы класс мог определить свою собственную реализацию копии, он может определять специальные методы __copy__() и __deepcopy__().

 __copy__() - вызывается для реализации операции поверхностного копирования, никаких дополнительных аргументов не передается.
 __deepcopy__() - вызывается для реализации операции глубокого копирования, передается один аргумент, memo-словарь.

 Если реализации __deepcopy__() необходимо сделать глубокую копию компонента, она должна вызвать функцию copy.deepcopy()
 с компонентом в качестве первого аргумента и memo-словарем(словарем заметок) в качестве второго аргумента.

 list.copy(), list[:], list[::], list(list) - изменения отразятся и на копии    - не глубокая копия (shallow)
 поверхностное копирование - станут двумя изолированными объектами, но их содержимое по-прежнему будет иметь одну и ту же ссылку.

 # ВСЕ примеры создают поверхностную копию списка                                                      <-----
 res = [1, 2, 3]
 list_1 = res[:]
 list_2 = res[::]
 list_3 = res.copy()
 list_4 = list(res)
 list_5 = res + []
 print(id(res), id(list_1), id(list_2), id(list_3), id(list_4), id(list_5))
 # 2225921212864 2225893028160 2225897553216 2225903276864 2225902572736 2225902572544    # id  ВСЕ РАЗНЫЕ

 import copy
 copy.deepcopy(list)  - изменения НЕ отразятся на копии   - глубокая копия
 Глубокое копирование - структура и содержание становятся полностью изолированными.

 Deepcopy в отличие от простого copy копирует ссылки вложенных объектов тоже.

 Глубокие копии отличаются от поверхностных копий тем, что поверхностные копии создают новую копию самого объекта,
 но любые ссылки внутри этого объекта сами по себе копироваться не будут.

 Попробуй запустить пример со словарем!!! Обьяснение !!!
 parent = {1: [1,2,3]}
 parent_copy = parent.copy()
 parent_reference = parent
 parent_deep = deepcopy(parent)

 print(id(parent), id(parent_copy), id(parent_reference), id(parent_deep))
 # 2256500164608    2256532944384    2256500164608        2256532945408

 print(id(parent[1]), id(parent_copy[1]), id(parent_reference[1]), id(parent_deep[1]))
 # 2256532935360      2256532935360       2256532935360            2256498954880

 parent_copy[1].append(4)
 parent_copy[2] = ['new']
 # parent[2] = ['new']

 print(parent, parent_copy, parent_reference, parent_deep)
 # {1: [1, 2, 3, 4]} {1: [1, 2, 3, 4], 2: ['new']} {1: [1, 2, 3, 4]} {1: [1, 2, 3]}


 # Сортировка O(n log n) - Линейно-логарифмическая сложность. Время выполнения алгоритма растет быстрее, чем линейно,
 но медленнее, чем квадратично. Например, сортировка слиянием (merge sort).
 ЭКСПОНЕНЦИАЛЬНО - для обозначения быстрого, как правило безудержного увеличения.

 Метод sort() - сортирует элементы списка по алфавиту в порядке возрастания НЕ СОЗДАВАЯ ЕГО КОПИЙ. # in-place O(n log(n))
 sorted() возвращает новый отсортированный список, не затрагивая исходный.   O(n log(n))
 Метод sort() сортирует элементы списка на месте (in-place), то есть изменяет исходный список и ничего не возвращает.

 Функции sorted() и метод list.sort() реализуют алгоритм TimSort                                            <-----


 Алгоритмы сортировки Python:

 1. **Пузырьковая сортировка (Bubble Sort)**:
 - **Описание**: Сравнивает пары соседних элементов и меняет их местами, если они находятся в неправильном порядке.
   Процесс повторяется, пока массив не будет отсортирован.
 - **Сложность**:
 - Время: O(n²) в худшем и среднем случаях, O(n) в лучшем (при уже отсортированном массиве).
 - Пространство: O(1).

 2. **Сортировка выбором (Selection Sort)**:
 - **Описание**: Находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом.
 Этот процесс повторяется для каждого элемента до конца массива.
 - **Сложность**:
 - Время: O(n²) во всех случаях.
 - Пространство: O(1).

 3. **Сортировка вставками (Insertion Sort)**:
 - **Описание**: Постепенно строит отсортированную последовательность, вставляя элементы из неотсортированной части в
 нужное место отсортированной части.
 - **Сложность**:
 - Время: O(n²) в худшем случае, O(n) в лучшем (если массив почти отсортирован).
 - Пространство: O(1).

 4. **Быстрая сортировка (Quick Sort)**:
 - **Описание**: Использует принцип "разделяй и властвуй". Выбирает опорный элемент и делит массив на две части —
 меньшие и большие по сравнению с опорным — и рекурсивно сортирует эти части.
 - **Сложность**:
 - Время: O(n log n) в среднем случае, O(n²) в худшем (при плохом выборе опорного элемента).
 - Пространство: O(log n) для рекурсии.

 5. **Сортировка слиянием (Merge Sort)**:
 - **Описание**: Разделяет массив на две половины, сортирует каждую половину и затем сливает их обратно в
 отсортированный массив. Также использует "разделяй и властвуй".
 - **Сложность**:
 - Время: O(n log n) во всех случаях.
 - Пространство: O(n).

 6. **Пирамидальная сортировка (Heap Sort)**:
 - **Описание**: Преобразует массив в структуру кучи (heap) и извлекает элементы по одному, чтобы получить
 отсортированный массив. Работает in-place.
 - **Сложность**:
 - Время: O(n log n) во всех случаях.
 - Пространство: O(1).

 7. **Тим-сорт (Tim Sort)**:
 - **Описание**: Адаптивный алгоритм, основанный на сортировке вставками и сортировке слиянием. Используется в Python в
 функции `sorted()` и методе `list.sort()`.
 - **Сложность**:
 - Время: O(n log n) в среднем, O(n) в лучшем случае (при почти отсортированных данных).
 - Пространство: O(n).

 8. **Сортировка Шелла (Shell Sort)**:
 - **Описание**: Улучшенная версия сортировки вставками, которая сравнивает и сортирует элементы, находящиеся на
 определенном расстоянии друг от друга, уменьшая расстояние до 1.
 - **Сложность**:
 - Время: O(n²) в худшем, O(n log n) в среднем (зависит от выбора последовательности).
 - Пространство: O(1).

 9. **Сортировка битом (Radix Sort)**:
 - **Описание**: Сортирует элементы по каждому разряду значений, начиная с наименьших и переходя к более значительным.
 Чаще всего используется для сортировки целых чисел.
 - **Сложность**:
 - Время: O(nk), где k — количество разрядов.
 - Пространство: O(n + k).

 10. **Сортировка подсчётом (Counting Sort)**:
 - **Описание**: Использует дополнительный массив для подсчета числа вхождений каждого уникального элемента.
   Сравнительно быстрая, но работает только для ограниченных диапазонов значений.
 - **Сложность**:
 - Время: O(n + k), где k — максимальное значение в массиве.
 - Пространство: O(k).

 11. **Сортировка по ведрам (Bucket Sort)**:
 - **Описание**: Делит элементы на несколько "ведер" и сортирует каждое ведро индивидуально, после чего объединяет все
   ведра в окончательный отсортированный массив.
 - **Сложность**:
 - Время: O(n + k) для равномерно распределенных данных, где k — количество ведер.
 - Пространство: O(n + k).


 Плоский Список(Flat list) - одномерный массив
 Вложенный список(Nested list) - многомерный массив
 Связный список(Linked List) - эффективность добавления элементов в начало, середину и конец.
 Связный список (связанный, список узлов и ссылок или указателей) (Linked List) - deque
 deque - doubly-linked list (двусвязный список)

 Односвязный список(Singly linked list) - однонаправленный связный список, можно передвигаться только в сторону конца списка.
 В практике применим редко, В Python встроенной реализации не имеет. Можно написать свою реализацию или deque

 Односвязный - Потому что каждый элемент хранит ровно 1 связь.   1 указатель/ссылка на следующий элемент
 Двусвязный - Хранит  указатель/ссылку на предыдущий и на следующий элемент

 Связный список
 Cвязный список (linked list) позволяет хранить элементы в цепи ячеек, которые не обязательно должны находиться
 в последовательных адресах памяти. Память для ячеек выделяется по мере необходимости. Каждая ячейка имеет указатель,
 сообщающей об адресе следующей в цепи. Ячейка с пустым указателем (NULL) отмечает конец цепи. Связные списки
 используются для реализации стеков, списков и очередей. При наращивании связного списка не возникает никаких проблем:
 любая ячейка может храниться в любой части памяти. Таким образом, размер списка ограничен только объемом имеющейся
 свободной памяти. Также не составит труда вставить элементы в середину списка или удалить их — достаточно просто
 изменить указатели ячеек.

 Связный список тоже имеет свои недостатки: мы не можем сразу получить n-й элемент. Сначала придется прочитать первую
 ячейку, извлечь из нее адрес второй ячейки, затем прочитать вторую ячейку, извлечь из нее указатель на следующую
 ячейку и т. д., пока мы не доберемся до n-й ячейки. Кроме того, когда известен адрес всего одной ячейки, не так просто
 ее удалить или переместиться по списку назад. Не имея другой информации, нельзя узнать адрес предыдущей ячейки в цепи.


 Двусвязный список
 Двусвязный список (double linked list) — это связный список, где ячейки имеют два указателя: один на предыдущую ячейку,
 другой — на следующую.

 Он обладает тем же преимуществом, что и связный список: не требует предварительного выделения большого блока памяти,
 потому что пространство для новых ячеек может выделяться по мере необходимости. При этом дополнительные указатели
 позволяют двигаться по цепи ячеек вперед и назад. В таком случае, если известен адрес всего одной ячейки, мы сможем быстро ее удалить.

 И тем не менее мы по-прежнему не имеем прямого доступа к n-му элементу. Кроме того, для поддержки двух указателей в
 каждой ячейке требуется более сложный код и больше памяти.


 Массив (array) — это самый простой способ хранения набора элементов в памяти компьютера. Он заключается в выделении
 единого пространства в памяти и последовательной записи в него ваших элементов. Конец последовательности отмечается
 специальным маркером NULL.

 Каждый объект в массиве занимает такой же объем памяти, что и любой другой. Представим массив, начинающийся с
 адреса ячейки памяти s, где каждый элемент занимает b байт. Чтобы получить n-й элемент, нужно извлечь b байт,
 начиная с позиции в памяти    s + (b × n).
 Это позволяет напрямую обращаться к любому элементу массива.

 Когда нам понадобится пятый элемент мы перейдем к элементу по адресу M + 5. То есть, если мы хотим получить i-й
 элемент из нашего массива, мы переходим к M + i
 Итак, если данные хранятся в памяти по порядку, то зная порядок расположенных данных, мы можем найти их за один шаг O(1)


 Массив
  - Предоставляет Константный доступ по индексу.
  - Занимает НЕПРЕРЫВНЫЙ кусок в памяти.
  - Размер куска памяти фиксируется при создании.

  Массив — это структура данных, которая хранит набор элементов одного типа и фиксированного размера.
  В массиве все элементы занимают одинаковое количество памяти, поскольку массив состоит из элементов одного типа.
  Это значит, что каждый элемент массива будет иметь одинаковый размер в байтах.


 Список и Массив  list vs array
 Список - можно хранить объекты разного размера и типа/размер списка НЕ ограничен
 Массив - Данные одного типа/размер массива ограничен.  Размер массива задается в момент создания.
 для создания массива нужно использовать  array.array, NumPy np.array()


 -- Как хранятся элементы списка и массива в памяти --                                       <-----     <-----

 В Python списки (объект типа `list`) представляют собой динамические структуры данных,
 и их элементы могут храниться в разных местах памяти.                                                  <-----

 Все элементы массива располагаются рядом друг с другом в оперативной памяти. Это свойство массивов позволяет эффективно
 использовать память и обеспечивает быстрый доступ к элементам массива.                                 <-----

 Random Access Memory(RAM, ОЗУ) - Оперативная память   ОЗУ - Оперативное запоминающее устройство

 Все элементы массива располагаются один за другим в непрерывном блоке памяти. Это позволяет быстро получать
 доступ к элементам массива с использованием индексов, поскольку адрес каждого элемента можно вычислить на основе
 адреса первого элемента и размера каждого элемента

 Элементы списков хранятся не обязательно в смежных участках памяти. Когда вы добавляете элементы в список, Python
 может выделять память динамически, что может означать размещение элементов в разных областях памяти.

 Массивы имеют фиксированный тип и размещение элементов в памяти, тогда как Списки представляют собой более гибкие
 структуры данных, которые могут содержать разные типы элементов, и размещение их в памяти НЕ обязательно будет смежным.




 Внутреннее строение списка — массив (точнее, vector) указателей, т. е. список является динамическим массивом.
 Вектор - одномерный массив проиндексированных элементов. В NumPy np.array()
 Векторы: это массивы с динамическим размером. размер памяти не ограничен

 Чтобы получить производительность с амортизируемым временем O(1) для вставок и удалений, новые элементы должны
 добавляться в конец списка методом append() и снова удалятся из конца методом pop().

 Добавление и удаление элементов вначале списка намного медленнее и занимает O(n) времени, поскольку существующие
 элементы должны сдвигаться, чтобы создать место для нового элемента. Такого антишаблона производительности следует избегать.

 Доступ к элементу по определенному индексу в списке — O(1) , но поиск элемента в списке — O(N)
 a_list = list(range(1000))
 print(timeit('a_list[0]', 'from __main__ import a_list'))       -> 0.029..  sec
 print(timeit('a_list[100]', 'from __main__ import a_list'))     -> 0.029..  sec
 print(timeit('1000 in a_list', 'from __main__ import a_list'))  -> 7.557..  sec
 print(timeit('10 in a_list', 'from __main__ import a_list'))    -> 0.114..  sec

 list — ужасно меееедленная очередь:
 Списки для этой цели довольно медленные, потому что вставка в начало очереди или удаление элемента влекут за собой
 сдвиг всех других элементов на одну позицию, требуя O(n) времени

 class list([iterable])
 Списки могут быть составлены несколькими способами:
 Использование пары квадратных скобок для обозначения пустого списка: a_list = []
 Используя квадратные скобки, разделяя элементы запятыми:             a_list = [1],  или  a_list = [1, 2, 3]
 Использование list comprehension:                                    a_list = [x for x in iterable]
 Используя конструктор типа:                                          a_list = list() или a_list = list(iterable)
 Создаём список: [], list(), list('foobar'), list(('a', 'b', 'foo')), list(['a', 'b', 'foo']),  list({'a', 'b', 'foo'})

 a_list = list(1, 1)    # -> TypeError: list expected at most 1 argument, got 2

 a_list = list(1)    # -> TypeError: 'int' object is not iterable
 a_tuple = tuple(1)  # -> TypeError: 'int' object is not iterable
 a_set = set(1)      # -> TypeError: 'int' object is not iterable

 list('abc')    # ->  ['a', 'b', 'c']
 tuple('abc')   # ->  ('a', 'b', 'c')
 set('abc')     # ->  {'b', 'a', 'c'}

 К линейным структурам можно отнести массивы, очереди, стеки, деки, линейные списки. Структуры стека.   <-----


 # Очень инетересный пример LISTCOMPS/GENEXP Можно ставить ДВА УСЛОВИЯ ВНУТРИ!!!   ВНАЧАЛЕ и в КОНЦЕ
 print([i if i > 2 else 100 for i in [1, 2, 3]])           # -> [100, 100, 3]
 print([i if i > 2 else 100 for i in [1, 2, 3] if i > 1])  # -> [100, 3]
 print([i if i > 2 else 100 for i in [1, 2, 3] if i < 2])  # -> [100]
 print([i if i > 2 else 100 for i in [1, 2, 3] if i > 2])  # -> [3]
 print((i if i > 2 else 100 for i in [1, 2, 3] if i < 2))  # -> <generator object <genexpr> at 0x00000176AEF68D40>]


 # Для чего используется пустой слайс [:] списка?     Ответ для получения всех элементов коллекции!!!
 print([1, 2, 3][:])  # -> [1, 2, 3]

 # Интересный пример срезов
 data = [22, 13, 11, 0]
 print(data[::-1])            # -> [0, 11, 13, 22]
 print(data[::-1] + data[:])  # -> [0, 11, 13, 22, 22, 13, 11, 0]                <-----


 -- Очень интересный момент С id Посмотри Внимательно --

 # Конструкция lst_1 *= 3  Изменение обьекта       # Конструкция lst_1 = lst_1 * 3  Создание НОВОГО обьекта

 # id НЕ Изменился                                  # id Изменился
 lst_1 = [1, 2, 3]                                  lst_1 = [1, 2, 3]
 print(id(lst_1))  # -> 2002285652864               print(id(lst_1))  # -> 2671279192832
 lst_1 *= 3                                         lst_1 = lst_1 * 3
 print(id(lst_1))  # -> 2002285652864               print(id(lst_1))  # -> 2671281626048
 print(lst_1)      # -> [1, 2, 3, 1, 2, 3, 1, 2, 3] print(lst_1)      # -> [1, 2, 3, 1, 2, 3, 1, 2, 3]


 # Построение списка списков
 good_lst = [['_'] * 3 for i in range(3)]
 print(good_lst)  # -> [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]

 good_lst[1][2] = 'X'
 print(good_lst)  # -> [['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]


 bad_lst = [['_'] * 3] * 3
 print(bad_lst)  # -> [['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]

 bad_lst[1][2] = 'X'
 print(bad_lst)  # -> [['_', '_', 'X'], ['_', '_', 'X'], ['_', '_', 'X']]



 # Получится список содержащий три ссылки на один и тот же внутренний список
 my_lst = [[]] * 3
 my_lst[0].append(1)

 # Таким образом, все три элемента ссылаются на один и тот же объект.
 print(my_lst)       # Выведет: [[1], [1], [1]]                                                 <-----


 # Интересный момент  +=  vs  extend()   В Python Console  Странное поведение оператора  +=    <-----
 # Будет TypeError   и Список ИЗМЕНИЛСЯ                            # Будет Работать
 t = (1, 2, [30, 40])                                              t = (1, 2, [30, 40])
 t[2] += [50, 60]                                                  t[2].extend([50, 60])
 # -> TypeError: 'tuple' object does not support item assignment   t                # -> (1, 2, [30, 40, 50, 60])
 t   # -> (1, 2, [30, 40, 50, 60])

 # Тоже самое с *=                                                 # Будет Работать
 t = (1, 2, [30, 40])                                              t = (1, 2, [30, 40])
 t[2] *= 2                                                         t[2].extend(t[2])
 # -> TypeError: 'tuple' object does not support item assignment
 t   # -> (1, 2, [30, 40, 30, 40])                                 t                # -> (1, 2, [30, 40, 30, 40])

 Составное присваивание (например, a += 1) в Python НЕ является АТОМАРНОЙ ОПЕРАЦИЕЙ. Это означает, что оно выполняет
 несколько шагов: чтение значения переменной, выполнение операции и запись результата обратно в переменную.
 Поэтому между этими шагами может произойти изменение значения переменной, особенно в многопоточных приложениях.

 # Если что-то НЕпонятно смотим байт-код    += *=    НЕ АТОМАРНЫЕ ОПЕРАЦИИ     Составное присваивание
 print(dis.dis('s[a] += b'))
 print(dis.dis('s[a] *= b'))

 # Для НЕИЗМЕНЯЕНЫХ ОБЪЕКТОВ Создается НОВЫЙ - ОБЪЕКТ                                                   +=  *=
 a_str = 'aaa'                                               a_str = 'aaa'
 a_tuple = (1, 2)                                            a_tuple = (1, 2)
 print(id(a_str))     # -> 2165838597680                     print(id(a_str))     # -> 2532912877104
 print(id(a_tuple))   # -> 2165835335616                     print(id(a_tuple))   # -> 2532909615040
 a_str += 'bbb'                                              a_str *= 2
 a_tuple += (3, 4)                                           a_tuple *= 2
 print(id(a_str))     # -> 2166400931184                     print(id(a_str))     # -> 2533454094128
 print(id(a_tuple))   # -> 2166379574864                     print(id(a_tuple))   # -> 2533453869232

 # Для ИЗМЕНЯЕНЫХ ОБЪЕКТОВ Изменяется ТОТ ЖЕ ОБЪЕКТ                                                      +=  *=
 a_list = [1, 2]                                             a_list = [1, 2]
 print(id(a_list))   # -> 2596759175296  # Одинаковые id     print(id(a_list))   # -> 2743847043968
 a_list += [3, 4]                                            a_list *= 2
 print(id(a_list))   # -> 2596759175296  # Одинаковые id     print(id(a_list))   # -> 2743847043968


 # Как изменить элементы Списка
 lst = [1, 2, 3, 4, 5]
 lst[:2] = 0, 0
 print(lst)   # -> [0, 0, 3, 4, 5]

 lst = [1, 2, 3, 4, 5]
 lst[:2] = 0, 0, 0, 0
 print(lst)   # -> [0, 0, 0, 0, 3, 4, 5]

 lst = [1, 2, 3, 4, 5]
 lst[:2] = 0  # -> TypeError: can only assign an iterable


 # Расширение Списков

 # Тоже самое                                    # Тоже самое
 lst = [1, 2, 3]                                 lst = [1, 2, 3]
 lst += 'abc'                                    lst.extend('abc')
 print(lst)  # -> [1, 2, 3, 'a', 'b', 'c']       print(lst)  # -> [1, 2, 3, 'a', 'b', 'c']


 # Можно конкатенировать РАЗНЫЕ ИТЕРИРУЕМЫЕ объекты   # Тоже самое через extend
 a = [1]                                              a = [1]
 print(id(a))  # -> 2734326301824 # Одинаковые id     print(id(a))  # -> 2734326301824 # Одинаковые id
 a += (2, 3)                                          a.extend((2, 3))
 a += '45'                                            a.extend('45')
 a += {6, 7}                                          a.extend({6, 7})
 a += {'8': 1, 9: 0}                                  a.extend({'8': 1, 9: 0})
 print(id(a))  # -> 2734326301824 # Одинаковые id     print(id(a))  # -> 2734326301824 # Одинаковые id
 print(a)  # -> [1, 2, 3, '4', '5', 6, 7, '8', 9]     print(a)  # -> [1, 2, 3, '4', '5', 6, 7, '8', 9]


 -- Методы списков:
 list.append(x)	Добавляет элемент в конец списка.  a[len(a):] = [x]  # inplace
 list.extend(iterable) - Расширяет список, добавив все элементы из итерируемого объекта.  a[len(a):] = iterable  # inplace
 list.insert(i, x)	Вставляет на i-ый элемент значение x. a.insert(0, x),   a.insert(len(a), x) == a.append(x).  # inplace
 list.remove(x)	Удаляет первый элемент в списке, имеющий значение x. ValueError, если такого элемента не существует.  # inplace
 list.pop([i])	Удаляет i элемент и возвращает его. Если индекс не указан, удаляется последний элемент. [] необязательно  # inplace
 list.clear()	Удаляет все элементы из списка. Эквивалент del a[:].  # inplace
 list.index(x, [start [, end]])	Возвращает положение первого элемента со значением x (при этом поиск ведется от start до end)
 list.count(x)	Возвращает количество элементов со значением x
 list.sort([key=функция], reverse=False)	Сортировка элементов списка на месте.  # inplace
 list.reverse()	Меняет местами элементы списка. Переворачивает список.  # inplace
 list.copy()	Возвращает неглубокую копию списка. Эквивалентно a[:].

 pop([i]), index(x[, start[, end]])
 Квадратные скобки вокруг [i], [, start[, end]. [] - Означает, что параметр является необязательным.    <-----

 Нужно отметить, что методы списков, в отличие от строковых методов, изменяют сам список, а потому результат выполнения
 не нужно записывать в эту переменную.

 -- Примеры методов списка(list) c Присваиванием значений. Почти все # inplace:
 ---------------------------  append(x)  # inplace  --------------------------------------------------------------------
 a_list = [1, 2, 3]                         a_list = [1, 2, 3]
 a_list.append(100)                         a_list = a_list.append(100)
 print(a_list) # -> [1, 2, 3, 100]          print(a_list) # -> None   <-----

 ---------------------------  extend(iterable)  # inplace  -------------------------------------------------------------
 a_list = [1, 2, 3]                         a_list = [1, 2, 3]
 a_list.extend(['one', 100])                a_list = a_list.extend(['one', 100])
 print(a_list) # -> [1, 2, 3, 'one', 100]   print(a_list) # -> None   <-----
 # += Делает тоже самое что и extend
 a_list += ['one', 100] # -> [1, 2, 3, 'one', 100]

 ---------------------------  insert(i, x)  # inplace  -----------------------------------------------------------------
 a_list = [1, 2, 3]                         a_list = [1, 2, 3]
 a_list.insert(1, 'one')                    a_list = a_list.insert(1, 'one')
 print(a_list)  # -> [1, 'one', 2, 3]       print(a_list)  # -> None   <-----

 a_list.insert(10000, 'one')                a_list = a_list.insert(10000, 'one')
 print(a_list)  # -> [1, 2, 3, 'one']       print(a_list)  # -> None   <-----

 ---------------------------  remove(x)  # inplace  --------------------------------------------------------------------
 a_list = [1, 2, 3]                              a_list = [1, 2, 3]
 a_list.remove(1)                                a_list = a_list.remove(1)
 print(a_list)  # -> [2, 3]                      print(a_list)  # -> None   <-----

 a_list.remove(10000)                          # a_list = a_list.remove(10000)
 # ValueError: list.remove(x): x not in list   # ValueError: list.remove(x): x not in list

 ---------------------------  pop([i])  # inplace  ---------------------------------------------------------------------
 a_list = [1, 2, 3]                     a_list = [1, 2, 3]
 a_list.pop(1)                          a_list = a_list.pop(1)
 print(a_list)  # -> [1, 3]             print(a_list)  # -> 2   <-----

 a_list.pop()                           a_list = a_list.pop()
 print(a_list)  # -> [1, 2]             print(a_list)  # -> 3   <-----

 a_list.pop(10000)                      a_list = a_list.pop(10000)
 # IndexError: pop index out of range   # IndexError: pop index out of range

 ---------------------------  clear()  # inplace  ----------------------------------------------------------------------
 a_list = [1, 2, 3]                    a_list = [1, 2, 3]
 a_list.clear()                        a_list = a_list.clear()
 print(a_list)  # -> []                print(a_list)  # -> None   <-----

 ---------------------------  index(x[, start[, end]])  ----------------------------------------------------------------
 a_list = [1, 2, 3]                    a_list = [1, 2, 3]
 print(a_list.index(3))       # -> 2   a_list = a_list.index(3)
 print(a_list.index(3, 1, 4)) # -> 2   print(a_list)  # -> 2
 print(a_list.index(4)) # ValueError   a_list = a_list.index(3, 1, 4)
 # ValueError: 4 is not in list        print(a_list)  # -> 2
 print(a_list.index(3, 1, 2))          a_list = a_list.index(4)        # -> ValueError: 4 is not in list
 # ValueError: 3 is not in list        a_list = a_list.index(3, 1, 2)  # -> ValueError: 3 is not in list
 print(a_list)                # -> [1, 2, 3]

 ---------------------------  count(x)  --------------------------------------------------------------------------------
 a_list = [1, 2, 3]                    a_list = [1, 2, 3]
 print(a_list.count(3))     # -> 1     a_list = a_list.count(3)
 print(a_list.count(10000)) # -> 0     print(a_list)  # -> 1
 print(a_list)              # -> [1, 2, 3]

 ---------------------------  sort(*, key=None, reverse=False)  # inplace  ---------------------------------------------
 a_list = [1, 2, 3]                                 a_list = [1, 2, 3]
 a_list.sort()                                      a_list = a_list.sort()
 print(a_list)       # [1, 2, 3]                    print(a_list)    # None   <-----

 a_list.sort(reverse=True)                          a_list = a_list.sort(reverse=True)
 print(a_list)       # [3, 2, 1]                    print(a_list)    # None   <-----

 a_list.sort(key=lambda x: x < 2)                   a_list = a_list.sort(key=lambda x: x < 2)
 print(a_list)       # -> [2, 3, 1]                 print(a_list)    # None   <-----

 a_list = [1, 2, 3, "A"]                            a_list = [1, 2, 3, "A"]
 a_list.sort(key=str)                               a_list = a_list.sort(key=str)
 print(a_list)  # -> [1, 2, 3, 'A']                 print(a_list)    # None   <-----

 a_list.sort()                                      a_list = a_list.sort() # TypeError
 # TypeError: '<' not supported between instances of 'str' and 'int'

 Сравнение list.sort() vs sorted()
 a = [1, 2, 3]
 b = [1, 2, 3]
 a.sort(reverse=True)
 sorted(b, reverse=True)
 print(a)  # -> [3, 2, 1]  <-----
 print(b)  # -> [1, 2, 3]  <-----

 ---------------------------  reverse()  # inplace  --------------------------------------------------------------------
 a_list = [1, 2, 3]                 a_list = [1, 2, 3]
 a_list.reverse()                   a_list = a_list.reverse()
 print(a_list)    # [3, 2, 1]       print(a_list)  # None   <-----

 ---------------------------  copy()  ----------------------------------------------------------------------------------
 a_list = [1, 2, 3, [10, 20]]
 b = a_list.copy()
 print(a_list, id(a_list))  # ->   [1, 2, 3, [10, 20]]  1616316748800
 print(b, id(b))            # ->   [1, 2, 3, [10, 20]]  1616316749440
 b.append(100)
 print(a_list)         # ->  [1, 2, 3, [10, 20]]
 print(b)              # ->  [1, 2, 3, [10, 20], 100]
 a_list[3].append(500)
 print(a_list)         # -> [1, 2, 3, [10, 20, 500]]
 print(b)              # -> [1, 2, 3, [10, 20, 500], 100]
------------------------------------------------------------------------------------------------------------------------

 -- Модуль bisect - реализация алгоритма бинарного поиска
 Обеспечивает поддержку вставки значений в отсортированный список, без необходимости сортировать этот список после каждой вставки.
 Бинарный поиск существенно быстрее, чем обычный, но требует предварительной сортировки коллекции, по которой осуществляется поиск.

 bin_lst = [-1, -3, 2, 4, 5, 7, 8, 9]  # Будем искать 9
 # БИНАРНЫЙ поиск  O(log n) - кратко как работает берем серединный элемент например  4
 # сравниваем 9 > 4  и будем искать  ТОЛЬКО УЖЕ ТУТ   [4, 5, 7, 8, 9]
 # берем серединный элемент например  7
 # сравниваем 9 > 7  и будем искать  ТОЛЬКО УЖЕ ТУТ   [8, 9]


 Левый и Правый двоичный поиск
 from bisect import bisect_left, bisect_right

 -- del statement --
 удалить элемент из списка, словаря учитывая его индекс, а не значение, удаления срезов из списка или очистки всего списка
 del  - Удаляет ссылку на объект, но не сам объект.   del - НЕ функция а предложение языка.

 a_list = [1, 2, 3, 4, 5]             a_dict = {'A':1, "B":2, "C":3}
 del a_list[1]                        del a_dict["A"]
 # del (a_list[1])  # Тоже самое      del (a_dict["A"])  # Тоже самое
 print(a_list)    # -> [1, 3, 4, 5]   print(a_dict) # -> {'B': 2, 'C': 3}

 del a_list[2:4]
 print(a_list)    # -> [1, 3]

 del a_list[:]
 print(a_list)    # -> []

 del a_list
 print(a_list)    # -> NameError: name 'a_list' is not defined. Did you mean: 'list'?




 Если начинаем срез с элемента которого нет, то ошибки не будет!
 a_list = [1, 2]
 print(a_list[10:])             # -> []
 print(a_list[slice(2, None)])  # -> []
 print(a_list[10])              # -> IndexError: list index out of range

 Создание Списка(list) с аннотациями: list принимает только один аргумент типа
 x: list[int] = [10, 20]
 y: list[int, str] = (5, 'a')  # -> Будет подсвечивать аннотации внутри


 --- tuple (Кортеж) ---
 tuple кортеж, НЕИЗМЕНЯЕМЫЙ УПОРЯДОЧЕННЫЙ, обычно хранит значения РАЗНЫХ типов, О(1) доступ к элементу
 используй кортежи везде, где это возможно и обоснованно
 tuple хранит ссылки на элементы,
 список внутри кортежа мы можем изменить потому что кортеж хранит ссылки,
 tuple в Python оптимизированы Python знает сколько места сразу нужно занять в памяти
 используй () для создания пустого tuple

 # Хороший пример  Список внутри кортежа мы можем изменить потому что кортеж хранит ссылки
 a_tuple = (1, 2, ['a', 'b'])
 a_tuple[2].append(9999999)
 print(a_tuple)  # -> (1, 2, ['a', 'b', 9999999])

 tuple может хранить - (unhashable, hashable)  (ИЗМЕНЯЕМЫЕ и НЕИЗМЕНЯЕМЫЕ)  (Mutable, Immutable)

 class tuple([iterable])
 Кортежи могут быть созданы несколькими способами:
 Использование пары круглых скобок для обозначения пустого кортежа:  a_tuple = ()
 Использование завершающей запятой для одноэлементного кортежа:      a_tuple = 1,       или  a_tuple = (1,)
 Разделение элементов запятыми:                                      a_tuple = 1, 2, 3  или  a_tuple = (1, 2, 3)
 Используя tuple() встроенный:                                       a_tuple = tuple()  или  a_tuple = tuple(iterable)
 Создаём кортеж: (), tuple(), tuple('foobar'), tuple(('a', 'b', 'foo')), tuple(['a', 'b', 'foo']),  tuple({'a', 'b', 'foo'})

 # Создание кортежа (Добавляем запятую)
 res = [1, 2, 3],
 print(res)  # -> ([1, 2, 3],)

 a = (100)   # Создание int    <-----
 b = (100,)  # Создание tuple  <-----
 print(type(a)) # -> <class 'int'>
 print(type(b)) # -> <class 'tuple'>

 Даже «настоящие» кортежи не делают содержащиеся в них объекты неизменяемыми, а только сам кортеж


 # hash() чтобы узнать  hashable  или НЕТ
 first_tuple = (1, 2, 3)
 second_tuple = ([1], 2, 3)

 print(hash(first_tuple))   # -> 529344067295497451
 print(hash(second_tuple))  # -> TypeError: unhashable type: 'list'

 Индексация и срезы в кортежах работают так же, как и в списках.
 Кортежи поддерживают большинство методов списков, за исключением удаления элементов и присваивания им новых значений.

 arr = 'один', 'два', 'три'
 arr[0]   # -> 'один'
 arr[:2]  # -> ('один', 'два')
 Кортежи не могут изменяться:
 arr[1] = 'привет'  # -> TypeError: 'tuple' object does not support item assignment
 del arr[1]         # -> TypeError: 'tuple' object doesn't support item deletion

 При добавлении элементов создается копия кортежа:
 arr + (23,) # -> ('один', 'два', 'три', 23)

 arr = 'один', 'два', 'три'
 arr     # -> ('один', 'два', 'три')
 id(arr) # -> 2263405210112                                        <-----
 arr += (23,)
 arr     # -> ('один', 'два', 'три', 23)
 id(arr) # -> 2263438656352   id  изменился создали новый обьект   <-----


 Методы кортежей :
 Встроенных метода всего два: это  count(), index()

 fruits = ('apple', 'banana', 'cherry', 'apple')
 print(fruits.count('apple')) # -> 2
 print(fruits.index('apple')) # -> 0


 Доступ к элементам дольше чем list
 from timeit import timeit

 a_tuple = tuple(range(1000))
 print(timeit('a_tuple[0]', 'from __main__ import a_tuple'))      # -> 0.029..sec
 print(timeit('a_tuple[100]', 'from __main__ import a_tuple'))    # -> 0.029..sec
 print(timeit('1000 in a_tuple', 'from __main__ import a_tuple')) # -> 9.071..sec  <------
 print(timeit('10 in a_tuple', 'from __main__ import a_tuple'))   # -> 0.130..sec

 a_list = list(range(1000))
 print(timeit('a_list[0]', 'from __main__ import a_list'))       # -> 0.029..sec
 print(timeit('a_list[100]', 'from __main__ import a_list'))     # -> 0.029..sec
 print(timeit('1000 in a_list', 'from __main__ import a_list'))  # -> 7.653..sec  <-------
 print(timeit('10 in a_list', 'from __main__ import a_list'))    # -> 0.130..sec

 Добавление элемента в tuple(кортеж):   Запусти весь код посмотри первую ошибку - SyntaxError: cannot use starred expression here
 new_tuple = (1, 2, 3)
 print(new_tuple)         # -> (1, 2, 3)
 type(new_tuple)          # -> <class 'tuple'>
 new_tuple += 100,        # -> (1, 2, 3, 100)
 new_tuple += ('a', 'b',) # -> (1, 2, 3, 100, 'a', 'b')
 new_tuple += [1]         # -> TypeError: can only concatenate tuple (not "list") to tuple

 a_tuple = tuple()
 a_tuple += (*'ABC')     # -> SyntaxError: cannot use starred expression here
 a_tuple += (*'ABC',)    # -> ('A', 'B', 'C')
 b_tuple = tuple('ABC')  # -> ('A', 'B', 'C')

 c_tuple = tuple()
 c_tuple += 'ABC',       # -> ('ABC',)

 Отличие от большинства других контейнеров Python, в идиоматическом коде Python кортежи часто содержат элементы одного типа.
 Создание Кортежа(tuple) с аннотациями: tuple принимает любое количество аргументов типа
 x: tuple[int] = (5,)
 y: tuple[int, str] = (5, 's')
 z: tuple[int] = (1, 2, 3)
 x: tuple[int, ...] = (1, 2)  # -> Обозначение любой длины ...


 -- В чем разница между кортежами/списками и каковы их преимущества/недостатки? --

 Разница между списком и кортежем:

 Синтаксис : в списках используется [], в кортежах используется ()
 someTuple = (1,2)
 someList  = [1,2]

 Из-за меньшего размера операции над кортежем она становится немного быстрее, но об этом не стоит упоминать,
 пока у вас не будет огромного количества элементов:

 a = tuple(range(1000))
 b = list(range(1000))

 print(a.__sizeof__()) # 8024
 print(b.__sizeof__()) # 8040

 Разрешенные операции:
 b = [1, 2]
 b[0] = 3       # [3, 2]
 del b[0]       # [2]

 a = (1,2)
 a[0] = 3      # TypeError: 'tuple' object does not support item assignment
 del a[0]      # TypeError: 'tuple' object doesn't support item deletion

 Это также означает, что вы не можете удалить элемент или отсортировать кортеж. Однако вы можете добавить новый элемент
 как в список, так и в кортеж с той лишь разницей, что, поскольку кортеж является неизменяемым, вы на самом деле
 не добавляете элемент, а создаете новый кортеж, поэтому его идентификатор изменится:

 a = (1, 2)
 b = [1, 2]

 print(id(a))          # 2207426434112
 print(id(b))          # 2205824173888

 a += (3,)    # (1, 2, 3)
 b += [3]     # [1, 2, 3]

 print(id(a))          # 2205823179136
 print(id(b))          # 2205824173888

 - Мутабельность:
 Кортежи неизменяемы, а списки изменяемы. Эта точка является основой для следующих.
 - Использование памяти:
 Из-за изменчивости вам нужно больше памяти для списков и меньше памяти для кортежей.
 - Расширение:
 Вы можете добавить новый элемент как в кортежи, так и в списки, с той лишь разницей,
 что идентификатор кортежа будет изменен (т. е. у нас появится новый объект).
 - Хеширование:
 Кортежи хешируются, а списки — нет.
 Можно использовать кортеж в качестве ключа в словаре. Если все элементы hashable
 Список нельзя использовать в качестве ключа в словаре.
 - Семантика:
 Этот пункт больше касается передовой практики.
 Кортежи следует использовать как гетерогенные структуры данных (предназначенные для хранения разнородных, разнотипных данных),
 а Списки — как однородные последовательности.

 -- Замеры создания встроенных типов:  Лучше создавать НЕ через конструктор --
 timeit("list()")       # -> 0.08837230014614761   timeit("[]")        # -> 0.03253289987333119  №1 []
 timeit("tuple()")      # -> 0.042795500019565225  timeit("()")        # -> 0.01456150016747415  №1 ()
 timeit("set((1,2,3))") # -> 0.1786022000014782    timeit("{1, 2, 3}") # -> 0.11987529997713864  №1 {1, 2, 3}
 timeit("dict()")       # -> 0.06708660000003874   timeit("{}")        # -> 0.05232750019058585  №1 {}

 Список(list)
 timeit("[1, 2, 3, 4, 5]")        # -> 0.06924239988438785  №1 []
 timeit("list((1, 2, 3, 4, 5))")  # -> 0.1061439998447895   №2 list( () )
 timeit("list([1, 2, 3, 4, 5])")  # -> 0.1681558999698609   №3 list( [] )
 timeit("list({1, 2, 3, 4, 5})")  # -> 0.32598190009593964  №4 list( {} )

 Кортеж(tuple)
 timeit("(1, 2, 3, 4, 5)")         # -> 0.01459829998202622  №1 ()
 timeit("tuple((1, 2, 3, 4, 5))")  # -> 0.04071550001390278  №2 tuple( () )
 timeit("tuple([1, 2, 3, 4, 5])")  # -> 0.12170610018074512  №3 tuple( [] )
 timeit("tuple({1, 2, 3, 4, 5})")  # -> 0.2961071999743581   №4 tuple( {} )

 Множество(set)
 timeit("{1, 2, 3, 4, 5}")        # -> 0.16579220001585782  №1 {}
 timeit("set((1, 2, 3, 4, 5))")   # -> 0.2189345001243055   №2 set( () )
 timeit("set([1, 2, 3, 4, 5])")   # -> 0.2953242000658065   №3 set( [] )
 timeit("set({1, 2, 3, 4, 5})")   # -> 0.3033869999926537   №4 set( {} )

 Словарь(dict)
 timeit("{'one': 1, 'two': 2, 'three': 3}")                   # -> №1 {}
 timeit("dict(one=1, two=2, three=3)")                        # -> №2 dict(one=1)
 timeit("dict((('one', 1), ('two', 2), ('three', 3)))")       # -> №3 dict( ( () ) )
 timeit("dict({'one': 1, 'two': 2, 'three': 3})")             # -> №4 dict( {} )
 timeit("dict([('one', 1), ('two', 2), ('three', 3)])")       # -> №5 dict( [ () ] )
 timeit("dict({('one', 1), ('two', 2), ('three', 3)})")       # -> №6 dict( { () } )
 timeit("dict(zip(('one', 'two', 'three'), (1, 2, 3)))")      # -> №7 dict(zip())


 # Кортеж внутри МЕНЯЕТ ссылку   l2 = list(l1)         Можно попробовать вариант  l2=l1  Будет другой результат)
 l1 = [3, [66, 55, 44], (7, 8, 9)]
 l2 = list(l1)
 #l2 = l1

 l1.append(100)
 l1[1].remove(55)
 # Ссылки внутри ОДИНАКОВЫЕ
 print(id(l1[1]), id(l1[1]), id(l1[2]))  # -> 2413815154112 2413815154112 2415377546240
 print(id(l2[1]), id(l2[1]), id(l2[2]))  # -> 2413815154112 2413815154112 2415377546240

 l2[1] += [33, 22]
 l2[2] += (10, 11)

 print(id(l1[1]), id(l1[1]), id(l1[2]))  # -> 2413815154112 2413815154112 2415377546240

 # ИЗМЕНИЛАСЬ Только ссылка на Кортеж    Был создан НОВЫЙ КОРТЕЖ                                    <-----
 print(id(l2[1]), id(l2[1]), id(l2[2]))  # -> 2413815154112 2413815154112 2413814827904

 # Объекты РАЗНЫЕ
 print(id(l1), id(l2))                   # -> 2415381110464 2413796420288



 --- Затраты памяти и времени на выполнение append и списковое включение (list comprehensions) memory_profiler ---

 #  В общем случае, списковое включение (list comprehension) обычно потребляет меньше памяти,
 #  чем использование метода append, потому что оно создает список в одном непрерывном блоке памяти, тогда как метод
 #  append может потребовать больше перераспределений памяти, если список растет.

 from memory_profiler import memory_usage, profile

 # Функция с использованием append
 def create_list_append():
     l = []
     for i in range(100_000):
         l.append(i * 2)
     return l

 # Функция с использованием спискового включения
 def create_list_comprehension():
     return [i * 2 for i in range(100_000)]

 # Замер памяти
 def memory_usage_test():
     # Замер памяти для append
     append_mem_usage = memory_usage((create_list_append, ))
     print(f"Peak memory usage for append: {max(append_mem_usage) - min(append_mem_usage)} MiB")

     # Замер памяти для спискового включения
     comprehension_mem_usage = memory_usage((create_list_comprehension, ))
     print(f"Peak memory usage for comprehension: {max(comprehension_mem_usage) - min(comprehension_mem_usage)} MiB")

 @profile
 def profile_memory():
     create_list_append()
     create_list_comprehension()

 # Запуск теста
 if __name__ == '__main__':
     memory_usage_test()
     profile_memory()

 # Выводы Всегда разные проверь сам!!!                                                       <-----   <-----
 # Peak memory usage for append:        1.59375 MiB
 # Peak memory usage for comprehension: 1.37109375 MiB


 # Line #    Mem usage    Increment  Occurrences   Line Contents
 # =============================================================
 #   1076     22.1 MiB     22.1 MiB           1   @profile
 #   1077                                         def profile_memory():
 #   1078     22.4 MiB      0.3 MiB           1       create_list_append()
 #   1079     22.4 MiB      0.0 MiB           1       create_list_comprehension()



 # Легкий пример как использовать profile                                                      <-----   <-----
 from memory_profiler import profile

 @profile
 def my_function():
     a = [i for i in range(100000)]
     b = [i * 2 for i in a]
     return b

 if __name__ == "__main__":
     my_function()

 # Line #    Mem usage    Increment  Occurrences   Line Contents
 # =============================================================
 #   1052     20.9 MiB     20.9 MiB           1   @profile
 #   1053                                         def my_function():
 #   1054     22.9 MiB      2.0 MiB      100001       a = [i for i in range(100000)]
 #   1055     25.1 MiB  -1819.1 MiB      100001       b = [i * 2 for i in a]
 #   1056     25.1 MiB      0.0 MiB           1       return b


 # Более того даже если мы создадим список без добавления (append), он всеравно будет занимать больше памяти чем кортеж
 # Потому что списки хранят дополнитулью информацию о своем текущем состоянии, чтобы эффективно изменять размер <------
 # Дополнительная информация занимает мало места (порядка одного дополнительного элемента) однако при использовании
 # миллиона списков мы начинаем чувствовать разницу!                                                            <------

 import timeit
 import sys

 # Функции для создания списка и кортежа
 def create_list():
     return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

 def create_tuple():
     return (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

 # Замер времени
 list_time = timeit.timeit(create_list, number=1000000)
 tuple_time = timeit.timeit(create_tuple, number=1000000)

 # Размеры
 list_size = sys.getsizeof(create_list())
 tuple_size = sys.getsizeof(create_tuple())

 # Вывод результатов
 print(f'Время создания списка: {list_time:.3f} секунд')    # ->  Время создания списка:  0.147 секунд
 print(f'Время создания кортежа: {tuple_time:.3f} секунд')  # ->  Время создания кортежа: 0.078 секунд
 print(f'Размер списка: {list_size} байт')                  # ->  Размер списка:          68 байт
 print(f'Размер кортежа: {tuple_size} байт')                # ->  Размер кортежа:         60 байт



 -- Вычисляем, сколько оперативной памяти используем! --

 memit берет данные об использовании ОЗУ от оперативной системы, а asizeof запрашивает у объектов их размер(который может
 быть сообщен неверно). Обычно asizeof работает медленнее, чем memit, но asizeof полезна при анализе небольших объектов
 Функция memit, вероятно, более подходит для реальных приложений, поскольку измеряет потребление памяти точнее (не на
 основе предположений)


 # memory_usage позволяет более точно оценить потребление памяти в реальном времени, а asizeof может быть полезен для
 # анализа небольших объектов, когда вам нужно измерить их размер более детально.

 from pympler.asizeof import asizeof                                                 <-----   <----- Интересный импорт

 # Создание списка
 my_list = [i for i in range(1000000)]

 # Измерение размера объекта
 size = asizeof(my_list)
 print(f"Size of my_list: {size} bytes")                # -> Size of my_list: 20224368 bytes



 from memory_profiler import memory_usage

 def my_function():
     return [i for i in range(1000000)]

 if __name__ == '__main__':
     # Измерение использования памяти
     mem_usage = memory_usage(my_function)
     print(f"Peak Memory Usage: {max(mem_usage)} MiB")  # -> Peak Memory Usage: 79.70703125 MiB



 --- Замеры размеров Python ---

                            -- Примеры Списков deque vs list --                                 <-----
 my_list = [1, 2, 3, 4, 5]
 print(f'getsizeof list:  {sys.getsizeof(my_list)} байт')     # -> getsizeof list:  104 байт
 print(f'asizeof   list:  {asizeof.asizeof(my_list)} байт')   # -> asizeof   list:  264 байт

 from collections import deque
 my_deque = deque([1, 2, 3, 4, 5])
 print(f'getsizeof deque: {sys.getsizeof(my_list)} байт')     # -> getsizeof deque: 104 байт
 print(f'asizeof   deque: {asizeof.asizeof(my_deque)} байт')  # -> asizeof   deque: 760 байт



                            -- Примеры Кортежей namedtuple vs tuple --                          <-----
 my_tuple = (1, 2, 3, 4, 5)
 print(f'getsizeof tuple:       {sys.getsizeof(my_tuple)} байт')    # -> getsizeof tuple:       80 байт
 print(f'asizeof   tuple:       {asizeof.asizeof(my_tuple)} байт')  # -> asizeof   tuple:       240 байт

 from collections import namedtuple
 nt_tuple = namedtuple('nt_tuple', ['a', 'b', 'c', 'd', 'e'])
 p = nt_tuple(1, 2, c=3, d=4, e=5)
 print(f'getsizeof namedtuple:  {sys.getsizeof(p)} байт')           # -> getsizeof namedtuple:  80 байт
 print(f'asizeof   namedtuple:  {asizeof.asizeof(p)} байт')         # -> asizeof   namedtuple:  240 байт

 Создание объекта namedtuple накладывает некоторые накладные расходы (например, ХРАНЕНИЕ ИМЕН ПОЛЕЙ), но для
 НЕБОЛЬШИХ ОБЪЕКТОВ эти накладные расходы могут быть минимальными.
 Однако в большинстве случаев namedtuple будет занимать больше места в памяти по сравнению с обычным кортежем


                            -- Примеры Словарей OrderedDict vs dict --                          <-----
 my_dict = {1: 'a', 2: 'b', 3: 'c'}
 print(f'getsizeof dict:         {sys.getsizeof(my_dict)} байт')     # -> getsizeof dict:       224 байт
 print(f'asizeof   dict:         {asizeof.asizeof(my_dict)} байт')   # -> asizeof   dict:       488 байт


 from collections import OrderedDict
 or_dict = OrderedDict({1: 'a', 2: 'b', 3: 'c'})

 print(f'getsizeof OrderedDict:  {sys.getsizeof(or_dict)} байт')    # -> getsizeof OrderedDict: 448 байт
 print(f'asizeof   OrderedDict:  {asizeof.asizeof(or_dict)} байт')  # -> asizeof   OrderedDict: 712 байт



                            -- Примеры Множества frozenset vs set --                            <-----
 my_set = {1, 2, 3, 4, 5}
 print(f'getsizeof set:        {sys.getsizeof(my_set)} байт')     # -> getsizeof set:       472 байт
 print(f'asizeof   set:        {asizeof.asizeof(my_set)} байт')   # -> asizeof   set:       632 байт


 fz_set = frozenset({1, 2, 3, 4, 5})

 print(f'getsizeof frozenset:  {sys.getsizeof(fz_set)} байт')    # -> getsizeof frozenset:  472 байт
 print(f'asizeof   frozenset:  {asizeof.asizeof(fz_set)} байт')  # -> asizeof   frozenset:  632 байт

 # Если list внутри
 fz_set = frozenset([1, 2, 3, 4, 5])

 print(f'getsizeof frozenset:  {sys.getsizeof(fz_set)} байт')    # -> getsizeof frozenset:  728 байт
 print(f'asizeof   frozenset:  {asizeof.asizeof(fz_set)} байт')  # -> asizeof   frozenset:  888 байт

 # Если tuple внутри
 fz_set = frozenset((1, 2, 3, 4, 5))

 print(f'getsizeof frozenset:  {sys.getsizeof(fz_set)} байт')    # -> getsizeof frozenset:  728 байт
 print(f'asizeof   frozenset:  {asizeof.asizeof(fz_set)} байт')  # -> asizeof   frozenset:  888 байт



                            -- Примеры Строки/Числа str vs int --                              <-----
 my_string = "Hello, World!"
 print(f'getsizeof str:  {sys.getsizeof(my_string)} байт')    # -> getsizeof str:  62 байт
 print(f'asizeof   str:  {asizeof.asizeof(my_string)} байт')  # -> asizeof   str:  64 байт


 my_int = 10000000000000000000000000000

 print(f'getsizeof int:  {sys.getsizeof(my_int)} байт')       # -> getsizeof int:  40 байт
 print(f'asizeof   int:  {asizeof.asizeof(my_int)} байт')     # -> asizeof   int:  40 байт



 # Чем больше строка тем больше размер так же и с другими обьектами

 my_string = "a"

 print(f'getsizeof str:  {sys.getsizeof(my_string)} байт')    # -> getsizeof str:  50 байт
 print(f'asizeof   str:  {asizeof.asizeof(my_string)} байт')  # -> asizeof   str:  56 байт


 my_int = 1

 print(f'getsizeof int:  {sys.getsizeof(my_int)} байт')       # -> getsizeof int:  28 байт
 print(f'asizeof   int:  {asizeof.asizeof(my_int)} байт')     # -> asizeof   int:  32 байт



                            -- Сравнение slots vs no_slots --                                  <-----
                            -- @dataclass(slots=True)  vs  @dataclass() --
 from dataclasses import dataclass

 @dataclass(slots=True)
 class WithSlots:
     value: int

 with_slots = WithSlots(10)
 print(f'getsizeof WithSlots:  {sys.getsizeof(with_slots)} байт')    # -> getsizeof WithSlots:  40 байт
 print(f'asizeof   WithSlots:  {asizeof.asizeof(with_slots)} байт')  # -> asizeof   WithSlots:  72 байт


 @dataclass
 class NoSlots:
     value: int

 no_slots = NoSlots(10)
 print(f'getsizeof NoSlots:    {sys.getsizeof(no_slots)} байт')      # -> getsizeof NoSlots:    56 байт
 print(f'asizeof   NoSlots:    {asizeof.asizeof(no_slots)} байт')    # -> asizeof   NoSlots:    440 байт



  --- Замеры ПУСТЫХ обьектом встроенных Python ---

                             -- Примеры list vs [] vs deque() vs heapq --                       <-----

 my_list = list()
 print(f'getsizeof list():      {sys.getsizeof(my_list)} байт')    # -> getsizeof list():       56 байт
 print(f'asizeof   list():      {asizeof.asizeof(my_list)} байт')  # -> asizeof   list():       56 байт

 my_list = []
 print(f'getsizeof []:          {sys.getsizeof(my_list)} байт')    # -> getsizeof []:           56 байт
 print(f'asizeof   []:          {asizeof.asizeof(my_list)} байт')  # -> asizeof   []:           56 байт


 from collections import deque

 my_deque = deque()
 print(f'getsizeof deque():     {sys.getsizeof(my_deque)} байт')    # -> getsizeof deque():     760 байт
 print(f'asizeof   deque():     {asizeof.asizeof(my_deque)} байт')  # -> asizeof   deque():     760 байт


 import heapq

 my_heapq = []
 heapq.heapify(my_heapq)
 print(f'getsizeof heapq:       {sys.getsizeof(my_heapq)} байт')    # -> getsizeof heapq:       56 байт
 print(f'asizeof   heapq:       {asizeof.asizeof(my_heapq)} байт')  # -> asizeof   heapq:       56 байт





                             -- Примеры set() vs frozenset() --                                 <-----

 my_set = set()
 print(f'getsizeof set():       {sys.getsizeof(my_set)} байт')    # -> getsizeof set():         216 байт
 print(f'asizeof   set():       {asizeof.asizeof(my_set)} байт')  # -> asizeof   set():         216 байт

 my_set = frozenset()
 print(f'getsizeof frozenset(): {sys.getsizeof(my_set)} байт')    # -> getsizeof frozenset():   216 байт
 print(f'asizeof   frozenset(): {asizeof.asizeof(my_set)} байт')  # -> asizeof   frozenset():   216 байт





                             -- Примеры tuple() vs namedtuple() vs () --                        <-----
my_tuple = tuple()
print(f'getsizeof tuple():    {sys.getsizeof(my_tuple)} байт')    # -> getsizeof tuple():       40 байт
print(f'asizeof   tuple():    {asizeof.asizeof(my_tuple)} байт')  # -> asizeof   tuple():       40 байт
print(f'asizeof   ():         {asizeof.asizeof(())} байт')        # -> asizeof   ():            40 байт


 from collections import namedtuple

 my_tuple = namedtuple('C', '')
 nt_tuple = my_tuple()
 print(f'getsizeof namedtuple: {sys.getsizeof(nt_tuple)} байт')    # -> getsizeof namedtuple:   40 байт
 print(f'asizeof   namedtuple: {asizeof.asizeof(nt_tuple)} байт')  # -> asizeof   namedtuple:   40 байт





                             -- Примеры dict() vs {} vs OrderedDict() vs defaultdict() vs ChainMap() --        <-----
 my_dict = dict()
 print(f'getsizeof dict():       {sys.getsizeof(my_dict)} байт')    # -> getsizeof dict():       64 байт
 print(f'asizeof   dict():       {asizeof.asizeof(my_dict)} байт')  # -> asizeof   dict():       64 байт


 my_dict = {}
 print(f'getsizeof {{}}:         {sys.getsizeof(my_dict)} байт')    # -> getsizeof {}:           64 байт
 print(f'asizeof   {{}}:         {asizeof.asizeof(my_dict)} байт')  # -> asizeof   {}:           64 байт


 from collections import OrderedDict

 my_OrDt = OrderedDict()
 print(f'getsizeof OrderedDict:  {sys.getsizeof(my_OrDt)} байт')    # -> getsizeof OrderedDict:  128 байт
 print(f'asizeof   OrderedDict:  {asizeof.asizeof(my_OrDt)} байт')  # -> asizeof   OrderedDict:  128 байт


 from collections import defaultdict

 my_defa = defaultdict(int)     # Все будут весить ОДИНАКОВО!!!
 my_defa = defaultdict(str)     # Все будут весить ОДИНАКОВО!!!
 my_defa = defaultdict(list)    # Все будут весить ОДИНАКОВО!!!
 my_defa = defaultdict(set)     # Все будут весить ОДИНАКОВО!!!
 my_defa = defaultdict(dict)    # Все будут весить ОДИНАКОВО!!!
 my_defa = defaultdict()        # Все будут весить ОДИНАКОВО!!!
 print(f'getsizeof defaultdict():  {sys.getsizeof(my_defa)} байт')    # -> getsizeof defaultdict():  72 байт
 print(f'asizeof   defaultdict():  {asizeof.asizeof(my_defa)} байт')  # -> asizeof   defaultdict():  72 байт


 from collections import ChainMap

 my_chain = ChainMap()
 print(f'getsizeof ChainMap():  {sys.getsizeof(my_chain)} байт')    # -> ggetsizeof ChainMap():  56 байт
 print(f'asizeof   ChainMap():  {asizeof.asizeof(my_chain)} байт')  # -> aasizeof   ChainMap():  536 байт





                             -- Сравнение slots vs no_slots --                                  <-----
                             -- @dataclass(slots=True)  vs  @dataclass() --

 from dataclasses import dataclass

 @dataclass(slots=True)
 class WithSlots:pass

 with_slots = WithSlots()
 print(f'getsizeof WithSlots:  {sys.getsizeof(with_slots)} байт')    # -> getsizeof WithSlots:  32 байт
 print(f'asizeof   WithSlots:  {asizeof.asizeof(with_slots)} байт')  # -> asizeof   WithSlots:  32 байт


 @dataclass
 class NoSlots:pass

 no_slots = NoSlots()
 print(f'getsizeof NoSlots:    {sys.getsizeof(no_slots)} байт')      # -> getsizeof NoSlots:    56 байт
 print(f'asizeof   NoSlots:    {asizeof.asizeof(no_slots)} байт')    # -> asizeof   NoSlots:    352 байт





                             -- Обычные классы По размеру тоже самое что @dataclass(slots=True)  vs  @dataclass() --
                             -- Сравнение slots vs no_slots --

 class WithSlots:__slots__ = ()

 with_slots = WithSlots()
 print(f'getsizeof WithSlots:  {sys.getsizeof(with_slots)} байт')    # -> getsizeof WithSlots:  32 байт
 print(f'asizeof   WithSlots:  {asizeof.asizeof(with_slots)} байт')  # -> asizeof   WithSlots:  32 байт


 class NoSlots:pass

 no_slots = NoSlots()
 print(f'getsizeof NoSlots:    {sys.getsizeof(no_slots)} байт')      # -> getsizeof NoSlots:    56 байт
 print(f'asizeof   NoSlots:    {asizeof.asizeof(no_slots)} байт')    # -> asizeof   NoSlots:    352 байт





                            -- Примеры int() float() complex() True False str() range(0) bytes() bytearray() vs None --
                            -- И пустые объекты Тоже самое 0  ''  0.0  0j  b""  bytearray(b"")  object()  --     <-----

 my_int = int()
 print(f'getsizeof int():  {sys.getsizeof(my_int)} байт')            # -> getsizeof int():      28 байт
 print(f'asizeof   int():  {asizeof.asizeof(my_int)} байт')          # -> asizeof   int():      32 байт
 print(f'asizeof   0:      {asizeof.asizeof(0)} байт')               # -> asizeof   0:          32 байт


 my_float = float()
 print(f'getsizeof float():  {sys.getsizeof(my_float)} байт')        # -> getsizeof float():    24 байт
 print(f'asizeof   float():  {asizeof.asizeof(my_float)} байт')      # -> asizeof   float():    24 байт
 print(f'asizeof   0.0:      {asizeof.asizeof(my_float)} байт')      # -> asizeof   0.0:        24 байт


 my_comp = complex()
 print(f'getsizeof complex():  {sys.getsizeof(my_comp)} байт')       # -> getsizeof complex():  32 байт
 print(f'asizeof   complex():  {asizeof.asizeof(my_comp)} байт')     # -> asizeof   complex():  32 байт
 print(f'asizeof   0j:         {asizeof.asizeof(my_comp)} байт')     # -> asizeof   0j:         32 байт


 # True
 print(f'getsizeof True:  {sys.getsizeof(True)} байт')               # -> getsizeof True:       28 байт
 print(f'asizeof   True:  {asizeof.asizeof(True)} байт')             # -> asizeof   True:       32 байт


 # False
 print(f'getsizeof False:  {sys.getsizeof(False)} байт')             # -> getsizeof False:      28 байт
 print(f'asizeof   False:  {asizeof.asizeof(False)} байт')           # -> asizeof   False:      32 байт


 # None  занимает фиксированное количество памяти!!!        Один из самых маленьких объектов по памяти!!!      <-----
 print(f'getsizeof None:  {sys.getsizeof(None)} байт')               # -> getsizeof None:       16 байт
 print(f'asizeof   None:  {asizeof.asizeof(None)} байт')             # -> asizeof   None:       16 байт


 my_str = str()
 print(f'getsizeof str():  {sys.getsizeof(my_str)} байт')            # -> getsizeof str():      49 байт
 print(f'asizeof   str():  {asizeof.asizeof(my_str)} байт')          # -> asizeof   str():      56 байт
 print(f'asizeof   "":     {asizeof.asizeof("")} байт')              # -> asizeof   "":         56 байт


 my_range = range(0)
 print(f'getsizeof range(0):  {sys.getsizeof(my_range)} байт')       # -> getsizeof range(0):   48 байт
 print(f'asizeof   range(0):  {asizeof.asizeof(my_range)} байт')     # -> asizeof   range(0):   48 байт


 my_bytes = bytes()
 print(f'getsizeof bytes():  {sys.getsizeof(my_bytes)} байт')        # -> getsizeof bytes():    33 байт
 print(f'asizeof   bytes():  {asizeof.asizeof(my_bytes)} байт')      # -> asizeof   bytes():    40 байт
 print(f'asizeof   b"":      {asizeof.asizeof(b"")} байт')           # -> asizeof   b"":        40 байт


 my_b_arr = bytearray()
 print(f'getsizeof bytearray():  {sys.getsizeof(my_b_arr)} байт')    # -> getsizeof bytearray():              56 байт
 print(f'asizeof   bytearray():  {asizeof.asizeof(my_b_arr)} байт')  # -> asizeof   bytearray():              56 байт
 print(f'asizeof   bytearray(b""):  {asizeof.asizeof(bytearray(b""))} байт')  # -> asizeof   bytearray(b""):  56 байт


 my_object = object()
 print(f'getsizeof object():  {sys.getsizeof(my_object)} байт')      # -> getsizeof object():   16 байт
 print(f'asizeof   object():  {asizeof.asizeof(my_object)} байт')    # -> asizeof   object():   0 байт

 object() возвращает 0 байт, потому что функция `asizeof` не находит вложенных объектов или атрибутов для учета,
 так как `object` не содержит информации.  Сам по себе object() - весит 16 байт
 object() - является базовым пустым объектом без дополнительных атрибутов или содержимого.



 # Обьединение *                                # Объединения **
 A = [1, 2, 3]  # list                          a = {"w": 5, "x": 6}
 B = (4, 5, 6)  # tuple                         b = {"y": 7}
 C = {7, 8, 9}  # set                           c = {"z": 8, **a, **b}
 L = [*A, *B, *C]                               print(c)  # -> {'z': 8, 'w': 5, 'x': 6, 'y': 7}
 G = list(chain(A, B, C))
 print(L)  # -> [1, 2, 3, 4, 5, 6, 8, 9, 7]
 print(G)  # -> [1, 2, 3, 4, 5, 6, 8, 9, 7]


 --- Символьный ад ---
 Уберите детей от экрана.

 {'a': 1}   # это словарь
 dict(a=1)  # это то же самое
 {'a'}      # это множество (set)
 {}         # это не пустое множество, это пустой словарь
 set()      # а вот это пустое множество

 1        # это просто число (int)
 (1)      # это тоже просто число
 (1, 2)   # это кортеж (tuple)
 1,       # это тоже кортеж
 ()       # это пустой кортеж
 (1+2)    # это число
 tuple()  # а это тоже пустой кортеж

 []                     # это пустой список
 [1]                    # это список с одним элементом
 [1, 2, 3]              # это список с 3 элементами
 [i for i in range(3)]  # это тоже список с 3 элементами
 ()                     # это пустой кортеж
 (1)                    # это просто число
 (1, 2, 3)              # это (ха-ха) кортеж
 (i for i in range(3))  # это не кортеж, это генератор :D


 --- Символьный ад  2 ---

 {'a': 1}               # это словарь
 {'a'}                  # это множество (set)
 {}                     # это не пустое множество, это пустой словарь
 set()                  # а вот это пустое множество

 1                      # это просто число (int)
 (1+2)                  # это число
 (1, 2)                 # это кортеж (tuple)
 (1)                    # это тоже просто число
 1,                     # это тоже кортеж
 ()                     # это пустой кортеж
 (,)                    # SyntaxError

 []                     # это пустой список
 [1]                    # это список с одним элементом
 [1, 2, 3]              # это список с 3 элементами
 [i for i in range(3)]  # это тоже список с 3 элементами
 ()                     # это пустой кортеж
 (1)                    # это просто число
 (1, 2, 3)              # это кортеж
 (i for i in range(3))  # это не кортеж, это generator expression


 Модель Random Access Machine (RAM) - это абстрактная модель вычислений, которая используется для анализа алгоритмов.
 Основная цель RAM — упростить анализ сложности алгоритмов, предполагая мгновенный доступ к данным.

 ПРОСТРАНСТВЕННАЯ (емкостаная) СЛОЖНОСТЬ - относиться к объему используемой ПАМЯТИ, необходимой для выполнения алгоритма



 --- Big O или Big Oh    Временная сложность ---
 Простыми словами Big O показывает как будет меняться производительность алгоритма в зависимости от роста входящих данных.
 Описания алгоритмической сложности. Она показывает, как сильно увеличится количество операций при увеличении размера данных.
 Примеры нотаций Big O:

 O(1):  Константная сложность. - Время выполнения алгоритма остается постоянным и не зависит от объема данных.
 O(log n): Логарифмическая сложность.  - Время выполнения алгоритма растет медленно с увеличением размера входных данных.
 Например Бинарный поиск в отсортированном массиве.   Везде где есть ДЕЛЕНИЕ будет   O(log n)   Бинарное дерево   <-----
 O(n):  Линейная сложность. - Время выполнения алгоритма растет линейно с увеличением размера входных данных.
 O(n log n): Линейно-логарифмическая сложность. - Время выполнения алгоритма растет быстрее, чем линейно, но медленнее,
 чем квадратично. Например, сортировка слиянием (merge sort).
 O(n^2): Квадратичная сложность. - Время выполнения алгоритма зависит от квадрата размера входных данных.
 Например, сортировка пузырьком (bubble sort).
 O(n^3): Кубическая сложность. Время выполнения алгоритма зависит от размера входных данных в кубе. Например, алгоритмы,
 которые имеют три вложенных цикла, такие как некоторые методы многомерной обработки данных.
 O(n!): Факториальная сложность. Это самая высокая степень роста времени выполнения алгоритма. Время выполнения
 алгоритма растет факториально от размера входных данных. Этот тип сложности встречается, например, при переборе всех
 возможных комбинаций элементов, что делает его чрезвычайно неэффективным для больших значений n.

 Скорость Алгоритмов:
 0(1) -> O(log n) -> O(n) -> O(n log n) -> O(n^2) -> O(n^3) -> O(n!)

 Худший случай (worst case)    - Когда входные данные требуют максимальных затрат времени и памяти.
 Лучший случай (best case)     - Полная противоположность worst case, самые удачные входные данные.
 Средний случай (average case) - Самый хитрый из тройки. Между best case и worst case, расчёт average case - Дело сложное

 Amortized Амортизированный анализ — это метод анализа сложности данного алгоритма или того , сколько ресурсов, особенно
 времени или памяти, требуется для его выполнения . Усредняет время выполнения операций в последовательности


  Big O или Big Oh - Верхняя оценка сложности алгоритма      Асимптотика    Асимптотический анализ
 Нотация большого O обозначает верхнюю границу времени выполнения алгоритма. Таким образом,
 она указывает на сложность алгоритма в худшем случае.


 --- Как определить Вычислительную сложность АЛГОРИТМА? ---

 O(1):  Константная сложность.
 Пример как работает   НЕ важно сколько команд входит в эту операцию:

 # Не важно сколько операций ГЛАВНОЕ ЧТОБЫ ВСЕ ОНИ БЫЛИ ЗА O(1)
 var_a = 10
 inf = float('inf')
 print(inf)

 # Все отбрасывается  Будет только 0(1)
 0(10) = 0(1)
 0(C) = 0(1)
 0(1 + 1 + 1) = 0(3) = 0(1)



 O(n):  Линейная сложность.  n == переменная

 # Число итераций зависит от Размерности lst    ЧЕМ  БОЛЬШЕ N тем больше итераций нужно сделать в цикле
 lst = [1, 4, 10, -5, 0, 2, 3, 18, 32]

 # Все команды будут 0(n)
 for i in lst:
     print(i, end=' ')
     i += 1

 # Все отбрасывается  Будет только 0(n)
 0(2n) = 0(n)
 0(1 + n) = 0(n)
 0(A * n) = 0(n)
 0(n + C) = 0(n)
 0(A * n + C) = 0(n)

 # Более сложный пример КАК РАСЧИТАТЬ СЛОЖНОСТЬ АЛГОРИТМА  Вычислительная сложность АЛГОРИТМА       <-----     <-----

 # 0(1)  Выполнение команды
 lst = [1, 4, 10, -5, 0, 2, 3, 18, 32]   # 0(1)  Выполнение команды

 # 0(n)  Выполнение Цикла
 for i, v in enumerate(lst):             # 0(n)  Выполнение Цикла
     lst[i] += 1

 # 0(n)  Выполнение Цикла
 for i in lst:                           # 0(n)  Выполнение Цикла
     print(i, end=' ')

 # Важно!!!  <-----                                                                                            <-----
 # Выходит следующее выражение   0(1) + 0(n) + 0(n) = 0(1 + n + n) = 0(1 + 2n)   Все отбрасывается  Будет только 0(n)


 # Правила сложения и умножения   ОТБРАСЫВАТЬ МОЖНО ТОЛЬКО КОНСТАНТЫ НО НЕ ПЕРЕМЕННЫЕ                          <-----

 # Для последовательных циклов сложение(+)   0(n + m)
 # 0(n)  Выполнение Цикла
 for i in range(n):             # 0(n)  Выполнение Цикла    переменная  n
     print(i)

 # 0(n)  Выполнение Цикла
 for i in range(m):             # 0(n)  Выполнение Цикла    переменная  m
     print(i)

 # Важно!!!  <-----         ОТБРАСЫВАТЬ МОЖНО ТОЛЬКО КОНСТАНТЫ НО НЕ ПЕРЕМЕННЫЕ                                <-----
 # Выходит следующее выражение  0(n) + 0(m) = 0(n + m)   СОКРАТИТЬ НИЧЕГО НЕЛЬЗЯ ПОТОМУ ЧТО ОБЕ ВЕЛИЧИНЫ == ПЕРЕМЕННЫЕ!!


 # Для вложенных циклов умножение(*)   0(n * m)
 for i in range(n):                             # 0(n * m) Потому что делаем перебор
     for j in range(m):
         print(i, y)

 # Если n = m:   0(n + n) = 0(2n) = 0(n)      При ВЛОЖЕННЫХ ЦИКЛАХ будет 0(n^2)   0(n * n) = 0(n^2)   Важно!!! <-----



 НЕ ВАЖНАЯ СЛОЖНОСТЬ
 # Для вложенных циклов умножение(*)   0(n * n) = 0(n^2)
 for i in range(n):                             # 0(n * n) = 0(n^2)
     for j in range(n):
         print(i, y)

 # Добавили еше 1 цикл
 # 0(n^2 + n) = 0(n^2)
 for t in range(n):                             # 0(n^2 + n) = 0(n^2)
     print(t)

 # Объяснение n^2  ЗНАЧИТЕЛЬНО БОЛЬШЕ ЧЕМ   n - Можно отбросить  будет 0(n^2 + n) = 0(n^2)
 # Если одно слагаемое принимает значение БОЛЕЕ ЧЕМ В 2 (ДВА) РАЗА БОЛЬШЕ чем другое значит МОЖНО ОТБРОСИТЬ
 # Примеры: 0(n + log n) = 0(n)         0(3n + 10n^2 + 2^n) = 0(n +10n^2 + 2^n) = 0(2^n)    Важно!!!   <-----
 # Если ничего не знаем об A      0(2^n + A) = 0(2^n + A)   Ничего не отбрасываем



 O(log n): Логарифмическая сложность.   Как пример бинарный поиск

 bin_lst = [-1, -3, 2, 4, 5, 7, 8, 9]  # Будем искать 9
 # БИНАРНЫЙ поиск  O(log n) - кратко как работает берем серединный элемент например  4
 # сравниваем 9 > 4  и будем искать  ТОЛЬКО УЖЕ ТУТ   [4, 5, 7, 8, 9]
 # берем серединный элемент например  7
 # сравниваем 9 > 7  и будем искать  ТОЛЬКО УЖЕ ТУТ   [8, 9]


 -- Интересный факт про append --
 Иногда append может быть за O(n)
 Таким образом, хотя `append` обычно выполняется за O(1), в особых ситуациях, связанных с перераспределением памяти,
 она может быть O(n). В среднем же, для обычного использования, её можно считать O(1).

 в Python операция `append` для списков в основном выполняется за O(1), но в редких случаях, когда требуется
 перераспределение памяти (например, при достижении максимальной емкости списка), она может занять O(n).
 Поэтому в худшем случае, когда происходит перераспределение, `append` может быть O(n), но это случается редко и в
 среднем время выполнения составляет O(1).


 --- Big O различных операций в CPython ---
 n — это количество элементов, находящихся в контейнере в данный момент.
 k — это либо значение параметра, либо количество элементов в параметре.


 Список (list):
 Внутри список представлен как массив; самые большие затраты возникают из-за превышения текущего размера выделения
 (поскольку все должно перемещаться) или из-за вставки или удаления где-то в начале (поскольку все, что после этого,
 должно перемещаться). Если вам нужно добавить/удалить на обоих концах, рассмотрите возможность использования вместо
 этого Collections.deque.

 Operation  Average Case  Amortized Worst Case
 Copy       O(n)          O(n)
 Append     O(1)          O(1)
 Pop last   O(1)          O(1)
 Pop(i)     O(n)          O(n)
 Insert     O(n)          O(n)
 Get Item   O(1)          O(1)
 Set Item   O(1)          O(1)
 Del Item   O(n)          O(n)
 Iteration  O(n)          O(n)
 Get Slice  O(k)          O(k)
 Del Slice  O(n)          O(n)
 Set Slice  O(k+n)        O(k+n)
 Extend     O(k)          O(k)
 Sort       O(n log n)    O(n log n)
 Multiply * O(nk)         O(nk)
 x in s     O(n)
 min(s)     O(n)
 max(s)     O(n)
 Get Length O(1)          O(1)
------------------------------------------------------------------------------------------------------------------------

 collections.deque
 collections.deque (double-ended queue) (двусторонняя очередь) внутренне представляется как двусвязный список.
 (Ну, для большей эффективности это список массивов, а не объектов.) Оба конца доступны, но даже просмотр середины
 происходит медленно, а добавление или удаление из середины происходит еще медленнее.

 Operation  Average Case  Amortized Worst Case
 Copy       O(n)          O(n)
 append     O(1)          O(1)
 appendleft O(1)          O(1)
 pop        O(1)          O(1)
 popleft    O(1)          O(1)
 extend     O(k)          O(k)
 extendleft O(k)          O(k)
 rotate     O(k)          O(k)
 remove     O(n)          O(n)
 Get Length O(1)          O(1)
------------------------------------------------------------------------------------------------------------------------

 Множество (set)
 реализация намеренно очень похожа на Словарь (dict)
 поиск/вставка/удаление в среднем за O(1) в худшем O(n)  set реализован как хеш-таблица

 Operation                         Average Case            Amortized Worst Case
 x in s                            O(1)                    O(n)
 Union s|t                         O(len(s)+len(t))
 Intersection s&t                  O(min(len(s), len(t)))  O(len(s) * len(t))     замените «min» на «max», если t не является set
 Multiple intersection s1&s2&..&sn                         (n-1)*O(l) where l is max(len(s1),..,len(sn))
 Difference s-t                    O(len(s))
 s.difference_update(t)            O(len(t))
 Symmetric Difference s^t          O(len(s))               O(len(s) * len(t))
 s.symmetric_difference_update(t)  O(len(t))               O(len(t) * len(s))
------------------------------------------------------------------------------------------------------------------------

 Словарь (dict)
 поиск/вставка/удаление в среднем за O(1) в худшем O(n)  dict реализован как хеш-таблица

 Operation  Average Case  Amortized Worst Case
 k in d     O(1)          O(n)
 Copy       O(n)          O(n)
 Get Item   O(1)          O(n)
 Set Item   O(1)          O(n)
 Del Item   O(1)          O(n)
 Iteration  O(n)          O(n)


 --- Интересный факт ---                                                                        <------
 Обратите внимание, что существует быстрый путь для dict, которые (на практике) работают только с ключами str; это не
 влияет на алгоритмическую сложность, но может существенно влиять на постоянные факторы: как быстро завершается типичная программа.

 -- Строковые (str) ключи в словаре (dict) - ПРЕДПОЧТИТЕЛЬНЕЕ    работают быстрее               <------
 # Таким образом, использование строковых ключей происходит примерно на 30% +/- быстрее даже по сравнению с int ключами
 print(timeit.timeit('a["500"]', 'a ={}\nfor i in range(1000): a[str(i)] = i')) # Поиск str key быстрее
 # 0.04318580008111894
 print(timeit.timeit('a[500]', 'a ={}\nfor i in range(1000): a[i] = i'))        # Поиск str key быстрее чем другие
 # 0.068284000037238

 -- Но специально преобразовывать их будет Дороже                                               <------
 Преобразование вашего ключа в строку будет стоить (намного) дороже, чем небольшой прирост, который вы могли бы получить,
 если бы он был строкой для dict.
 # Как вы можете видеть, несмотря на то, что строковый dict работает быстрее, преобразование ключа по сравнению с ним
 очень затратно, что полностью снижает выигрыш (и даже больше).

 print(timeit.timeit("a[500]", "a={key: 1 for key in range(1000)}" ))
 # 0.06836240005213767
 print(timeit.timeit("a[\"500\"]", "a={str(key): 1 for key in range(1000)}" ))
 # 0.04284069989807904
 print(timeit.timeit("a[str(500)]", "a={str(key): 1 for key in range(1000)}" ))
 # 0.16474479995667934

 -- Вывод --                                                                                     <------
 Так что да, если данные, которые вы используете, используются только в качестве ключей к словарю, и не имеет значения,
 в каком формате вы их храните, тогда предпочтительнее использовать строки в небольшом словаре.  <------
------------------------------------------------------------------------------------------------------------------------

 -- У каждого объекта с методом __iter__() автоматически начинает работать метод __contains__().
 -- Iterable Пример:

 class MyIterable:
     def __init__(self, *args):
         self.a = list(args)

     def __iter__(self):
         return iter(self.a)   #  <-----

 mi = MyIterable(1, 2, 3, 4)
 print([el for el in mi])          # -> [1, 2, 3, 4]
 print(1 in mi)  # __contains__()

 -- Collection Пример:

 class MyCollection:
     def __init__(self, *args):
         self.a = list(args)

     def __iter__(self):
         return iter(self.a)   #  <-----

     def __len__(self):
         return len(self.a)    #  <-----

 mc = MyCollection(1, 2, 3, 4)
 print([el for el in mc])        # ->  [1, 2, 3, 4]
 print(1 in mc)                  # ->  True
 print(len(mc))                  # ->  4

 -- Sequence Пример:

 class MySequence:
    def __init__(self, a):
        self.a = a
    def __len__(self):
        return len(self.a)
    def __getitem__(self, i):
        return self.a[i]


 --- Тип данных Iterator, Протокол итератора (iterator protocol)  Iterator Types ---

 Протокол итератора (iterator protocol) - объекты итератора должны поддерживать  iterator.__iter__()  и iterator.__next__()

 Сами объекты итератора должны поддерживать следующие два метода, которые вместе образуют протокол итератора:

 container.__iter__() - Метод вернет объект итератора. Это необходимо для того, чтобы разрешить использование контейнеров
 и итераторов с операторами for и in. Метод container.__iter__() соответствует слоту tp_iter структуры типа для объектов
 Python в API-интерфейсе. PyTypeObject.tp_iter - необязательный указатель на функцию, которая возвращает итератор для
 объекта. Его присутствие обычно сигнализирует о том, что экземпляры этого типа являются итеративными, хотя
 последовательности могут быть итерируемыми без этой функции.

 container.__next__() - Метод должен возвращать следующий элемент из контейнера, а если элементы в последовательности
 закончились, то метод container.__next__() должен бросить исключение StopIteration.

 Этот метод соответствует PyTypeObject.tp_iternext слоту структуры типа для объектов Python в API Python/C.

 Python определяет несколько объектов итератора для поддержки итерации по общим и конкретным типам последовательностей,
 словарям и другим более специализированным формам. Конкретные типы не важны за пределами их реализации протокола итератора.

 Как только метод container.__next__() итератора вызывает StopIteration, он должен продолжать вызывать его и при
 последующих вызовах. Реализации, которые не подчиняются этому свойству, считаются нарушенными.

 Для создания объекта типа Iterator можно воспользоваться встроенной функцией iter(). По итератору можно двигаться с помощью функции next().

 it = iter([i*i for i in range(10)])
 - Нельзя получить длину итератора функцией len():
 len(it) -> TypeError: object of type 'list_iterator' has no len()

 НО МОЖНО ИСПОЛЬЗОВАТЬ more_itertools.ilen(iterable) - Возвращает количество элементов в iterable .
 from more_itertools import ilen

 ilen(it) # -> 10

 - Итератор не поддерживает получение элемента по индексу:
 it[2] ->  TypeError: 'list_iterator' object is not subscriptable

 - К итератору нельзя применить обычные операции среза или функцию slice(). Для этих целей, можно использовать функцию
 itertools.islice() модуля itertools. - так же подходит и к генератору
 it = iter([i*i for i in range(10)])
 it[2:5]  -> TypeError: 'list_iterator' object is not subscriptable

 import itertools
 list(itertools.islice(it, 2, 5)) -> # [49, 64, 81]

 class more_itertools.islice_extended(iterable, stop)  для получения отрицательных индексов
 from more_itertools import islice_extended

 iterable = iter('abcdefgh')
 list(islice_extended(iterable, -4, -1))  # -> ['e', 'f', 'g']

 # Срезы напрямую Любые Отрицательные или Положительные
 iterable = iter('abcdefgh')
 list(islice_extended(iterable))[-4:-1]  # -> ['e', 'f', 'g']

 - После прохождения по итератору, он остается пустым:
 it = iter([i*i for i in range(10)])
 list(it)
 # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
 list(it)
 # []


 # reversed/__reversed__() НЕ Работает с generator/iterator  (Любой итератор)

 print(*reversed([1 for _ in '123']))          # -> 1 1 1
 print([1 for _ in '123'].__reversed__())      # -> <list_reverseiterator object at 0x000001DB708FFA30>
 print(*reversed((1 for _ in '123')))          # -> TypeError: 'generator' object is not reversible
 print(*reversed(iter([1 for _ in '123'])))    # -> TypeError: 'list_iterator' object is not reversible


 # Перевернуть генератор/итератор

 # Через list
 my_list = [1, 2, 3, 4, 5]
 my_generator = (x**2 for x in my_list)

 for item in reversed(list(my_generator)):
     print(item, end=' ')  # -> 25 16 9 4 1


 # Тоже самое только через tuple
 my_list = [1, 2, 3, 4, 5]
 my_generator = (x**2 for x in my_list)

 for item in reversed(tuple(my_generator)):
     print(item, end=' ')  # -> 25 16 9 4 1

 # Как перевернуть генератор/итератор?     reversed(list)

 # Что будет на выходе ПОСМОТРИ
 my_list = [1, 2, 3, 4, 5]
 my_generator = (x**2 for x in my_list)

 print(reversed(list(my_generator)))  # -> <list_reverseiterator object at 0x000001C4286F3A00>
 print(my_generator)                  # -> <generator object <genexpr> at 0x000001CA17B23850>
 print(list(my_generator))            # -> []


 Пример создания итератора Iterator:

 class SimpleIterator:
     def __iter__(self):
         return self

     def __init__(self, limit):
         self.limit = limit
         self.counter = 0

     def __next__(self):
         if self.counter < self.limit:
             ret = self.counter
             self.counter += 1
             return ret
         else:
             raise StopIteration

 iters = SimpleIterator(4)

 print('Функция next:', next(iters))
 # Функция next: 0

 for i in iters:
    print('Цикл for ... in: ', i)
 # Цикл for ... in:  1
 # Цикл for ... in:  2
 # Цикл for ... in:  3

 next(iters)
 # StopIteration

 Обратите внимание, что по итератору можно двигаться только вперед. Нет возможности получить предыдущий элемент,
 сбросить итератор или сделать его копию!!! Объекты-итераторы могут дополнительно предоставлять эти дополнительные
 возможности, но протокол итератора определяет только метод __next__(). Следовательно, функция может потребить весь
 вывод итератора, и если нужно сделать что-то другое с тем же итератором, то придется создать его снова:

 Интересные примеры!!!
 a_list = iter([1, 2, 3])
 print(list(a_list)) -> [1, 2, 3]
 print(list(a_list)) -> []

 a_list = iter([1, 2, 3])
 print(3 in a_list)  -> True
 print(list(a_list)) -> []

 # Находит элемент дальше не идет!
 a_list = iter([1, 2, 3])
 print(1 in a_list)  # -> True
 print(list(a_list)) # -> [2, 3]

 a_list = iter([1, 2, 3])
 print(3 in a_list)  -> True
 print(2 in a_list)  -> False

 a_list = iter([1, 2, 3])
 print(max(a_list)) -> 3
 print(min(a_list)) -> ValueError: min() arg is an empty sequence


 Недостаток типа Iterator состоит в том, что при первом его вызове вычисляются сразу все значения последовательности как
 физической, так и виртуальной, к тому же все они хранятся в памяти до их исчерпания. Этот недостаток решает тип generator (генератор).


 --- Generator Types Протокол генератора в Python и выражение yield ---

 Тип generator (генератор) похож на тип iterator (итератор), но тип generator не хранит значения последовательности в
 памяти, а генерирует/вычисляет результат на лету - в ходе каждого вызова, тем самым экономит память и вычислительные ресурсы.

 Функция считается генератором, если:
 - Cодержит одно или несколько выражений yield.
 - При вызове возвращает объект типа generator, но не начнет выполнение.
 - Методы __iter__() и __next__() реализуются автоматически.
 - После каждого вызова функция приостанавливается, а управление передается вызывающей стороне.
 - Локальные переменные и их состояния запоминаются между последовательными вызовами.
 - Когда вычисления заканчиваются по какому то условию, автоматически вызывается StopIteration.

 Важно! Так как генератор - это "улучшенный" итератор, следовательно на тип generator распространяются такие же
 ограничения как и на тип iterator.

 - Нельзя получить длину генератора функцией len():
 - не поддерживает получение элемента по индексу
 - После прохождения по генератору, он остается пустым

 для срезов используем - itertools.islice()   но не поддерживает отрицательные индексы -1...
 для Отрицательных или Положительных срезов используем - from more_itertools import islice_extended

 Методы Генератора:
 generator.__name__      - Имя
 generator.__qualname__  - Полное имя функции
 generator.gi_frame      - Фрейм кода
 generator.gi_running    - генератор работает?
 generator.gi_code       - Объект кода
 generator.gi_yieldfrom  - объект, который итерируется с помощью  yield from или None

 Выражение yield предоставляют удобный способ реализации протокола итератора, который технически, представляет из себя
 объект генератора. Это выражение используется в теле функции и приводит к тому, что функция становится генератором.
 Выражение yield используется примерно как return, отличие в том, что функция возвращает генератор.

 Функции-генераторы так же могут включать инструкцию return, которая завершает генерацию значений, возбуждая исключение
 StopIteration после выполнения обычного выхода из функции. С точки зрения вызывающей программы,
 метод generator.__next__() генератора возобновляет выполнение функции, пока она не встретит следующую инструкцию yield
 или пока не возбудит исключение StopIteration.

 Принцип работы генератора:
 Выполнение начинается при вызове одного из методов генератора. В это время выполнение переходит к первому выражению
 yield, где он снова приостанавливается, возвращая значение expression_list, объекту, вызвавшему генератор. Под
 приостановкой, подразумевается сохранение всех локальных состояний, включая текущие привязки локальных переменных,
 указатель инструкции, внутренний стек вычислений и состояние любой обработки исключений.

 Когда выполнение возобновляется вызовом одного из методов генератора, то он может действовать точно так же, как если бы
 выражение yield было просто другим внешним вызовом. Значение выражения yield после возобновления зависит от метода,
 который возобновил выполнение. Если используется метод generator.__next__() (обычно через for ... in или функцию next()),
 то результат отсутствует. В противном случае, если используется метод generator.send(), то результатом будет значение,
 переданное этому методу.

 Выражения yield допускаются в любом месте конструкции try ... expect. Если генератор не возобновляется до его завершения
 (при достижении нулевого числа ссылок или при сборе мусора), то вызывается метод generator.close() генератора,
 позволяющий инструкции finally в конструкции try ... expect, выполнить любой завершающий код.

 Пример демонстрирующий методы и поведение генератора:
 def echo(value=None):
    print("next() вызвали в первый раз - началось выполнение.")
    try:
        while True:
            try:
                value = (yield value)
                # Приостановка. Все локальное состояние
                # сохраняется до следующего вызова
            except Exception as e:
                value = e
    finally:
        print("Вызван метод close(), не забудьте очистить память.")

 generator = echo(1)
 print(next(generator))
 # next() вызвали в первый раз - началось выполнение.
 # 1
 print(next(generator))
 # None
 print(generator.send(2))
 # 2
 print(generator.throw(TypeError, "- Error -"))
 # - Error -
 generator.close()
 # Вызван метод close(), не забудьте очистить память.


 Generator-iterator methods:
 generator.__next__() - Запускает выполнение функции генератора или возобновляет его при последнем выполненном выражении yield.

 generator.send(value) - Метод возобновляет выполнение и “отправляет " значение в функцию генератора.

 generator.throw(value), generator.throw(type[, value[, traceback]]) - Создает исключение в точке, где генератор был
 приостановлен, и возвращает следующее значение, выданное функцией генератора .

 generator.close() - Метод вызывает исключение GeneratorExit в точке, где функция генератора была приостановлена.

 Обратите внимание, что вызов любого из методов генератора, когда генератор уже выполняется, вызывает исключение ValueError.

 Glossary:
 generator - Функция, возвращающая итератор-генератор . Она выглядит как обычная функция, за исключением того, что она
 содержит yield выражения для создания серии значений, которые можно использовать в цикле for или которые можно получать
 по одному с помощью функции next().

 generator iterator (итератор-генератора) - Объект, созданный функцией -генератором .
 Каждый из них yield временно приостанавливает обработку, запоминая состояние выполнения местоположения
 (включая локальные переменные и ожидающие операторы try). Когда итератор-генератор возобновляет работу,
 он продолжает работу с того места, где остановился (в отличие от функций, которые начинаются заново при каждом вызове).

 В чем разница между итераторами и генераторами?

 Каждый генератор является итератором, но не наоборот. Генератор создается путем вызова функции, которая имеет одно или
 несколько yield выражений (yield инструкции в Python 2.5 и более ранних версиях) и является объектом, соответствующим определению iterator.

 Возможно, вы захотите использовать собственный итератор, а не генератор, если вам нужен класс с несколько сложным
 поведением по поддержанию состояния или вы хотите предоставить другие методы, кроме __next__(и __iter__и __init__).
 Чаще всего генератора (иногда, для достаточно простых нужд, выражения генератора ) достаточно, и его проще кодировать,
 поскольку поддержание состояния (в разумных пределах) по сути «делается за вас» путем приостановки и возобновления кадра.

 Например, такой генератор, как:
 def squares(start, stop):
    for i in range(start, stop):
        yield i * i

 generator = squares(a, b)

 или эквивалентное выражение генератора (genexp)
 generator = (i*i for i in range(a, b))

 для создания пользовательского итератора потребуется больше кода:
 class Squares(object):
    def __init__(self, start, stop):
       self.start = start
       self.stop = stop

    def __iter__(self):
        return self

    def __next__(self): # next in Python 2
       if self.start >= self.stop:
           raise StopIteration
       current = self.start * self.start
       self.start += 1
       return current


 iterator = Squares(a, b)

 Генератор — это итератор
 В частности, генератор является подтипом итератора.
 print(issubclass(collections.abc.Generator, collections.abc.Iterator))  # -> True
 print(issubclass(types.GeneratorType, collections.abc.Iterator))        # -> True

 yield предоставляет простой способ реализации протокола итератора.

 Мы можем создать генератор несколькими способами. Очень распространенный и простой способ сделать это — с помощью функции.
 В частности, функция с yield — это функция, которая при вызове возвращает генератор:

 def a_function():
    "just a function definition with yield in it"
    yield

 print(type(a_function))
 # <class 'function'>
 a_generator = a_function()     # when called
 # <class 'generator'>
 print(type(a_generator))      # returns a generator

 И генератор, опять же, является Итератором:
 isinstance(a_generator, collections.abc.Iterator) -> True

 Итератор — это итерируемый объект
 issubclass(collections.abc.Iterator, collections.abc.Iterable) -> True

 для которого требуется __iter__ метод, возвращающий итератор:
 collections.abc.Iterable() -> TypeError: Can't instantiate abstract class Iterable with abstract method __iter__

 Некоторыми примерами итераций являются:
 built-in tuples, lists, dictionaries, sets, frozen sets, strings, byte strings, byte arrays, ranges and memoryviews:

 all(isinstance(element, collections.abc.Iterable) for element in (
    (), [], {}, set(), frozenset(), '', b'', bytearray(), range(0), memoryview(b'')))  -> True

 Мы можем получить итераторы из встроенных объектов (или пользовательских объектов) с помощью функции iter:
 all(isinstance(iter(element), collections.abc.Iterator) for element in (
    (), [], {}, set(), frozenset(), '', b'', bytearray(), range(0), memoryview(b''))   -> True

 Генераторы Python предоставляют удобный способ реализации протокола итератора.
 Итак, из этого мы узнаем, что генераторы — это (удобный) тип итератора.

 Примеры объектов итератора:

 import collections

 class Yes(collections.abc.Iterator):

     def __init__(self, stop):
         self.x = 0
         self.stop = stop

     def __iter__(self):
         return self

     def next(self):
         if self.x < self.stop:
             self.x += 1
             return 'yes'
         else:
             # Iterators must raise when done, else considered broken
             raise StopIteration

     __next__ = next # Python 3 compatibility

 Но для этого проще просто использовать генератор:
 def yes(stop):
    for _ in range(stop):
        yield 'yes'

 Или, возможно, проще, выражение-генератор (работает аналогично пониманию списков):

 yes_expr = ('yes' for _ in range(stop))

 различия между yield и return?
 - Всё, что делает return — это возвращает указанный объект и завершает работу функции.
 - после return функция сразу завершается.  работает всегда первый return если вдруг их больше
 - yield выполнение приостанавливает.
 - yield функция генератор как бы вызывается многократно каждый раз с места последнего yield

 return                                               yield
 Оператор return возвращает только одно значение.     Оператор yield может возвращать серию результатов в виде объекта-генератора.

 Return выходит из функции, а в случае цикла он       Не уничтожает локальные переменные функции. Выполнение программы
 закрывает цикл. Это последний оператор, который      приостанавливается, значение отправляется вызывающей стороне, после
 нужно разместить внутри функции.                     чего выполнение программы продолжается с последнего оператора yield.

 Логически, функция должна иметь только один return.  Внутри функции может быть более одного оператора yield.

 Оператор return может выполняться только один раз.   Оператор yield может выполняться несколько раз.

 return помещается внутри обычной функции Python.     Оператор yield преобразует обычную функцию в функцию-генератор.


 -- return --
 def return_test():
    return 10+10  # работает только первый return
    return 20+20  # остальные return не имеют значения

 new = return_test()
 print(new)           -> 20
 print(return_test()) -> 20


 -- yield --
 def yield_test():
    yield 10+10
    yield 20+20

 testtt = yield_test()

 for i in yield_test():
     print(i)

 # 20
 # 40

 next(testtt) ->  20
 next(testtt) ->  40
 next(testtt) ->  StopIteration

 lst = [10, 20, 30]

 def test_return(lst):
     for i in lst:
         return i

 print(test_return(lst)) -> 10

 def test_yield():
    for i in lst:
        yield i

 for i in test_yield():
     print(i, end=' ') -> 10 20 30


 def foo():
    yield 'onlyvalue'
    return 'returnvalue'

 f = foo()

 print(next(f)) -> onlyvalue
 print(next(f)) -> StopIteration: returnvalue

 --- Простая функция-генератор. Для чего нужен yield ---
 Любая функция, содержащая ключевое слово yield является функцией-генератором (независимо от наличия return)
 и при вызове возвращает объект-генератор.
 1) ленивый, не выполняется пока не попросить значение
 2) одноразовый -при исчерпании кидает StopIteration (в for этого не видно, ибо обрабатывается внутри)
 3) после выполнения yield встает на паузу, при этом сохраняет все внутреннее состояние (аргументы, локальные переменные)
 4) при повторном запросе (next) продолжает работу с места остановки

 Удобен при работе с большими данными, но и в целом может применяться там, где нам нужно получать наборы данных, обрабатывать их.

  -- yield --
 yield показывает что функция - генератор
 генератор ленивый (lazy)
 после выполнения yield встает на паузу!
 Оператор yield позволяет приостановить выполнение функции-генератора и сохранить ее текущее состояние
 Это позволяет экономить память и упрощает работу с последовательностями данных.

 yield — это ключевое слово, которое используется аналогично return, за исключением того, что функция возвращает генератор.

 1)                                         2)
 def func(an_iterable):                     def func(an_iterable):         #  yield from  аналогично 1)
    for item in an_iterable:                   yield from an_iterable
        yield item

 new_func = func([1,2,3])                  new_func = func([1,2,3])
 print(next(new_func))  # -> 1             print(next(new_func))  # -> 1
 print(next(new_func))  # -> 2             print(next(new_func))  # -> 2

 END --- yield ---


 -- YIELD FROM И СУБГЕНЕРАТОРЫ --
 # Тоже самое                          # Тоже самое                         # return + yield   # Разбери пример <-----
 def sub_gen():                        def sub_gen():                       def sub_gen():
     yield 1.1                             yield 1.1                            yield 1.1
     yield 1.2                             yield 1.2                            yield 1.2
                                                                                return 'Done'
 def gen():                            def gen():
     yield 1                               yield 1                          def gen():
     for i in sub_gen():                   yield from sub_gen()                 yield 1
         yield i                           yield 2                              result = yield from sub_gen()
     yield 2                                                                    print('<--', result, end=' ')
                                                                                yield 2

 for i in gen():                       for i in gen():                      for i in gen():
     print(i, end=' ') # 1 1.1 1.2 2      print(i, end=' ') # 1 1.1 1.2 2       print(i, end=' ') # 1 1.1 1.2 <-- Done 2


 -- КОГДА НУЖНО ОБОРАЧИВАТЬ ГЕНЕРАТОР В СКОБКИ ()

 # Если АГРУМЕНТА НЕТ   СКОБКИ ()  НЕ НУЖНЫ
 print(i for i in range(10))            # -> <generator object <genexpr> at 0x000002D45E5B3B90>

 # Если ЕСТЬ АГРУМЕНТ то нужно ОБОРАЧИВАТЬ ГЕНЕРАТОР   В СКОБКИ ()
 print((i for i in range(10)), sep='')  # -> <generator object <genexpr> at 0x000002D45E5B3B90>

 # БУДЕТ SyntaxError
 # print(i for i in range(10), sep='')  # -> SyntaxError: Generator expression must be parenthesized



 Кто не использует генераторы в питоне, тот ещё юнец! Генераторы были придуманы, чтобы не писать скобки в вызовах функций:

 # Красиво? Красиво!
 sorted(element.value for element in elements)

 # ... хотя стоит добавить аргумент, и скобки становятся обязательными. Какого хрена?!
 sorted((element.value for element in elemens), key=attrgetter('attr'))

 А, чуть не забыл - генераторы ещё экономят память, потому что не вываливают все результаты целиком,
 а генерируют элементы на лету. Поэтому в памяти хранится не вся коллекция, а только текущее состояние генератора.

 Генераторы откладывают выполнение кода
 Поэтому заранее знать, где код будет выполнен - та ещё задача.


 --- List comprehension, Generator expressions ---
 List comprehension = Listcomps (однострочник) киллер фича языка
 Generator expressions - genexp (однострочник) киллер фича языка

 Listcomps - оптимизирован, работает на уровне языка C
 1) все компсы и генэксп работают по принципу
 [ВЫРАЖЕНИЕ/ПРЕОБРАЗОВАНИЕ for element in ИСТОЧНИК if УСЛОВИЕ]
 читается это слева направо, что важно когда циклов больше 1.
 2) принцип работы операций у листкомпс и генэксп одинаков, синтаксически различаются скобками
 3) компсы (листкомпс, сеткомпс, дикткомпс) в результате своей работы формируют
 соответствующую коллекцию и занимают память
 4) переменные созданные внутри компсов или генэкспа недоступны извне
 5) генэксп вернет объект, а не коллекцию! при создании объекта он проверит источник,
 что может быть критично, если это какая-то функция. Если источник не валидный
 то ошибка упадет при создании генератора, а не при попытке получить значение
 6) генэксп ленивый, то есть ничего не делает и не занимает память пока не потребуется значение.
 Сгенерировав значение снова засыпает пока опять не попросят новое.
 7) генэксп одноразовый, при исчерпании начинает бросать исключение, которое мы не увидим,
 если используем генератор в цикле for
 8) генэксп может потенциально генерировать бесконечные последовательности,
 но он ничего не знает о порядке элементов или о их количестве (нет len)

  переменные в листкомпс недоступны извне
  читается слева направо
  для словаря обязательно указать КЛЮЧ:ЗНАЧЕНИЕ
  генератор вернет обьект (generator object), а не коллецию
  генератор ленивый, не выполняет действий и не занимает память пока не потребуется (next)
  генератор проверяет источник при создании!!! чтобы он был iterable
  генератор одноразовый, если исчерпан то бросает StopIteration
  цикл for перехватывает StopIteration
  используйте генэксп вместо компс, кроме случаев когда нужна длина len или индексы

 Лично мое мнение -  если вам НЕ нужна длина, слайсы, индексы, то нужно использовать генэскп,
 не только из-за экономии памяти, но и из-за ленивости, экономии процессорного времени.
 Естественно важно помнить что даже pep-8 и дзен - это не закон, а рекомендации,
 наша конкретная реализация и подход должны диктоваться имеющимися условиями и решаемой задачей.

 List comprehensions работают быстрее обычных циклов for                                            <-----
 List comprehensions напрямую записывает данные в список не используя временную переменную и глобальный метод .append.

 Цикл for можно использовать для выполнения множества разных задач: сканирования последовательности для подсчета или
 выбора элементов, вычисления агрегатов (сумм, средних значений) или любого количества других задач обработки.
 Напротив, listcomp предназначен только для одного: создания нового списка.                         <-----

 ', '.join([str(x) for x in list((1, 2, 3))])  # list comprehension     join( [] )
 ', '.join(str(x) for x in list((1, 2, 3)))    # generator expression   join( )

 a, b = [1, 2, 3], [1, 2, 3]
 print(timeit.timeit("', '.join([str(x) for x in a])", globals=globals()))  # -> 0.6712358999066055  list comprehension
 print(timeit.timeit("', '.join(str(x) for x in b)", globals=globals()))    # -> 0.969636800000444  generator expression
 print(timeit.timeit("', '.join(map(str, b))", globals=globals()))          # -> 0.6806077000219375  iterator = map


 Пример с join:
 print(', '.join(f"i={i}" for i in "abc"))                  # -> i=a, i=b, i=c
 d = dict(a=1, b=2, c=3)
 print(', '.join(f"{var}={val}" for var, val in d.items())) # -> a=1, b=2, c=3

 При передаче в функцию дополнительные скобки необязательны:
 sum(i*i for i in range(10)) - Выражения-генератор (Generator Expressions)

 Выражения-генераторы не поддерживают получение длины функцией len():
 len(i*i for i in range(10)) -> TypeError: object of type 'generator' has no len()

 Можно использовать from more_itertools import ilen
 ilen(i * i for i in range(10)) # -> 10

 Выражения-генераторы не поддерживают получение элемента по индексу:
 gen = (i*i for i in range(10))
 gen[1] -> TypeError: 'generator' object is not subscriptable

 К выражению-генератору нельзя применить обычные операции среза или функцию slice(). Для этих целей, можно
 воспользоваться функцией itertools.islice() модуля itertools. Для отрицательных индексов from more_itertools import islice_extended
 gen = (i*i for i in range(10))
 gen[1:5] -> TypeError: 'generator' object is not subscriptable

 import itertools
 list(itertools.islice(gen, 1, 5)) -> [1, 4, 9, 16]
 list(itertools.islice(gen, None, -1)) ->  ValueError: Stop argument for islice() must be None or an integer: 0 <= x <= sys.maxsize.

 from more_itertools import ilen, islice_extended

 gen = (i*i for i in range(10))
 list(gen)                               # -> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

 gen = (i*i for i in range(10))
 list(islice_extended(gen, None, -4))    # -> [0, 1, 4, 9, 16, 25]

 gen = (i * i for i in range(10))
 # Можно использовать напрямую срезы
 print(list(islice_extended(gen)[:-4]))  # -> [0, 1, 4, 9, 16, 25]


 После использования/итерации по выражению-генератору, оно остается пустым:
 gen = (i*i for i in range(10))
 list(gen) -> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
 list(gen) -> []

 Теперь в списке выражений разрешены элементы, отмеченные звездочкой
 Пример интересный c for:

 a = ['abc']
 b = [[1, 2], [3, 4]]
 for i in *a, *b:
     print(i)

 --- Mapping Отображениe — контейнер, элементы которого являются соответствиями одних данных другим ---
 Первые при этом называют ключами, вторые — значениями.
 Mapping Types — dict,  from collections import defaultdict, OrderedDict, Counter
 реализует методы, указанные в -> collections.abc.Mapping,    collections.abc.MutableMapping,      abstract base classes
 Отображения — это изменяемые объекты. В настоящее время существует только один стандартный тип сопоставления — словарь и
 и его наследники из collections  и  abstract base classes
 Словарь — изменяемый объект-отображение.
 mapping - отображение для обозначения словарных объектов.
 любая структура, к которой можно обращаться по ключам — то есть обобщённый тип Mapping


 --- Контекстный менеджер и 2 способа его написания. Конструкция WITH ---
 Контекстный менеджер это удобный способ инкапсулировать логику работы с каким то ресурсом try-except-finally,
 в том числе гарантировать освобождение ресурса, его закрытие. Например закрывать файл, бд, соединение с сетью при
 выходе из контекста. Многие ресурсы в python уже имеют менеджеры контекста, например для работы с файлами.

 Особенности:
 1) если пишем менеджер через contextlib то используем yield возвращающий ровно 1 значение (наш ресурс)
 2) если пишем менеджер через класс, то используем return в методе _enter_
 3) если у какого-либо ресурса уже есть контекстный менеджер, то лучше работать через него
 4) используем контекстный менеджер с помощью конструкции WITH


 --- Context Manager Types     Тип контекстный менеджер ---
 В питоне есть оператор with вход и выход, при работе с файлами, файл автоматически закрывается.
 Контекстные менеджеры в Python — это удобный инструмент для управления ресурсами и обеспечения безопасной работы с ними.
 Для создания своего контекстного менеджера нужно определить класс с двумя специальными методами:
 __enter__() и __exit__().
 Мы также можем создать контекстный менеджер, используя функцию и декоратор contextlib.contextmanager.
 В этом случае функция должна быть генератором, который yield‘ит объект для использования в блоке with.
 Все, что находится до yield, будет выполняться перед входом в блок, а после yield — после выхода из блока.
 from contextlib import contextmanager

 @contextmanager
 def open_file(name):
     f = open(name, 'w')
     try:
         yield f
     finally:
         f.close()

 contextmanager.__enter__() - вводит контекст среды выполнения и возвращает либо себя, либо другой объект, связанный
 с контекстом среды выполнения. Значение, возвращаемое этим методом, привязывается к идентификатору в предложении
 as оператора with, использующего этот контекстный менеджер.

 Контекстные менеджеры в Python используются для управления ресурсами, автоматически выполняя определённые действия
 при входе и выходе из блока кода. Наиболее распространённые применения:

 1. **Файлы**: Автоматическое закрытие файлов после их использования.
 python
    with open('file.txt') as f:
        data = f.read()


 2. **Сессии базы данных**: Управление подключениями к БД, обеспечивая корректное закрытие соединений
      (например, с помощью `with` с библиотекой SQLAlchemy).

 3. **Блокировки**: Управление мьютексами и семафорами для обеспечения потокобезопасности.

 4. **Транзакции**: Упрощение работы с транзакциями, автоматически откатывая их в случае ошибок.

 5. **Кастомные ресурсы**: Создание собственных контекстных менеджеров для управления любыми ресурсами
    (например, сетевыми соединениями), используя `__enter__` и `__exit__`.

 Таким образом, контекстные менеджеры помогают избежать утечек ресурсов и делают код более читаемым и безопасным.

 Транзакции в Python — это последовательность операций, которые выполняются как единое целое. Если одна операция
 НЕ удается, все изменения отменяются, что гарантирует целостность данных. Обычно используются при работе с базами данных.

 Примеры Транзакций в Python:
 - Использование SQLite
 - Использование SQLAlchemy


 Ярким примером контекстного менеджера, который возвращает себя, является объект file. Файловые объекты возвращают себя
 из __enter__(), чтобы разрешить использование встроенной функции open() в качестве контекстного выражения в операторе with.

 with open('/etc/passwd') as fp:
    for line in fp:
        print line.rstrip()

 contextmanager.__exit__(exc_type, exc_val, exc_tb) - предоставляет выход из контекста среды выполнения и возвращает
 логический флаг, указывающий, следует ли подавлять любое возникшее исключение. При возникновении исключения во время
 выполнения тела оператора with аргументы содержат:    В противном случае все три аргумента - это None.
 - exc_type - тип исключения
 - exc_val - значение
 - exc_tb - информацию о трассировке

 Обычно, менеджеры контекста отслеживают какое-то полезное состояние своего собственного объекта, по этому метод
 __enter__ возвращает собственный объект self.

 Аргументы, передаваемые в __exit__()
 Как насчет метода __exit__()? Какие три аргумента он принимает? И нужно ли возвращать значение?

 Если внутри блока with возникает исключение, то эти три аргумента будут следующими:

 - exc_type - класс исключения
 - exc_val - объект исключения
 - exc_tb - объект трассировки для исключения
 Если исключений не возникает, то все эти три аргумента будут иметь значение None.

 Асинхронный менеджер контекста — это менеджер контекста, который может приостанавливать выполнение своих методов входа и выхода.
 async with   __aenter__() и  __aexit__()
 __aenter__() - Семантически(по смыслу) похож на __enter__(), с той лишь разницей, что он должен возвращать ожидаемое значение .
 __aexit__() - Семантически(по смыслу) похож на __exit__(), с той лишь разницей, что он должен возвращать ожидаемое значение .
 Пример класса асинхронного менеджера контекста:

 class AsyncContextManager:
    async def __aenter__(self):
        await log('entering context')

    async def __aexit__(self, exc_type, exc, tb):
        await log('exiting context')

 --- Асинхронные итераторы ---
 async for - Этот оператор позволяет удобно перебирать асинхронные итерации:

 async for TARGET in ITER:
    SUITE
 else:
    SUITE2

 object.__aiter__(self) - Должен возвращать объект асинхронного итератора.
 object.__anext__(self) - Должен возвращать ожидаемое значение , приводящее к следующему значению итератора.
 Должен вызывать StopAsyncIteration ошибку после завершения итерации.

 --- LEGB-rule. Как Python ищет имена переменных ---
 Буквы в аббревиатуре LEGB обозначают локальную, вложенную, глобальную и встроенную
 (Local, Enclosing, Global и Built-in Scope) области. Поиск идёт снизу-вверх сначала L-E-G-B
 даже для встроенных функций если не нашел переменную, то ошибка  NameError:

 Особенности LEGB:
 1) сначала поиск идет в локальном пространстве имен, максимально близко к использованию имени и
 далее идет снизу-вверх, изнутри-наружу к глобальному пространству имен
 2) после локального пространства имен интерпретатор посмотрит в enclosing, то есть в функцию,
 которая содержит текущую (если она есть) и далее проверит глобальное пространство имен
 3) последним шагом будут проверены имена в модуле builtins (встроенные функции)
 4) если на любом этапе имя найдено, то далее поиск не идет. Если все этапы неудачны то выбрасывается NameError
 5) важно понимать что даже если мы используем встроенную функцию, типа max/min/sum/print,
 то интерпретатор сначала проведет поиск по всем скоупам. Вот почему крайне важно НИКОГДА не давать своим переменным,
 функциям, модулям имена встроенных функций или библиотек (самые частые фейлы это имена типа len, list, sum, json, dict)

 Локальные переменные видны только в локальной области видимости, которой может выступать отдельно взятая функция
 Глобальные переменные видны во всей программе.
 Локальные переменные создаются каждый раз при входе в функцию и уничтожаются при выходе из нее.   <-----

 Локальные переменные НЕ требуют поиска в словаре, так как хранятся в очень ТОНКОМ массиве с малым временем поиска <-----

 END --- LEGB ---

 -- Почему локальные переменные работают быстрее, чем глобальные - Это деталь реализации CPython.
 Вы можете спросить, почему хранить локальные переменные быстрее, чем глобальные. Это деталь реализации CPython.

 Помните, что CPython компилируется в байт-код, который запускает интерпретатор. Когда функция компилируется, локальные
 переменные сохраняются в массиве фиксированного размера ( не a dict), а имена переменных присваиваются индексам.
 Это возможно, поскольку вы не можете динамически добавлять локальные переменные в функцию. Тогда получение локальной
 переменной — это буквально поиск указателя в списке и увеличение счетчика ссылок, что PyObject тривиально.

 Сравните это с глобальным поиском ( LOAD_GLOBAL), который представляет собой настоящий dict поиск, включающий хэш и т. д.
 Кстати, именно поэтому вам нужно указать, global i хотите ли вы, чтобы она была глобальной: если вы когда-либо
 присваиваете значение переменной внутри области видимости, компилятор выдаст STORE_FASTs для доступа к ней,
 если вы не скажете ему этого не делать.

 Кстати, глобальный поиск все еще довольно оптимизирован. Поиск атрибутов foo.bar очень медленный !


 Почему код Python в функции выполняется быстрее?
 Важно!!!
 Причина, по которой в локальных переменных это происходит быстрее, заключается в том, что локальные области фактически
 реализуются как массивы, а не словари (поскольку их размер известен во время компиляции).    <-----


 --- global и nonlocal ---
 global и nonlocal нужны только для изменения значений
 global может создать переменную, nonlocal не может!
 nonlocal ищет только во внешних скоупах, но не в глобальном и не builtins
 не используйте global, nonlocal

 Особенности:
 1) если мы пытаемся изменить какую-то переменную внутри функции, интерпретатор автоматически считает ее локальной,
 слова global/nonlocal нужны как информация интерпретатору, что переменная не локальна
 2) оба ключевых слова НЕ нужны, если вам нужно только читать переменную, используйте их только для изменения
 3) оба слова позволяют сразу перейти к поиску в нужном пространстве имен, nonlocal сразу переходит к поиску
 во внешних функциях (в который вложена текущая), global сразу переходит к поиску в глобальном пространстве имен.
 То есть nonlocal сразу идет в букву E, а global в букву G в аббревиатуре LEGB
 4) global позволяет создать в глобальном пространстве имен переменную, которой там не было.
 Nonlocal работает только с уже существующими переменными
 5) Nonlocal НЕ ищет в глобальном, а global во вложенных скоупах! Они не взаимозаменяемы
 6) Есть редкие случаи, когда использование global оправдано,
 но в большинстве случаев и просто как хорошая практика  - не стоит использовать global и nonlocal.
 Стоит отдавать предпочтение независимым, "чистым" функциям.

 Ошибка UnboundLocalError:
 Пример ошибки nonlocal:                    Пример ошибки global:
 x = 10                              x = 10
 def foo():                          def foo():
     x = 10                              print(x)
     def bar():                          x += 1
         print(x)                    foo()
         x += 1                      # UnboundLocalError: cannot access local variable 'x' where it is not associated with a value
     bar()
     print(x)
 foo()
 # UnboundLocalError: cannot access local variable 'x' where it is not associated with a value

 Решение с nonlocal:                         Решение с global:
 x = 10                                      x = 10
 def foo():                                  def foo():
     x = 10                                      global x, z   # МОЖЕТ создать z
     def bar():                                  print(x)
         nonlocal x # не может создать z         x += 1
         print(x)                                z = 100
         x += 1
     bar()
     print(x)                                 foo()    # -> 10
 foo()      # -> 10, 11                       print(x) # -> 11   меняет x
 print(x)   # -> 10  не меняет x              print(z) # -> 100  СОЗДАЕТ z

 Совет: самая хорошая функция которая не влияет ни на что вне себя. Ничего не знает о внешнем мире
 END --- global и nonlocal ---

 --- Стек вызовов  call stack ---
  — это структура данных, которая управляет вызовами функций во время выполнения программы.
 Если программа пытается разместить на стеке больше данных, чем он может вместить, происходит переполнение стека.
 Когда стек переполняется, он не может больше хранить элементы, и любая попытка добавления нового элемента приведет к ошибке
 на дне стека есть функция module(ИСПОЛНЯЕТ НАШИ ЗАПРОСЫ) 1) когда мы вызываем функцию она попадает в СТЕК.
 2) когда функция завершается она снимается со СТЕКА
 Все функции внутри стека вызова исполняются но только одна функция выполняется реально(которая на верхушке стека)
 а остальные функции ждут соседа сверху пока он исполнится
 СТЕК ВЫЗОВОВ ОТОБРАЖАЕТ ВСЕ ФУНКЦИИ КОТОРЫЕ ИСПОЛНЯЮТСЯ В ДАННЫЙ МОМЕНТ И КТО КОГО ЖДЕТ

 Стек (stack) — это область памяти, в которой программа хранит информацию о вызываемых функциях, их аргументах и
 каждой локальной переменной в функциях. Размер области может меняться по мере работы программы. При вызове функций
 стек увеличивается, а при завершении — уменьшается.

 Стек — это область оперативной памяти, которая создаётся для каждого потока. Он работает в порядке
 LIFO (Last In, First Out), то есть последний добавленный в стек кусок памяти будет первым в очереди на вывод из стека.

 Очереди похожи на стеки, и разница между ними в том, как удаляются элементы.
 stack - принцип «последним пришел — первым ушел», или LIFO
 queue - принцип «первым пришел — первым ушел», или FIFO есть и другие варианты помимо FIFO

 По умолчанию размер стека в Питоне ограничен 1000 вызовов.

 Ограничение можно ослабить вызовом sys.setrecursionlimit. Этот вызов увеличит предел, но он не всесилен.
 В Питоне количество вызовов ограничено ещё и количеством памяти которая выделена под стек. Изнутри программы повлиять
 на размер стека нельзя. Если стек переполняется, то операционная система останавливает интерпретатор.

 Выбор грустный: или программа упрётся в лимит самого интерпретатора и получит исключение:
 RecursionError: maximum recursion depth exceeded in comparison

 или программа будет остановлена с ошибкой:
 Segmentation fault (core dumped)      или сокращенно  “segfault”

 Ошибка сегментации (segfault) является общей, для этого существует множество возможных причин:

 - Мало памяти
 - Неисправная оперативная память
 - Получение огромного набора данных из базы данных с помощью запроса (если размер полученных данных превышает размер памяти подкачки)
 - неправильный запрос/неправильный код
 - наличие длинного цикла (множественная рекурсия)

 - когда расширение Python (написанное на C) пытается получить доступ к недоступной памяти.

 stack frame(стековый кадр) - фрейм по сути представляет собой просто таблицу всех переменных,  которые являются
 локальными для вашей функции.

 В Python, когда вы вызываете функцию, вы создаете нечто, называемое кадром стека.

 Куча (heap) — это область памяти, в которой программа может делать всё, что заблагорассудится. Размер области может
 меняться. Программист имеет возможность воспользоваться частью памяти кучи с помощью функции malloc(), и тогда эта
 область памяти увеличивается. Возврат ресурсов осуществляется с помощью free(), после чего куча уменьшается.

 Куча — это хранилище памяти, также расположенное в ОЗУ, которое допускает динамическое выделение памяти и не работает
 по принципу стека: это просто склад для ваших переменных.

 Куча в Python — это структура данных, основанная на уникальном двоичном дереве, предназначенная для эффективного
 доступа к самому маленькому или самому большому элементу в коллекции элементов

 Python min-куча (наименьшее значение всегда лежит в корне) реализована на базе списка при помощи встроенного модуля heapq
 Если вам нужна max-куча, с максимальным значением в корне можно использовать инвертирование или _protected функции
 heapq.heapify(listForTree) # for a min heap         heapq._heapify_max(listForTree)  # for a maxheap!!  или умножить на (-1)
                                                                                                         или добавить - к числу

 -- Модуль heapq обеспечивает реализацию алгоритма очереди кучи, также известного как алгоритм очереди приоритетов.
 Можно рассматривать кучу как обычный список Python без сюрпризов.

 heapq.heappush(heap, item) - добавляет значение элемента item в кучу heap, сохраняя инвариант кучи.  # inplace
 heapq.heappop(heap) - возвращает и удаляет наименьший элемент из кучи heap, сохраняя инвариант кучи. IndexError - пустая # inplace
 heapq.heappushpop(heap, item) - добавляет значение элемента item в кучу heap, затем возвращает и удаляет самый
 маленький элемент из кучи heap.  # inplace
 heapq.heapify(x) - преобразовывает список x в кучу на месте за линейное время.  # inplace
 heapq.heapreplace(heap, item) - удаляет и возвращает наименьший элемент из heap, а потом добавляет новый элемент item. # inplace
 heapq.merge(*iterables, key=None, reverse=False) - объединяет несколько отсортированных *iterables в один отсортированный generator.
 аналогично sorted как функция itertools.chain(*iterables), но возвращает итерируемую последовательность, не извлекает сразу
 данные в память и предполагает, что каждый из входных потоков iterables уже отсортирован от наименьшего к наибольшему.
 heapq.nlargest(n, iterable, key=None) - возвращает список с n самыми большими элементами из набора данных,
 определенного с помощью итерируемой последовательности iterable. Эквивалентно: .sorted(iterable, key=key, reverse=True)[:n]
 heapq.nsmallest(n, iterable, key=None) - возвращает список с n наименьшими элементами из набора данных, определенного
 с помощью итерируемой последовательности iterable. Эквивалентно: .sorted(iterable, key=key)[:n]

 nlargest, nsmallest - работают ЛУЧШЕ для нахождения нескольких наибольших или наименьших элементов в коллекции.
 min, max - ЛУЧШЕ для поиска единственного минимального или максимального значения,работают быстрее и имеют линейную сложность.

 Функции `nlargest` и `nsmallest` из модуля `heapq` более эффективны для нахождения нескольких наибольших или
 наименьших элементов в коллекции.

 Однако  значения лучше использовать `min` и `max`, так как они лучше для поиска единственного минимального или максимального значения

 Отсутствие лишних операций: Если вам нужно только одно значение, нет смысла вызывать функции, которые делают больше,
 чем требуется, тем более что min и max возвращают единственный элемент без дополнительных затрат.

-- Примеры методов кучи(heapq) c Присваиванием значений. Почти все # inplace:

 ---------------------------  heappush(heap, item)  # inplace  ---------------------------------------------------------
 import heapq                                                             import heapq
 h = [] # Работает только с list                                          h = []
 h = {} # -> TypeError: heappush() argument 1 must be list, not dict      h = heapq.heappush(h, 20)
 heapq.heappush(h, 20)                                                    print(h)        # -> None   <-----
 print(h)        # -> [20]
 print(type(h))  # -> <class 'list'>

 ---------------------------  heappop(heap)  # inplace  ----------------------------------------------------------------
 import heapq                                                             import heapq
 h = [20, 10, 1]                                                          h = [20, 10, 1]
 print(h)         # -> [20, 10, 1]          <-----                        h = heapq.heapify(h)
 heapq.heapify(h) # создаем кучу(heap)      <-----                        print(h)        # -> None    <-----
 print(h)         # -> [1, 10, 20]          <-----
 print(h[0])      # -> 1                                                  h = [20, 10, 1]
 heapq.heappop(h)                                                         heapq.heapify(h)
 print(h)         # -> [10, 20]                                           h = heapq.heappop(h)
 print(h[0])      # -> 10                                                 print(h)        # -> 1    <-----

 ---------------------------  heappushpop(heap, item)  # inplace  ------------------------------------------------------
 import heapq                               import heapq                             import heapq
 h = [20, 10, 1]                            h = [20, 10, 1]                          h = [20, 10, 1]
 print(h)  # -> [20, 10, 1]                 print(h)  # -> [20, 10, 1]               print(h)  # -> [20, 10, 1]
 heapq.heapify(h)  # -> СОЗДАЛИ КУЧУ        # -> НЕ СОЗДАВАЛИ КУЧУ                   heapq.heapify(h)
 heapq.heappushpop(h, 100)                  heapq.heappushpop(h, 100)                h = heapq.heappushpop(h, 100)
 print(h)  # -> [10, 100, 20]    <-----     print(h)  # -> [1, 10, 100]    <-----    print(h)  # -> 1

 ---------------------------  heapify(x)  # inplace  -------------------------------------------------------------------
 import heapq                                   import heapq
 h = [20, 10, 1]                                h = [20, 10, 1]
 print(h)  # -> [20, 10, 1]                     print(h)  # -> [20, 10, 1]
 heapq.heapify(h)                               h = heapq.heapify(h)
 print(h)  # -> [1, 10, 20]                     print(h)  # -> None    <-----
 print(type(h)) # -> <class 'list'>

 ---------------------------  heapreplace(heap, item)  # inplace  ------------------------------------------------------
 import heapq                                   import heapq
 h = [20, 10, 1]                                h = [20, 10, 1]
 print(h)  # -> [20, 10, 1]                     print(h)  # -> [20, 10, 1]
 heapq.heapify(h)                               heapq.heapify(h)
 heapq.heapreplace(h, 100)                      h = heapq.heapreplace(h, 100)
 print(h)  # -> [10, 100, 20]                   print(h)  # -> 1

 ---------------------------  merge(*iterables, key=None, reverse=False)    --------------------------------------------
 import heapq                                                           h1 = sorted([20, 10, 1], reverse=True)
 h1 = sorted([20, 10, 1])                                               h2 = sorted([200, 100, 11], reverse=True)
 h2 = sorted([200, 100, 11])                                            new = itertools.chain(h1, h2)
 new = heapq.merge(h1, h2)                                              print(new)        # -> <itertools.chain object >
 print(new)        # -> <generator object merge at 0x000001D88F92D4E0>  print(list(new))  # -> [20, 10, 1, 200, 100, 11]
 print(list(new))  # -> [1, 10, 11,   20, 100, 200]

 ---------------------------  nlargest(n, iterable, key=None)  ---------------------------------------------------------
 import heapq                                         Тоже самое что и   nlargest(n, iterable, key=None):
 h = [20, 10, 1, 200]                                 h = [20, 10, 1, 200]
 print(heapq.nlargest(2, h)) # -> [200, 20]           print(sorted(h, reverse=True)[:2])  #  -> [200, 20]
 print(heapq.nlargest(3, h)) # -> [200, 20, 10]       print(sorted(h, reverse=True)[:3])  #  -> [200, 20, 10]
 print(h)                    # -> [20, 10, 1, 200]    print(h)                            #  -> [20, 10, 1, 200]

 ---------------------------  nsmallest(n, iterable, key=None)  --------------------------------------------------------
 import heapq                                                Тоже самое что и   nsmallest(n, iterable, key=None):
 h = [20, 10, 1, 200]                                        h = [20, 10, 1, 200]
 print(heapq.nsmallest(2, h))  #  -> [1, 10]                 print(sorted(h)[:2])  #  -> [1, 10]
 print(heapq.nsmallest(3, h))  #  -> [1, 10, 20]             print(sorted(h)[:3])  #  -> [1, 10, 20]
 print(h)                      #  -> [20, 10, 1, 200]        print(h)              #  -> [20, 10, 1, 200]

 ---------------------------  maxheap  private functions _ -------------------------------------------------------------
 import heapq

 listForTree = [1, 2, 3, 4, 100]
 heapq.heapify(listForTree)           # for a min heap
 heapq._heapify_max(listForTree)      # for a maxheap!!

 print(heapq._heappop_max(listForTree))  # -> 100
 print(heapq._heappop_max(listForTree))  # -> 4
 print(listForTree)                      # -> [3, 2, 1]

'_heappush_max', '_heappop_max', '_heapify_max', '_heapreplace_max', '_heappushpop_max',

 -----------------------------------------------------------------------------------------------------------------------

 -- Кэш  ЦП L1/L2/L3/L4 --
 Кэши L1/L2/L3 имеют настолько важное значение, что занимают большую часть кремниевого пространства внутри микросхемы ЦП

 Использование кэшей L1/L2/L3 существенно увеличивает производительность компьютеров. Благодаря кэшу L2 емкостью 200 Кб
 менее 10 % запросов к памяти, которые делает ЦП, приходятся на выборку непосредственно из ОЗУ.

 - Кэш L1 обычно имеет наименьшую емкость (обычно от 16 до 128 Кб) и обеспечивает самый быстрый доступ к данным.
 - Кэш L2 больше по размеру (обычно от 256 Кб до нескольких Мб) и немного медленнее, но все еще быстрее,
 чем доступ к оперативной памяти (ОЗУ).
 - Кэш L3, как правило, является общим кэшем для нескольких ядер процессора и может иметь емкость от нескольких Мб до десятков Мб.

 В следующий раз, когда вы пойдете покупать компьютер, не забудьте сравнить размеры кэшей L1/L2/L3 процессоров.
 Более хорошие ЦП будут иметь кэш большей емкости. Лучше взять ЦП с меньшей тактовой частотой, но с более объемным кэшем.


 Однако можно заглянуть глубже и увидеть, что в самом процессоре тоже есть несколько блоков памяти: кэш L1, L2,
 а иногда даже L3, L4. Они имеют малую емкость (от нескольких килобайт до десятка мегабайт)
 но очень высокую производительность

 -- END Кэш  ЦП L1/L2/L3/L4 --


 -- Блоки Памяти --
 Блоки памяти в компьютерах используются для хранения битов. Это могут быть переменные в вашей программе, а могут быть
 пиксели изображения.
 Таким образом, абстаркция блока памяти - ЭТО РЕГИСТРЫ НА ВАШЕЙ МАТЕРИНСКОЙ ПЛАТЕ, ОПЕРАТИВНАЯ ПАМЯТЬ, ЖЕСТКИЙ ДИСК.
 Одно из основных различий между всеми этими типами блоков памяти заключается в скорости,
 с которой они могут ЧИТАТЬ/ЗАПИСЫВАТЬ данные.

 Например, большинство блоков памяти работает намного лучше, когда читает один большой кусок данных, а не множество
 маленьких (это называется ПОСЛЕДОВАТЕЛЬНЫМ ЧТЕНИЕМ И СЛУЧАЙНЫМИ ДАННЫМИ)

 Скорость чтения/запись                 Размеры
 1) Кэш L1/L2/L3/L4                     1) Обычный жесткий диск (HDD)
 2) ОЗУ                                 2) Твердотельный жесткий диск (SSD)
 3) Твердотельный жесткий диск (SSD)    3) ОЗУ
 4) Обычный жесткий диск (HDD)          4) Кэш L1/L2/L3/L4

 -- END Блоки Памяти --


 Адресное пространство содержит всё, что нужно для выполнения процесса:
 - Машинные инструкции, которые должен выполнить ЦПУ.
 - Данные, с которыми будут работать эти машинные инструкции.

 Поскольку стек и куча могут меняться в размерах, они размещены в противоположных частях общего адресного пространства.
 В обязанности ОС входит контроль над тем, чтобы эти области не наложились друг на друга.

 Для СPython : Реализация самой ВМ управляет стеком и кучей (как и сборкой мусора). Сверху стек, снизу куча.
 В стеке - ссылки на объекты в куче. Фактических значений в стеке нет. Все объекты и структуры данных
 (т.е. и переменные и значения) - в куче. Управляет ей внутренний менеджер памяти.

 Напонимню, что в CPython переменная - не то же самое, что в C. Тут это просто имя, ссылающееся на PyObject/PyListObject.
 Среда выполнения CPython рассматривает все Python объекты как переменные типа PyObject.
 PyObject служит «базовым типом» для всех Python объектов. Сама структура PyObject содержит только счетчик ссылок
 объекта и указатель на «объект type» объекта.
 PyObject * PyLong_FromLong ( long v )
 PyLong_FromLong - Текущая реализация хранит массив целочисленных объектов для всех целых чисел между [-5, 256].
 Когда вы создаете int в этом диапазоне, вы фактически просто получаете ссылку на существующий объект.
 Вернет новый PyLongObject объект из v или NULL в случае сбоя.

 Большинство функций API Python/C имеют один или несколько аргументов, а также возвращаемое значение типа PyObject
 PyObject - Все типы объектов являются расширениями этого типа. Это тип, который содержит информацию, необходимую Python
 для обработки указателя на объект как объекта. В обычной «релизной» сборке она содержит только счетчик ссылок на объект
 и указатель на объект соответствующего типа. На самом деле ничто не объявлено как PyObject, но каждый указатель на
 объект Python может быть преобразован в PyObject * .
 Доступ к членам должен осуществляться с помощью макросов Py_REFCNT и Py_TYPE.
 Py_REFCNT - Получите счетчик ссылок объекта Python
 Py_TYPE -  Получите тип объекта Python

 Ключевая разница между стековой и кучной памятью:
 - Стек получает доступ только к локальным переменным, тогда как куча позволяет вам получать доступ к глобальным переменным.
 - Размер переменных стека нельзя изменить, тогда как размер переменных кучи можно изменить.


 --- Pytest ---
 Главным конкурентом старого доброго unittest в мире тестирования на python является модный молодежный pytest.

 Плюсы:
 1) не нужно создавать классы и наследоваться, не нужно знать ООП, то есть новичок легко начнет пользоваться
 2) используется простой assert, не нужно помнить все варианты assertEqual из юниттеста
 3) прост в освоении, есть хорошая документация, большое комьюнити, а значит большинство проблем уже известно и исправлено
 4) интегрируется с юниттестом, значит не придется переписывать их, если решите внести в проект pytest

 Условные минусы (чтобы разбавить бочку меда):
 1) это сторонняя библиотека, ее нужно устанавливать отдельно от пайтон, добавляя лишние зависимости проекту
 2) "магия" во многих механизмах, начиная с ассерта, а мы в питоне любим все явное
 3) не похож на стандартные nUnit библиотеки из других языков

 Лично мое мнение - главное что вы пишите тесты, а библиотеку выбирайте сами, исходя из знаний, потребностей и удобства.


 Фикстуры (fixtures) в pytest — это специальные функции, которые подготавливают данные или состояние,
 необходимые для выполнения тестов. Они позволяют создавать общее окружение для нескольких тестов, упрощают код,
 обеспечивают настройку и очистку ресурсов. Фикстуры определяются с помощью декоратора `@pytest.fixture` и могут быть
 использованы, передавая их как аргументы в тестовые функции. Это делает тесты более читаемыми и поддерживаемыми.

 ### Основные цели фикстур:
 1. **Подготовка данных**: Создание необходимых объектов, например, подключение к базе данных или подготовка тестовых данных.
 2. **Очистка ресурсов**: Освобождение ресурсов после завершения теста (например, закрытие соединения с базой данных).
 3. **Упрощение кода**: Устранение дублирования кода за счет централизации логики подготовки.


 --- Юнит-тестирование. Использование unittest и coverage в PyCharm ---
 Тесты нужно писать обязательно, это единственное доказательство того, что ваш код работает.

 Преимущества тестов:
 - доказывают что код работает
 - актуальная "документация"
 - экономия нервов и времени на поддержке и рефакторинге

 Порядок действий:
 1) создаем папку tests (не пакет!)
 2) создаем модуль в стиле функция_test.py
 3) сначала пишем позитивные тесты (те, где все хорошо)
 4) тест должен быть сначала красный, проверяем что он проверяет что нужно
 5) не забываем покрывать тестами ветки условий и исключений
 6) после каждого действия или изменения запускаем тесты
 7) создаем конфигурацию запуска всех тестов
 8) используем покрытие кода (code coverage) как информацию о том, что не покрыто тестами
 9) при рефакторинге постоянно запускаем тесты

 Рефакторинг - Улучшение существующего кода

 Фикстуры (fixtures) в юнит-тестировании — это функции или объекты, которые предварительно настраивают необходимое
 окружение или состояние для тестов. Они помогают избежать дублирования кода, обеспечивают подготовку и очистку ресурсов,
 такие как создание тестовых данных или подключение к базе данных, и могут использоваться в нескольких тестах для
 повышения читаемости и поддерживаемости кода.

  ### Основные цели фикстур:
 1. **Инициализация ресурсов**: Подготовка необходимых объектов или данных, таких как создание тестовой базы данных,
  настройка файлов и т.д.
 2. **Очистка ресурсов**: Освобождение ресурсов после выполнения тестов для предотвращения утечек памяти или конфликтов
  в будущем тестировании.

 ### Использование:
 Фикстуры определяются с помощью методов `setUp()` и `tearDown()` в классе тестов. Метод `setUp()` выполняется перед
 каждым тестом, а `tearDown()` — после него. Эти методы позволяют централизовать логику подготовки и очистки,
 что упрощает поддержку тестов.


 --- Использование doctest в Python. Интеграция doctest и unittest ---
 Плюсы:
 1) сразу видно тест, не нужно идти в другие папки, чтобы посмотреть проверки
 2) виден пример использования функции, что особенно актуально для сложных вариантов
 3) мотивирует писать и поддерживать документацию к функции
 4) интегрируется с юниттестом, что позволяет прогонять сразу все тесты проекта, и юниты и доктесты.

 Минусы:
 1) свой синтаксис
 2) не очень удобно писать сложные тесты, обрабатывать исключения и т.п.

 Мой совет - использовать доктест как добавку к юниттесту, то есть писать в сложных функциях примеры использования
 (и документацию, что немаловажно), а сложные кейсы решать уже средствами юниттеста.


 Вот основные виды тестирования в Python:

 1. **Unit Testing (Модульное тестирование)**: Тестирует отдельные функции или классы для проверки их корректности.
  Используются библиотеки `unittest` и `pytest`.

 2. **Integration Testing (Интеграционное тестирование)**: Проверяет взаимодействие между несколькими модулями или
  системами, чтобы убедиться в их совместной работе.

 3. **Functional Testing (Функциональное тестирование)**: Проверяет функциональность приложения в соответствии с
 требованиями, не углубляясь в внутренние детали реализации.

 4. **End-to-End Testing (Тестирование "от конца до конца")**: Тестирует полный пользовательский поток в приложении,
  включая все интеграции и зависимости.

 5. **Regression Testing (Регрессионное тестирование)**: Убеждается, что изменения в коде не нарушили существующую
  функциональность.

 6. **Тестирование пользовательского интерфейса (UI Testing)**: Проверяет интерфейс приложения, чтобы убедиться в
  правильном отображении и работе элементов.

 7. **Тестирование производительности (Performance Testing)**: Оценивает скорость и стабильность приложения под нагрузкой.

 8. **Приемочное тестирование (Acceptance Testing)**: Проверяет готовность системы к использованию конечными пользователями.


 Эти виды тестирования обеспечивают базовую проверку качества и надежности приложений.


 --- Тестирование ---
 Selenium — это один из самых популярных и широко используемых инструментов для автоматизации тестирования веб-приложений.

 -- Методы Тестирование --

 1. **Тестирование по классам эквивалентности (Equivalence Class Testing)**: Делит входные данные на эквивалентные классы,
  чтобы минимизировать количество тестов. Проверяется только одно значение из каждого класса.

 2. **Тестирование граничных значений (Boundary Value Testing)**: Тестирует значения на границах эквивалентных классов
  (например, минимальные и максимальные значения), так как ошибки часто возникают именно на этих границах.

 3. **Тестирование случайных значений (Random Testing)**: Случайно выбирает входные данные для тестирования, чтобы
 выявить ошибки, которые могут быть пропущены более структурированными методами.

 4. **Тестирование по состояниям (State Transition Testing)**: Основано на моделировании состояний системы. Проверяет,
  как система реагирует на переходы между различными состояниями.

 5. **Тестирование на основе требований (Requirement-Based Testing)**: Разрабатывает тесты на основе спецификаций и
 требований к системе, чтобы убедиться, что функциональность реализована правильно.

 6. **Тестирование изомерной (Combinatorial Testing)**: Исследует разные комбинации входных значений и их влияние на
  систему, что особенно полезно для систем с множеством параметров.

 7. **Тестирование сценариев (Scenario Testing)**: Оценивает систему на основе реальных сценариев использования.

 8. **Проверка условий (Condition Testing)**: Проверяет, как программа обрабатывает разные логические условия.

 Эти методы помогают обеспечить качественное тестирование программного обеспечения с разных сторон и выявить
  потенциальные ошибки в коде.


 Классы эквивалентности - это разделение функционала или данных на определенные наборы,
 с которыми тестируемое приложение должно работать одинаково.

 Класс эквивалентности (Equivalence class) – это набор входных (или выходных) данных ПО, которые обрабатываются
 программой по одному алгоритму или приводят к одному результату.

 # Хороший ответ
 Значения называется эквивалентными друг другу если они приводят к одному и тому же результату.        <-----
 Пример калькулятор: Ужимать тесты
 Выделить классы эквивалентности: это значит написать 10 тестов вместо 100. С тем же результатом!


 Граничные значения (Boundary Values) — это значения, в которых один класс эквивалентности переходит в другой диапазон.
 Эта техника тестирования фокусируется на анализе поведения программы на ее границах или близких к ним цифрах.
 Это метод тестирования, в котором основное внимание уделяется значениям на границах допустимого диапазона.


 --- Unittest ---
 Unittest — это модуль стандартной библиотеки Python. Внутри есть фреймворк для создания и запуска тестов.
 С его помощью можно создавать мок-объекты, которые имитируют поведение зависимых компонентов
 и помогают изолировать тестируемый код. Нельзя лишь имитировать внешние сервисы.

 from unittest import TestCase, main
 from Again.unit_tests.calculator_new import calculator

 class CalculatorTest(TestCase):

     def test_plus(self):
         self.assertEqual(calculator('2+2'), 4)

     def test_many_sings(self):
         with self.assertRaises(ValueError) as e:
             calculator('2+2*10')
         self.assertEqual('Выражение должно содержать 2 целых числа и 1 знак', e.exception.args[0])

 if __name__ == '__main__':
     main()

  Типы проверок в классе TestCase
 assertEqual(a, b)          a == b
 assertNotEqual(a, b)       a != b
 assertTrue(x)              bool(x) is True
 assertFalse(x)             bool(x) is False
 assertIs(a, b)             a is b
 assertIsNot(a, b)          a is not b
 assertIsNone(x)            x is None
 assertIsNotNone(x)         x is not None
 assertIn(a, b)             a in b
 assertNotIn(a, b)          a not in b
 assertIsInstance(a, b)     isinstance(a, b)
 assertNotIsInstance(a, b)  not isinstance(a, b)


 Модуль Mock: макеты-пустышки в тестировании

 unittest.mock предоставляет базовый Mock класс, устраняющий необходимость создания множества заглушек в вашем наборе тестов.

 Кроме того, макет предоставляет patch() декоратор, который обрабатывает атрибуты уровня модуля и класса в рамках теста

 sentinel создает уникальные объекты. Атрибуты создаются по требованию, когда вы обращаетесь к ним по имени.

 Mock и MagicMock объекты создают все атрибуты и методы по мере доступа к ним и сохраняют сведения о том, как они использовались.
 AsyncMock - Асинхронная версия MagicMock. Объект AsyncMock будет вести себя так, что объект распознается как асинхронная функция,
 а результат вызова является ожидаемым.

 from unittest.mock import patch
 Декоратор patch()/менеджер контекста позволяет легко имитировать классы или объекты в тестируемом модуле.
 Указанный вами объект будет заменен макетом (или другим объектом) во время теста и восстановлен по завершении теста:

 Мокинг - можно подменить макетами-пустышками
 Mock подменяет объекты

 Mock на английском значит «имитация», «подделка». Принцип его работы простой: если нужно тестировать функцию, то всё,
 что не относится к ней самой (например, чтение с диска или из сети), можно подменить макетами-пустышками.
 При этом тестируемые функции не нужно адаптировать для тестов: Mock подменяет объекты в других модулях,
 даже если код не принимает их в виде параметров. То есть, тестировать можно вообще без адаптации под тесты.

 Мок проверяет, что какой-то код выполнился определенным образом. Это может быть вызов функции, HTTP-запрос
 и тому подобное. У мока две задачи: Убедиться в том, что событие произошло — например, функция передала данные
 ОТСЛЕЖИВАНИЕ ВЫПОЛНЕНИЯ КАКОГО-ТО ДЕЙСТВИЯ — это и есть мокинг

 Моки (mocks) – более продвинутые заглушки, которые позволяют контролировать вызов методов,
 передачу аргументов и проверку ожидаемого поведения тестируемой системы.
 Фейки (fakes) – имитационные объекты, которые имитируют поведение реальных компонентов, но с упрощенной реализацией


 --- Конкурентность (concurrency)  Параллельность (parallel) ---
 Конкурентность (concurrency) - запуск на выполнение сразу нескольких задач
 (не обязательно в 1 момент времени выполняется несколько). Зависит от ПО Первые ОС с процессором без ядер -использовали только ее.
 Проще говоря быстрое переключение между задачами

 Параллельность (parallel) - конкурентность, когда 2+ задачи выполняются одновременно. Зависит от железа
  Вы не можете одновременно (!) выполнять больше задач, чем есть ядер в системе.

 thread-safe - потокобезопасность, означает что при работе с обьектом не возникают известные проблемы
 при работе с конкурентностью

 Часть кода является потокобезопасной, если она корректно работает при одновременном выполнении несколькими потоками.

 Если код или объект считается thread-safe, это означает, что его использование не приведет к непредсказуемому поведению
 при одновременном выполнении нескольких потоков.


 --- Global Interpreter Lock (GIL) ---
 GIL (Global Interpreter Lock) - глобальная блокировка интерпретатора -
 механизм гарантирующий, что в любой момент времени выполняется только 1 инструкция в питоне.

 GIL - Гарантирует нам что в один момент времени в Python работает РОВНО 1 ПОТОК(инструкция),
 даже если потоков больше

 GIL может быть удержан потоком не дольше 5 мс  - 0.0000005

 Чтобы помешать потоку Python удерживать GIL БЕСКОНЕЧНО, Интерпретатор байт-кода Python периодически
 (По умолчанию раз в 5 миллисекунд) приостанавливает текущий поток и тем самым освобождает GIL.

 В CPython глобальная блокировка интерпретатора, или GIL, представляет собой мьютекс, который защищает доступ к
 объектам Python, не позволяя нескольким потокам одновременно выполнять байт-коды Python. GIL предотвращает состояния
 гонки и обеспечивает безопасность потоков.
 Короче говоря, этот мьютекс необходим главным образом потому, что управление памятью CPython не является потокобезопасным.

 GIL - Механизм, используемый интерпретатором CPython для обеспечения того, чтобы только один поток выполнял байт-код Python одновременно.

 Краткие сведения о GIL:
 - Одновременно может выполняться только один поток.
 - Интерпретатор Python переключается между потоками для достижения конкурентности.
 - GIL применим к CPython (стандартной реализации). Но такие как, например, Jython и IronPython не имеют GIL.
 - GIL делает однопоточные программы быстрыми.
 - Операциям ввода/вывода, обычно GIL не мешает.
 - GIL позволяет легко интегрировать непотокобезопасные библиотеки на языке C
 - Благодаря GIL есть много высокопроизводительных расширений/модулей, написанных на языке C.

 Для CPU зависимых задач интерпретатор делает проверку каждые N тиков и переключает потоки.
 Таким образом один поток не блокирует другие.


 Да, GIL (Global Interpreter Lock) в Python помогает Garbage Collector (GC) работать корректно.
 Он предотвращает одновременный доступ нескольких потоков к объектам Python, что минимизирует риски гонок данных и
 обеспечивает безопасную работу с памятью. Это позволяет GC надежно отслеживать и освобождать память,
 избегая проблем с памятью, которые могут возникнуть при работе в многопоточной среде.


 Таким образом, GIL способствует безопасности и эффективности работы сборщика мусора в Python.    <-----   Важно


  --- Сборщик мусора (Garbage Collector, GC) ---
  Задача сборщика мусора — именно поиск циклических ссылок на объекты

  Сборщик мусора не умный и не глупый. Он просто ищет циклы из ссылок и удаляет их.
  Большая часть объектов удаляется ещё до сборщика, так как в Python есть подсчёт ссылок.

 Сборщик мусора автоматически освобождает память, которая больше не используется.
 Он определяет, что память больше не используется, если на объект нет ссылок
 модуль gc - для дополнительных возможностей сборщика мусора
 Сборщик мусора (Garbage Collector, GC)
 import gc, gc.collect() - Принудительный запуск Сборщика мусора
 gc.collect(generation=2)  generation - какое поколение собирать (от 0 до 2)
 gc.set_threshold(...) - Управление частотой вызова Сборщик мусора
 gc.enable(), gc.disable()  - вкл, выкл Сборщик мусора
 gc.freeze() - Заморозить все объекты, отслеживаемые сборщиком мусора; переместите их в постоянное поколение
 и игнорируйте во всех будущих коллекциях.
 gc.unfreeze() - Разморозьте объекты в постоянном поколении и поместите их обратно в самое старое поколение.


 Обратите внимание, что использование средств трассировки или отладки реализации может поддерживать работоспособность
 объектов, которые обычно можно собирать. Также обратите внимание, что перехват исключения с помощью оператора try… except
 может сохранить объекты живыми.

 GC классифицирует объекты на три поколения в зависимости от того, сколько проверок коллекции они пережили.
 - Новые объекты помещаются в самое молодое поколение (поколение 0).
 - Если объект сохраняется в коллекции, он перемещается в следующее старшее поколение.
 - Поскольку поколение 2 является самым старым поколением, объекты этого поколения остаются там после коллекции.

 - Первоначально исследуется только 0 поколение
 - Если поколение 0 было проверено более порогового 1 раз с момента 1 проверки поколения, то поколение 1 также проверяется.

 - Полная коллекция запускается, когда количество новых объектов превышает 25% от количества существующих объектов.
 - количество долгоживущих объектов практически неограниченно.

 Таким образом, поколение 1 запускается только в том случае, если поколение 0 было запущено 10 раз. Поскольку поколение 0
 запускается только каждые 700 циклов (дельта выделения-освобождения), это означает, что поколение 1 запускается каждые
 10 * 700 == 7000 циклов. Генерация 2 запускается каждые 10 * 10 * 700 == 70 000 циклов.


 Начиная с версии 3.13, CPython содержит две реализации GC: 1) по умолчанию 2) со свободным потоком    <-----

 - по умолчанию опирается на глобальную блокировку интерпретатора для обеспечения потокобезопасности.
 - со свободным потоком приостанавливает другие выполняющиеся потоки при выполнении сбора для обеспечения безопасности потоков.
 Обе реализации используют одни и те же базовые алгоритмы, но работают с разными структурами данных.

 PyGC_Head — элемент двойного связанного списка, который используется сборщиком мусора для обнаружения кольцевых ссылок.
 Различия между реализациями GC:
 - по умолчанию широко использует структуру PyGC_Head
 - со свободным потоком не использует  PyGC_Head структуру данных.

 - по умолчанию опирается на глобальную блокировку интерпретатора для обеспечения потокобезопасности.
 - со свободным потоком имеет две паузы «остановить мир», во время которых все остальные выполняющиеся
 потоки временно приостанавливаются, чтобы сборщик мусора мог безопасно получить доступ к счетчикам ссылок и атрибутам объектов.

 - по умолчанию — сборщик поколений.
 - со свободным потоком не требует генерации поколений; каждая коллекция сканирует всю кучу.

 Отслеживать поколения объектов в сборке по умолчанию просто и недорого.

 Сборка со свободным потоком использует mimalloc для поиска отслеживаемых объектов; идентифицировать «молодые» объекты
 без сканирования всей кучи будет сложнее.

 Оптимизация: поколения
 Оптимизация: повторное использование полей для экономии памяти

 Оптимизация: контейнеры отслеживания задержек:
 Определенные типы контейнеров не могут участвовать в reference cycle(цикле ссылок) и поэтому сборщик мусора не требует их отслеживания:
 Существует две возможные стратегии отмены отслеживания контейнера:
 - Когда контейнер создан.
 - Когда контейнер осматривается сборщиком мусора.
 is_tracked(obj) - возвращает текущий статус отслеживания объекта.

 Отложенное отслеживание:
 - Кортежи, содержащие только неизменяемые объекты.
 - Словари, содержащие только неизменяемые объекты.

 В Основном НЕИЗМЕНЯЕМЫЕ НЕ отслеживаються а ИЗМЕНЯЕМЫЕ отслеживаються
 Можно самому посмотреть кто отслеживается а кто нет:
 import gc
 gc.is_tracked(0)           # -> False    # int не могут находиться в цикле ссылок
 gc.is_tracked("a")         # -> False    # str не могут находиться в цикле ссылок
 gc.is_tracked([])          # -> True     # list может быть в цикле ссылок
 gc.is_tracked(tuple())     # -> False    # пустой tuple не отслеживается
 gc.is_tracked({})          # -> False
 gc.is_tracked({"a": 1})    # -> False
 gc.is_tracked({"a": []})   # -> True
 gc.is_tracked((i for i in range(10)))   # -> True     Generator
 gc.is_tracked(iter([1, 2, 3]))          # -> True     Iterator

 Кортежи изначально отслеживаются:
 t1 = ([1],)
 t2 = ((1.),)
 print(gc.is_tracked(t1)) # -> True   <-----
 print(gc.is_tracked(t2)) # -> True   <-----

 Однако если циклический сборщик мусора запускается и определяет, что кортеж является неизменяемым «до конца»,
 он отменяет отслеживание этого кортежа:

 gc.collect()
 print(gc.is_tracked(t1)) # -> True   <-----
 print(gc.is_tracked(t2)) # -> False  <-----

 Ничего нельзя сделать, чтобы t2 заставить его участвовать в цикле, потому что он и все его компоненты
 (снова и снова, вплоть до конца) неизменяемы. Но t1 все равно нужно отслеживать! Поскольку t1[0] он изменчив,
 t1 может быть частью цикла позже:

 print(t1)       # -> ([1],)
 t1[0][0] = t1
 print(t1)       # -> ([(...)],)     <-----  цикл ссылок

 Для диктов (словарей) используется другая политика. Если возможно, они создаются без отслеживания:
 d = {1: [2]}
 print(gc.is_tracked(d))  # -> True

 Поскольку этот dict имеет изменяемое значение, он может стать частью цикла позже, поэтому его необходимо отслеживать
 с помощью циклического gc.

 d[1][0] = d
 print(d)  # -> {1: [{...}]}        <-----  цикл ссылок

 Но словарь с неотслеживаемыми ключами и значениями создается без отслеживания:

 d = {1: 2}
 print(gc.is_tracked(d))  # -> False

 Это сложно, потому что такое высказывание может позже стать частью цикла!

 d[2] = d
 print(gc.is_tracked(d))  # -> True

 Обнаружение таких изменений не является бесплатным.
 Далее следуют комбинации вышеперечисленного:

 d = {(1, 2): (4, "abc", 5)}
 print(gc.is_tracked(d))  # -> True
 gc.collect()
 print(gc.is_tracked(d))  # -> False

 В этом случае d сначала отслеживается, поскольку его ключи и значения (кортежи) создаются отслеживаемыми в первую очередь.
 Но после того, как циклический сборщик мусора запускается в первый раз, он определяет, что ключи и значения
 «неизменяемы до конца», поэтому отменяет dict.


 ПОДСЧЕТ ССЫЛОК также является формой сборки мусора(GC).
 В Python, алгоритм подсчета ссылок является фундаментальным и не может быть отключен, тогда как GC опционален и может быть отключен.

 ИНТЕРЕСНЫЙ ПРИМЕР Обьясняент работу сборщика мусора и как можно ускорить код!!!                               <-----

 Общий код установки (все дальнейшие блоки кода должны запускаться сразу после этого при новом запуске, не объединяйте их):

 from timeit import default_timer as timer
 n = 10**7
 a = list(range(n))
 b = list(range(n))
 pairs = list(zip(a, b))

 # Время с включенной сборкой мусора (по умолчанию):   gc.enable()   <-----
 t0 = timer()
 a[:], b[:] = zip(*pairs)
 t1 = timer()
 print(t1 - t0)  # ->  8.323833500035107           <-----

 # Время с отключенной сборкой мусора:  gc.disable()                 <-----
 t0 = timer()
 gc.disable()
 a[:], b[:] = zip(*pairs)
 gc.enable()
 t1 = timer()
 print(t1 - t0)  # ->  1.4535378000000492          <-----

 Итак, теперь мы знаем, что именно сборка мусора почему-то занимает большую часть времени , хотя при этом ничего и не собирается.

 Вот кое-что интересное: уже большую часть времени отвечает именно создание итератора zip:
 t0 = timer()
 z = zip(*pairs)
 t1 = timer()
 print(t1 - t0)  # ->  7.15841899998486            <-----

 Обратите внимание, что я сохранил zip итератор в переменной, поэтому пока нечего отбрасывать — ни при подсчете ссылок,
 ни при сборке мусора!  Что?! Куда тогда уходит время?

 Ну... как я уже сказал, эталонных циклов нет, поэтому сборщик мусора на самом деле не будет собирать мусор.     <-----
 Но сборщик мусора этого не знает! Чтобы это выяснить, его нужно проверить!                                      <-----

 Поскольку итераторы могут стать частью ссылочного цикла, они зарегистрированы для отслеживания сборки мусора. Посмотрим,
 сколько еще объектов будет отслеживаться в результате создания zip(сделаем это сразу после общего кода настройки):

 gc.collect()
 tracked_before = len(gc.get_objects())
 z = zip(*pairs)
 print(len(gc.get_objects()) - tracked_before) # -> 10000003  <-----

 Результат: 10000003 отслеживаются новые объекты. Я считаю, что это zip сам объект, его внутренний кортеж для хранения
 итераторов, его внутренний кортеж -держатель результатов и 10 миллионов итераторов.

 Итак, сборщик мусора отслеживает все эти объекты. Но что это значит? Ну, время от времени, после создания определенного
 количества новых объектов, сборщик просматривает отслеживаемые объекты, чтобы увидеть, являются ли некоторые из них
 мусором и их можно выбросить. Коллектор хранит три «поколения» отслеживаемых объектов. Новые объекты переходят в поколение 0.
 Если они выдерживают сборку там, они перемещаются в поколение 1. Если они выдерживают сборку там, они перемещаются
 в поколение 2. Если они выдерживают дальнейшие сборки там, они остаются в поколении. 2. Проверим поколения до и после:

 Вывод (в каждой строке показаны значения для трех поколений):
 gc.collect()
 print('collections:', [stats['collections'] for stats in gc.get_stats()])   # ->  collections: [13089, 1189, 2]
 print('objects:', [len(gc.get_objects(i)) for i in range(3)])               # ->  objects: [5, 0, 7021]
 z = zip(*pairs)
 print('collections:', [stats['collections'] for stats in gc.get_stats()])   # ->  collections: [26149, 2376, 20]
 print('objects:', [len(gc.get_objects(i)) for i in range(3)])               # ->  objects: [250, 2103, 10004675]

 10004675 показывает, что большинство из 10 миллионов итераторов не просто были зарегистрированы для отслеживания,
 но уже находятся в поколении 2. Таким образом, они участвовали как минимум в двух запусках сборки мусора.
 А количество коллекций поколения 2 выросло с 2 до 20, так что наши миллионы итераторов участвовали в 20 запусках
 сборки мусора (две для попадания во 2 поколение и еще до 18 уже во 2 поколение). Мы также можем зарегистрировать
 обратный вызов для более точного подсчета:

 checks = 0
 def count(phase, info):
     if phase == 'start':
         global checks
         checks += len(gc.get_objects(info['generation']))

 gc.callbacks.append(count)
 z = zip(*pairs)
 gc.callbacks.remove(count)
 print(checks)   # -> 63668257    <-----

 Это дало мне общее количество проверок 63 668 257 (т. е. в среднем каждый итератор участвовал в более чем 6 запусках
 сборки мусора). Это много работы. И все это только для того, чтобы создать zip итератор, еще до его использования.

 При этом цикл:
 for i, (a[i], b[i]) in enumerate(pairs):
    pass

 почти не создает новых объектов. Давайте проверим, насколько сильно отслеживание enumerate вызывает:

 gc.collect()
 tracked_before = len(gc.get_objects())
 e = enumerate(pairs)
 print(len(gc.get_objects()) - tracked_before)  # -> 3

 Выходные данные: 3 отслеживаются новые объекты ( enumerate сам объект итератора, единственный итератор, который он
 создает для итерации pairs, и кортеж результатов, который он будет использовать

 Я бы сказал, что это отвечает на вопрос : «Почему тайминги настолько различаются?» . Решение zip создает миллионы
 объектов, которые проходят несколько циклов сборки мусора, а решение с циклом — нет.
 Таким образом, отключение сборщика мусора zip очень помогает решению, а решение с циклом не имеет значения.

 По умолчанию timeit() временно отключает сбор мусора на время. Преимущество этого подхода в том, что он делает
 независимые тайминги более сопоставимыми. Недостаток заключается в том, что GC может быть важным компонентом выполнения
 измеряемой функции . Если это так, GC можно повторно включить в качестве первого оператора в строке настройки. Например:

 timeit.Timer('for i in range(10): oct(i)', 'gc.enable()').timeit()

 В нашем случае затраты на сбор мусора не связаны с каким-то другим несвязанным кодом. Это напрямую вызвано zip звонком.
 И вы действительно платите эту цену, когда запускаете это. Поэтому в данном случае я считаю это «важным компонентом
 эффективности измеряемой функции» . Чтобы прямо ответить на заданный вопрос: здесь я бы поверил методу default_timer,
 а не timeit методу. Или иначе: Здесь timeit метод следует использовать с включением сборки мусора, как предложено в документации.

 Или... альтернативно, мы могли бы отключить сбор мусора как часть решения (не только для тестирования):    <-----

 def f1(a, b, pairs):
    gc.disable()
    a[:], b[:] = zip(*pairs)
    gc.enable()

 Но хорошая ли это идея? Вот что говорится в gc документации :

 Поскольку сборщик дополняет подсчет ссылок, уже используемый в Python, вы можете отключить сборщик,        <-----
 если уверены, что ваша программа не создает циклы ссылок.

 Похоже, это нормально. Но я не уверен, что не создаю ссылочные циклы в других местах своей программы, поэтому
 заканчиваю тем, gc.enable() что снова включаю сбор мусора после завершения. На этом этапе все эти временные объекты уже
 были удалены благодаря подсчету ссылок. Поэтому все, что я делаю, — это избегаю множества бессмысленных проверок
 по сбору мусора. Я считаю это ценным уроком и, возможно, действительно сделаю это в будущем, если буду знать,
 что создаю много объектов только временно.





 --- Подсчет ссылок ---
 Подсчет ссылок Этот метод отслеживает количество ссылок, указывающих на каждый объект.
 Когда счетчик ссылок для объекта достигает нуля, что означает их отсутствие,
 объект считается “мусором” (ненужным), он уничтожается сборщиком мусора и память освобождается

 Для всех объектов в программе Python ведется подсчет ссылок. Счетчик ссылок на объект увеличивается всякий раз,
 когда ссылка на объект записывается в новую переменную или когда объект помещается в контейнер, такой как список,
 кортеж или словарь

 Счетчик ссылок (отслеживает создание/удаление обьектов) - ПОТОКОНЕБЕЗОПАСЕН не умеет работать чтобы сразу
 2 потока создавали или удаляли обьекты

 sys.getrefcount()  - функция показывает сколько ссылок ссылается на обьект. Возвращаемое значение обычно (+1) на
 единицу больше, чем вы могли ожидать, поскольку оно включает (временную) ссылку в качестве аргумента getrefcount().
 x = []
 print(sys.getrefcount(x)) # -> 2    +1 за (временную) ссылку в качестве аргумента getrefcount().
 в REPL создаете автоматическую ссылку в переменной  '_'  которая  добавляет +1

 Основной алгоритм сборки мусора, используемый CPython, — подсчет ссылок:
 x = object()
 sys.getrefcount(x) # -> 2 ссылки на обьект +1 из-за getrefcount
 y = x
 sys.getrefcount(x) # -> 3 ссылки на обьект +1 из-за getrefcount
 del y
 # del (y)  # Тоже самое
 sys.getrefcount(x) # -> 2 ссылки на обьект +1 из-за getrefcount
 import gc
 print(gc.collect()) # -> 0  ПОДСЧЕТ ССЫЛОК сработал

 Основная проблема схемы подсчета ссылок заключается в том, что она не обрабатывает циклы ссылок:
 container = []
 container.append(container)
 sys.getrefcount(container)   # -> 3
 print(container)  # -> [[...]]  # показывает, что структура данных ссылается на себя, избегая бесконечного рекурсивного вывода.

 del container
 import gc
 print(gc.collect()) # -> 1  СБОРЩИК МУСОРА сработал

 Garbage Collector (GC) в Python справится с этой ситуацией. Он может обрабатывать циклические ссылки, такие как
 `container`, содержащий сам себя. Хотя сборка мусора может потребовать немного больше ресурсов из-за необходимости
 отслеживания циклических ссылок, утечек памяти не произойдет, и GC не "ЗАХЛЕБНЕТСЯ".

 # В Python `[...]` используется, чтобы показать циклическую ссылку, поскольку повторяющееся содержание может привести
 # к бесконечному выводу

 В этом примере container содержит ссылку на себя, поэтому даже когда мы удаляем ссылку на нее (переменную «контейнер»),
 счетчик ссылок никогда не падает до 0, поскольку у него все еще есть собственная внутренняя ссылка. Поэтому его никогда
 нельзя будет очистить простым подсчетом ссылок. По этой причине необходим некоторый дополнительный механизм для очистки
 этих циклов ссылок между объектами, когда они становятся недоступными. Это циклический сборщик мусора, обычно называемый
 просто сборщиком мусора (GC), хотя подсчет ссылок также является формой сборки мусора.

 Бессмертные объекты не меняют счетчик ссылок, что делает их неизменяемыми, и их нельзя собирать мусором, поэтому
 они живут до завершения работы интерпретатора.
 Бессмертные глобальные объекты:
 Все глобальные (встроенные) объекты среды выполнения будут бессмертными:
 - singletons (None, True, False, Ellipsis, NotImplemented)
 - все статические типы (например PyLong_Type, PyExc_Exception)  PyLong_Type == int, PyExc_Exception == Exception
   PyLong_Type - экземпляр PyTypeObject представляет целочисленный тип Python. Это тот же объект, что и int на слое Python.
   Exception - доступный в C как PyExc_Exception
 - все статические объекты _PyRuntimeState.global_objects(например, идентификаторы, небольшие целые числа)
 Пример:
 for i in ['a', True, False, None, Ellipsis, NotImplemented, 1, Exception]:
     print(f"{i}: {sys.getrefcount(i)},", end=' ')  # сколько ссылок у обьекта
 # a: 1000000364, True: 1548, False: 1476, None: 9685, Ellipsis: 62, NotImplemented: 7, 1: 1000001059, <class 'Exception'>: 203,
 Простой Пример:
 print(sys.getrefcount(-6))  # -> 3               print(sys.getrefcount('a'))       # -> 1000000361
 print(sys.getrefcount(-5))  # -> 1000000004      print(sys.getrefcount('aaaaaa'))  # -> 3
 print(sys.getrefcount(256)) # -> 1000000049      print(sys.getrefcount([]))        # -> 1
 print(sys.getrefcount(257)) # -> 3               print(sys.getrefcount({}))        # -> 1


 Циклические ссылки происходят когда один или более объектов ссылаются на друг друга.
 ЦИКЛ ССЫЛОК - когда ПОДСЧЕТ ССЫЛОК не справляется с удалением обьектов
 Ссылочный цикл просто означает, что один или несколько объектов ссылаются друг на друга

 Самый простой ссылочный цикл — это объект, который ссылается на себя:
 a = []                             b = [1, 2, 3, 4]
 a.append(a)                        b.append(b)
 print(a)  # -> [[...]]             print(b) # -> [1, 2, 3, 4, [...]]

 CPython использует другой инструмент – ЦИКЛИЧЕСКИЙ СБОРЩИК МУСОРА
 Это исправляет проблему с циклом ссылок, однако могут появиться заметные паузы, когда в памяти находится большое количество объектов.

 Методы __del__() не препятствуют сборке мусора в ссылочных циклах
 Оператор del не обязательно вызывает __del__(). Оператор del просто уменьшает счетчик ссылок на объект,
 и если он достигает нуля, __del__() вызывается.
 объекты с__del__() методом больше не попадают в gc.garbage.

 Способы избежать cyclical references (циклических ссылок):
 1) gc.collect()
 1) модуль weakref


 --- Слабые и Обычные Ссылки на обьекты ---
 Обычная ссылка увеличивает счетчик ссылок на объект и предотвращает сбор мусора.
 Слабые ссылки - не увеличивают счетчик ссылок. Соответственно, объект на который есть такая ссылка, может быть уничтожен
 Модуль weakref позволяет создавать "слабые" ссылки на объекты.
 Когда единственными оставшимися ссылками на объект являются слабые ссылки,
 то сборщик мусора может уничтожить этот объект и повторно использовать его память для чего-то другого.
 Однако до тех пор, пока объект не будет уничтожен, слабая ссылка может вернуть исходный объект,
 даже если на него нет сильных ссылок
 С самими слабыми ссылками при работе счетчика мусора ничего не происходит, он уничтожает объекты (и сильные ссылки), а не слабые ссылки.
 Слабые ссылки позволяют ссылаться на объект, не увеличивая его счетчик ссылок.
 Каждый объект, на который могут ссылаться "слабые" ссылки, содержит атрибут   __weakref__
 __weakrefoffset__ - проверка имеет ли тип слабую ссылочную поддержку или нет. Если 0 - не имеет, если > 0 имеет
 Слабые ссылки можно создавать на пользовательские классы (свои собственные), на set и на подклассы от dict и list
 list и dict, напрямую не поддерживают слабые ссылки, но могут добавить поддержку через подклассы.
 Другие встроенные типы, такие как tuple и int, str и подобные не поддерживают слабые ссылки даже в подклассах.

 Основное использование слабых ссылок - реализация кешей или словарей, содержащих большие объекты,
 которые не должны долго находится в памяти.

 import weakref , weakref.getweakrefcount(object)      - функция показывает сколько "слабых" ссылок ссылается на обьект
 getweakrefcount()                           - количество слабых ссылок , ссылающихся на объект .
 ref()                                       - Создать слабую ссылку на объект
 proxy()                                     - Использовать прокси объект по слабой ссылке
 WeakKeyDictionary() и WeakValueDictionary() - Слабая ссылка на ключи или значения словаря dict
 WeakMethod()                                - Слабая ссылка на связанный метод
 finalize()                                  - Вызываемая функция при удалении объекта сборщиком мусора

 Когда в данном типе присутствует атрибут __slots__, "слабые" ссылки не доступны до тех пор, пока атрибут __weakref__
 явно не присутствует в списке __slots__.

 borrowed reference(заимствованная ссылка, Кража ссылки) — это ссылка на объект, при этом код, использующий этот объект,
 не владеет ссылкой. Он становится висячим указателем, если объект уничтожается.
 описывается API, используемый программистами C и C++, которые хотят писать модули расширения или встраивать Python.
 скомпилировать программу использующую API Python/C:
 Макросы в этом разделе используются для управления счетчиком ссылок объектов Python. API Python/C:
 Py_INCREF() - Укажите получение новой строгой ссылки на объект , указывая, что он используется и не должен быть уничтожен.
 Py_NewRef() - Эта функция обычно используется для преобразования заимствованной ссылки в надежную ссылку на месте.
 Эту Py_NewRef() функцию можно использовать для создания новой сильной ссылки.
 Py_XNewRef() - Аналогично Py_NewRef(), но объект может иметь значение NULL.
 Py_DECREF() - Эта функция обычно используется для удаления строгой ссылки перед выходом из ее области действия.
 Py_XDECREF() - Аналогично Py_DECREF(), но объект может быть NULL.


 --- Менеджер Памяти и как эта память высвобождается Memory Management ---
 Python не освобождает всю память обратно операционной системе как только он удаляет какой либо объект.
 Вместо этого, он использует дополнительный менеджер памяти,
 предназначенный для маленьких объектов (размер которых меньше чем 512 байт).
 Для работы с такими объектами он выделяет большие блоки памяти, в которых в дальнейшем будет хранится множество маленьких объектов.
 Менеджер небольших объектов Python редко возвращает память обратно в операционную систему

 Хотя Python использует «счетчик ссылок» и «GC» для освобождения памяти (для объектов, которые не используются),
 эта свободная память не возвращается обратно в операционную систему (хотя в Windows это другой случай). Это означает,
 что свободный фрагмент памяти просто возвращается обратно в интерпретатор Python, а не в операционную систему.
 Таким образом, в конечном итоге ваш процесс Python будет хранить одну и ту же память. Однако Python будет использовать
 эту память для выделения некоторым другим объектам.

 Управление памятью Python разделено на две части.
 - Память стека
 - Куча памяти
 - Методы и переменные создаются в памяти стека.
 - Значения переменных объектов и экземпляров создаются в памяти кучи.
 - В памяти стека — кадр стека создается при каждом создании методов и переменных.
 - Эти кадры стека автоматически уничтожаются всякий раз, когда функции/методы возвращаются.
 - В Python есть механизм сборщика мусора: как только переменные и функции возвращаются, сборщик мусора очищает мертвые объекты.

 -- Memory Management Управление памятью --
 Python управляет всеми методами/функциями объектов в частной куче.
 Управление памятью в Python включает в себя частную кучу, содержащую все объекты Python и структуры данных.
 Управление этой частной кучей обеспечивается внутренним менеджером памяти Python. Диспетчер памяти Python имеет различные
 компоненты, которые отвечают за различные аспекты динамического управления хранилищем, такие как совместное использование,
 сегментация, предварительное выделение или кэширование.

 На самом низком уровне необработанный распределитель памяти гарантирует, что в частной куче достаточно места для
 хранения всех данных, связанных с Python, путем взаимодействия с диспетчером памяти операционной системы.

 Помимо необработанного распределителя памяти, несколько объектно-ориентированных распределителей работают в одной куче
 и реализуют различные политики управления памятью, адаптированные к особенностям каждого типа объекта.

 Например, целочисленные объекты в куче управляются иначе, чем строки, кортежи или словари, поскольку целые числа <---
 подразумевают другие требования к хранению и компромиссы между скоростью и пространством.                        <---

 Важно понимать, что управление кучей Python осуществляет сам интерпретатор и что пользователь не имеет над ней контроля,
 даже если он регулярно манипулирует указателями объектов на блоки памяти внутри этой кучи. Выделение кучи для объектов
 Python и других внутренних буферов выполняется по требованию диспетчером памяти Python с помощью функций API Python/C
------------------------------------------------------------------------------------------------------------------------

 Задачи могут быть:
 CPU-bound - зависит от мощности процессора # расчеты внутри python власть GIL
 IO-bound - зависит от системы ввода/вывода # обращение к файлу, обращение к сайту # GIL не трогает

 threading - IO-bound задачи # GIL не помешает
 asyncio - IO-bound задачи , 1 поток использует Конкурентность (concurrency) по полной
 multiprocessing - любые задачи

  # Потоки ИСПОЛНЯЮТСЯ на уровне ОС а asyncio на уровне Интерпретатора                                 <-----

 -- КОНКУРЕНТНОСТЬ vs ПАРАЛЛЕЛИЗМ --

 В случае КОНКУРЕНТНОСТИ несколько задач работают в течении одного промежутка времени, но только одна активна в каждый
 момент.
 В случае ПАРАЛЛЕЛИЗМА несколько задач активно одновременно.

 В случае КОНКУРЕНТНОСТИ мы переключаемся между двумя приложениями.
 В случае ПАРАЛЛЕЛИЗМА мы активно выполняем два приложения одновременно.


 Примеры I/O-bound задач в Python:
 **Загрузка данных из веб-API**:            - ожидание ответа от сервера.
 **Чтение и запись файлов**:                - работа с файлами на диске
 **Взаимодействие с базами данных**:        - выполнение запросов и получение данных.
 **Отправка и получение данных по сети**:   - работа с сокетами и сетевыми протоколами.

 Для I/O-bound задач особенно эффективны многопоточность и асинхронное программирование, так как они позволяют
 выполнять другие задачи, пока происходит ожидание.



 --- Многопоточность (multithreading) ---
 multithreading - многопоточность, подходит для IO-bound задач, использует ОС, страдает от GIL(важно помнить)
 Полезно для ускорения выполнения задач для того, чтобы текущий поток занялся другой задачей
 Любая программа это минимум один процесс и один поток
 Полезно использовать daemon=True (чтобы остальные потоки не висели), Queue(очереди), pool executor,
 НО в любом случае все зависит от программиста!

 Плюсы:
 + просто(сравнительно)
 + быстро
 + не умирает из-за одного(!)

 Минусы:
 - потребление ресурсов(ОС)
 - неуправляемость(старт, приостановка, переключение)
 - проблема потоков(гонка, блокировки)

 Race condition (состояние гонки) - это ситуация, при которой несколько потоков (или процессов) одновременно пытаются
 выполнить операции чтения или записи к общим ресурсам без должной синхронизации.

 Состояние гонки могут возникать, когда два потока одновременно обращаются к одному обьекту Python

 Если два потока одновременно увеличивают счетчик ссылок, то может случиться, что счетчик обнулится, хотя обьект еще
 используется.

 Состояние гонки, возникающее, когда два потока одновременно пытаются увеличить счетчик ссылок.


 -- Модуль concurrent.futures --
 concurrent.futures — Запуск параллельных задач, Параллельное выполнения задач в разных процессах или потоках

 - при использовании класса ThreadPoolExecutor, задачи выполняются в потоках;
 - при использовании класса ProcessPoolExecutor, задачи выполняются на ядрах процессора;
 - оба класса реализуют одинаковый API-интерфейс, который определяется абстрактным классом concurrent.futures.Executor,
 поэтому приложения могут переключаться между потоками и процессами с минимальными изменениями;
 - легко интегрируется в модуль asyncio, для запуска блокирующих операции в отдельных потоках/процессах.

 Класс ThreadPoolExecutor() модуля concurrent.futures -  Создает пул потоков для асинхронного выполнения вызовов
 ThreadPoolExecutor(max_workers=None) - использует пул не более max_workers потоков для асинхронного выполнения вызовов.

 Класс ProcessPoolExecutor() модуля concurrent.futures - Создает пул из ядер процессора для асинхронного выполнения вызовов
 ProcessPoolExecutor(max_workers=None) - использует пул не более чем max_workers ядер процессора для асинхронного выполнения вызовов.

 ProcessPoolExecutor в Python использует СЕМАФОР для управления количеством одновременно работающих процессов.
 Семафор ограничивает количество потоков или процессов, которые могут одновременно выполнять определенные операции,
 что помогает предотвратить чрезмерное использование ресурсов системы.

 Семафор — это синхронизирующий объект, который используется для управления доступом к общему ресурсу в многопоточной
 или многопроцессорной среде. Он может быть представлен как счетчик, который указывает, сколько потоков или процессов
 могут одновременно выполнять определенную задачу. Если счетчик достигает нуля, остальные потоки или процессы должны
 ожидать, пока другие освободят ресурсы.

 В стандартной библиотеке Python есть Три (3)  класса Semaphore: по одному в модулях threading, multiprocessing, asyncio

 Многопоточность достигается модулем Threading.
 Это нативные Posix-треды. Такие треды исполняются операционной системой, а не виртуальной машиной.
 from threading import Thread

 Предупреждение. Любой процессор поддерживает определенное количество потоков на ядро, заложенное производителем
 (обычно 4-6 потоков), при которых он работает оптимально быстро. Нельзя создавать безгранично много потоков.
 При увеличении числа потоков на величину, большую, чем заложил производитель, программа будет выполняться дольше
 или вообще поведет себя непредсказуемым образом (вплоть до зависания).

 -- Как запустить что-то в потоке и вывести результат?
 Ну, есть ThreadPoolExecutor - красиво:

 from concurrent.futures import ThreadPoolExecutor

 fn = lambda: 5
 with ThreadPoolExecutor() as pool:
     future = pool.submit(fn)
     print(future.result())


 -- Модуль joblib --
 Модель joblib использует библиотеку Loky, которая является улучшенной версией concurrent.futures,
 и применяет модуль cloudpickle для сериализации функций, определенных в интерактивной оболочке,
 что позволяет их использовать в многопроцессорных вычислениях.

 from joblib import Parallel, delayed

 def my_function(x):
     return x * x

 # Параллельное выполнение функции с использованием 4 процессов
 results = Parallel(n_jobs=4)(delayed(my_function)(i) for i in range(10))

 print(results)  # -> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]



 --- Greenlet == Green thread == Зеленые треды ---
 Что такое гринлеты. Общее понятие. Примеры реализаций
 Greenlet == Green thread == Зеленые треды == легковесные треды внутри виртуальной машины. Могут называться корутинами,
 сопроцессами, акторами и т.д. в зависимости от платформы. Операционная система не видит их.
 С точки зрения ОС запущен один процесс виртуальной машины, а что внутри нее – неизвестно.
 Такими тредами управляет сама вируальная машина: порождает, исполняет, согласует доступ к ресурсам.

 Треды в Питоне — это нативные треды или нет
 Да, это (native threads) нативные Posix-совместимые треды, которые исполняются на уровне операционной системы.
 POSIX (англ. Portable Operating System Interface — переносимый интерфейс операционных систем)
 Стандарт POSIX определяет интерфейс операционной системы
 Стандарты, такие как POSIX, позволяют легко перемещаться между различными операционными системами.
 это стандарт, описывающий интерфейс между операционной системой и прикладной программой. Цель создания этого стандарта
 – обеспечение совместимости unix-like операционных систем, а также переносимости программ на уровне исходного кода.

 В чем отличие тредов от мультипроцессинга?
 Главное отличие в разделении памяти. Процессы независимы друг от друга, имеют раздельные адресные пространства,
 идентификаторы, ресурсы. Треды исполняются в совместном адресном порстранстве,
 имеют общий доступ к памяти, переменным, загруженным модулям.


 Многопоточность - имеет смысл использовать только для блокирующего ввода-вывода. GIL не будет мешать.
 Если ЗНАЧИТЕЛЬНАЯ часть библиотеки написаны на C например hashlib, Numpy. - GIL не будет мешать.

 Numexpr — это библиотека Python, которая позволяет эффективно выполнять выражения с использованием NumPy.
 Установка библиотеки NumExpr УСКОРЯЕТ выполнение функции eval в Pandas, но библиотека Pandas не сообщает пользователю
 о необходимости установки NumExpr.                              ВАЖНО ПРО функцию eval          <-----   <-----

 Помните, что Pandas без NumExpr выполняет функцию eval крайне медленно!
 NumExpr оптимизирует вычисления и использует многоядерные процессоры, что значительно ускоряет операции с массивами данных.

 # В этом примере, если NumExpr установлен, выполнение df.eval будет быстрее.                    <-----   <-----
 import pandas as pd
 import numpy as np

 # Создание DataFrame
 df = pd.DataFrame({
     'a': np.random.rand(1000000),
     'b': np.random.rand(1000000)
 })

 # Использование eval без NumExpr
 result_without_numexpr = df.eval('c = a + b')

 # Использование eval с NumExpr
 result_with_numexpr = df.eval('c = a + b')  # NumExpr будет использован автоматически, если установлен


 Tkinter - это пакет модулей Python для создания приложений с графическим интерфейсом пользователя.
 Tkinter используется в Python по-умолчанию. Tkinter - Создание простого окна приложения.      # Виджет Frame (рамка)
 Tkinter работает в однопоточном режиме. Так же как и asyncio

 Любая программа - это один процесс(система создала процесс дала ему id выделила память)
 а потоков может быть большое количество (на уровне ОС есть ограничение на количество потоков)
 потоки все внутри 'коробочки' которая называется процесс
 Процесс - большая сущность, ПОТОКИ - маленькие сущности они внутри Процесса и могут разделять общую память,
 память пренадлежит процессу и потоки могут память переиспользовать

 Функциональное программирование заточено под многопоточку

 -- Модуль queue, очереди в Python --
 import queue, from queue import Queue

 Модуль queue реализует очереди с несколькими производителями и несколькими потребителями. Это особенно полезно в
 многопоточном программировании, когда необходимо безопасно обмениваться информацией между несколькими потоками.
 Класс Queue в этом модуле реализует всю необходимую семантику блокировки.

 Модуль реализует три типа очереди, которые отличаются только порядком, в котором извлекаются записи:

 1) В очереди FIFO первые добавленные задачи являются первыми извлеченными.  queue.Queue()
 2) В очереди LIFO самая последняя добавленная запись является первой извлеченной (работающей как стек). queue.LifoQueue()
 3) В очереди с приоритетами записи сохраняются отсортированными с использованием модуля heapq(очереди с кучей) и сначала
    извлекается запись с наименьшим значением.  queue.PriorityQueue()

 1) Очередь FIFO - Класс queue.Queue():
 Класс queue.Queue() реализует базовый контейнер типа FIFO - "первым пришел - первым вышел". Элементы добавляются
 к одному концу очереди с помощью метода put(), а удаляются с другого конца с помощью метода get().

 2) Очередь LIFO - Класс queue.LifoQueue():
 В отличие от стандартной реализации очереди FIFO, в queue.LifoQueue() используется порядок
 "последним пришел - первым вышел", который обычно связан со структурой данных стека.

 3) Очередь с приоритетом - Класс queue.PriorityQueue():
 Иногда порядок обработки элементов в очереди должен основываться на характеристиках этих элементов, а не только на
 порядке их создания или добавления в очередь. Например, задания на печать из финансового отдела могут иметь приоритет
 над списком заданий из отдела технической поддержки. Класс модуля queue.PriorityQueue() использует порядок сортировки
 содержимого очереди, чтобы решить, какой элемент получить.


 Внутренне эти три типа очередей используют блокировки для временного блокирования конкурирующих потоков,
 однако они не предназначены для обработки повторного входа в поток.

 Кроме того, модуль реализует простой тип очереди FIFO - queue.SimpleQueue(), специфическая реализация которого
 обеспечивает дополнительные гарантии в обмен на меньшую функциональность.
 Очередь FIFO без отслеживания задач queue.SimpleQueue():
 Класс SimpleQueue() модуля queue представляет собой конструктор для простой неограниченной очереди FIFO.

 -- Класс Lock() модуля threading в Python --
 Синхронизация потоков при помощи блокировок
 Для защиты от одновременного доступа к объекту нескольких потоков используйте объект threading.Lock().

 Методы объекта threading.Lock:
 Lock.acquire() -  устанавливает блокировку
 Lock.release() -  снимает блокировку
 Lock.locked()  -  проверяет состояние блокировки


 Книги multithreading - многопоточность: Мартин Фаулер


 --- multiprocessing (многопроцессорность) ---
 multiprocessing - использование нескольких ядер
 Породить процессы с помощью multiprocessing.Pool. Число, которое будет передано в Pool(),
 будет равно числу порожденных процессов
 import multiprocessing, from multiprocessing import Process, Pool

 --- Multiprocessing выдуман чтобы побороть GIL! Как его побороть? - Сделать много GIL каждый из которых независимый ---
 --- Multiprocessing работает только с обьектами которые поддерживают сериализацию через pickle
 В других ЯП: параллельность вычислений достигается с помощью 2-х средств - ПОТОКИ или asyncio. Потому что у них нет GIL
 Multiprocessing - позволяет решать любые задачи (IO-bound или CPU-bound)
 Ускорение любые задачи, распараллеливая их на ядра процессора (лишь до определенного предела, закон Амдала)
 закон Амдала - с какого-то момента бессмысленно добавлять дополнительных рабочих(ЦПУ, доп.ядра) быстрее не станет
 Ускорение не идеально и возможно только до определенного предела, смотрим закон Амдала.
 Создает несколько процессов, у каждого из которых своя память и свой GIL, каждый выполняет свою задачу, взаимодействие
 между ними требует pickle(сериализация, превращение обьектов python в байты и наоборот байтов в обьекты python)
 API принципиально похоже на многопоточность, выгодно использовать Pool, а для взаимодействия между процессами Queue и Pipe
 Pipe - когда нужно 2 процесса между собой подружить чтобы они передавали друг другу данные.


 Плюсы:
 + реальная параллельность любых задач
 + не умирает из-за одного(!)
 + процессы не зависят друг от друга(у каждого процесса своя память и GIL)
 Минусы:
 - потребление ресурсов (памяти, процессора, времени)
 - необходимость сериализации в pickle
 - проблемы синхронизации (взаимодействие между процессами)


 -- ЦЕЛЬ СЕРИАЛИЗАЦИИ с помощью pickle в multiprocessing --

 ЦЕЛЬ СЕРИАЛИЗАЦИИ с помощью pickle в multiprocessing заключается в том, чтобы преобразовать объекты Python в формат,
 который можно сохранить в файл или передать между процессами. Это необходимо, поскольку каждый процесс в
 multiprocessing имеет своё собственное пространство памяти. Сериализация позволяет копировать данные и передавать их,
 обеспечивая тем самым возможность взаимодействия между процессами.


 --- Основы асинхронного программирования в Python ---
 async используется для объявления асинхронной функции. Это означает, что функция будет возвращать объект coroutine,
 который можно выполнить асинхронно. await используется внутри асинхронной функции
 для ожидания результата другой асинхронной операции.

 Асинхронное программирование позволяет запускать операции параллельно, не дожидаясь выполнения последовательности.

 Асинхронное функции позволяют выполнять большое количество одновременных задач в небольшом количестве потоков ОС,
 сохраняя при этом большую часть внешнего вида обычного синхронного программирования с помощью синтаксиса async/await

 Асинхронное программирование — это подход к написанию кода,
 при котором несколько задач выполняются параллельно и независимо друг от друга
 (в отличие от синхронного программирования, где каждая операция выполняется последовательно и синхронно)

 Корутины(асинхронные функции) или сопрограммы (англ. coroutine) — это специальные функции, которые могут приостанавливать
 свое выполнение и передавать управление другим корутинам, а затем продолжать с того места, где остановились

 Кроме того, в асинхронном коде используются конструкции await и async with,
 которые позволяют приостановить выполнение текущей задачи и переключиться на другую,
 пока выполняется асинхронная операция. Это позволяет эффективно использовать ресурсы процессора и снизить время ожидания.

 --- asyncio ---
 asyncio - Асинхронное выполнение, подходит для IO-bound задач, работает ровно 1 поток - использует Конкурентность по полной
 Плюсы:
 + скорость и экономия времени, вместо x + y + z -> max(x, y, z)
 + управляемость
 + меньше потребление ресурсов (в сравнении с потоками)
 Минусы:
 - "умирает" из-за одного блокирующего вызова (!)
 - event loop не безразмерный, нужно понимать, что корутины не бесплатные

 1) корутина работает как генератор
 2) async - явный флаг, что данная функция является асинхронной (корутиной)
 3) await - явный флаг, что в этом месте функция встает на паузу и дает работать другим, пока ждёт свои данные
 4) event loop - цикл событий, механизм, который отвечает за планирование и запуск корутин. Можно представить как
 список/очередь, из которого в вечном цикле достаются и запускаются корутины
 Частые ошибки:
 - не использование await внутри корутины
 - создание корутины, но использование ее, как функции
 - использование внутри корутин синхронного(блокирующего) кода, в том числе IO

 asyncio.gather(one(), two(), three()) - one,two,three - функции
 gather() - одновременно запускает объекты awaitable, переданные в функцию как последовательность *aws.
 *aws - последовательность объектов ожидания,       return_exceptions=False - обработка исключений.
 asyncio.run() запускает цикл событий в асинхронном коде
 asyncio.run(main())

 Легкий пример:
 import asyncio

 async def one():
     print('Start one')
     await asyncio.sleep(1)
     print('Stop one')

 async def two():
     print('Start two')
     await asyncio.sleep(2)
     print('Stop two')

 async def three():
     print('Start three')
     await asyncio.sleep(3)
     print('Stop three')

 async def main():
     await asyncio.gather(one(), two(), three())  # Можно запустить сразу все. Выполнения нескольких задач одновременно
     # asyncio.create_task(one())
     # asyncio.create_task(two())
     # await asyncio.create_task(three())

 if __name__ == '__main__':
     start = time.time()
     asyncio.run(main())          # Запускает цикл событий в асинхронном коде
     print(time.time() - start)


 asyncio.sleep(0) приостанавливает выполнение текущей корутины, позволяя циклу событий выполнить другие задачи.
 Это полезно для перераспределения управления между корутинами без фактической задержки.

  -- Блокирующие API --

 Примеры блокирующих API:
 библиотека requests или функция time.sleep

 Вообще, любая функция, которая выполняет ввод-вывод, не-являясь сопрограммой, или занимает процессор длительными
 операциями, может считатся блокирующей.

 библиотека requests - Блокирующая т.е. блокирует поток, в котором выполняется. Поскольку asyncio ОДНОПОТОЧНАЯ,
 requests блокирует цикл событий и не дает ничему выполняться конкурентно.

 Чтобы использовать async c requests  Нужно Указать asyncio задействовать многопоточность с помощью исполнителя ПУЛА  ПОТОКОВ

 Большинство API с которыми мы работаем, в настоящий момент являються БЛОКИРУЮЩИМИ и без ДОРАБОТОК РАБОТАТЬ с asyncio
 НЕ БУДУТ!
 Нужно использовать библиотеки, которые поддерживают СОПРОГРАММЫ и НЕБЛОКИРУЮЩИЕ сокеты.
 Можно использовать aiohttp - в которой используются НЕБЛОКИРУЮЩИЕ сокеты и которая возвращает СОПРОГРАММЫ!


 **Блокирующий сокет** — это сокет, который при выполнении операций останавливает выполнение программы до их завершения.
 Если нет данных для чтения или операция не может быть выполнена, программа "зависает".

 **Неблокирующий сокет** — это сокет, который не останавливает выполнение программы. Если операция не может быть
 выполнена мгновенно (например, нет данных), она завершится неудачей, и программа может продолжать свою работу или
 пытаться повторить операцию позже.

 Таким образом, блокирующий сокет прост в использовании, но может замедлить программу, тогда как неблокирующий позволяет
 более гибко управлять потоком выполнения, но требует более сложной обработки ошибок.

------------------------------------------------------------------------------------------------------------------------

 -- А текущее состояние может быть странным. Вот, например, Гвидо вам говорит, что сорян, но если asyncio.as_completed
 падает по таймауту, то оставшиеся таски всё равно продолжают работать. С другой стороны, если вы запустите
 asyncio.create_task и случайно не сохраните где-нибудь эту задачу, то придёт сборщик мусора и убъёт вашу задачу,
 прям даже в середине выполнения. Asyncio - это весело.


  -- namedtuple, dataclasses и typing.NamedTuple    Построители классов данных  --

 - namedtuple: легковесные объекты с именованными полями.
 - dataclass: классы с автоматическим созданием метода __init__ и другими.
 - typing.NamedTuple: именованные кортежи с поддержкой аннотаций типов.

 Примеры:

 # dataclass                              # typing.NamedTuple                    # namedtuple
 from dataclasses import dataclass        from typing import NamedTuple          from collections import namedtuple

 @dataclass                               class Point(NamedTuple):               Point = namedtuple('Point', ['x', 'y'])
 class Point:                                 x: int
     x: int                                   y: int
     y: int

 p = Point(10, 20)                        p = Point(10, 20)                      p = Point(10, 20)
 Point.__doc__ # Point(x: int, y: int)    print(Point.__doc__)  # Point(x, y)    print(Point.__doc__)  # Point(x, y)
 print(p)  # Point(x=10, y=20)            print(p.x, p.y)  # 10 20               print(p.x, p.y)  # 10 20

 print(Point.__annotations__)               print(Point.__annotations__)                print(Point.__annotations__)
 # {'x': <class 'int'>, 'y': <class 'int'>} # {'x': <class 'int'>, 'y': <class 'int'>}  # {}


  --- OOP ---
 Объектно-ориентированное программирование (ООП) — это подход,
 при котором программа рассматривается как набор объектов, взаимодействующих друг с другом

 Объе́ктно ориенти́рованное программи́рование(ООП) - это способ решения задач когда все в программе обьекты
 и взаимодействие между ними

 ООП основано на «трех китах» - трех важнейших принципах придающих объектам новые свойства.
 Этими принципами являются ИНКАПСУЛЯЦИЯ, НАСЛЕДОВАНИЕ и ПОЛИМОРФИЗМ.

 Суперкласс еще называется базовым (base class) или родительским (parent class),
 подкласс - производным (derived class) или дочерним (child class).

 Обьект - сущность, обьединяющая данные и методы для работы с ними (состояние и поведение)

 Божественный обьект(God object)  — антипаттерн объектно-ориентированного программирования, описывающий объект, который
 хранит в себе «слишком много» или делает «слишком много» Основная идея модульного программирования состоит в том,
 что большая задача делится на меньшие относительно независимые подзадачи (принцип «разделяй и властвуй»)

 Объекты, у которых есть свой идентификатор и время жизни, называют объектами-сущностями
 <__main__.Test object at 0x000001987FBD11D0>   # -> <модуль.ИмяКласса object at Адрес>

 Класс - это новый тип данных, обьект - его конкретный представитель
 у любого обьекта есть id (адресс в памяти), значение и тип
 первая потребность для классов - когда не хватает встроенных типов, вторая - разное состояние
 метод - это функция которая принадлежит классу
 self - ссылка на экземпляр класса
 если класс пустой(pass) сравнивает == через is по адресу в памяти (ссылка)

 -- Обьяснение self:
 class Cat:
    def meow(self):   # -> self ссылка на Экземпляр класса на tom
        print('MEOW')
 tom = Cat()    # tom Экземпляр класса Cat
 tom.meow()     # self подставляется Python не явно под капотом! Python сам за нас подставит агрумент self
 Cat.meow(tom)  # Явно передаем ссылку на tom Экземпляр класса - tom


 -- Обьяснение __func__ для методов экземпляров класса + интерессный пример:
 class Test(object):
    a = 'world'

    def test_method(self, b='hello'):
        print(b, self.a)

 c = Test()

 c.test_method()      # Python сам подставил self
 Test.test_method(c)  # Явно передали аргумент self

 # <__main__.Test object at 0x000001987FBD11D0> # -> <модуль.ИмяКласса object at Адрес>

 print(c)                       # ->  0x000001E3955AB110 адрес в памяти (идентификатор обьекта)
 print(c.test_method)           # ->  0x000001E3955AB110 адрес в памяти (идентификатор обьекта)
 print(c.test_method.__func__)  # ->  0x000001E3B5C57600 адрес в памяти (идентификатор обьекта)
 print(Test.test_method)        # ->  0x000001E3B5C57600 адрес в памяти (идентификатор обьекта)
 c.test_method.__func__(c)          # -> hello world
 c.test_method.__func__.__call__(c) # -> hello world

 c.test_method.__func__.cool = 50   # -> установка атрибута метода
 c.test_method.__dict__             # -> {'cool': 50}
 c.test_method.__func__.__dict__    # -> {'cool': 50}

 Таким образом, цель __func__ состоит в том, чтобы настроить, как модули и классы будут искать функцию. Если это метод
 внутри класса, у него есть некоторые дополнительные функции, работающие за кулисами для установки контекста, чтобы он
 мог получить доступ к self.a или другому классу. методы внутри класса.

 -- Пример id и адресс в памяти в hex() число в шестнадцатеричной строке --
 class A:pass
 print(A())                     # -> <__main__.A object at 0x000001BCEA4EAE50>
 print(hex(id(A())))            # ->                            0x1bcea4eae50
 print(id(A()))                 # ->                            1910896504400

 def foo():...
 print(foo)                     # -> <function foo at 0x000001BCFF777600>
 print(hex(id(foo)))            # ->                       0x1bcff777600
 print(id(foo))                 # ->                       1911251498496

 it_lst = iter([1, 2, 3])
 print(it_lst)                  # -> <list_iterator object at 0x000001BCFF7785E0>
 print(hex(id(it_lst)))         # ->                               0x1bcff7785e0
 print(id(it_lst))              # ->                               1911251502560

 gen = (i for i in range(1, 4))
 print(gen)                     # -> <generator object <genexpr> at 0x000001BCEAB286C0>
 print(hex(id(gen)))            # ->                                     0x1bceab286c0
 print(id(gen))                 # ->                                     1910903047872

 -- В Python все обьекты (object): включая классы, а также их объекты (экземпляры).
 class A: pass                                 issubclass(A, object)     # -> True
 isinstance(A, A)             # -> False       issubclass(int, object)   # -> True
 isinstance(type, type)       # -> True        issubclass(type, object)  # -> True
 isinstance(object, object)   # -> True        issubclass(object, type)  # -> False
 Эти отношения между object и type(оба являются экземплярами друг друга, а также сами по себе) существуют в Python
 из-за «обмана» на уровне реализации.

 -- Как создается экземпляр класса за кулисами?
 Как мы выяснили, вызов __new__ происходит при вызове __call__ у type, который неявно вызывается при создании объекта.

 Внутри питона (то бишь в исходниках на Cи) выделяется память под новый объект, который мы получаем из функции __new__,
 которую мы переопределяем в нашем классе. После этого, на моменте int res = type->tp_init(obj, args, kwds);
 вызывается функция __init__, которая инициализирует наш объект (устанавливает поля и т.д.)

 И вот этот полученный объект нам и возвращается в переменную t, которую мы объявили в питоне.
 Если из функции __new__ мы вернем объект, не являющийся экземпляром нашего класса, то __init__ вызываться не будет

 При создании экземпляра класса:
 Вызывается Test.__new__. Которая возвращает объект.   # Test - имя класса    Пример -   class Test:
 После этого (если __new__ вернула объект типа Test или его наследника) вызывается Test.__init__, устанавливающий все нужные поля и т.д.

 Когда стоит переопределять __new__, а когда __init__?
 __new__ стоит переопределять, когда при создании экземпляра класса может быть необходима какая-то логика связанная
 с тем, будет ли вообще по итогу создан новый объект, или нет. Например: Если при создании нового объекта нам нужно
 следить за количеством уже созданных экземпляров и т.п.

 __init__ же стоит переопределять тогда, когда при создании объекты мы хотим задать этому объекту какие-то поля,
 вызвать какие-то внешние функции (например напечатать что-то и т.п.), которые не затрагивают информацию о других
 созданных экземплярах класса и т.п. (Практически всегда)

 -- Функции Python — это дескрипторы.  Как передаётся self в методы --
 Объектно-ориентированные функции Python построены на среде, основанной на функциях.
 Используя non-data descriptors(только метод __get__), они легко объединяются.

 Вот как Python волшебным образом передает экземпляры(self) методам:
 то есть ВСЕ ОБЪЕКТЫ ФУНКЦИЙ - ЯВЛЯЮТСЯ ДЕСКРИПТОРАМИ, метод которых __get__ передает экземпляр в качестве первого
 аргумента самой функции при доступе к экземпляру класса!

 Функции являются дескрипторами и используют протокол дескрипторов для привязки экземпляра, к которому вызывается метод,
 к первому аргументу. Вот как « РАБОТАЕТ self ».

 Для поддержки автоматического создания методов функции включают __get__()
 class Function:
    ...

    def __get__(self, obj, objtype=None):
        "Simulate func_descr_get() in Objects/funcobject.c"
        if obj is None:
            return self
        return MethodType(self, obj)


 Книги ООП: Дасти Филлипс, Марк Лутц, Ден Бейдер

 --- Encapsulation (Инкапсуляция) ---

 Инкапсуляция - Механизм и способ организации классов когда мы данные и методы для работы с ними помещаем в одно место
 но кроме того мы предоставляем пользователю публичный АПИ для взаимодействия с нашим обьектом или классом

 Публичный АПИ - некий интерфейс, публичные методы которые помечаем тем что не ставим _, __ перед атрибутами и методами

 Инкапсуляция заключается в сборе в одно место (класс) данных и методов для работы с ними и
 предоставлении пользователю публичного интерфейса(API(Публичный интерфейс))
 public(публичный) = без _ , __
 _ - protected(защищенный) знак того, что этот атрибут не предназначен для прямого использования.
 Работа обьекта не гарантируется, при использовании таких атрибутов
 __ - private(приватный) под капотом преобразуется в object._Class__attribute (только для случаев когда начинается с __)
 Name MangLing (Преобразование в не явное)
 Явное лучше неявного!!!
 Публичный АПИ(интерфейс) - это контракт, все методы будут работать, внутренняя же реализация не гарантируется.
 Совет - делать одно _ для врутренних атрибутов и реализаций, не перебарщивать с __ и сеттерами/геттерами

 В питоне применяется нижнее подчеркивание _ для пометки внутренней реализации,
 то есть атрибутов не относящихся к публичному интерфейсу.
 Одно подчеркивание (protected) - это всего лишь сигнал, интерпретатор относится к таким атрибутам как к обычным.
 Два подчеркивания (private) - включает механизм подмены имени Name Mangling,
 который предназначен не для сокрытия данных.
 Инкапсуляция в питоне не подразумевает сокрытия данных (в некоторых языках это одно и то же)
 - все данные доступны для просмотра и изменения. В Python мы не пробуем отобрать у юзера инструменты, мы предупреждаем.

 Итак, в статических языках ИНКАПСУЛЯЦИЯ реализуется более ЖЕСТКО с помощью модификаторов доступа,
 в то время как в Python она основывается на соглашениях и предоставляет более гибкий подход.

 --- Inheritance (Наследование) ---

 Inheritance - Наследование, это механизм получения доступа к данным и поведению своего предка.
 И расширению (изменению поведения) классов не меняя код
 IS-A является (наследование)
 HAS-A содержит (композиция)
 __ сделано для того чтобы при наследовании не переопределить(изменить) атрибут предка

 Правильно исполненная композиция дадут сто очков вперед наследованию.                  <-----

 -- Композиция vs Наследование   Composition vs Inheritance  --
 **Композиция** и **наследование** — это два основных подхода к организации кода и связыванию объектов
 в объектно-ориентированном программировании (в том числе в Python).

 ### Наследование:
 - **Определение**: Наследование позволяет создать новый класс на основе существующего. Новый класс (подкласс) наследует
  атрибуты и методы родительского класса (суперкласса).
 - **Преимущества**: Позволяет повторно использовать код и расширять функциональность. Обеспечивает иерархическую структуру классов.
 - **Недостатки**: Может приводить к "жесткой" привязке между классами, что делает код менее гибким и трудным для поддержки.

 **Пример наследования**:
 python
 class Animal:
     def speak(self):
         return "Animal sound"

 class Dog(Animal):
     def speak(self):
         return "Bark"


 ### Композиция:
 - **Определение**: Композиция подразумевает создание классов, которые содержат экземпляры других классов как атрибуты.
  Вместо наследования класс использует функциональность других классов.
 - **Преимущества**: Обеспечивает большую гибкость, позволяет изменять поведение на лету, снижает зависимость между классами.
 - **Недостатки**: Может потребовать больше кода для определения взаимодействий между компонентами.

 **Пример композиции**:
 python
 class Engine:
     def start(self):
         return "Engine starts"

 class Car:
     def __init__(self):
         self.engine = Engine()  # композиция

     def start(self):
         return self.engine.start() + " and Car moves"


 ### Основные различия:
 1. **Структура**: Наследование создает иерархические связи, тогда как композиция использует "составляет" отношения.
 2. **Связь классов**: Наследование подразумевает сильную зависимость, а композиция — более слабую.
 3. **Использование**: Наследование подходит, когда есть "является" (is-a) отношения, а композиция — когда есть "имеет"
    (has-a) отношения.

 Таким образом, выбор между наследованием и композицией зависит от требований вашего проекта и архитектуры вашего кода.

  -- Метод __init_subclass__(cls) --
 classmethod object.__init_subclass__(cls) - вызывается всякий раз, когда содержащий класс является подклассом.
 Является заменой использования метакласса в дереве наследования этого класса.
 Применяется исключительно к будущим подклассам класса, определяющего метод.
 __init_subclass__ - это замена метакласса в дереве наследования этого класса

 __init_subclass__ - это просто метод хука. Вы можете использовать его для чего угодно. Это полезно как для регистрации
 подклассов каким-либо образом, так и для установки значений атрибутов по умолчанию для этих подклассов.

 Хуки названы соответствующим образом, поскольку они позволяют «подцепиться» к определенным моментам выполнения программы.

 Hooks(Хуки) — это специальные функции, которые вызываются перед или после определенного события или действия
 В Python, хуки могут быть полезными для многих задач, таких как изменение поведения функций,
 отслеживание состояния программы, или выполнение дополнительных действий при вызове функций.


 В Python нет возможности перегрузить метод класса, как например в Java или С.
 Но есть костыль. Метод может иметь значения параметров по-умолчанию, что совместно с проверкой типа аргумента
 позволит вам сделать то, что вы хотите:
 from types import *

 class Test(object):

     def testrunner(self, i=None):
         if isinstance(i, str):
             print 'c: ', i
         elif isinstance(i, int):
             print 'b: ', i
         else:
             print 'a'

 Создание универсальных методов в классах Python
 Перегрузка методов в классе (по другому - универсальные методы) - это распространенный шаблон программирования
 (известен как множественная диспетчеризация/отправка), который, наверное, зарезервирован только для статически
 типизированных, компилируемых языков.

 Для перегрузки методов требуется, чтобы язык программирования мог различать типы во время компиляции. Интерпретатору
 Python, для этого нужно как-то определять типы аргументов, передаваемых методу во время его вызова, и на их основе
 динамически выбирать, какую из нескольких реализаций конкретного метода использовать/отправить.

 Без множественной диспетчеризации (отправки) очевидный способ сделать это - использовать проверку типов с isinstance().
 Это очень хрупкое решение, которое закрыто для расширения кода, а некоторые программисты называют его "костылем" или анти-паттерном.

 class Test(object):

    def testrunner(self, t=None):
        if isinstance(t, str):
            print('str: ', t)
        elif isinstance(t, int):
            print('int: ', t)
        else:
            print(type(t), t)

 t = Test()
 t.testrunner(10)
 # int:  10
 t.testrunner('A')
 # str:  A
 t.testrunner(10.1)
 # <class 'float'> 10.1

 В примере, на основе типа передаваемого аргумента t принимается решение о его строковом представлении. А что будет с
 кодом метода, если для получения результата определенного типа необходима длинная логика? Придется использовать фабрику,
 но проще и понятней использовать перегрузку метода.

 В Python нет функции или класса, который поддерживает множественную отправку, но доступна одиночная отправка.
 Фактическое различие между множественной и одиночной отправкой - это количество аргументов, которые можно перегрузить.
 Функция (и декоратор), предоставляющая эту возможность - @singledispatch() и @singledispatchmethod и расположена в модуле functools.

 Множественная диспетчеризация/отправка.   --- модуль multipledispatch ---
 Часто одиночной отправки будет недостаточно, и может понадобиться надлежащая функциональность множественной отправки.
 Она доступна в стороннем модуле multipledispatch.

 Модуль multipledispatch и его декоратор @dispatch ведут себя очень похоже на @singledispatchmethod.
 Единственная разница заключается в том что он может принимать в качестве аргументов несколько типов

 from multipledispatch import dispatch

 class Foo():

     @dispatch(list, str)
     def concatenate(a, b):
         a.append(b)
         return a

     @dispatch(str, str)
     def concatenate(a, b):
         return a + b

     @dispatch(str, int)
     def concatenate(a, b):
         return a + str(b)

 f = Foo()
 f.concatenate(["a", "b"], "c")
 # ['a', 'b', 'c']
 f.concatenate("Hello", "World")
 # HelloWorld
 f.concatenate("a", 1)
 f.concatenate("a", 1)
 # a1

 Перегрузка (overload) метода подразумевает наличие двух или более методов в одном классе с одинаковым именем, но разными аргументами.

 Переопределение метода означает наличие двух методов с одинаковыми аргументами, но разными реализациями.
 Один из них будет существовать в родительском классе, а другой — в производном или дочернем классе.

 В чем разница между перегрузкой (Overloading) и переопределением (Overriding) методов?
 При перегрузке вы создаёте внутри одного класса много методов с одинаковым названием, но разными параметрами.
 При переопределении вы берёте один и тот же метод и заставляете его делать разные вещи в зависимости от того, в каком классе его вызвали.


 Перегрузка операторов в Python – это возможность с помощью специальных методов в классах переопределять различные
 операторы языка. Имена таких методов включают двойное подчеркивание спереди и сзади.

 Под операторами в данном контексте понимаются не только знаки +, -, *, /, обеспечивающие операции сложения,
 вычитания и др., но также специфика синтаксиса языка, обеспечивающая операции создания объекта, вызова объекта как
 функции, обращение к элементу объекта по индексу, вывод объекта и другое.
 Несколько примеров операторов перегрузки в Python: __init__(), __str__(), __del__(), __add__(), __setattr__() и другие...
 Примеры операторов перегрузки в Python: Все магические методы(Dunder methods)

 Override - Переопределение означает, что в подклассе создается метод с тем же именем, что и в родительском классе
 Override - Переопределение методов — это возможность создавать методы с тем же именем и параметрами,
 но с разной реализацией в классе-наследнике


 --- ЛЮБОЙ обьект в Python наследуется от object ---                                                   <-----

 -- История Python 2.x: --                                                                             <-----
 В Python 2.x (начиная с версии 2.2) существует ДВА СТИЛЯ классов(СТАРЫЙ и НОВЫЙ) в зависимости от наличия или отсутствия
 object базового класса:

 1) - Классы «КЛАССИЧЕСКОГО» стиля (СТАРЫЙ класс): у них нет object базового класса:
 class ClassicSpam:      # НЕТ object  <-----
    pass
 ClassicSpam.__bases__   # -> ()       <-----

2) - классы «НОВОГО» стиля : они прямо или косвенно (например, наследуются от встроенного типа ) object
 в качестве базового класса:

 class NewSpam(object):     # напрямую наследуемся от object   <-----
     pass
 print(NewSpam.__bases__)   # -> (<class 'object'>,)

 class IntSpam(int):        # косвенно(неявно) наследуемся от object   <-----
     pass

 print(IntSpam.__bases__)                # -> (<class 'int'>,)
 print(IntSpam.__bases__[0].__bases__)   # -> (<class 'object'>,) потому что int наследуется от object  <-----

 При наследование от object Преимущества этого многочисленны, перечислим некоторые из них:

 - Поддержка дескрипторов . В частности, с помощью дескрипторов становятся возможными следующие конструкции:
 1) classmethod: метод, который получает класс в качестве неявного аргумента вместо экземпляра.
 2) staticmethod: метод, который не получает неявный аргумент self в качестве первого аргумента.
 3) свойства с property: Создайте функции для управления получением, установкой и удалением атрибута
 4) __slots__: экономит потребление памяти классом, а также приводит к более быстрому доступу к атрибутам.
   Конечно, это накладывает ограничения .

 - Статический __new__ метод: позволяет настроить способ создания новых экземпляров класса.
 - Порядок разрешения метода (MRO) : в каком порядке будут проверяться базовые классы класса при попытке решить, какой метод вызывать.
 - Связано с MRO, super() вызовы. Функция super() - доступ к унаследованным методам

 Одним из недостатков классов нового стиля является то, что сам класс требует больше памяти.

 -- История Python 3.x: --                                                                          <-----

 В Python 3 все упрощено. Существуют только классы нового стиля (называемые просто классами), поэтому
 единственная разница при добавлении object заключается в том, что вам потребуется ввести еще 8 символов.
 Этот: полностью эквивалентно (кроме названия :-) этому:

 class ClassicSpam:         class NewSpam(object):         class Spam():                            <-----
    pass                         pass                          pass

 У всех есть object в своем __bases__.
 print([object in cls.__bases__ for cls in {Spam, NewSpam, ClassicSpam}])  # -> [True, True, True]

 -- Итак, что нужно делать? --                                                                      <-----
 В Python 3: наследовать от object, если вы пишете код, который пытается быть независимым от Python, то есть он должен
 работать как в Python 2, так и в Python 3. В противном случае не делайте этого, это действительно не имеет значения,
 поскольку Python вставляет его за вас. за кулисами.
------------------------------------------------------------------------------------------------------------------------

 --- object ---

 Примечание object не имеет , __dict__ поэтому вы не можете назначать произвольные атрибуты экземпляру класса object.
 Почему «вы не можете назначить произвольные атрибуты экземпляру класса object»?

 object().__dict__  # -> AttributeError: 'object' object has no attribute '__dict__'. Did you mean: '__dir__'?

 Обратите внимание, что __dict__ атрибутом экземпляров пользовательского класса Python является дескриптор ;
 сам экземпляр не имеет атрибута, его предоставляет класс
 (поэтому type(instance).__dict__['__dict__'].__get__(instance) он возвращается). object.__dict__ может существовать,
 но object.__dict__['__dict__'] не существует.

 object() не поддерживает атрибуты экземпляра, поскольку он является основой для всех пользовательских классов Python,
 которые должны поддерживать отсутствие атрибута __dict__ при определении слотов .

 Атрибуты экземпляров могут быть заданы двумя различными способами: ключами в __dict__ иерархии классов и атрибутами.
 Атрибуты в иерархии классов могут быть дескрипторами , которые затем привязываются к экземпляру. __dict__
 реализован как такой дескриптор, поэтому класс предоставляет его . Так что да,  поскольку класс (или родительский класс)
 имеет __dict__атрибут, который является дескриптором, этот атрибут работает во всех экземплярах. Точно так же, как и методы.

 Обратите внимание, что то же самое относится и к type; он может предоставлять дескрипторы для классов (включая object).
 object.__dict__ на самом деле это не атрибут непосредственно в object, это дескриптор, который type предоставляет;
 object.__dict__действительно type.__dict__['__dict__'].__get__(object). Однако нет object.__dict__['__dict__'].


 -- Дополнительный ответ!
 Для поддержки произвольного назначения атрибутов объекту необходим __dict__: словарь, связанный с объектом,
 в котором могут храниться произвольные атрибуты. Иначе некуда будет помещать новые атрибуты.

 Экземпляр object не содержит a __dict__- если бы это было так, до ужасной проблемы циклической зависимости
 (поскольку dict, как и большинство всего остального, наследуется от object;-), это обременяло бы каждый
 объект в Python dict, что означало бы накладные расходы многих байтов на объект, который в настоящее время не имеет
 или не нуждается в словаре (по сути, все объекты, которые не имеют произвольно назначаемых атрибутов,
 не имеют словаря и не нуждаются в нем) .

 from pympler import asizeof
 asizeof.asizeof({})   # -> 64                                             <----
 asizeof.asizeof(23)   # -> 32                                             <----
 Вы бы не хотели, чтобы каждый int занимал 64 байта вместо 32, верно?-)

 Теперь, когда вы создаете класс (наследующий что-либо), все меняется...:

 class dint(int): pass
 print(asizeof.asizeof(dint(23)))  # -> 112

 теперь __dict__ добавлен (плюс немного больше накладных расходов) - так что dint экземпляр может иметь произвольные атрибуты,
 но за эту гибкость вы платите довольно много места.

 Нельзя использовать НЕ пустые __slots__ c int, bytes tuple и его подклассами - namedtuple
 class fint(int):
    __slots__ = 'foobar',
    def __init__(self, x): self.foobar=x+100
 print(asizeof.asizeof(fint(23)))  # -> TypeError: nonempty __slots__ not supported for subtype of 'int'

 Пример с str:
 class dint(str): pass
 print(asizeof.asizeof(dint('B')))            # -> 184  <-----

 class fint(str):
     __slots__ = 'foobar',
     def __init__(self, x): self.foobar=x+'B'
 print(asizeof.asizeof(fint('A')))            # -> 160  <-----  Лучше чем без __slots__

 Когда класс имеет специальный атрибут __slots__ (последовательность строк), тогда оператор класса (точнее, метакласс
 по умолчанию, type) не снабжает каждый экземпляр этого класса __dict__ (и, следовательно, возможностью иметь
 произвольные атрибуты). , просто конечный, жесткий набор «слотов» (по сути, мест, каждое из которых может содержать
 одну ссылку на некоторый объект) с заданными именами.


 Numpy не имеет __dict__ и поэтому не поддерживает произвольные атрибуты .
 Большинство (возможно, все) классов, определенных в C, не имеют словаря для оптимизации.   <-----
------------------------------------------------------------------------------------------------------------------------

 Наследование представляет собой очень мощный и крутой механизм, помогающий писать код красиво,
 структурировано и без дублирования. Достигается это за счет использования трех методик:
 Переопределение (Overriding), Расширение (Extending), Делегирование (Delegation)
 Переопределение метода («Method overriding») — концепция в ООП,
 позволяющая дочернему классу обеспечивать специфическую (свою собственную) реализацию метода,
 уже реализованного в родительском классе.
 Идея Расширение (Extending) заключается в том, что вы можете добавлять в дочерний класс новые атрибуты и методы,
 имеющие отличающиеся имена от атрибутов и методов родительского класса. В результате такого добавления получим,
 что в дочернем классе будут доступны все методы и атрибуты родителя плюс свои собственные,
 то есть более расширенное поведение, чем у его родителя
 - Делегирование - это способ вызова в дочернем(субклассе) метода родительского (базового) класса.
 Вызывается через использовании функции super()
 Механизм делегирования позволяет «переложить» часть работы на другие объекты.


 --- Mixin (Миксины, Примеси) ---
 Миксины — это особый вид множественного наследования в Python,
 которые используются для предоставления дополнительной функциональности классам.

 Часто миксины используется с другими базовыми классами. Поэтому миксины — это подмножество или особый случай наследования.

 Основная цель миксинов - предоставить какие-то дополнительные методы.

 Mixin - это просто класс, который был разработан для «смешивания», а не для использования отдельно.
 Примесь — это особый, ограниченный случай (множественного) наследования.

 --- Множественное наследование   Multiple inheritance ---
 Python позволяет использовать концепцию множественного наследования. Это значит,
 что ваш класс может наследовать атрибуты и методы сразу от нескольких родительских классов.
 Это позволяет создавать более сложные иерархии классов, объединяя функциональность из разных источников

 Пример:
 class MyBaseClass1:
    pass

 class MyBaseClass2:
     pass

 class MyDerivedClass(MyBaseClass1, MyBaseClass2):
     pass
------------------------------------------------------------------------------------------------------------------------
 # Порядок наследования Классов ИМЕЕТ значение            # Изменили Порядок наследования Классов
 class Parent1:                                           class Parent1:
     def method1(self):                                       def method1(self):
         print("Parent=1 ONE")                                    print("Parent=1 ONE")

 class Parent2:                                           class Parent2:
     def method1(self):                                       def method1(self):
         print("Parent=2 TWO")                                    print("Parent=2 TWO")

     def method2(self):                                       def method2(self):
         print("Parent=2 TWO")                                    print("Parent=2 TWO")

 class MyClass(Parent1, Parent2): # <-----                class MyClass(Parent2, Parent1):  # Изменили Порядок   <-----
     pass                                                     pass

 obj = MyClass()                                          obj = MyClass()
 obj.method1()  # Parent=1 ONE    <-----                  obj.method1()  # Parent=2 TWO     <-----
 obj.method1()  # Parent=1 ONE    <-----                  obj.method1()  # Parent=2 TWO     <-----
 obj.method2()  # Parent=2 TWO    <-----                  obj.method2()  # Parent=2 TWO     <-----

 Книги: Kent Beck (Кент Бек)

 --- MRO (method resolution order) ---
 Аббревиатура MRO – method resolution order (переводится как «порядок разрешения методов»).
 Этот порядок относится не только к поискам методов, но и к прочим атрибутам класса,
 так как методы – это частный случай более общего понятия «атрибут».

 Данная команда возвращает нам список классов ровно в том порядке, в котором Python будет искать методы
 в иерархии класса пока не найдет нужный или не выдаст ошибку. - AttributeError
 Class.mro()   Class.__mro__
 Поиск идёт по алгоритму С3-линеаризации

 -- Алгоритм C3-линеаризации --
 1) Каждый класс должен входить в список ровно 1 раз.

 2) Если какой-то класс D наследуется от нескольких классов, допустим, A, B, C (class D(A, B, C):), в таком же порядке
 они должны появиться в MRO. D -> ... -> A -> ... -> B -> ... -> C -> ... Между ними могут оказаться и другие классы,
 но исходный порядок должен быть соблюден.

 3) Родители данного класса должны появляться по порядку старшинства. Сначала идут непосредственные родители,
 потом дедушки и бабушки, но не наоборот.


 Когда нельзя линеаризовать?
 1) Пример 1:
 class X: ...
 class Y: ...
 class A(X, Y): ...
 class B(Y, X): ...
 class G(A, B): ...
 print(G)

 1) Для A порядок X -> Y, а для B – обратный Y -> X. Класс G обязан удовлетворить обоим порядкам наследования,
 что невозможно, так как они противоречат друг другу. Возникнет ошибка в строке объявления класса G:
 TypeError: Cannot create a consistent method resolution
 order (MRO) for bases X, Y

 2) Пример 2:
 class X: ...
 class Y(X): ...
 class A(X, Y): ...

 2) Здесь класс X наследуется дважды, и куда мы его не поместили в цепочке MRO, он либо нарушит правило старшинства
 (A -> X -> Y -> object), либо порядка наследования (A -> Y -> X -> object).

 Как задать свой порядок MRO?
 Это возможно, используя метаклассы. Для «конфликтного» класса мы определим особый метакласс, который переопределяет
 явно метод mro(), указывая вручную, какой именно должен быть порядок разрешения методов. На первом «неразрешимом»
 примере решение будет такое:

 class X: ...
 class Y: ...
 class A(X, Y): ...
 class B(Y, X): ...
 class MyMRO(type):  # наследование type = это метакласс
     def mro(cls):
         return (cls, A, B, X, Y, object)  # явно задаем порядок!

 class G(A, B, metaclass=MyMRO):
    ...
 print(G)  # G -> A -> B -> X -> Y -> object

 Используется первое обнаруженное вхождение. Такой порядок называется DFLR (Обход вглубину и слева направо).

 -- Diamond problem --
 В Python, наследование ромбовидной формы (или diamond inheritance) возникает, когда класс наследует от двух классов,
 которые, в свою очередь, наследуют от одного общего базового класса. Это может привести к неоднозначности,
 когда необходимо определить, какой метод или атрибут должен быть использован.

 # Пример ромбовидного наследования:
 class A:
     def say_hello(self):
         print("Hello from A")

 class B(A):
     def say_hello(self):
         print("Hello from B")

 class C(A):
     def say_hello(self):
         print("Hello from C")

 class D(B, C):
     pass

 d = D()
 d.say_hello()  # Вывод: Hello from B


 --- Polymorphism (Полиморфизм) ---
 Если не вдаваться в теории, то полиморфизм о котором вам нужно знать и о котором спросят на собеседовании
 - это механизм, позволяющий выполнять один и тот же код по-разному.
 Polymorphism (Полиморфизм) в объектно-ориентированном программировании – это возможность обработки разных типов данных,
 т. е.(то есть) принадлежащих к разным классам, с помощью "одной и той же" функции, или метода.

 Это означает, что одна и та же сущность (операция, функция, метод, объект) может использоваться для разных типов.
 Это делает программирование более интуитивным и простым

 Пример Полиморфизма!!!
 class Dog:
     def speak(self):
         return "Woof!"

 class Cat:
     def speak(self):
         return "Meow!"

 def animal_sound(animal):
     print(animal.speak())

 dog = Dog()
 cat = Cat()

 animal_sound(dog)  # Вывод: Woof!
 animal_sound(cat)  # Вывод: Meow!


 Polymorphism - Полиморфизм (Много форм) -  ЭТО МЕХАНИЗМ, ПОЗВОЛЯЮЩИЙ ВЫПОЛНЯТЬ ОДИН И ТОТ ЖЕ КОД ПО-РАЗНОМУ
 Ducktyping (утиная типизация) - наличие поведения для использования в полиморфизме
 Ducktyping - термин пошел после статьи Алекса Мартелли:
 Если что-то выглядит как утка, плавает как утка и крякает как утка, то, скорее всего, это утка
 Утиная типизация в свою очередь означает механизм, когда для работы во главу угла ставится поведение,
 а не принадлежность к какому-либо классу.

 В ЯП со статической типизацией для полиморфизма важно кто ты (какой тип)
 Для питона важно что ты умеешь (поведение)
 В питоне везде полиморфизм (требуются методы)

 Книги: Лучано Рамальо

 --- Singleton (Одиночка)    АнтиПаттерн ---
 Singleton (Одиночка) (Порождающий Паттерн Проектирования) -
 это шаблон предоставления глобального доступа к состоянию, гарантируется, что объект всегда будет один и тот же.

 Singleton (Одиночка) – ЭТО ПАТТЕРН ПРОЕКТИРОВАНИЯ (Порождающий)
 ЦЕЛЬ КОТОРОГО ОГРАНИЧИТЬ ВОЗМОЖНОСТЬ СОЗДАНИЯ ОБЪЕКТОВ ДАННОГО КЛАССА ОДНИМ ЭКЗЕМПЛЯРОМ.
 Синглтон (Singleton) — это порождающий шаблон проектирования, который обеспечивает,
 что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к нему. Это особенно полезно,
 когда вам нужно точно контролировать доступ к некоторому общему ресурсу, например, базе данных или файлу.

 class instances - экземпляры классов

 В многопоточном приложении будет сложнее потому что нам надо обеспечить чтобы всегда один поток блокировал
 конструктор и создавал обьект, может быть вариант что два потока одновременно создадут обьект

 Модуль в python -это синглтон! Потому нам никуда от них не деться, даже если считать синглтон анти-паттерном

 Singleton Одиночка - это шаблон предоставления глобального доступа к состоянию, обьект всегда один
 Паттерны или шаблоны разработки - это общие способы решения частых задач и проблем
 class Singleton:
    instance = None

    def __new__(cls, *args, **kwargs):
        if cls.instance is None:
            cls.instance = super().__new__(cls)
        return cls.instance


 --- Моносостояние (Аналог Singleton) ---
 Инициализируется словарь при создании класса, а не экземпляра класса. При создании экземпляра всем экземплярам
 присваивается ссылка на один и тот же словарь, с которым и работают в итоге все экземпляры

 Monostate - это шаблон предоставления глобального доступа к состоянию, объекты при этом могут быть разными.
 нужен для одной точки доступа к ресурсам/данным и для того чтобы ресурсоемкие задачи сделать 1 раз
 + плюсы: 1 раз выполняем тяжелые задачи, имеем 1 вход для всей системы
 - минусы: общесистемная глобальная переменная

 class Monostate:
    _shared_state = {}

    def __init__(self):
        self.__dict__ = self._shared_state

 Композиция: объект A управляет временем жизни объекта B
 Агрегация: объект А получает ссылку на объект B


 ---  __slots__  ---

 Создатель Python, Guido van Rossum, утверждает,
 что на самом деле он создал __slots__ для более быстрого доступа к атрибутам.
 __slots__ - уменьшить объем в памяти, которое занимает каждый экземпляр объекта.
 После указания __slots__ добавление новых атрибутов в экземпляр класса, кроме уже указанных, невозможно
 Также при использовании __slots__ пропадает возможность получить словарь self.__dict__ с атрибутами.
 Ограничивает допустимый набор имен атрибутов объекта только перечисленными именами.
 Поскольку атрибуты теперь фиксированы  атрибут __dict__ удаляется
 __slots__ при наследовании:
 Чтобы в дочернем классе не пропадала функциональность __slots__ родительского класса,
 нужно просто прописать свой __slots__
 При наследовании от класса без атрибута __slots__ атрибуты __dict__ и __weakref__ экземпляров всегда будут доступны.
 __slots__ - создан для уменьшения памяти, занимаемой обьектами
 но как побочное свойство - не даст добавить объекту новый атрибут

 TLDR:    слишком длинно, не читал:
 Специальный атрибут __slots__ позволяет вам явно указать, какие атрибуты экземпляра вы ожидаете иметь у
 экземпляров вашего объекта, с ожидаемыми результатами:
 1) более быстрый доступ к атрибутам.
 2) экономия места в памяти.

 Экономия места происходит от:
 1) Хранение ссылок на значения в слотах вместо __dict__.
 2) Запрещение создания __dict__ и __weakref__, если родительские классы запрещают их, а вы объявляете __slots__.

 Пример Работы __slots__ :

 import sys
 from pympler import asizeof

 class NoSlots: pass
 class WithSlots: __slots__ = ('a', 'b', 'c')

 no_slots = NoSlots()
 with_slots = WithSlots()

 print(sys.getsizeof(with_slots))    # -> 56    # sys.getsizeof не учитывается «содержимое объекта», такое как словарь:
 print(sys.getsizeof(no_slots))      # -> 56    # sys.getsizeof не учитывается «содержимое объекта», такое как словарь:
 sys.getsizeof(no_slots.__dict__)    # -> 296   # Разница в потреблении памяти     БЕЗ __slots__
 print(asizeof.asizeof(no_slots))    # -> 352   # Разница в потреблении памяти     БЕЗ __slots__
 print(asizeof.asizeof(with_slots))  # -> 56    # Разница в потреблении памяти     __slots__
 print(no_slots.__dict__)            # -> {}    Есть __dict__    БЕЗ __slots__
 print(with_slots.__dict__) # -> AttributeError: 'WithSlots' object has no attribute '__dict__'. Did you mean: '__dir__'?
 print('__dict__' in dir(no_slots))      # ->  True     # Есть __dict__       БЕЗ __slots__
 print('__weakref__' in dir(no_slots))   # ->  True     # Есть __weakref__    БЕЗ __slots__
 print('__dict__' in dir(with_slots))    # ->  False    # НЕТ __dict__       __slots__
 print('__weakref__' in dir(with_slots)) # ->  False    # НЕТ __weakref__    __slots__
------------------------------------------------------------------------------------------------------------------------
 -- Быстрые предостережения:
 Небольшое предостережение: объявлять определенный слот в дереве наследования следует только один раз.         <-----
 class Base:
     __slots__ = 'foo', 'bar'

 class Right(Base):
     __slots__ = 'baz',

 class Wrong(Base):
     __slots__ = 'foo', 'bar', 'baz'     # redundant foo and bar   Нужно убрать  foo и bar и ошибки не будет    <-----

 from sys import getsizeof

 print(getsizeof(Right()), getsizeof(Wrong()))               # ->   56 72
 print(asizeof.asizeof(Right()), asizeof.asizeof(Wrong()))   # ->   56 72
 w = Wrong()
 w.foo = 'foo'
 Base.foo.__get__(w)  # -> AttributeError: 'Wrong' object has no attribute 'foo'   Ошибка из-за одинаковых атрибутов
------------------------------------------------------------------------------------------------------------------------

 -- Демонстрация __slots__ :                                                                                    <-----
 class Child:                                                class Child:
     __slots__ = ()  # Нельзя создавать атрибуты                 __slots__ = ('name',)  # Можно создать только указанные

 b = Child()                                                 b = Child()
 b.name = 'a'                                                b.name = 'a'
 # AttributeError: 'Child' object has no attribute 'name'    b.name  # -> a
------------------------------------------------------------------------------------------------------------------------

 -- Наследование __slots__ :                                                                                    <-----
 class Base:
     __slots__ = ()

 class Child(Base):
     __slots__ = ('a',)

 # Чтобы разрешить __dict__ создание при создании подклассов объектов с слотами, просто добавьте '__dict__' к __slots__
 # (обратите внимание, что слоты упорядочены, и вам не следует повторять слоты, которые уже есть в родительских классах):

 class SlottedWithDict(Child):
     __slots__ = ('__dict__', 'b')

 swd = SlottedWithDict()
 swd.a = 'a'
 swd.b = 'b'
 swd.c = 'c'

 print(swd.__dict__)                                     # -> {'c': 'c'}
 print([i for i in dir(swd) if not i.startswith('__')])  # -> ['a', 'b', 'c']    Наследуем  __slots__ Родителей  <-----

 # Или вам даже не нужно объявлять __slots__ в своем подклассе, и вы все равно будете использовать слоты от родителей,
 # но не ограничивать создание __dict__:

 class NoSlots(Child): pass
 ns = NoSlots()
 ns.a = 'a'
 ns.b = 'b'

 print(ns.__dict__)                        # -> {'b': 'b'}
 print([i for i in dir(ns) if not i.startswith('__')])  # -> ['a', 'b']    Наследуем  __slots__ Родителей        <-----
------------------------------------------------------------------------------------------------------------------------

 -- Однако __slots__ могут возникнуть проблемы при МНОЖЕСТВЕННОМ наследовании:                               <-----
 class BaseA:
     __slots__ = ('a',)

 class BaseB:
     __slots__ = ('b',)

 class Child(BaseA, BaseB): __slots__ = ()
 # TypeError: multiple bases have instance lay-out conflict


 -- Самое большое предостережение: МНОЖЕСТВЕННОЕ наследование --                                                 <-----
 -- Даже если непустые слоты одинаковы для нескольких родителей, их нельзя использовать вместе:             <-----
 Решение или удалить __slots__ у родителей или оставить им пустые __slots__ = ()                            <-----

 class Foo:                                                                class Foo:
     __slots__ = 'foo', 'bar'                                                  __slots__ = ()
 class Bar:                                                                class Bar:
     __slots__ = 'foo', 'bar'  # будет работать если ()                        __slots__ = ()  # Работает
                                                                           class Baz(Foo, Bar): pass
 class Baz(Foo, Bar): pass                                                 b = Baz()
 # TypeError: multiple bases have instance lay-out conflict    <-----      b.foo, b.bar = 'foo', 'bar'      <-----

 Вам не обязательно иметь слоты — поэтому, если вы добавите их, а потом удалите, это не должно вызвать никаких проблем.
------------------------------------------------------------------------------------------------------------------------

 -- Доказательства использования памяти:    Экономия памяти                                                 <-----
 __slots__ — уменьшить объем памяти, занимаемый каждым экземпляром объекта.

 from pympler import asizeof
 class Foo: pass
 class Bar: __slots__ = ()

 foos = [Foo() for f in range(100000)]
 bars = [Bar() for b in range(100000)]

 print(asizeof.asizeof(foos))   # -> 13600984
 print(asizeof.asizeof(bars))   # -> 4000984
------------------------------------------------------------------------------------------------------------------------

 -- Более быстрый доступ к атрибутам:       Замеры скорости доступа                                          <-----
 __slots__ создан для более быстрого доступа к атрибутам.

 import timeit

 class Foo(object): __slots__ = 'foo',

 class Bar(object): pass

 slotted = Foo()
 not_slotted = Bar()

 def get_set_delete_fn(obj):
     def get_set_delete():
         obj.foo = 'foo'
         obj.foo
         del obj.foo
     return get_set_delete

 print(min(timeit.repeat(get_set_delete_fn(slotted))))        # -> 0.146375099895522
 print(min(timeit.repeat(get_set_delete_fn(not_slotted))))    # -> 0.13652659999206662

 with_slots = min(timeit.repeat(get_set_delete_fn(slotted)))
 no_slots = min(timeit.repeat(get_set_delete_fn(not_slotted)))

 print(with_slots / no_slots)  # -> 1.0658213334420952
 print(f'{with_slots / no_slots:.2%}'.removeprefix('10'))  # -> 6.58%     Для одного атрибута Примерно на 6.58% быстрее
------------------------------------------------------------------------------------------------------------------------
 Для полноты моих заметок обратите внимание, что единовременная стоимость слота в пространстве имен класса составляет:
 64 байта в Python 3, поскольку слоты используют дескрипторы данных, такие как свойства, называемые  "members"

 class Foo(object): __slots__ = 'foo',

 class Bar(object): pass

 print(Foo.foo)        # -> <member 'foo' of 'Foo' objects>
 print(type(Foo.foo))  # -> <class 'member_descriptor'>
 print(sys.getsizeof(Foo.foo))         # -> 64
 print(asizeof.asizeof(Foo.foo))       # -> 64

 # Замеры размера  class Bar:
 print(sys.getsizeof(Bar.__dict__))    # -> 40    #  БЕЗ учёта __dict__
 print(asizeof.asizeof(Bar.__dict__))  # -> 496   #  С учётом  __dict__
------------------------------------------------------------------------------------------------------------------------

 -- Нельзя для int, tuple, bytes создавать НЕ Пустой __slots__ :

 class Child(int):   # tuple, bytes тоже не работают                         class Child(int):
    __slots__ = ('a',)  # НЕ Работает                                            __slots__ = ()  # Работает

 Nonempty __slots__ does not work for classes derived from “variable-length” built-in types such as int, bytes and tuple.
 Непустой __slots__ не работает для классов, производных от встроенных типов «переменной длины», таких как int, bytes и кортеж.

 -- Вы также можете добавить __weakref__ ,  __dict__ явно в __slots__ :

 class My_Slots:
     __slots__ = '__dict__', '__weakref__'

 --- END __slots__ ---


 --- @property ---
 property - это удобный механизм создания геттеров и сеттеров
 У класса (и объекта) есть два основных инструмента взаимодействия — свойства и методы.
 Свойства — это данные, которые лежат внутри объекта.
 Методы — это то, что объект умеет делать или как реагирует на внешние запросы.
 Геттеры и сеттеры являются методами класса, которые используются для получения
 и установки значений атрибутов экземпляра класса, соответственно.

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if not value:
            raise AttributeError('Name cant be empty')
        self._name = value

 Возможность установки/получения атрибутов с логикой
 Зарпетить менять атрибут или добавлять новые атрибуты
 __dict__ - это атрибут обьектов в питоне, который хранит состояние
 __setattr__ вызывается при попытке установить атрибут
 @property - это удобный механизм создания геттеров и сеттеров
 в __init__ нужно вызывать setter
 как можно сделать чтобы нельзя было поменять атрибут?
 можно сделать при помощи @property или переопределение __setattr__ просто прописывает условия

 getter еще называют - аксессор,  setter - мутатор



 --- Абстрактный класс ---

 Зачем нужны АБСТРАКТНЫЕ классы в Python?

 ОНИ ПОЗВОЛЯЮТ ЯВНО УКАЗАТЬ, КАКИЕ МЕТОДЫ ДОЛЖНЫ БЫТЬ РЕАЛИЗОВАНЫ В КЛАССАХ-ПОТОМКАХ.           <-----

 Абстрактный базовый класс является шаблоном для проектирования других классов. Он не может быть использован для
 создания объектов, но определяет общий интерфейс и/или реализацию, которую должны следовать все производные классы.


 Зачем нужен ABC в Python?
 ПОЗВОЛЯЮТ ОПРЕДЕЛИТЬ КЛАСС, УКАЗАВ ПРИ ЭТОМ, КАКИЕ МЕТОДЫ ИЛИ СВОЙСТВА ОБЯЗАТЕЛЬНО ПЕРЕОПРЕДЕЛИТЬ В КЛАССАХ-НАСЛЕДНИКАХ.


 Абстрактный класс - это класс, который не предназначен для создания объектов напрямую.
 Он является классом-шаблоном для других классов и определяет абстрактные методы,
 которые ДОЛЖНЫ БЫТЬ РЕАЛИЗОВАНЫ В ДОЧЕРНИХ КЛАССАХ.
 Абстрактный класс является абстракцией того, что должны делать его наследники,
 но не определяет, как именно это должно быть сделано
 abc (аббревиатура от Abstract Base Classes) from abc import ABC, abstractmethod
 и вешаем декоратор @abstractmethod на pass функции


 from abc import ABC, abstractmethod
 class Shape(ABC):
     @abstractmethod
     def area(self):
         pass

 # Нельзя создать экземпляр класса Shape:
 s = Shape()  # -> TypeError: Can't instantiate abstract class Shape with abstract method area

 # Нужно реализовать метод area
 class MyClass(Shape):
     pass

 c = MyClass()  # -> TypeError: Can't instantiate abstract class MyClass with abstract method area

 # Всё работает
 class MyClass(Shape):
     def area(self):
         return 1000

 c = MyClass()
 print(c.area())  # -> 1000

 Класс, который наследует абстрактный класс, должен реализовать все его абстрактные методы, иначе он не будет создан.

 КОРОЧЕ ГОВОРЯ, абстрактный класс определяет общий интерфейс для набора подклассов. Он предоставляет общие атрибуты и
 методы для всех подклассов, чтобы уменьшить дублирование кода. Он также заставляет подклассы реализовывать абстрактные
 методы, чтобы избежать каких-то несоответствий.

 Абстрактный метод - это метод, который объявлен в абстрактном классе, но не имеет реализации.
 Он служит как бы шаблоном для метода, который должен быть реализован в подклассах.

 NotImplementedError - Исключение, возникающее в случаях, когда наследник класса не переопределил метод, который должен был.

 Enum (Енам) – это абстрактный базовый класс всех ПЕРЕЧИСЛЕНИЙ.
 from enum import Enum

 # синтаксис класса
 class Color(Enum):
     RED = 1
     GREEN = 2
     BLUE = 3


 print(Color.GREEN.value)
 print(Color['RED'].value)
 print(Color(1))

 # функциональный синтаксис
 Color = Enum('Color', ['RED', 'GREEN', 'BLUE'])
 print(Color.GREEN.value)


 # Enum(перечисления) -  это класс, который содержит константы и методы для работы с ними

 # Enum нужен там, где количество значений ограничено, если у вас есть 2+ констант, связанных по смыслу - это возможно
 # хороший вариант для Enum. CREATED-PROCESSED-FINISHED-CANCELED

 # Enum "ограничивает" выбор пользователя, помогает пользователю понять возможные варианты, позволяет легко добавлять или
 # удалять значения
 # Позволяет легко добавлять или удалять значения


 --- Протоколы с версии python 3.8 ---
 Протоколы — это альтернатива абстрактным базовым классам. Они позволяют определить свой набор методов,
 который другие классы должны реализовать, чтобы соответствовать данному протоколу, но без наследования и иерархии.
 Протоколы осуществляют проверку совместимости классов исключительно на основе анализа их атрибутов и методов
 за счет использования структурной подтипизацией (structural subtyping)

 Структурная типизация (structural typing) — это принцип, определяющий совместимость типов, основываясь
 не на иерархии наследования или явной реализации интерфейсов, а на основе структуры этих типов.
 Подобный механизм может рассматриваться как некоторый аналог утиной типизации, но для статических проверок,
 в некотором смысле compile time duck typing.

 --- Дескрипторы ---
 Дескрипторы позволяют объектам настраивать поиск, хранение и удаление атрибутов.
 Определяет поведение при доступе к атрибутам
 Переопределяют поведения атрибутов
 Дескрипторы - это объекты Python, которые определяют, как другие объекты должны вести себя при доступе к атрибуту.
 Дескрипторы могут использоваться для реализации протоколов, таких как протокол доступа к атрибутам, протокол дескрипторов и протокол методов.
 Аналоги  сеттеров/геттеров можем всё вынести в отдельный класс

 Descriptor(Дескриптор) -  Любой объект, определяющий методы __get__(), __set__(), или __delete__().
 Дескрипторы данных(data descriptor) - Если объект определяет __set__() или __delete__()
 Дескрипторы без данных(non-data descriptor) - которые определяют только __get__()
 __set_name__ в классе дескриптора это замена метакласса для класса, который имеет экземпляр дескриптора в качестве атрибута .

 Функции - это Дескрипторы
 Это Python делает чтобы поддерживать динамическое добавление функций в классы.
 Когда __get__ вызывается объект функции (обычно это делается через точечный доступ .к экземпляру класса),
 Python преобразует функцию в метод и неявно передает экземпляр (обычно распознаваемый как self) в качестве первого аргумента.


  -- Хороший пример про ДЕСКРИПТОРЫ --
 # Примеры встроенных объектов дескрипторов: classmethod, staticmethod, property, функции в целом      <-----
 def has_descriptor_attrs(obj):
     return set(['__get__', '__set__', '__delete__']).intersection(dir(obj))

 def is_descriptor(obj):
     '''obj can be instance of descriptor or the descriptor class'''
     return bool(has_descriptor_attrs(obj))

 def has_data_descriptor_attrs(obj):
     return set(['__set__', '__delete__']) & set(dir(obj))

 def is_data_descriptor(obj):
     return bool(has_data_descriptor_attrs(obj))



 # Мы можем видеть, что это classmethod и staticmethod и функции в целом есть Non-Data-Descriptors:
 print(is_descriptor(classmethod), is_data_descriptor(classmethod))    # -> True False
 print(is_descriptor(staticmethod), is_data_descriptor(staticmethod))  # -> True False

 # Обычные функция  Тоже Non-Data-Descriptors
 def foo(): pass
 my_func = lambda: 5

 print(is_descriptor(foo), is_data_descriptor(foo))                    # -> True False
 print(is_descriptor(my_func), is_data_descriptor(my_func))            # -> True False

 # Только метод __get__
 print(has_descriptor_attrs(classmethod))   # -> {'__get__'}
 print(has_descriptor_attrs(staticmethod))  # -> {'__get__'}
 # Обычные функции __get__
 print(has_descriptor_attrs(foo))           # -> {'__get__'}
 print(has_descriptor_attrs(my_func))       # -> {'__get__'}



 # Дескриптор данных, @property    Data-Descriptor
 # @property
 print(is_data_descriptor(property))    # -> True
 print(has_descriptor_attrs(property))  # -> {'__get__', '__delete__', '__set__'}



 --- dataclass Python 3.7   Классы данных ---
 Аннотации типов обязательны. Автоматическое создание методов: __init__ , __repr__, __eq__
 Модуль dataclasses предоставляет декоратор dataclass,
 который позволяет создавать data-классы - подобные позволяют значительно сократить шаблонный код классов
 Dataclass — это функционал, который позволяет легко создавать классы,
 основным предназначением которых является хранение данных. Вот почему их называют КЛАССЫ ДАННЫХ.
 Dataclass предоставляют удобный способ создания классов,
 которые могут быть использованы для хранения и обработки данных.

 Основная идея dataclass заключается в том, что они автоматически генерируют методы для инициализации,
 сравнения и преобразования в строку. Это позволяет значительно упростить код и сделать его более читаемым.

 @dataclasses.dataclass(*, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True,
 kw_only=False, slots=False, weakref_slot=False)

  В Python `dataclasses` — это модуль, который упрощает создание классов, в основном используемых для хранения
 данных. Декоратор `@dataclass` позволяет автоматически генерировать специальные методы
 (такие как `__init__`, `__repr__`, `__eq__` и другие) на основе объявленных полей. Вот краткое описание каждого аргумента:

 1. **init**: Если установлен в `True`, автоматически создается метод `__init__`, который позволяет создавать
  экземпляры класса с заданными полями.

 2. **repr**: Если установлен в `True`, автоматически создается метод `__repr__`, который возвращает строковое
  представление объекта, что особенно полезно для отладки.

 3. **eq**: Если установлен в `True`, автоматически создается метод `__eq__`, который определяет, как сравниваются
  экземпляры класса на равенство.

 4. **order**: Если установлен в `True`, автоматически создаются методы для упорядочивания экземпляров класса
  (`__lt__`, `__le__`, `__gt__`, `__ge__`), позволяя использовать операторы сравнения.

 5. **unsafe_hash**: Если установлен в `True`, создается метод `__hash__`, даже если класс содержит изменяемые поля.
  Это может привести к непредсказуемому поведению, если объект изменяется после добавления в множество или как ключ в словаре.

 6. **frozen**: Если установлен в `True`, класс становится неизменяемым (immutable), что означает, что после его
  создания нельзя изменять его поля.  ЭК НЕ могут изменять поля

 7. **match_args**: Если установлен в `True`, позволяет использовать новую конструкцию `match`
  (введенную в версии Python 3.10) для сопоставления с образцом (pattern matching) с аргументами класса.

 8. **kw_only**: Если установлен в `True`, все поля класса должны быть указаны как именованные аргументы при создании
  экземпляра, что делает вызов конструктора более явным.

 9. **slots**: Если установлен в `True`, используется механизм `__slots__`, который может уменьшить размер экземпляров
  классов и сделать доступ к атрибутам немного быстрее, но не поддерживает динамическое добавление атрибутов.

 10. **weakref_slot**: Этот параметр не является стандартным в Python до версии 3.11. Если он будет добавлен, ожидается,
  что он будет работать с `__slots__`, чтобы поддерживать слабые ссылки на атрибуты. Поможет создать более эффективные
 и оптимизированные классы данных, при этом обеспечивая возможность поддержки слабых ссылок на атрибуты,  что делает
 управление памятью более эффективным.

 Эти аргументы предоставляют множество возможностей для настройки поведения классов, которые создаются с помощью `dataclasses`

 from dataclasses import dataclass
 @dataclass
 class Customer:
     name: str
     balance: int = 4
     items: list[str] = field(default_factory=list)  # <-- и всё это - чтобы по умолчанию был пустой список


 @dataclass сравнение объектов класса (__eq__)
 Если мы хотим сравнить два объекта одного класса на равенство, то @dataclass уже поддерживает встроенное сравнение,
 когда сравниваются все атрибуты объектов.

 c = Customer('a')
 c1 = Customer('b')
 print(c == c1)       # -> False
 print(c.__eq__(c1))  # -> False


 s = Customer('a')
 s1 = Customer('a')
 print(s == s1)       # -> False
 print(s.__eq__(s1))  # -> False


 -- Интересный пример Наследование в Dataclasses  Декорировать нужно все классы при Наследовании --

 # Вот ещё пример логичности и простоты. Датаклассы Base и Child:

 from dataclasses import dataclass

 @dataclass
 class Base:
   a: str

 class Child(Base):
   b: str


 # Внезапно оказывается, что Base ведёт себя как приличный датакласс, а Child — как неприличный:

 print(Base())                     # -> TypeError: Base.__init__() missing 1 required positional argument: 'a'
 print(Base(a='test'))             # -> Base(a='test')
 print(Child(a='test'))            # -> Child(a='test')
 print(Child(a='test', b='test'))  # -> TypeError: Base.__init__() got an unexpected keyword argument 'b'

 # Почему так? Потому что «датаклассовость» не наследуется. Если хочется, чтобы Child тоже был датаклассом,
 # его нужно тоже декорировать.             Так что будьте осторожны при наследовании.                      <-----



 -- Атрибут экземпляра  и   Атрибут класса        dataclass  с аннотацией и БЕЗ --

 from dataclasses import dataclass
 from typing import ClassVar       #  ClassVar - атрибут является атрибутом класса

 # Обьяление С аннотацией типа  БУДЕТ  Атрибут экземпляра
 @dataclass
 class Spam:
     repeat: int       # Атрибут экземпляра

                                                # Объяление БЕЗ аннотации типа  БУДЕТ  Атрибут Класса    ClassVar
 @dataclass                                     @dataclass                           @dataclass
 class Spam:                                    class Spam:                          class Spam:
     repeat: int = 99  # Атрибут экземпляра         repeat = 99  # Атрибут Класса        repeat: ClassVar[int] = 99

 s = Spam()                                     s = Spam()
 s1 = Spam()                                    s1 = Spam()

 # Значение изменяется для всех ЭК              # Значение НЕ изменяется для всех ЭК
 Spam.repeat = 10                               Spam.repeat = 10
 print(s.repeat)   # -> 99                      print(s.repeat)    # -> 10
 print(s1.repeat)  # -> 99                      print(s1.repeat)   # -> 10



 --- @classmethod    @staticmethod ---
 1) LEGB - правило продолжает действовать для простых имен переменных и их поиска
 2) для self атрибутов поиск идет сначала в объекте, потом в классе, затем у предков OCP(object-class-parent).
 То если через селф можно достучаться как к обычным методам/атрибутам, так и к классовым, статичным
 3) если через self пытаться поменять неизменяемый атрибут (строка) класса, то будет создана локальная копия,
 ее не увидят другие объекты класса
 4) если менять через self изменямый атрибут класса (список), то он изменится для всех объектов класса
 5) cls - это ссылка на класс (не объект!), питон передает его под капотом. cls = Class
 6) @classmethod используется для работы с атрибутами класса и с другими методами класса.
 Часто используется для конструирования готовых объектов
 7) @staticmethod не получает ссылок под капотом, это просто функция связанная контекстом с классом.
 Используется редко и часто завуалированно
 8) если есть метод где self, cls передаются но нигде не используются это @staticmethod


  --- Встроенные функции vs Магические методы ---

 1. Оптимизация: Встроенные функции в Python часто оптимизированы для производительности.
 2. Накладные расходы: Вызов метода требует дополнительных накладных расходов на доступ к атрибуту объекта,
    что может замедлить выполнение.

 На практике, разница во времени может зависеть от конкретной версии Python и системы, на которой вы выполняете код,
 но в общем случае встроенные функции будут более быстрыми и предпочтительными.

 Для встроенных объектов в CPython встроенные функции (например, len(), str()) работают напрямую с объектами и НЕ
 вызывают соответствующие магические методы. Это позволяет избежать накладных расходов, связанных с вызовом методов,
 что делает их более быстрыми.


 # Сравнение built-in function vs dunder method
 from timeit import timeit

 #  str() vs __str__()
 print(timeit('str(100)'))                                # -> 0.10770369996316731
 print(timeit('100 .__str__()'))                          # -> 0.15946240001358092

 #  iter() vs __iter__()
 print(timeit('iter([100, 1000])', number=1000000))       # -> 0.11073940002825111
 print(timeit('[100, 1000].__iter__()', number=1000000))  # -> 0.1557056000456214

 Для встроенных объектов интерпретатор CPython вообще НЕ вызывает никаких методов: длина просто читается из поля
 C-структуры.  Эффективно работает для встроенных типов как str, list, memoryview и т.п.     <-----  Важно!!!

 # Например функция len()
 # Сравнение tuple, set, dict, list
 #  len() vs __len__()    len()  Намного быстрее работает                                    <-----  Важно!!!

 # РАБОТАЕТ В 2 РАЗА БЫСТРЕЕ  для []
 print(f"{timeit('len([100, 1000])', number=1000000):.6f}")        # -> 0.072438
 print(f"{timeit('[100, 1000].__len__()', number=1000000):.6f}")   # -> 0.145085

 # tuple  ()
 print(f"{timeit('len((100, 1000))', number=1000000):.6f}")        # -> 0.036578
 print(f"{timeit('(100, 1000).__len__()', number=1000000):.6f}")   # -> 0.103023

 # set
 print(f"{timeit('len({100, 1000})', number=1000000):.6f}")        # -> 0.127049
 print(f"{timeit('{100, 1000}.__len__()', number=1000000):.6f}")   # -> 0.183266

 # dict
 print(f"{timeit('len({100: 1000})', number=1000000):.6f}")        # -> 0.117994
 print(f"{timeit('{100: 1000}.__len__()', number=1000000):.6f}")   # -> 0.171075

 # Расширенный пример

 # Измеряем время для встроенной функции str()
 builtin_time = timeit('str(100)', number=1000000)  # Выполняем 1,000,000 раз
 print(f'Встроенная функция str(): {builtin_time:.6f} секунд')  # -> Встроенная функция str(): 0.107998 секунд

 # Измеряем время для дандер-метода
 dunder_time = timeit('100 .__str__()', number=1000000)  # Выполняем 1,000,000 раз
 print(f'Метод __str__(): {dunder_time:.6f} секунд')            # -> Метод __str__():          0.161750 секунд


 --- Dunder methods (Double Underscores) Магические методы ---

 Магические методы - dunder методы, методы которые начинаются и заканчиваются __
 для самописных классов нужно переопеделить магические методы для нужного поведения и действий

 Метод __new__ вызывается при создании нового экземпляра класса. Он отвечает за выделение памяти под новый объект
  и возвращает этот объект. __new__ является статическим методом и должен возвращать экземпляр класса.
 __init__ отвечает за инициализацию экземпляров класса после их создания.
 __init__ используется для инициализации атрибутов объекта при его создании
 __init__ по умолчанию не ждет аргументов
 __new__() для его создания, а __init__() для его настройки


 Создание атрибутов экземпляра вне метода __init__ может привести к созданию ненужных атрибутов и увеличению
 потребления памяти, особенно если они не используются.
 Для экономим памяти избегайте создания атрибутов ЭКЗЕМПЛЯРА ВНЕ метода __init__           <-----  Важно!!!

 Добавление атрибута экземпляра после возврата из __init__ заставляет Python создать хэш-таблицу для хранения __dict__
 только для ОДНОГО этого экземпляра это оптимизация сокращает потребление памяти на 10% - 20%.    PEP 412

 В Python, если атрибут экземпляра добавляется после вызова __init__, интерпретатор может оптимизировать использование
 памяти, создавая хэш-таблицу (__dict__) только для этого экземпляра. Это может сократить потребление памяти на 10% - 20%,
 особенно если экземпляр имеет немного атрибутов.

 What the f*ck Python!   # Проект  СПОРНЫЙ МОМЕНТ ПРОВЕРЯЙ САМ!!!                          <-----  Важно!!!
 Небольшой совет, если вы хотите уменьшить объем памяти, занимаемый вашей программой: не удаляйте атрибуты экземпляра
 и обязательно инициализируйте все атрибуты в вашем __init__!

 __repr__ - для програмистов, возвращает строку, по которой видно (и можно воссоздать) состояние обьекта  !r
 __str__ - для людей, возвращает строку    !s
 если не реализован репр и стр, то будет возвращать адрес в памяти (который в Python являет-ся адресом объекта в оперативной памяти).
 __eq__ по умолчанию сравнивает адрес в памяти, в реализации лучше сразу проверить тип
 если определяете метод __eq__ то теряется возможность нахождение hash()
 если методы сравнения не реализованы то падает ошибка
 contains для реализации проверки IN
 bool для самодельных обьектов всегда вернет True, для изменения поведения нужно написать __bool__
 len вернет ошибку если не переопределить метод __len__
 чтобы обьект стал вызываемым (callable) нужно реализовать __call__, иначе ошибка
 __iter__ возвращает обьект итератор, тот кто реализует итер = Итерабл
 __iter__ = должен вернуть обьект который умеет делать __next__
 __next__ должен вернуть следующий обьект из контейнера, кто его реализует = Итератор, for работает до StorIteration
 Итератор = обьект в нём есть данные и он может по вызову обьекта __next__ данные выдавать
 __getitem__ нужен для функционала [] (аналог списка и словаря)
 __setitem__ для присвоения через [], если не реализовать = ошибка
 если в обьекте не реализован __iter__ то для цикла фор будет использован __getitem__ там ожидается падение IndexError

 repr() и !r  -> одно и тоже

 def __repr__(self):
     return f'Car({repr(self.color)}, {repr(self.mileage)})'
     return f'Car({self.color!r}, {self.mileage!r})'

 В настоящее время поддерживаются три флага преобразования:
 '!s' - вызывает str() по значению
 '!r' - вызывает repr()
 '!a' - вызывает ascii()

 В Python 2 вместо метода __str__ следует использовать метод __unicode__.

 -- reprlib --                                                                              <-----
 reprlib в Python используется для создания сокращенных представлений объектов, которые могут быть слишком большими
 для стандартного repr()

 import reprlib

 large_list = list(range(1000))

 print(reprlib.repr(large_list))  # -> [0, 1, 2, 3, 4, 5, ...]
 print(repr(large_list))          # -> Будет ОГРОМНЫЙ ВЫВОД!!!

 # По умолчанию 30 символов лимит
 large_str = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'

 print(reprlib.repr(large_str))  # -> 'aaaaaaaaaaaa...aaaaaaaaaaaaa'
 print(repr(large_str))          # -> 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'

 # ИЗМЕНЯЕМ ЛИМИТЫ
 # Создаем объект Repr    Там ЕЩЕ МНОГО АТРИБУТОВ
 r = reprlib.Repr()
 r.maxlist = 10    # Максимум элементов в списке
 r.maxdict = 5     # Максимум элементов в словаре
 r.maxstring = 10  # Максимум элементов в строке

 # Вывод после ИЗМЕНЕНИЯ  ЛИМИТОВ
 print(r.repr(large_list))       # -> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ...]
 print(r.repr(large_str))        # -> 'aa...aaa'


 -- Таблица Магических методов --

 Базовая пользовательская настройка классов Python:
 __new__()             создает новый экземпляр класса,
 __init__()            конструктор класса,
 __del__()             финализатор класса,   вызывается, когда экземпляр класса будет уничтожен.
 __repr__()            официальное строковое представление объекта,   вызывается встроенной функцией repr()
 __str__()             печатаемое строковое представление объекта, вызывается встроенными функциями str(), format(), print()
 __bytes__()           байтовое представление объекта, вызывается встроенной функцией bytes()
 __format__()          форматированное представление объекта, вызывается встроенной функцией format()
 __hash__()            хеш объекта,  вызывается встроенной функцией hash()
 __bool__()            для проверки истинности, вызывается встроенной функцией bool()

 Методы расширенного сравнения:
 __lt__(self, other)   <          x < y:  вызывает x.__lt__(y)
 __le__(self, other)   <=         x <= y: вызывает x.__le__(y)
 __eq__(self, other)   ==         x == y  вызывает x.__eq__(y)
 __ne__(self, other)   !=         x != y  вызывает x.__ne__(y)
 __gt__(self, other)   >          x > y   вызывает x.__gt__(y)
 __ge__(self, other)   >=         x >= y  вызывает x.__ge__(y)

 Настройка доступа к атрибутам класса Python:
 __getattr__()         вызывается при обращении, к несуществующему атрибуту,
 __getattribute__()    вызывается всегда, при обращении к любому атрибуту,
 __setattr__()         вызывается при попытке присвоения значения любому атрибуту,
 __delattr__()         вызывается при попытке удаления любого атрибута,
 __dir__()	           Возвращает список атрибутов и методов объекта.   вызывается функцией dir().

 Интерпретатор Python вызывает специальный метод __getattr__ только если обычный поиск атрибута завершился НЕУДАЧНО.
 (т.е. именованный атрибут не удатся найти ни в экземпляре, ни в классе, ни в его суперклассах)                   <-----

 Управление атрибутами через дескрипторы:
 __get__(self, instance, type=None)	 Доступ к атрибуту в дескрипторе
 __set__(self, instance, value)	     Установка значения атрибута в дескрипторе
 __delete__(self, instance)	         Удаление атрибута в дескрипторе
 __set_name__(self, owner, name)     Связывание дескриптора с именем переменной класса.

 Специальный атрибут __slots__ класса Python:
 __slots__ - предотвращает автоматическое создание __dict__ и __weakref__  ограничивает атрибуты только прописанными

 Специальный метод __init_subclass__ класса Python:
 __init_subclass__(cls) - вызов когда содержащий класс является подклассом.Замена метакласса в дереве наследования этого класса.

 Настройка проверок экземпляра и подкласса:
 __instancecheck__()  - Проверяет, является ли объект экземпляром определенного класса  isinstance()
 __subclasscheck__()  - Проверяет, является ли класс подклассом определенного класса    issubclass()

 Эмуляция универсальных "generic" типов:
 __class_getitem__(cls, key) - цель упростить применение подсказок типов(Type hints)   например, List[int]

 Создание вызываемых объектов:
 __call__()         Вызывается, когда экземпляр используем в качестве функции. ()

 Эмуляция контейнерных типов в классах Python:
 __len__()                  вызывается функцией len(),
 __length_hint__()          вызывается operator.length_hint(),
 __getitem__()              вызывается для возврата значения self[key],
 __setitem__()              вызывается для установки значения self[key],
 __delitem__()              вызывается для удаления self[key],
 __missing__() self[key]    вызывается dict.__getitem__() для реализации self[key] для подклассов dict, когда ключ отсутствует в словаре.
 __iter__()                 вызывается при итерации,
 __reversed__()             вызывается функцией reversed(),
 __contains__()             вызывается оператором in,

 Побитовые операторы:
 __and__(self, other)                 &     Двоичное И
 __or__(self, other)                  |     Двоичное ИЛИ
 __xor__(self, other)                 ^     Двоичное ИСКЛЮЧАЮЩЕЕ ИЛИ
 __lshift__(self, other)              <<    Двоичный сдвиг влево
 __rshift__(self, other)              >>    Двоичный сдвиг вправо
 __invert__(self)                     ~     Двоичное НЕ  Побитовая инверсия - (перевести) в противоположное состояние

 Арифметические операторы:
 __add__(self, other)                 +
 __sub__(self, other)                 -
 __mul__(self, other)                 *
 __matmul__(self, other)              @     используется для умножения матриц в NumPy
 __truediv__(self, other)             /
 __floordiv__(self, other)            //    Целочисленное деление 9 // 2 -> 4 ,  -11 // 10 -> -2 ,  -9 // 2 -> -5
 __mod__(self, other)                 %     Остаток от деления 31 % 10 -> 1 , -31 % 10 -> 9 , -20 % 2 -> 0 , -9 % 2 -> 1
 __divmod__(self, other)              (a // b, a % b)     встроенной функции divmod()
 __pow__(self, other[, modulo])       **                                                Возведение в степень    <----

 Отражённые арифметические операторы    обратный порядок действий:
 __radd__(self, other)              +
 __rsub__(self, other)              -
 __rmul__(self, other)              *
 __rmatmul__(self, other)           @
 __rtruediv__(self, other)          /
 __rfloordiv__(self, other)         //
 __rmod__(self, other)              %
 __rdivmod__(self, other)           (a // b, a % b)
 __rpow__(self, other[, modulo])    **                                                  Возведение в степень    <----
 __rlshift__(self, other)           <<
 __rrshift__(self, other)           >>
 __rand__(self, other)              &
 __rxor__(self, other)              ^
 __ror__(self, other)               |

 Расширенных арифметических присваиваний:
 __iadd__(self, other)              +=
 __isub__(self, other)              -=
 __imul__(self, other)              *=
 __imatmul__(self, other)           @=
 __itruediv__(self, other)          /=
 __ifloordiv__(self, other)         //=
 __imod__(self, other)              %=
 __ipow__(self, other[, modulo])    **=
 __ilshift__(self, other)           <<=
 __irshift__(self, other)           >>=
 __iand__(self, other)              &=
 __ixor__(self, other)              ^=
 __ior__(self, other)               |=


 Реализации унарных арифметических операций:
 __neg__(self)         -            Определяет поведение для отрицания(-some_object)
 __pos__(self)         +            Определяет поведение для унарного плюса (+some_object)
 __abs__(self)         abs()        Определяет поведение для встроенной функции abs()
 __invert__(self)      ~            Двоичное НЕ  Побитовая инверсия - (перевести) в противоположное состояние

 Реализации встроенных функций:
 __complex__(self)            вызывается встроенной функцией  complex()
 __int__(self)                вызывается встроенной функцией  int()
 __float__(self)              вызывается встроенной функцией  float()

 __index__(self)              Преобразование типа к int, когда объект используется в срезах  или  bin()  hex()  oct()

 __round__(self[, ndigits])   вызывается встроенной функцией round() - округление    round(2.5) -> 2 , round(2.51) -> 3
 __trunc__(self)              вызывается функцией math   trunc()  - отбрасывание дробной части    math.trunc(2.567)-> 2
 __floor__(self)              вызывается функцией math   floor()  - округление в меньшую сторону  math.floor(2.567)-> 2
 __ceil__(self)               вызывается функцией math   ceil()   - округление в большую сторону  math.ceil(2.567) -> 3

 Python 3.0+, round() используется БАНКОВСКОЕ ОКРУГЛЕНИЕ , при котором дроби 0,5 округляются до ближайшего четного числа:
 import numpy  # numpy does the same  # numpy делает то же самое  # БАНКОВСКОЕ ОКРУГЛЕНИЕ - до ближайшего четного числа:
 numpy.round(0.5) # -> 0.0    round(0.5) # -> 0
 numpy.round(1.5) # -> 2.0    round(1.5) # -> 2
 numpy.round(2.5) # -> 2.0    round(2.5) # -> 2

 Настройка позиционных аргументов при сопоставлении с образцом класса  Добавлено в версии 3.10:
 __match_args__  - определить конкретную позицию для атрибутов в шаблонах, установив специальный атрибут __match_args__
 в классах.  Для работы с match/case.

 Эмуляция типов буферов:
 __buffer__()             Вызывается, когда буфер запрашивается у себя
 __release_buffer__()     Вызывается, когда буфер больше не нужен.

 Создание итераторов:
 __iter__()	      Вызывается для инициализации итератора. Он должен возвращать объект-итератор.
 __next__()	      Вызывается для перебора итератора. Он должен вернуть следующее значение в потоке данных.

 Асинхронные итераторы  Asynchronous Iterators:
 __aiter__        должен возвращать асинхронный итерируемый объект   асинхронный __iter__()
 __anext__        Должен возвращать ожидаемое значение               похож на __next__()

 Контекстный менеджер Context Manager :
 __enter__()      with obj (вход в контекстный менеджер)
 __exit__()       with obj (выход из контекстного менеджера)

 Асинхронные менеджеры контекста  Asynchronous Context Managers:
 __aenter__()     Вход в асинхронный контекстный менеджер       async with obj
 __aexit__()      Выход из асинхронного контекстного менеджера  async with obj

 Корутины(асинхронные функции) Coroutines:
 __await__()      Реализация асинхронных объектов


 -----  S.O.L.I.D принципы ООП  объектно-ориентированном программировании -----

 1) ПРИНЦИП ЕДИНСТВЕННОЙ ОТВЕТСТВЕННОСТИ (Single Responsibility Principle)
 Требует того, чтобы один класс выполнял только одну работу.
 Таким образом, если у класса есть более одной работы, он становится зависимым.
 Изменение поведения одной работы класса приводит к изменению в другой
 «У класса должна быть лишь одна причина для изменения»


 2) ПРИНЦИП ОТКРЫТОСТИ/ЗАКРЫТОСТИ (Open-Closed Principle)
 Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не модификации.
 Программные сущности (классы, модули, функции) должны быть открыты для расширения, но закрыты для изменений.


 3) ПРИНЦИП ПОДСТАНОВКИ ЛИСКОВ (Liskov Substitution Principle)
 Главная идея, стоящая за Liskov Substitution Principle в том, что для любого класса клиент
 должен иметь возможность использовать любой подкласс базового класса, не замечая разницы между ними,
 и следовательно, без каких-либо изменений поведения программы при выполнении. Это означает,
 что клиент полностью изолирован и не подозревает об изменениях в иерархии классов

 Проще говоря, это значит, что подкласс, дочерний класс должны соответствовать их родительскому классу или супер классу.

 «Объекты в программе должны быть заменяемы экземплярами их подтипов без ущерба корректности работы программы»


 4) ПРИНЦИП РАЗДЕЛЕНИЯ ИНТЕРФЕЙСОВ (Interface Segregation Principle)
 Создавайте тонкие интерфейсы, которые ориентированы на клиента. Клиенты не должны зависеть от интерфейсов,
 которые они не используют. Этот принцип устраняет недостатки реализации больших интерфейсов.

 Принцип разделения интерфейсов гласит, что «Ни один клиент не должен зависеть от методов, которые он не использует».

 Принцип разделения интерфейсов предполагает создание небольших интерфейсов, известных как «ролевые интерфейсы»,
 вместо большого интерфейса, состоящего из нескольких методов. Разделяя методы по ролям на более мелкие интерфейсы
 клиенты будут зависеть только от методов, которые имеют к ним отношение.


 5) ПРИНЦИП ИНВЕРСИИ ЗАВИСИМОСТЕЙ (Dependency Inversion Principle)
 Зависимость должна быть от абстракций, а не от конкретики. Модули верхних уровней не должны зависеть
 от модулей нижних уровней. Классы и верхних, и нижних уровней должны зависеть от одних и тех же абстракций.
 Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

 Принцип инверсии зависимостей гласит:
 Модуль высокого уровня не должен зависеть от модулей низкого уровня. И то, и другое должно зависеть от абстракций.
 Абстракции не должны зависеть от деталей реализации. Детали реализации должны зависеть от абстракций.

 Если ваш код уже реализует принципы 2) открытости/закрытости и 3) подстановки Лисков,
 он уже будет неявно согласован с принципом инверсии зависимостей


  ----- ИТОГ S.O.L.I.D -----
 1) ПРИНЦИП ЕДИНСТВЕННОЙ ОТВЕТСТВЕННОСТИ (Single Responsibility Principle):
 1) У класса должна быть всего одна причина для изменения.
 1) Один класс выполнял только одну работу.


 2) ПРИНЦИП ОТКРЫТОСТИ/ЗАКРЫТОСТИ (Open-Closed Principle):
 2) Программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменений.


 3) ПРИНЦИП ПОДСТАНОВКИ БАРБАРЫ ЛИСКОВ (Liskov Substitution Principle):
 3) подклассы не должны противоречить надклассам
 3) функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

 3) Объекты в программе должны быть заменяемы экземплярами их подтипов без ущерба корректности работы программы.
 3) Проще говоря, это значит, что подкласс, дочерний класс должны соответствовать их родительскому классу или супер классу
 3) использовать любой подкласс базового класса, не замечая разницы между ними


 4) ПРИНЦИП РАЗДЕЛЕНИЯ ИНТЕРФЕЙСОВ (Interface Segregation Principle):
 4) Ни один клиент не должен зависеть от методов, которые он не использует.
 4) слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические
 4) «Программные сущности не должны зависеть от методов, которые они не используют»

 4) «Много интерфейсов, специально предназначенных для клиентов, лучше чем один интерфейс общего назначения»


 5) ПРИНЦИП ИНВЕРСИИ ЗАВИСИМОСТЕЙ (Dependency Inversion Principle):
 5) Модуль высокого уровня не должен зависеть от модулей низкого уровня. И то, и другое должно зависеть от абстракций.
 5) Абстракции не должны зависеть от деталей реализации. Детали реализации должны зависеть от абстракций.

 5) «Зависимость на Абстракциях. Нет зависимостри на что-то конкретное»


 Абстракция — основной способ борьбы со сложностью в программировании. Она позволяет уйти от деталей реализации
 и сосредоточиться на главном. Хороший пример абстракции — функция сортировки списка.
 Не важно, как она устроена, важно, что она делает то, что нам нужно.

 Абстракция гласит что мы должны выделять важные характеристики объекта.



 Авторы книг: Марк Лутц, Дасти Филлипс, Дэвид Бизли, Кент Бек, Лучано Рамальо, Мартин Фаулер, Ден Бейдер, Фаулер Мэттью,
 Фило Владстон Феррейра, (Миша Горелик, Йен Освальд)
 END --- OOP ---

 Можно почитать:  Эндрю Таненбаум


 Domain-Driven Design (предметно-ориентированное проектирование)
 Есть такой подход – DDD (Domain Driven Design), который как раз и предлагает способ построение больших систем
 на основе супер-простых элементарных компонент.
 DDD – это микросервисная архитектура на базе сущностей предметной области.
 Вся суть DDD — использовать единый язык и работать с экспертами в доменной области, чтобы максимально точно отразить бизнес-цели.
 DDD про разделение на предметные области. Смысл в логическом разделении данных
 Концепция DDD - создавалась в первую очередь для упрощения микросервисной архитектуры

 Инстанцирование — создание экземпляра класса
 В Python инстанцирование фактически и является вызовом некоторой функции, которая возвращает новый экземпляр класса.

 Унифицировать - приведение к единообразию, к единому виду

 --- Метаклассы metaclass ---
 Если коротко, то метаклассы - это классы, которые конструируют другие классы
 Основная цель метаклассов — автоматически изменять класс в момент создания.
 Метаклассы — это продвинутый инструмент Python, который позволяет управлять поведением классов
 Итак, метакласс это просто штука, создающая объекты-классы.
 Если хотите, можно называть его «фабрикой классов»

 type это встроенный метакласс, который использует Питон, но вы, конечно, можете создать свой.

 Объявляются они через атрибут класса __metaclass__ - в Python 2.x
 В Python 3 изменился способ указания метакласса , __metaclass__ который больше не проверяется.
 class Table(object, metaclass=MetaTable): # -> способ указания метакласса     metaclass=

 Метаклассы - это классы, которые определяют поведение других классов. Они используются для изменения способа,
  которым Python создает и обрабатывает классы

 Зачем вообще использовать метаклассы?
 Основное применение метаклассов это создание API. Типичный пример — Django ORM.   <----

 Django использует метаклассы для создания моделей базы данных

 По умолчанию классы создаются с использованием класса type(). Тело класса выполняется в новом пространстве имен,
 а имя класса локально привязано к результату выполнения type(name, bases, namespace).

 Процесс создания класса можно настроить, передав ключевой аргумент metaclass в строке определения класса или наследовав
 от существующего класса, который включал такой аргумент. В следующем примере MyClass и MySubclass являются экземплярами Meta:

 class Meta(type):
    pass

 class MyClass(metaclass=Meta):
     pass

 class MySubclass(MyClass):
     pass


 Пример Создание своего Метакласса!

 # Таким образом, вы создали метакласс `MyMeta`, который добавляет атрибут `custom_attribute` в класс `MyClass`.

 class MyMeta(type):
     def __new__(cls, name, bases, attrs):
         # Модификация атрибутов класса
         attrs['custom_attribute'] = 'This is a custom attribute'
         attrs['hehe'] = '123'
         return super().__new__(cls, name, bases, attrs)

 class MyClass(metaclass=MyMeta):
     pass

 instance = MyClass()
 print(instance.custom_attribute)  # Вывод: This is a custom attribute
 print(instance.hehe)              # Вывод: 123
 print(instance.__dict__)          # Вывод: {}
 print(MyClass.hehe)               # Вывод: 123
 print(MyClass.custom_attribute)   # Вывод: This is a custom attribute

 # Важно Интересный пример!!!
 print(type(MyClass))              # -> <class '__main__.MyMeta'>
 print(type(instance))             # -> <class '__main__.MyClass'>


 - Как создать класс без слова class?
 Kласс можно создать без использования ключевого слова class, используя типы type :

 MyClass = type('MyClass', (), {'x': 42, 'foo': lambda self: self.x})

 # Тоже самое что и выше но с ключевым словом class!
 class MyClass:
    x = 42
    def foo(self):
        return self.x


 # ТОЖЕ САМОЕ НО УКАЗЫВАЕМ  НАСЛЕДОВАНИЕ
 MyClass = type('MyClass', (MySuperClass, MyMixin), {'x': 42, 'foo': lambda self: self.x})

 # Тоже самое что и выше но с ключевым словом class!
 class MyClass(MySuperClass, MyMixin):
     x = 42

     def foo(self):
         return self.x

 # type - это тип всех типов, для которых не указан явно иной метакласс
 print(type(type))    # -> <class 'type'>
 print(type(object))  # -> <class 'type'>
 print(type(list))    # -> <class 'type'>
 print(type(set))     # -> <class 'type'>
 print(type(dict))    # -> <class 'type'>
 print(type(bool))    # -> <class 'type'>
 print(type(int))     # -> <class 'type'>
 print(type(str))     # -> <class 'type'>
 print(type(collections.deque))     # -> <class 'type'>

 class Bar(object): pass

 b = Bar()
 print(type(Bar))     # -> <class 'type'>
 print(type(b))       # -> <class '__main__.Bar'>


 НЕЛЬЗЯ изменять сам type, вы НЕ можете добавлять атрибуты напрямую к встроенному типу type   <-----
 type является частью внутреннего устройства Python и НЕ предназначен для изменения.
 Безопасно изменять только свои собственные метаклассы, созданные на основе type.


 super(self, self) - не является опечаткой

 В конечном итоге, super(self, self) корректен, но его использование не является стандартной практикой.
 Рекомендуется использовать либо super(), либо super(Child, self) для большей ясности кода.


 Когда выполняется определение класса, происходят следующие шаги:
 - разрешаются записи MRO;
 - определяется соответствующий метакласс;
 - подготавливается пространство имен класса;
 - выполняется тело класса;
 - создается объект класса.

 Разрешение записей MRO:
 __mro_entries__(self, bases)
 Если база, которая появляется в определении класса, не является экземпляром type, то по ней ищется метод __mro_entries__.
 Если он найден, то он вызывается с исходным базовым кортежем. Этот метод должен возвращать кортеж классов, который
 будет использоваться вместо этой базы. Кортеж может быть пустым, в этом случае исходная база игнорируется.

 Определение соответствующего метакласса:
 Соответствующий метакласс для определения класса определяется следующим образом:
 - если не указаны ни базы, ни явный метакласс (как аргумент), то используется type();
 - если указан явный метакласс и он не является экземпляром type(), то он используется непосредственно как метакласс;
 - если экземпляр type() задан как явный метакласс или определены базы, то используется наиболее производный метакласс.

 Наиболее производный метакласс выбирается из явно указанного метакласса (если есть) и метаклассов (то есть type(cls))
 всех указанных базовых классов. Самый производный метакласс - это тот, который является подтипом всех этих
 метаклассов-кандидатов. Если ни один из метаклассов-кандидатов не соответствует этому критерию, определение класса
 завершится ошибкой TypeError.

 Подготовка пространства имен классов:  --  __prepare__  --

 После того, как соответствующий метакласс идентифицирован, подготавливается пространство имен класса. Если у метакласса
 есть атрибут __prepare__, то он именуется как namespace=metaclass.__prepare__(name, base, ** kwds), где дополнительные
 ключевые аргументы, если таковые имеются, берутся из определения класса. Метод __prepare__ должен быть реализован как
 метод класса classmethod(). Пространство имен, возвращаемое __prepare__, передается в __new__, но когда создается
 последний объект класса, пространство имен копируется в новый словарь dict.

 Если метакласс не имеет атрибута __prepare__, то тогда пространство имен класса инициализируется как
 пустое упорядоченное отображение (словарь).

 Обычно __prepare__ реализуется как метод класса, поскольку он вызывается до создания экземпляра метакласса.

 Возвращаемое пространство имен __prepare__— это всего лишь временный объект во время создания класса, который будет
 передан в __new__, а не пространство имен, которое ваш класс будет использовать во время выполнения после создания.
 (классы имеют оптимизированный объект пространства имен, называемый MappingProxy, который обеспечивает, чтобы ключи были строками)

 Выполнение тела класса:
 Тело класса выполняется (приблизительно) как exec(body, globals(), namespace). Ключевое отличие от обычного вызова
 функции exec() состоит в том, что лексическая область видимости позволяет телу класса (включая любые методы) ссылаться
 на имена из текущей и внешней областей, когда определение класса происходит внутри функции.

 Однако, даже когда определение класса происходит внутри функции, методы, определенные внутри класса, по-прежнему
 не могут видеть имена, определенные в области класса. Доступ к переменным класса должен осуществляться через первый
 параметр методов экземпляра или класса или через неявную ссылку __class__ с лексической областью видимости,
 описанную в "Создании объекта класса".

 Создание объекта класса:
 Как только пространство имен класса заполнено путем выполнения тела класса, объект класса создается путем вызова
 metaclass(name, bases, namespace, **kwds). Дополнительные ключевые слова **kwds, переданные здесь, такие же, как те,
 которые переданы в __prepare__.

 Этот объект класса является тем, на который будет ссылаться форма с нулевым аргументом super().__class__ - это неявная
 ссылка на замыкание, созданная компилятором, если какие-либо методы в теле класса ссылаются либо на __class__,
 либо на super(). Это позволяет нулевой форме аргумента функции super() правильно идентифицировать определяемый класс
 на основе лексической области видимости, в то время как класс или экземпляр, который был использован для выполнения
 текущего вызова, идентифицируется на основе первого аргумента, переданного методу.

 Подробности реализации CPython: в CPython 3.6 и более поздних версиях ячейка __class__ передается метаклассу как запись
 __classcell__ в пространстве имен классов. Если он присутствует, то он должен быть распространен до type.__new__,
 чтобы класс был правильно инициализирован. Невыполнение этого требования приведет к ошибке RuntimeError в Python 3.8.

 При использовании метакласса type по умолчанию или любого метакласса, который в конечном итоге вызывает type.__new__
 после создания объекта класса, вызываются следующие дополнительные шаги настройки:
 - сначала type.__new__ собирает все дескрипторы в пространстве имен класса, которые определяют метод __set_name__();
 - во-вторых, все эти методы __set_name__ вызываются с определяемым классом и присвоенным именем этого конкретного дескриптора;
 - наконец, вызывается хук __init_subclass__() для непосредственного родителя нового класса в порядке разрешения его методов.

 После того, как объект класса создан, он передается декораторам класса, включенным в определение класса (если есть)
 и полученный объект привязывается в локальном пространстве имен как определенный класс.

 Когда новый класс создается по type.__new__, то объект, указанный в качестве параметра пространства имен, копируется
 в новое упорядоченное сопоставление (словарь), а исходный объект отбрасывается. Новая копия упаковывается в прокси
 только для чтения, который становится атрибутом __dict__ объекта класса.

 --- Модуль timeit   Измерение производительности небольших фрагментов кода ---
 предоставляет простой способ измерения времени выполнения (производительности) маленьких кусочков кода Python.
 Он имеет как интерфейс командной строки, так и программный интерфейс.
 Это позволяет избежать ряда распространенных ловушек для измерения времени выполнения.

 Модуль timeit предназначен специально для запуска тестов производительности.
 timeit многократно выполняет код и возвращает среднее время выполнения.
 timeit является более точным по сравнению с обычным time                                              <-----
 timeit является более точным по трем причинам:
 - он повторяет тесты много раз, чтобы исключить влияние других задач на вашу машину, таких как очистка диска и планирование ОС.
 - он отключает сборщик мусора, чтобы предотвратить искажение результатов этим процессом из-за планирования запуска
 сбора мусора в неподходящий момент.
 - он выбирает наиболее точный таймер для вашей ОС  timeit.default_timer == time.perf_counter()

 Jupyter-ноутбук — это среда разработки, где сразу можно видеть результат выполнения кода и его отдельных фрагментов.
 в Jupyter-ноутбук можно замерить время ->   %time a = list(range(100))  есть много магических команд  %time, %timeit, %%time

 В среде IPython использовать %timeit становится проще: ->  %timeit sum(range(100))

 запустить в командной строке (terminal) ->      python -m timeit "[str(n) for n in range(100)]"

 То же самое, только достигнуто с помощью интерфейса Python:
 timeit.timeit('[str(n) for n in range(100)]', number=10000)

 -- Функция timeit() - Измерить среднее время выполнения куска кода:
 timeit.timeit(stmt='pass', setup='pass', timer=<default timer>, number=1000000, globals=None)

 print(timeit.timeit('"-".join([str(n) for n in range(100)])', number=10000))  # -> 0.13303739996626973    join( [] )
 print(timeit.timeit('"-".join(str(n) for n in range(100))', number=10000))    # -> 0.17059490003157407    join( )
 print(timeit.timeit('"-".join(map(str, range(100)))', number=10000))          # -> 0.150374099961482      map
 Вызываемый объект также можно передать:
 print(timeit.timeit(lambda: "-".join(map(str, range(100))), number=10000))    # -> 0.15062750002834946

 Пример с функциями:
 def using_list_comprehension():
     return [i for i in range(10000)]

 def using_map_function():
     return map(lambda i: i, range(10000))

 def using_for_loop():
     result = []
     for i in range(10000):
         result.append(i)
     return result

 times = {
     'List Comprehension': timeit.timeit(using_list_comprehension, number=10000),
     'Функция Map': timeit.timeit(using_map_function, number=10000),
     'Цикл For': timeit.timeit(using_for_loop, number=10000),
 }

 # Оценим время, за которое они завершили исполнение!
 print(sorted(times.items(), key=lambda x: x[1]))
 # [('Функция Map', 0.004270799923688173), ('List Comprehension', 3.063175900024362), ('Цикл For', 4.384404100012034)]

 Пример:Что со скоростью?

 def using_list_comprehension():
     return [str(i) for i in range(10000)]

 def using_map_function():
     return map(lambda i: str(i), range(10000))

 def using_for_loop():
     result = []
     for i in range(10000):
         result.append(str(i))
     return result

 print(timeit.timeit(using_list_comprehension, number=10000))    # ->  12.336594399996102
 print(timeit.timeit(using_for_loop, number=10000))              # ->  14.48195659997873
 print(timeit.timeit(using_map_function, number=10000))          # ->  0.004364400054328144    <-----

 Варианты замера времени функции:

 def list_comp():
     return [i for i in range(10)][::-1]

 timeit.timeit(list_comp, globals=globals(), number=10000)
 timeit.timeit('list_comp()', 'from __main__ import list_comp', number=10000)
 timeit.timeit('list_comp()', setup='from __main__ import list_comp', number=10000)

 Настройка условий:                                 stmt='pass' - проверяемый код,
 setup_code = ```                                   setup='pass' - настройка кода,
 a_list = [i for i in range(100)][::-1]             timer=<default timer> - используемый таймер,
  ```                                               number=1000000 - число циклов измерений,
 test_code = ```                                    globals=None - область видимости.
 sorted(a_list)
 ```
 print(timeit.timeit(stmt=test_code, setup=setup_code, number=10000000)) # -> 10.221246400033124
 times = timeit.repeat(stmt=test_code, setup=setup_code, repeat=3, number=10000000)
 print(times)  # -> [10.238533199997619, 10.291957900044508, 10.204945100005716]

 -- Функция repeat() - Средняя производительность куска кода:
 timeit.repeat(stmt='pass', setup='pass', timer=<default timer>, repeat=5, number=1000000, globals=None)

 print(timeit.repeat('[i for i in range(10)]'))  # -> default repeat=5
 # [0.6879016000311822, 0.6823506000218913, 0.6835212000878528, 0.6849087999435142, 0.6851303000003099]
 print(timeit.repeat('[i for i in range(10)]', repeat=2)) # -> [0.6879646999295801, 0.6873995999339968]

 -- timeit.default_timer() - Таймер по умолчанию, которым всегда является time.perf_counter()

 import timeit                                          import time
 a = timeit.default_timer()                             a = time.perf_counter()
 zip(set(range(100000000)), list(range(100000000)))     zip(set(range(100000000)), list(range(100000000)))
 b = timeit.default_timer()                             b = time.perf_counter()
 print(b - a)  # -> 9.14232650003396                    print(b - a)  # -> 9.14232650003396

 -- Класс Timer() - Измерение производительности кода
 class timeit.Timer(stmt='pass', setup='pass', timer=<timer function>, globals=None)

 Методы класса Timer():
 - timeit(number=1000000) - возвращает время выполнения основного выражения stmt.
 Примечание По умолчанию timeit() временно отключает сбор мусора на время. Преимущество этого подхода в том, что он делает
 независимые тайминги более сопоставимыми. Недостатком является то, что GC может быть важным компонентом  производительности
 измеряемой функции. Если это так, GC можно повторно включить в качестве первого оператора в строке настройки . Например:
 timeit.Timer('for i in range(10): oct(i)', 'gc.enable()').timeit()

 - autorange(callback=None) -  автоматически определяет, сколько раз нужно вызвать метод Timer.timeit().
 print(timeit.Timer('for i in range(10): oct(i)', 'gc.enable()').autorange())  # -> (200000, 0.22509459999855608)

 - repeat(repeat=5, number=1000000) - вызывает метод Timer.timeit() несколько раз.
 print(timeit.Timer('for i in range(10): oct(i)', 'gc.enable()').repeat(3))
 # -> [1.1317513999529183, 1.1250234000617638, 1.123560499981977]

 - print_exc(file=None) - помощник для печати трассировки из временного кода.

 Общие примеры!!!
 print(timeit.timeit('char in text', setup='text = "sample string"; char = "g"'))     # -> 0.06030969996936619
 print(timeit.timeit('text.find(char)', setup='text = "sample string"; char = "g"'))  # -> 0.16739119996782392

 То же самое можно сделать, используя Timer класс и его методы:
 t = timeit.Timer('char in text', setup='text = "sample string"; char = "g"')
 print(t.timeit())  # -> 0.059912400087341666
 print(t.repeat(4))  # -> [0.06021869997493923, 0.060236999997869134, 0.060238400008529425, 0.060194100020453334]

 def f(x):                                         def test():
     return x**2                                       L = [i for i in range(100)]
 def g(x):
     return x**4                                   if __name__ == '__main__':
 def h(x):                                             import timeit
     return x**8                                       print(timeit.timeit("test()", setup="from __main__ import test"))

 print(timeit.timeit('[func(42) for func in (f,g,h)]', globals=globals()))

 Передать параметры функции при помощи замыкания, partial, lambda:                                            <-----

 def foo(a: str, b:int) -> list[str]:  from timeit import timeit                    from timeit import timeit
     def _foo():                       def foo(a: str, b:int) -> list[str]:         def foo(a: str, b:int) -> list[str]:
         return [str(a), str(b)]           return [str(a), str(b)]                      return [str(a), str(b)]
     return _foo
                                       t = timeit(functools.partial(foo, 'A', 10))  t = timeit(lambda: foo('A', 10))
 t = timeit.Timer(foo('A', 10))        print(t)                                     print(t)
 t.timeit()


 --- Логирование ---
 Logging — это важный инструмент для отладки и отслеживания работы программы

 Модуль logging
 Этот модуль определяет функции и классы, которые реализуют гибкую систему регистрации событий для приложений и библиотек.

 logging использует модульный подход и предлагает несколько категорий компонентов: регистраторы, обработчики, фильтры и форматеры.
 - Регистраторы Logger предоставляют интерфейс, который непосредственно использует код приложения.
 - Обработчики Handler отправляют записи журнала (созданные регистраторами) в соответствующий пункт назначения.
 - Фильтры Filter предоставляют более точную возможность определить, какие записи журнала выводить.
 - Форматтеры Formatter определяют расположение записей журнала в конечном выводе.


 Логирование решает основную функцию - диагностирование проблемы
 - В каком состоянии находится система
 - В каком состоянии находятся данные
 - Что у вас происходит в системе
 Нужно для того чтобы понимать:
 1) Понимать что всё работает правильно
 2) Понимать что всё вообще работает
 3) Для диагностики проблемы

 В самом простом логировании мы используем - функцию print()
 print() - нормальный способ логирования для простых программ (пара функций, 1 класс)
 Чем сложнее/больше ваше приложение - тем сильнее растет необходимость использования специальных инструментов для логирования
 Логирования много не бывает :) легче диагностировать проблему когда информации много

 Логирование - это фиксация состояния вашего приложения в определенный момент времени.
 Оно позволяет понимать, что система работает как ожидается (и вообще работает), а также облегчает диагностику проблем

 Минусы print:
- нет общего формата (дата)
- не ясно какой модуль в каком месте написал информацию, насколько она важна
- нужно выключать/включать, обязательно забудем удалить
- нельзя гибко настроить куда писать (файл/консоль)

 Когда уместен print: в очень простых, маленьких приложениях и скриптах.
 Чем больше и сложнее приложение тем важнее использовать специальные инструменты логирования

 DIWEC = DEBUG - INFO - WARNING - ERROR - CRITICAL
 DEBUG - самая подробная информация, нужна только разработчику и только для отладки, например значения переменных,
 какие данные получены и т.д.
 INFO - информационные сообщения, как подтверждение работы, например запуск сервиса
 WARNING - еще не ошибка, но уже надо посмотреть - мало места на диске, мало памяти, много созданных объектов и т.д
 ERROR - приложение еще работает и может работать, но что-то пошло не так
 CRITICAL - приложение не может работать дальше

 logger = getLogger(__name__) - принятый подход для логирования с именем модуля
 логеры с именами наследуют настройки от root, но могут быть настроены иначе
 logger.debug("Get expression %s", exp)  - для обратной совместимости используется старый формат через %


 --- Общие принципы оптимизации кода Python ---
 Цитата: "Если необходимо, чтобы Ваш код работал быстрее, то вероятно, следует просто использовать PyPy"
 Гвидо ван Россум (создатель Python).

 Любой код, в первую очередь, должен быть написан обдуманно и быть рабочим и только потом можно приступать к его
 дополнительной оптимизации. При этом оптимизация должна проходит прямо в процессе разработки, так как потом сложно
 будет изменить множество мелких моментов.

 Оптимизация производительности в любом языке программирования не имеет четкого алгоритма действий. Иногда даже
 незначительные изменения в "нужном месте" могут ускорить работу кода Python в несколько раз. Оптимизация кода - это
 придание важности мелочам.

 ИЗБЕГАЙТЕ ПРИМЕНЕНИЕ ГЛОБАЛЬНЫХ ПЕРЕМЕННЫХ.
 Python очень медленно обрабатывает доступ к глобальным переменным, особенно внутри циклов. Также множественное
 применение глобальных переменных очень часто приводит к спагетти-коду, что вызывает дополнительные трудности и проблемы.

 ИСПОЛЬЗОВАНИЕ СТОРОННИХ МОДУЛЕЙ И БИБЛИОТЕК.
 Обращайте внимание на каком языке написан сторонний модуль или библиотека. Если есть возможность, то используйте
 библиотеки, написанные на С, так как они работают быстрее, а это значит, что и программа на Python будет работать немного быстрее.

 АКТИВНО ИСПОЛЬЗУЙТЕ ВСТРОЕННЫЕ ИНСТРУМЕНТЫ PYTHON.
 Их применение ускоряет код за счет того, что они предварительно оптимизированы, скомпилированы и следовательно выполняются быстрее.

 РАБОТА НАД КОДОМ.
 - пишите код обдуманно и максимально лаконично;
 - по возможности, внедряйте кэширование объектов;
 - не создавать лишние экземпляры объектов (помните, объекты потребляют дополнительную память);

 ОБРАБАТЫВАЙТЕ ВХОДНЫЕ ДАННЫЕ  input sanitization(очистка входных данных перед выполнением программы).
 Модуль unicodedata в Python, база данных Unicode
 модуль unicodedata и функция combining() для генерации и отображения. Их можно использовать для удаления всех акцентов из строки.

 ИСПОЛЬЗУЙТЕ ИТЕРАТОРЫ СО СРЕЗАМИ.
 s = itertools.islice(range(50), 10, 20)

 ПРОПУСКАЙТЕ НАЧАЛО ИТЕРИРУЕМОГО ОБЪЕКТА.
 Иногда приходится работать с файлами, которые начинаются с неизвестного количества бесполезных строк, например,
 с комментариев. И тут модуль itertools снова предлагает простое решение:
 string_from_file =   ```// Автор: ...
  // Лицензия: ...
  //
  // Дата: ...

 Содержание...
 ```
 import itertools

 for line in itertools.dropwhile(lambda line: line.strip().startswith('//'),
                                string_from_file.splitlines()):
     print(line)

 ИСПОЛЬЗУЙТЕ KWARGS. *, *args, **kwargs
 def test(*, a, b):
  pass

 ИСПОЛЬЗУЙТЕ ОБЪЕКТЫ, КОТОРЫЕ ПОДДЕРЖИВАЮТ ОПЕРАТОР WITH.
 - протокол context manager используя методы __enter__ и __exit__
 и более простой способ:  декоратор менеджера contextmanager
 from contextlib import contextmanager

 @contextmanager
 def tag(name):
   print (f"<{name}>")
   yield
   print (f"</{name}>")

 with tag("h1"):
   print("This is Title.")

 СОХРАНИТЕ ВСЁ С ПОМОЩЬЮ __slots__.
 class Person:
     __slots__ = ["first_name", "last_name", "phone"]
     def __init__ (self, first_name, last_name, phone):
         self.first_name = first_name
         self.last_name = last_name
         self.phone = phone

 Следует учесть, что в этом случае есть и недостатки: нельзя объявлять какие-либо новые атрибуты помимо используемых
 в __slots__, а классы со __slots__ не могут использовать множественное наследование.

 ОГРАНИЧЬТЕ ИСПОЛЬЗОВАНИЕ ПРОЦЕССОРА И ПАМЯТИ.
 - Модуль resource
 Контроль и ограничение потребления системных ресурсов ОС.
 Модуль resource предоставляет базовые механизмы для измерения и контроля системных ресурсов, используемых программой

 УПРАВЛЯЙТЕ ЭКСПОРТОМ ЭЛЕМЕНТОВ.
 - Используем переменную __all__:
 def foo():
    pass

 def bar():
    pass

 __all__ = ["bar"]

 В данном случае, благодаря __all__ экспортирован будет не весь код, а только функция bar(). Кроме того, можно оставить
 переменную пустой, то при попытке импорта из этого модуля ничего не попадёт в экспорт, что приведёт к ошибке AttributeError.
--- END Общие принципы оптимизации кода Python ---


 --- Интернирование строк ---
 Интернирование строк - это процесс, при котором две или более строковые переменные,
 содержащие одинаковое значение, ссылаются на один и тот же объект в памяти

 Интернирование строк применяется для оптимизации использования памяти и ускорения выполнения программы.
 Поскольку операция сравнения двух строк, ссылающихся на один и тот же объект в памяти, выполняется быстрее,
 чем сравнение двух строк, которые хранятся в разных объектах в памяти.

 В некоторых случаях Python пытается переиспользовать существующие неизменяемые объекты. Интернирование строки - это один из таких случаев.
 a = 'wtf'                                           a = "Hello"
 b = 'wtf'                                           b = "Hello"
 c = ''.join(['w', 't', 'f'])                        a is b       # -> True
 a is b # -> True                                    id(a), id(b) # 2455734427568 2455734427568
 a is c # -> False                                   a == b       # -> True


 a = 10000                           a = 10000
 b = int("10000")                    b = 10000
 print(a == b)          # True       print(a == b)          # True
 print(a is b)          # False      print(a is b)          # True
 print(id(a) == id(b))  # False      print(id(a) == id(b))  # True

 Итак, следующие утверждения эквивалентны:
 a is b
 id(a) == id(b)

 Интернирование объектов — это метод, используемый в Python для оптимизации использования памяти и повышения
 производительности за счет повторного использования неизменяемых объектов вместо создания новых экземпляров .

 -- Профилирование(profile)   Профилировщики(profilers) --
 Профилирование кода на Python — это важный этап оптимизации, который помогает улучшить производительность программы.
 Профилирование кода — метод, который разработчики используют, чтобы понимать поведение программы. Процесс включает
 наблюдение за выполнением программы для сбора данных о различных аспектах, таких как:
 - сколько времени занимает выполнение каждой функции
 - сколько памяти используется, и другие ресурсы
 Основная цель — выявить 'УЗКИЕ МЕСТА' или области, где программа может быть оптимизирована для повышения ее эффективности
 и производительности. Профилирование может быть статическим и динамическим:
 - Статическое включает анализ кода программы без ее выполнения, как правило, для понимания ее сложности.
 - Динамическое профилирование отслеживает программу во время ее выполнения, чтобы собрать статистику за время выполнения.

 Bottleneck - Узкое место программы.

 Профилировщик — это инструмент, запускающий код и собирающий информацию о времени, необходимом для вызова каждой
 функции, количестве вызовов и иерархии вызовов функций

 Стандартный профилировщик Python:
 cProfile - расширение C
 profile  - модуль на чистом Python, интерфейс которого имитируется cProfile

 Это особенно относится к сравнению кода Python с кодом C: профилировщики вносят накладные расходы для кода Python,
 но не для функций уровня C, и поэтому код C будет казаться быстрее, чем любой код Python.

 PyCharm запускает сеанс профилирования с yappi по умолчанию, в противном случае он использует стандартный профилировщик cProfile

 - Модуль atexit   Обработчики завершения программы -
 Модуль atexit определяет функции для регистрации и отмены регистрации функций очистки. Зарегистрированные таким образом
 функции автоматически выполняются после обычного завершения интерпретатора.

 atexit.register(func, *args, **kwargs) - Вызвать функцию при обычного завершения программы (завершении интерпретатора)
 atexit.unregister(func) - удаляет func из списка функций, запускаемых при завершении интерпретатора.

 import atexit
 @atexit.register
 def goodbye():
    print("Bye bye!")

 print("Hello Yang!")

 -- Numba   - ускоряет код Python --
 Numba — это Just-In-Time компилятор, который превращает ваш код на питоне в машинный код на лету.
 Она анализирует вашу функцию, определяет типы данных и затем компилирует её в оптимизированный машинный код.

 Одна из самых выжных рекомендаций при работе с Numba - по возможности использовать режим nopython

 Использование режима nopython в Numba позволяет компилировать функции в машинный код без использования Python-объектов,
 что значительно увеличивает производительность. В этом режиме Numba не будет пытаться использовать интерпретатор Python,
 что позволяет избежать накладных расходов.

 Слияние циклов (loop fusion) в Numba — это оптимизация, которая комбинирует несколько последовательных циклов в один.
 Это уменьшает количество итераций и накладных расходов на управление циклами.



 Оптимизация потребления памяти в Python:
 - Модуль memory_profiler - измеряет использование памяти конкретной функцией построчно.
 - Модуль Pympler - много полезных функций включая отслеживание экземпляров классов или выявление утечек памяти.
 - NumPy , Scipy , Pandas , __slots__ , Trie-префиксное дерево
 - Использование генераторов Python и/или модуль mmap - ускорение операций ввода-вывода



 ОПТИМИЗАЦИЯ в Python:
 - Используйте операции с множествами set - Методы set  O(1) без hash-коллизий  O(n) c hash-коллизиями
 - Set - увеличивает скорость выполнения но будет потреблять еще больше оперативной памяти.
 - ОПТИМИЗАЦИЯ ИСПОЛЬЗОВАНИЯ СТРОК: Не используем Конкатенация строк - лучше join или f-строки
 - Интернирование строк, Кэширование чисел, Кэширование результатов functools декораторов
 - more-itertools, itertools, functools, collections, operator, built-in functions, используем and or замыкания,
 - list comprehensions, generator expression, iterators, set comprehensions, dict comprehensions, with
 - timeit(замера скорости) , asizeof(размера структур) , dis(байт код), Логирование logging
 - Профилирование кода - timeit и модуль cProfile (собирает статистику, анализ производительности), memory_profiler
 - multiprocessing (ядра пк), multithreading (потоки) , asyncio (асинхронные операции) , Numba - ускоряет код Python
 - Тестирование Pytest, unittest

 --- Python Snippets ---
 Python Snippets (Сниппет) - это какой-то отрывок кода, который может быть использован повторно.

 Set Operations, Functools, Metaclasses, asyncio, Dataclasses, Decorators with Arguments, Asynchronous Iterators,
 getattr, list/dict/set Comprehensions, genexp, with open, lambda, import, built-in functions, f-string ...


 --- Hadoop   Spark ---
 Выполняют операции MapReduce
 MapReduce Техника
 В модели программирования MapReduce большой набор данных сначала разбивается на меньшие части.
 После того как все задачи для всех поднаборов решены, мы может объединить результаты.

 MapReduce — это модель обработки больших данных, состоящая из двух этапов:

 1. **Map**: Разделение данных на пары ключ-значение и их предварительная обработка.
 2. **Reduce**: Агрегация промежуточных результатов по ключам для получения финальных результатов.

 Применяется для параллельной обработки и анализа данных


 -- Agile(Еджайл) - это группа методик для гибкого управления проектами в команде разработки. Рабочий процесс при таком подходе
 разбивается на небольшие временные промежутки, их еще называют спринтами (sprint — бег на короткую дистанцию) или итерациями.

 Scrum и Kanban — представители методологий Agile-семейства. Обе считаются гибкими и итеративными.

 Основу Scrum составляют короткие итерации или спринты, как правило, 2-3-х недельные. Перед началом спринта команда
 сама формирует список фич на итерацию, далее запускается спринт.

 Kanban дает больше гибкости, если под гибкостью понимать частоту смены приоритетов.

 Основная разница между Scrum и Канбан — в длине итераций. В Scrum итерации — 2 недели,
 в Kanban задачи программисту можно «подсовывать» хоть каждый день.

 Итак, в Scrum наша цель — закончить спринт, в Kanban — задачу.


 Непрерывная интеграция (Continuous Integration, CI)
 Непрерывная поставка   (Continuous Delivery, CD)
 CI — это практика, связанная с регулярной интеграцией изменений кода в общий репозиторий.
 CD — это практика, которая подразумевает, что код, который прошел этапы тестирования в CI, готов к развертыванию на любой среде
 CI/CD объединяет разработку, тестирование и развёртывание приложений.

 CI/CD — это одна из DevOps-практик. Она также относится и к agile-практикам: автоматизация развертывания позволяет
 разработчикам сосредоточиться на реализации бизнес-требований, на качестве кода и безопасности.

 Инструменты для CI/CD:
 Существует множество инструментов, которые поддерживают CI/CD процессы, включая:
 - Jenkins
 - GitLab CI/CD
 - Travis CI
 - CircleCI
 - GitHub Actions
 - Azure DevOps и другие.

 CI/CD — это важный элемент современных подходов к разработке программного обеспечения,
 обеспечивающий эффективное и качественное сопровождение проектов.


 --- BI  (Business Intelligence, Бизнес-Аналитика) ---
 ETL (Extract, Transform, Load) — это процесс, который используется для интеграции данных из разных источников в единую
 систему, обычно в системы бизнес-аналитики (BI)

 1. **Extract (Извлечение)**: Собираются данные из различных источников, таких как базы данных, файлы, API и другие
 системы. Это может включать как структурированные, так и неструктурированные данные.

 2. **Transform (Преобразование)**: Данные обрабатываются и преобразуются в нужный формат. Этот этап может включать
 фильтрацию, агрегацию, очистку и интеграцию данных, чтобы обеспечить их качество и целостность.

 3. **Load (Загрузка)**: Преобразованные данные загружаются в целевую систему хранения, такую как дата-warehouse
 (хранилище данных) или BI-платформу, где они могут быть использованы для анализа и отчетности.


 MicroStrategy — BI Система - это мощная платформа для бизнес-аналитики (BI), которая предоставляет инструменты для
 анализа данных, визуализации и создания отчетов.

 Datalens (или Яндекс.Даталеннс) — это инструмент для бизнес-аналитики и визуализации данных, разработанный Яндексом.
 Он позволяет пользователям анализировать и представлять свои данные в удобном и наглядном формате.


  Вечный враг: сложность
 - главный охотник на груга это сложность
 - сложность плохо
 - скажу снова:
 - сложность очень плохо
 - теперь ты скажи сам:
 - сложность очень, очень плохо
 - если выбрать между сложность и биться с динозавром, груг выбери динозавр: груг хотя бы видеть динозавра


 --- Чат-бот в Telegram на Python ---

 Aiogram - это современный и полностью асинхронный фреймворк для Telegram Bot API, написанный на Python
 с использованием asyncio и aiohttp.

 aiohttp - это опенсорсная библиотека, построенная на основе I/O фреймворка Asyncio и предназначенная для обработки
 большого количества одновременных HTTP-запросов без традиционного потокового нетворкинга.


 Практика:
 1) Написать декоратор, который выводит на экран время работы произвольной функции:

 from functools import wraps
 from time import time, perf_counter

 def timer(func):
     @wraps(func)
     def wrapper(*args, **kwargs):
         start = perf_counter()
         res = func(*args, **kwargs)
         finish = perf_counter()
         print(f"Время выполнения функции '{func.__name__}': {finish - start:.4f} секунд")
         return res
     return wrapper

 @timer
 def example_function(n):
     total = 0
     for i in range(n):
         total += i
     return total

 example_function(1000000)  # -> Время выполнения функции 'example_function': 0.0738 секунд

 2) Написать декоратор, который возвращает либо результат, либо экземпляр исключения:

 def safe_decorator(func):
    @__import__('functools').wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except ZeroDivisionError as e:
            return e
    return wrapper

 @safe_decorator
 def divide(a, b):
     return a / b

 print(divide(10, 0))  # -> division by zero
 print(divide(10, 2))  # -> 5.0

 3) Написать генератор Фибоначчи от a и b.

 def fibonacci_generator(a, b):
     while True:
         yield a
         a, b = b, a + b

 # Пример использования
 fib_gen = fibonacci_generator(1, 1)
 for _ in range(10):
     print(next(fib_gen))  # Выведет первые 10 чисел Фибоначчи

 4) Получить из файла текст в юникоде.

 def read_unicode_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    return content

 # Пример использования
 # текст = read_unicode_file('path_to_your_file.txt')
 # print(текст)

 5) Написать генератор чисел Фибоначчи вида def fib(a=1, b=2):

 def fib(a=1, b=2):
     while True:
         yield a
         a, b = b, a + b

 # Пример использования
 fib_gen = fib()
 for _ in range(10):
     print(next(fib_gen))  # Выведет первые 10 чисел Фибоначчи начиная с a=1, b=2


 # Где будет быстрее поиск, а где перебор и почему: dict, list, set, tuple ?

 # Поиск будет быстрее в dict и set, потому что это хэш-таблицы, доступ к элементу которых выполняется за O(1).
 # Для list и tuple поиск будет выполняться в среднем за O(n).

 # Исключение работает только для очень маленьких списков длиной до 5 элементов. В этом случае интерпретатору будет
 # быстрей пробежаться по списку, чем считать хеш.


 l = list(range(1000000))
 d = dict.fromkeys(l)
 s = set(l)
 def iter_list():
     for _ in l:
         pass

 def iter_dict():
     for _ in d:
         pass

 def iter_set():
     for _ in s:
         pass

 print(timeit.timeit(iter_list, number=1000))  # -> 14.252523400005884
 print(timeit.timeit(iter_dict, number=1000))  # -> 17.633023599977605
 print(timeit.timeit(iter_set, number=1000))   # -> 17.516106499999296


 --- Монолитное приложение и Микросервисная архитектура — это два подхода к разработке программного обеспечения. ---

 Монолитное приложение - Это единое, целостное приложение, в котором все компоненты и функциональности интегрированы
 и развиваются вместе. Это единый код, который управляет всеми бизнес-функциями и интерфейсами.

 - **Преимущества**:
 - Простота разработки и тестирования.
 - Меньше накладных расходов на взаимодействие между компонентами.
 - **Недостатки**:
 - Сложность масштабирования: при увеличении нагрузки нужно копировать всю систему.
 - Трудности с обновлениями и поддержкой, изменения в одном месте могут влиять на все приложение.


 Микросервисы - Это архитектурный стиль, в котором приложение разбивается на мелкие, независимые сервисы, каждое из
 которых выполняет  свою задачу и может быть разработано и развернуто отдельно/самостоятельно .

 **Преимущества**:
 - Гибкость в использовании разных технологий для отдельных сервисов.
 - Упрощенное масштабирование: можно отдельно масштабировать только нужные сервисы.
 - Лучшая устойчивость: сбой в одном сервисе не приводит к сбоям в целом приложении.
 - **Недостатки**:
 - Увеличенная сложность в управлении и взаимодействии между сервисами.
 - Необходимость в более сложной инфраструктуре для развертывания и мониторинга.


 Legacy проект в контексте разработки программного обеспечения — это проект, который был создан с использованием
 УСТАРЕВШИХ ТЕХНОЛОГИЙ, БИБЛИОТЕК или ПОДХОДОВ.

 UI (User Interface) — это пользовательский интерфейс.

 Пайплайн (или PIPELINE) — это концепция, используемая в разных областях, таких как разработка программного обеспечения,
 машинное обучение и обработка данных. Основная идея пайплайна заключается в том, что он представляет собой
 последовательность шагов, через которые проходят данные или процесс для достижения конечного результата.


 1. **Разработка программного обеспечения**: В CI/CD (непрерывная интеграция и непрерывное развертывание) пайплайн
 представляет собой автоматизированный процесс, который проходит через несколько этапов — от написания кода и
 тестирования до развертывания на сервере.

 2. **Машинное обучение**: В этой области пайплайн состоит из последовательности этапов, таких как подготовка данных,
 выбор признаков, обучение модели и оценка ее производительности. Каждая из этих стадий последовательно передает
 свои результаты следующей.

 3. **Обработка данных**: В системах обработки данных, таких как ETL (извлечение, преобразование, загрузка), пайплайн
 описывает процесс перемещения и преобразования данных из одной системы в другую.

 Основная цель пайплайнов — автоматизировать и стандартизировать процессы, чтобы сделать их более надежными и эффективными.


 PuTTY — это терминальный эмулятор, позволяющий устанавливать SSH-соединение с удаленными серверами.
 SSH (Secure Shell) С С АШ — это протокол для безопасного удаленного доступа к другим компьютерам, позволяющий шифровать
 данные и обеспечивать защищенное подключение.

 -- Через терминал подключение по SSH к СЕРВЕРУ --
 SSH tech_deleloper14@tvlds-0126      # По ХОСТУ
 SSH tech_deleloper14@10.10.207.111   # По ПРОКСИ

 Notepad++
 Plugins -> JsonFormat                  # Чтобы преобразовать в удобный формат
 Plugins -> JsonFormat -> JsonViewer    # Чтобы добавить слева табличку

 Podman — это инструмент для управления контейнерами, который позволяет создавать, запускать и управлять контейнерами и
 подами без необходимости в демоне, как в Docker. Он обеспечивает совместимость с Docker CLI и позволяет работать
 с контейнерами от имени обычного пользователя, что повышает безопасность.


 Podman и Docker — это инструменты для управления контейнерами, но имеют несколько ключевых отличий:

 Архитектура:

 Docker использует клиент-серверную архитектуру, где демон (Docker daemon) управляет контейнерами.
 Podman работает без демона и использует архитектуру "без демона", что делает его более безопасным и простым в
 использовании в некоторых сценариях.

 Пользовательские права:

 Docker обычно требует привилегированных прав для работы с демоном.
 Podman может работать от имени обычного пользователя без необходимости в повышенных привилегиях.
 Совместимость:

 Podman поддерживает команды Docker CLI, что облегчает переход с Docker на Podman.
 Поддержка подов:

 Podman имеет встроенную поддержку для управления подами (группами контейнеров), что делает его более подходящим для
 работы с многоконтейнерными приложениями.

 Эти отличия делают каждый инструмент более подходящим для различных сценариев использования.



 Docker - Изолирует приложение и упаковывает все в контейнер
 Kubernetes - Инструмент для оркестровки и управления деплоем контейнеров на нескольких машинах паралельно
 K8s - Сокращенное название Kubernetes      В сокращении “K8S” цифра 8 - это восемь букв между K и S.


 --- Горячие клавиши PyCharm ---


 Окружить код/выражение      Ctrl + Alt + T
 Замена в тексте             Ctrl + R
 Замена во всех файлах       Ctrl + Shift + R
 Дублировать  строку         Ctrl + D
 Удаление строки             Ctrl + Y
 Code-Style                  Ctrl + Alt + L
 Поиск в файле	             Ctrl + F
 Недавние файлы	             Ctrl + E
 Полный автокомплит	         Ctrl + Space
 Отменить последнее действие Ctrl + Z
 Отменить последнюю отмену действия	 Ctrl + Shift + Z
 Выделить текст/Убрать       Ctrl + W/Ctrl + Shift + W



 Переместить курсор в начало/конец строки             Home/End              или  Ctrl + ]/[
 Переместить курсор в начало/конец текста             Ctrl + Home/End
 Страница вверх/вниз                                  Page Up/Page Down
 Переместить курсор в начало/конец страницы           Ctrl + Page Up/Page Down
 Переместить+Выделить курсор в начало/конец строки    Shift + Home/End
 Переместить курсор к следующему/предыдущему слову    Ctrl + влево/вправо
 Переместить+Выделить курсор к след/пред слову        Ctrl + Shift + влево/вправо
 Создание нескольких курсоров                         Alt + Click
 Информация о параметрах                              Ctrl + P          Нажимаем внутри Вызова функции ( )
 Краткая документация                                 Ctrl + Q
 Поставить Анонимные закладки                         F11
 Показать все закладки                                Shift + F11


 Запустить  Код                                        Shift + F10
 Запустить  Отладку/Debug                              Shift + F9
 Переместить заявление/строку вверх/вниз               Ctrl + Shift + вверх/вниз
 Переключить регистр Маленькие/Большие буквы           Ctrl + Shift + U
 Настройки Pycharm                                     Ctrl + Alt + S
 Обернуть выделенный код в один из шаблонов	           Ctrl + Alt + J
 Автокомплит с фильтрацией по подходящему типу	       Ctrl + Shift + Space
 Показать контекстные действия                         Alt + Enter
 Переименование переменной, класса и тд во всем коде   Shift + F6
 Поиск по всем файлам (переход — F4)	               Ctr + Shift + F
 Быстрый поиск по всему проекту                        Дважды Shift
 Закомментировать/раскомментировать текущую строку     Ctrl + /
 Закомментировать/раскомментировать выделенный код	   Ctrl + Shift + /
 Увеличить / уменьшить текущий отступ                  Tab / Shift + Tab
 Свернуть код                                          Ctrl + .
 Открыть/Закрыть Свернутый код                         Ctrl + -/+

 Выделить текст  Тоже что и  Ctrl + C                  Ctrl + Insert
 Вставить текст  Тоже что и  Ctrl + W                  Shift + Insert


 Зайти сразу в Show History Git                        Alt + 9

 Перейти где определена                                Ctrl + B
 Найти использование                                   Alt + F7
 Показать использование                                Ctrl + Alt + F7
 Выделить использования в файле                        Ctrl + F7            # Вроде Тоже самое ?
 Выделить использования в файле                        Ctrl + Shift + F7    # Вроде Тоже самое ?

 Открывает окно, в котором отображаются все места в коде, где используется выбранный элемент   Alt + F7
 перемещаться между методами и классами в текущем файле                                        Ctrl + Alt + влево/вправо

 Вставка из истории буфера                             Ctrl + Shift + V     # Вся история ваших действий с буфером обмена
 Аналог  Буфера Обмена Windows                         Win + V              # Не в Pycharm Pro команда


 a_str = "нажать внутри enter"  нажать enter в пустой строке и будет ("" "") так же работает и с {}, (), []
 a_str = (''      a_list = [      a_dict = {        a_tuple = (
         '')      ]               }                 )


 Чтобы вернуть просмотр документации при наведении мышки. Ctrl+Q нажимаем на три точки снизу - Show on Mouse Move
 Изменить лимит вкладок - In the Settings dialog (Ctrl+Alt+S) , go to Editor | General | Editor Tabs | Tab limit
 Изменить размер шрифта - In the Settings dialog (Ctrl+Alt+S) , go to Editor | Font  Size: 13.0  Line height: 1.2

 Backspace -  удаления символа, находящегося слева от курсора
 Delete    -  удаления символа, находящегося справа от курсора.


 Win + вверх/вниз   - Разбить экран на половину

 Classic UI  - Plugin для Pycharm pro  (Чтобы вернуть старый интерфейс)

 Black — это автоматический форматировщик кода для Python.  pip install black

 Наводим на номер строки жмем другой кнопкой мыши и выбираем   Annotate with Git Blame    -  Показать кто делал код

 Автоматическое редактирование кода - Tools -> Actions on Save -> Reformat code (Убираем галочку)

 SyntaxWarning: invalid escape sequence - ошибка связанная с многострочной строкой используем r перед строкой r''' '''

 Посмотреть номер строки и сколько символов Go to Line:Column Наводим снизу там где надпись  CRLF UTF Python 3.12 master

 Настройка Deployment -  Tools -> Deployment -> Configuration -> +

 Если подчеркивает серым наводим читаем подсказки - Method 'your_method' may be static   - Значит сделать @staticmethod


"""
