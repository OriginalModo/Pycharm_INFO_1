"""

 Самое Важное!!!
 Всегда ДУМАТЬ! перед тем, как что-либо сделать, необходимо всё тщательно обдумать

 Радоваться Жизни  Радоваться разным мелочам

 Ценить:         Ценить то что есть и стремиться к лучшему, Ценить сегодняшний день и брать МАКСИМУМ
 Быть проще:     Ко всему относиться Проще и Спокойнее без Волнения
 Слушать Других: Прислушиваться к мнению других людей они могут быть правы  И делать выводы
 Время:          Тайм-менеджмент   Грамотное распределение времени, Контроль Времени, Правильно раставлять Приоритеты
 Уверенность:    Быть уверенным в себе НО Оценивать свои силы!
 Развития:       Развиваться, Учиться, учиться и ещё раз - учиться, Саморазвитие
 Не Надеяться:   Надеяться только на себя
 Контроль:       Быть менее Эмоциональным, Совладать с Эмоциями, Контролировать свои эмоции в любой ситуации
 Внимательность: Быть Внимательным
 Спокойствие:    Быть Спокойнее, Перестать Нервничать , Быть Расслабленным, Не Злиться на себя и на других
 Режим:          Правильный Сон, Пить Воду
 Зарядка:        Бег, Тренировки, Стойка на Голове
 Тельце в тепле: НЕ переохлаждаться

 Молчание золото:  Лучше промолчать, чем сказать и потом жалеть о том, что сказал
 Соломон:          Все пройдёт, и это тоже пройдёт
 Вообще это замечательный подход: осознать, что проблема не такая уж и проблема, и вполне решаема.
 Кто ищет-тот всегда найдет!
 Искать Другие способы
 Не спеши, а то успеешь...   Успеешь, но не туда куда хотел...
 Подумай, нужно ли тебе ЭТО и для Чего
 Надо принимать вещи такими, как они есть, и пользоваться ими с наибольшей для себя выгодой.
 Если научиться принимать вещи как они есть, страдание исчезнет.
________________________________________________________________________________________________________________________


 Встроенные функции:   Built-in Functions  количество: 71:
 Интерпретатор Python имеет ряд встроенных в него функций и типов, которые всегда доступны. Здесь они перечислены в алфавитном порядке.
________________________________________________________________________________________________________________________
 abs(x) - Возвращает абсолютное значение числа. Аргумент(x) может быть целым числом, числом с плавающей запятой или объектом,
 реализующим __abs__(). Если аргумент является комплексным числом, возвращается его величина.
 abs(-5) -> 5,  abs(5) -> 5, abs(-5+0j) -> 5, abs(-5.5) -> 5.5

 abs() возвращает положительное значение для целых и вещественных чисел, а для комплексных чисел — их модуль
 print(abs(3 - 4j))  # -> 5.0   # Вывод: 5.0 (модуль комплексного числа)
________________________________________________________________________________________________________________________
 aiter(async_iterable) - Возвращает асинхронный итератор для асинхронной итерации . Эквивалент звонка x.__aiter__().
 Примечание. В отличие от iter(), aiter() не имеет варианта с двумя аргументами.
________________________________________________________________________________________________________________________
 await anext(async_iterator), awaitable anext(async_iterator, default) - при ожидании await, возвращает следующий
 элемент из переданного асинхронного итератора async_iterator или значение по умолчанию default, если оно задано и итератор исчерпан.
 Это асинхронный вариант встроенной функции next(), который ведет себя аналогичным образом.

 Если задано значение по умолчанию default, то оно возвращается, если итератор исчерпан,
 в противном случае вызывается исключение StopAsyncIteration.
________________________________________________________________________________________________________________________
 all() - Возврат, True если все элементы итерируемого объекта истинны (или если итерируемый объект пуст).
 all([x > 0 for x in range(1, 9)]) -> True,   all([x > 0 for x in range(-1, 9)]) -> False, any([x > 0 for x in [1, 2]]) -> True
 all(x > 0 for x in range(1, 9)) -> True,   all(x > 0 for x in range(-1, 9)) -> False, any(x > 0 for x in [1, 2]) -> True
 all([]) -> True

 def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True


 gen = (i for i in [0, .0, 7, 8])
 print(all(gen))         # -> False
 print(next(gen))        # -> 0.0
________________________________________________________________________________________________________________________
 any() - Возвращает значение True, если какой-либо элемент итерируемого объекта имеет значение True.
 Если итерируемый объект пуст, вернет False.
 any(['', {}, [], (), set(), 0, False, None, range(0)]) -> False, any([1, 0]) -> True,  any([]) -> False

 def any(iterable):
    for element in iterable:
        if element:
            return True
    return False


 gen = (i for i in [0, .0, 7, 8])
 print(any(gen))         # -> True
 print(next(gen))        # -> 8
________________________________________________________________________________________________________________________
 ascii(object) - Возвращает читаемую версию объекта, экранируя символы, отличные от ASCII
 ascii('My name is Сяся') -> 'My name is \u0421\u044f\u0441\u044f',  ascii([1, 2, 'Ю']) -> [1, 2, '\u042e']
________________________________________________________________________________________________________________________
 bin(x) - Преобразует целое число в двоичную строку с префиксом 0b.  bin(5) -> 0b101,   bin(-10) -> -0b1010
________________________________________________________________________________________________________________________
 class bool(x=False) - возвращает логическое значение указанного объекта, True или False, bool([]) -> False, bool(1) -> True
 print(bool())  # -> False

 Аналогичные примеры: Под капотом Python сам подставляет bool() его можно не писать
 num = -1                                      |    num = []
 if num:                 if bool(num):         |    if num:                 if bool(num):
    print(True)              print(True)       |       print(True)              print(True)
 if not num:             if not bool(num):     |    if not num:             if not bool(num):
    print(False)             print(False)      |       print(False)             print(False)
                                               |
 # True                  # True                |    # False                  # False

НЕ ПРАВИЛЬНО!!!                     |  Правильно.                                          | Очень Правильно!!!
word = 'NO'                         |  word = 'NO'                                         | word = 'NO'
if word == 'YES' or 'yes' or 'Yes': |  if word == 'YES' or word == 'yes' or word == 'Yes': | if word in ('YES', 'yes', 'Yes'):
    print('YES')                    |     print('YES')                                     |     print('YES')
else:                               |  else:                                               | else:
    print('NO')                     |     print('NO')                                      |     print('NO')
                                    |                                                      |
# YES                               |  # NO                                                | # NO
________________________________________________________________________________________________________________________
 breakpoint(*args, **kws) - Эта функция отправляет вас в отладчик на месте вызова. В частности, он вызывает
 sys.breakpointhook(). По умолчанию sys.breakpointhook() в свою очередь вызывает функцию pdb.set_trace().
________________________________________________________________________________________________________________________
 class bytearray(source, encoding, errors) - возвращает массив байтов bytearray, который является изменяемой
 последовательностью целых чисел в диапазоне от 0 <= х <256. bytearray('Hello', encoding='utf-8') -> bytearray(b'Hello')
________________________________________________________________________________________________________________________
 class bytes(source, encoding, errors) - Возвращает новый объект «байты», который представляет собой неизменяемую
 последовательность целых чисел в диапазоне от 0 <= х <256.  bytes('Hello', encoding='utf-8') -> b'Hello'
________________________________________________________________________________________________________________________
 callable(object) - возвращает True, если указанный объект вызываемый, в противном случае она возвращает значение False.
 Обратите внимание, что объект будет вызываемый, если в нем определен метод __call__().   callable(5) -> False
________________________________________________________________________________________________________________________
 chr(i) - вернет строку, представляющую символ, соответствующий переданному в качестве аргумента целому числу из таблицы
 символов Unicode (ASCII). Обратная операция ord().   ord('A') -> 65,  chr(65) -> 'A'
________________________________________________________________________________________________________________________
 @classmethod - Преобразует метод в метод класса. Метод класса получает cls = класс в качестве неявного первого аргумента.

 class C:
    @classmethod
    def f(cls, arg1, arg2): ...
________________________________________________________________________________________________________________________
 compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1) - Позволяет скомпилировать блок кода для
 выполнения в exec() или eval().
 exec(compile('x = 1\nz = x + 5\nprint(z)', 'a', 'exec')) -> 6
 compile('print("5 + 5 =", 5 + 5)', '', 'eval') -> 5 + 5 = 10
________________________________________________________________________________________________________________________
 class complex(real=0, imag=0), class complex(string) - создает/преобразовывает число/строку в комплексное число
 complex() -> 0j, complex(1) -> (1+0j),  complex(' 1+2j '), complex('   0.1+2.0j') -> (0.1+2j),    complex() # -> 0j
________________________________________________________________________________________________________________________
 delattr(object, name) - Позволяет удалить атрибут по имени указанного объекта

 class New:
    name = 'Chuck Norris'
    surname = 'Sasya'

 delattr(New, 'surname')
 del New.name # аналог
________________________________________________________________________________________________________________________
 class dict(**kwarg), class dict(mapping, **kwarg), class dict(iterable, **kwarg) - Создаcт новый словарь.  dict() -> {}
 dict(one=1, two=2, three=3), {'one': 1, 'two': 2, 'three': 3}, dict(zip(['one', 'two', 'three'], [1, 2, 3]))

 # 0 - это дескриптор файла. Мы можем получить доступ к потоку ввода-вывода через файловый дескриптор.
 # 0 - это stdin - стандартный ввод, тоже самое, что input().  open(0)
 lst_in = ['ножницы=100', 'котелок=500', 'спички=20', 'зажигалка=40', 'зеркальце=50']

 # Создали словарь и отсортировали по значению
 b_dict = dict((i.split('=') for i in lst_in))
 # b_dict = dict((i.split('=') for i in open(0)))   # stdin
 print(b_dict)  # -> {'ножницы': '100', 'котелок': '500', 'спички': '20', 'зажигалка': '40', 'зеркальце': '50'}
 print(*sorted(b_dict, key=lambda x: int(b_dict[x]), reverse=True))  # -> котелок ножницы зеркальце зажигалка спички
________________________________________________________________________________________________________________________
 dir() - без аргумента, возвращает список имен в текущей локальной области, а вызванная с аргументом попытается вернуть
 список допустимых атрибутов для указанного объекта.
________________________________________________________________________________________________________________________
 divmod(a, b) - возвращает: (a // b, a % b) — кортеж, содержащий частное и остаток от деления , divmod(9, 2) -> (4, 1)
________________________________________________________________________________________________________________________
 enumerate(iterable, start=0) - Счетчик элементов последовательности в циклах.
 list(enumerate(['a', 'b', 'c'])) -> [(0, 'a'), (1, 'b'), (2, 'c')]

 for index, value in enumerate('ab', 1):  ->  1: a
    print(f'{index}: {value}')                2: b

 def enumerate(iterable, start=0):
    n = start
    for elem in iterable:
        yield n, elem
        n += 1


 import collections

 e = enumerate("abcdef")
 print(isinstance(e, enumerate))                   # ->  True
 print(isinstance(e, collections.abc.Iterable))    # ->  True
 print(isinstance(e, collections.abc.Iterator))    # ->  True
 print(isinstance(e, collections.abc.Generator))   # ->  False
 print(type(e))   # -> <class 'enumerate'>
________________________________________________________________________________________________________________________
 eval(expression, globals=None, locals=None) - выполняет строку-выражение, переданную ей в качестве обязательного
 аргумента и возвращает результат выполнения этой строки.
 eval('1+1') -> 2, x = "print('Привет')"  eval(x) -> Привет, s=3 eval('s==3') -> True, eval('str(s)+"test"') -> 4test
________________________________________________________________________________________________________________________
 exec(object, globals=None, locals=None, /, *, closure=None) - поддерживает динамическое выполнение кода Python
 и принимает большие блоки кода, в отличие от eval(). Передаваемый функции код должен быть либо строкой,
 либо объектом кода, например сгенерированный функцией compile().
 exec('name = "John"\nprint(name)') -> John,   exec('print("5 + 10 =", (5+10))') -> 5 + 10 = 15
________________________________________________________________________________________________________________________
 filter(function, iterable) - отбирает/фильтрует элементы переданного объекта iterable при помощи пользовательской функции func.
 num = [1, 2.0, 3.1, 4, 5, 6, 7.9]
 отбираем числа > 4:   list(filter(lambda x: x > 4, num)) ->  [5, 6, 7.9]
 отбираем только целые числа:   list(filter(lambda x: type(x) is int, num)) ->  [1, 4, 5, 6]
 num = ['ноль', '1', '2.0', '3.1', '4', '5', '7.9', 'семь']
 отбираем строки с записью чисел:  list(filter(lambda x: x.replace(".", '').isdigit(), num)) -> ['1', '2.0', '3.1', '4', '5', '7.9']
 отбираем строки которые имеют вхождение символа точки '.': list(filter(lambda x: '.' in x, num)) -> ['2.0', '3.1', '7.9']
 lst = [0, 1, False, 2, '', 3, 'a', 's', 34]
 Удаление ложных значений (False, None, 0 и '') из списка с помощью filter():   list(filter(None, lst)) -> [1, 2, 3, 'a', 's', 34]
________________________________________________________________________________________________________________________
 class float(x=0.0) - Возвращает число с плавающей запятой, составленное из числа или строки x .
 float('+1.23') -> 1.23, float('   -12345\n') -> -12345.0, float('+1E6') -> 1000000.0, float('-Infinity') -> -inf
 float('NaN') -> nan, float('Inf') -> inf,   print(float())  # -> 0.0
________________________________________________________________________________________________________________________
 format(value, format_spec='') - строка, отформатированная в соответствии с форматом 'Mini-Language'.
 format(1, 'f') -> 1.000000, f'{1:f}' -> 1.000000, format(10, '.2f') -> 10.00, f'{10:.2f}' -> 10.00
 format('format', '.2') -> fo, f'{"format":.2}' -> fo, f"{10:.3f}" -> 10.000
________________________________________________________________________________________________________________________
 class frozenset(iterable=set()) - Вернет новый frozenset объект, возможно, с элементами, взятыми из iterable .
 iterable - строка или любая последовательность (итерация), которая имеет в качестве элементов "хешируемые" объекты.
 frozenset('мама мыла раму') -> frozenset({'л', 'р', 'м', 'а', 'у', ' ', 'ы'}), frozenset('ab') -> frozenset({'b', 'a'})
________________________________________________________________________________________________________________________
 getattr(object, name, default) -  возвращает значение атрибута указанного объекта object по его имени name.
 class New:
    name = 'Chuck Norris'
    surname = 'Sasya'

 getattr(New, 'name')
 New.name # аналог
 # del New.surname
 # getattr(New, 'surname') # AttributeError: type object 'New' has no attribute 'surname'
 # getattr(New, 'surname', 5) # -> 5
________________________________________________________________________________________________________________________
 globals() - возвращает словарь со значениями переменных, представляющий текущую глобальную область видимости модуля.
 Это всегда словарь области видимости переменных текущего модуля, а не функции или метода из которого он вызывается.
________________________________________________________________________________________________________________________
 hasattr(object, name) - проверяет существование атрибута с именем name в объекте object.
 Возвращает True, если атрибут с именем name существует, иначе False.
 Реализация функция hasattr() основывается на вызове функции getattr() с последующей проверкой на предмет брошенного
 ей исключения AttributeError.

 class New:
   name = 'Chuck Norris'
   surname = 'Sasya'

 hasattr(New, 'name') # True
 hasattr(New, 'age') # False
________________________________________________________________________________________________________________________
 hash() - возвращает хеш-значение объекта, если оно есть. Хэш-значения являются целыми числами. Они используются для
 быстрого сравнения ключей словаря во время поиска в словаре.
 hash(1) -> 1, hash(1.0) -> 1, hash(True) -> 1, hash('1') -> 7700504461803770333
________________________________________________________________________________________________________________________
 help() - вызывает встроенную справочную систему.
________________________________________________________________________________________________________________________
 hex() - преобразует целое число в шестнадцатеричную строку с префиксом 0x. может быть передан любой объект,
 реализующий метод __index__(), возвращающий целое число. hex(255) -> '0xff', hex(-42) -> '-0x2a'
________________________________________________________________________________________________________________________
 id(object) - возвращает уникальный идентификатор для указанного объекта. Это целое число, которое гарантированно будет
 уникальным и постоянным для этого объекта в течение его жизни. Два объекта с непересекающимися сроками жизни могут
 иметь одинаковое id() значение. Детали реализации CPython: это адрес объекта в памяти.
 id(1) -> 140728049197864
________________________________________________________________________________________________________________________
 input(), input(prompt) - позволяет обеспечить ввод пользовательских данных из консоли. Если передан необязательный
 аргумент подсказки prompt, то он записывается в стандартный вывод без завершающей строки. все что вводится в консоль
 при использовании встроенной функции input() преобразуется в тип str. Это происходит в том числе и с числами.
 Следовательно, числовые данные, перед их использованием необходимо распознавать и преобразовывать к нужным типам.
 for line in iter(input, 'good'):  -> пока input() не будет равен 'good'            a = input('Введите что-то:')
    print(line.upper())

 ints = [int(i) for i in iter(input, '10')] - создание списка чисел пока не введем '10'
 res = list(iter(input, '10'))              - создание списка пока не введем '10'
________________________________________________________________________________________________________________________
 class int(x=0), class int(x, base=10) -  возвращает целочисленный объект, созданный из числа или строки x, или
 возвращает 0, если аргументы не заданы. default=10    print(int())  # -> 0
 sys.int_info - содержит информацию о внутреннем представлении Python целых чисел.
 Ограничение распространяется только на потенциально медленные преобразования между int и str или bytes:
 int('2' * 5432) -> ValueError: Exceeds the limit (4300 digits), int(3.5) -> 3, int('3') -> 3
 int('0b1010', base=2) -> 10,   int('0o12', base=8) -> 10,   int('10', base=10) -> 10, int('0xa', base=16) -> 10
 int('0b1010', 2) -> 10,   int('0o12', 8) -> 10,   int('10', 10) -> 10, int('0xa', 16) -> 10   # без указания keyword

 По умолчанию система счисления десятичная, но можно задать любое основание от 2 до 36 включительно.
 Системы счисления:
 int('0b1010', base=2)  # -> 10   int('0b1010', 2)  # -> 10              bin(10)    # -> 0b1010
 int('0o12', base=8)    # -> 10   int('0o12', 8)    # -> 10              int('10')  # -> 10
 int('10', base=10)     # -> 10   int('10', 10)     # -> 10              oct(10)    # -> 0o12
 int('0xa', base=16)    # -> 10   int('0xa', 16)    # -> 10              hex(10)    # -> 0xa
________________________________________________________________________________________________________________________
 isinstance(object, classinfo) - вернет True, если проверяемый объект object является экземпляром любого указанного
 в classinfo класса (классов) или его подкласса (прямого, косвенного или виртуального=abstract base class). Иначе False
 Если аргумент classinfo не является классом, либо кортежем с классами то возбуждается исключение TypeError.
 isinstance('Hello', (float, int, str, list, dict, tuple)) -> True
 isinstance('Hello', float | int | str | list | dict | tuple) -> True
 a = 3
 isinstance(a, object)        # True
 type(a) == object            # False
 issubclass(type(a), object)  # True
________________________________________________________________________________________________________________________
 issubclass(class, classinfo) - возвращает True, если указанный класс class является подклассом указанного класса (классов)
 classinfo (прямым, косвенным или виртуальным=abstract base class) . Класс считается подклассом самого себя.
 issubclass(int, str | object) -> True,  issubclass(int, (str, object)) -> True
 issubclass(1, str | object) -> TypeError: issubclass() arg 1 must be a class

 class A:
    pass

 class B(A):
    pass

 issubclass(A, A) # True Подкласс самого себя
 issubclass(B, A) # True
 issubclass(A, B) # False

 class C:
     pass

 isinstance(B(), (A, C)) # True
 isinstance (B(), A | C) # True

 Не путайте!
 isinstance (B, A) # False
 Класс B унаследован от A, но он не является его сущностью. Классы сами по себе объекты и функция isinstance() к ним
 вполне применима. Класс B является сущностью класса type, который в свою очередь, унаследован от object, поэтому:
 isinstance(B, object) # True
________________________________________________________________________________________________________________________
 iter(object), iter(object, sentinel) - возвращает объект итератора. Первый аргумент object интерпретируется по-разному,
 в зависимости от наличия второго аргумента sentinel.
 Если НЕТ аргумента sentinel, то первый аргумент object должен быть объектом-коллекцией, которая поддерживает протокол
 итераций метод __iter__() или он должен поддерживать протокол последовательности метод __getitem__() с целыми
 аргументами, начиная с 0. Если он не поддерживает любой из этих протоколов, бросается исключение TypeError.

 Если передается аргумент sentinel, то ожидается, что первый аргумент object, поддерживает вызов __call__().
 В этом случае, созданный итератор будет вызывать указанный объект с каждым обращением к своему __next__() и проверять
 полученное значение на равенство со значением, переданным в аргумент sentinel. Если полученное значение равно sentinel,
 то бросается исключение StopIteration, иначе возвращается полученное значение.

 x = iter(["apple", "banana", "cherry"])
 print(next(x)) # apple
 print(next(x)) # banana
 print(next(x)) # cherry
 print(next(x)) # StopIteration

 Одно из применений второго аргумента sentinel это чтение строк файла, пока не будет достигнута, переданная в sentinel.
 Следующий пример считывает файл, пока метод readline() не вернёт пустую строку:

 with open('mydata.txt') as fp:
    # читаем, пока не попадется пустая строка
    for line in iter(fp.readline, sentinel=''):
        # Делаем что-то с line.

 Пользовательский тип, определивший __call__():

 class MyIterable(object):
    def __init__(self):
        self.index = 0
        self.items = [1, 2, 3, 4]

    def __call__(self):
        value = self.items[self.index]
        self.index += 1
        return value


 x = iter(MyIterable(), 2)  # будет выполнятся пока число не равно 2, если число равно 2 - StopIteration

 print(next(x)) # 1
 print(next(x)) # 2
 print(next(x)) # StopIteration
________________________________________________________________________________________________________________________
 len(s) - возвращает длину (количество элементов) в объекте.
 Детали реализации CPython: len поднимает OverflowError значения длины больше sys.maxsize, например: len(range(2 ** 100))
 len(['a', 'b', 'c']) -> 3, len('Hello') -> 5, len({'a': 1, 'b': 1, 'c': 1, 'd': 1}) -> 4
 len([i for i in range(10)]) # -> 10,  len(i for i in range(10)) # -> TypeError: object of type 'generator' has no len()
________________________________________________________________________________________________________________________
 class list(), class list(iterable) - создает или преобразует переданный объект, поддерживающий итерирование, в список
 (изменяемую последовательность с упорядоченными элементами). Элементы в списках упорядочены по очередности их добавления.
 Если аргумент iterable не указан, будет создан пустой список.     list('abc') # -> ['a', 'b', 'c'] ,   list()  # -> []
 list([1, 'foo', 2]) -> [1, 'foo', 2], list(('a', 'b', 'c')) -> ['a', 'b', 'c'], list(range(3)) -> [0, 1, 2]
________________________________________________________________________________________________________________________
 locals() - обновляет и возвращает словарь с переменными и их значениями из текущей локальной области видимости.
 Обратите внимание, что на уровне модуля, функции locals() и globals() возвращают один и тот же словарь.
 Содержимое словаря не следует изменять, потому как изменённые значения могут быть проигнорированы интерпретатором!

 asd = 1

 def func(a=1):
     b = 2
     c = a + b
     x = locals()
     print(x)

 func()
 # Заметьте в словаре нет глобальной переменной 'asd'
 {'c': 3, 'b': 2, 'a': 1}
________________________________________________________________________________________________________________________
 map(function, iterable, *iterables) - выполняет пользовательскую функцию function для каждого элемента последовательности,
 коллекции или итератора iterable. Каждый элемент iterable отправляется в функцию function в качестве аргумента.
 Если в map() передаётся несколько iterable, то пользовательская функция function должна принимать количество аргументов,
 соответствующее количеству переданных последовательностей, при этом function будет применяться к элементам из всех итераций параллельно.

 def plus(a, b, c):
    return a+b+c

 list(map(plus, [1, 2], [3, 4], [5, 6])) -> [9, 12]
 list(map(lambda x, y, z: x+y+z, [1, 2], [3, 4], [5, 6])) -> [9, 12]
 x = [1, 2, 3]
 y = [4, 5, 6, 7]
 list(map(pow, x, y)) -> [1, 32, 729]
 list(map(lambda a, b: a**b, x, y)) -> [1, 32, 729]
 list(map(str, [1, 2, 3])) -> ['1', '2', '3']
 list(map(len, ['a', 'ab', 'abc'])) -> [1, 2, 3]

 Преимуществ использования map():
 Так как функция map() написана на языке C и хорошо оптимизирована, ее внутренний цикл более эффективный, чем обычный цикл for в Python.

 Низкое потребление памяти. С помощью цикла for .. in: программе необходимо хранить в памяти системы весь список
 элементов последовательности над которым производятся какие-то действия внутри цикла. При помощи функции map() элементы
 последовательности извлекаются по запросу, следовательно при каждом внутреннем цикле map() в памяти системы находится
 и обрабатывается только один элемент последовательности.
________________________________________________________________________________________________________________________
 max(iterable, *, key=None), max(iterable, *, default, key=None), max(arg1, arg2, *args, key=None) - возвращает
 наибольшее значение элемента итерируемого объекта или самое большое из двух или более переданных позиционных аргументов.
 x = ['4', '11', '6', '31']
 max(x) -> '6',  max(x, key=lambda i: int(i)) -> 31,  max([1, 2, 3, 4], [3, 4, 5], key=sum) -> [3, 4, 5]
 max([]) -> ValueError: max() arg is an empty sequence,  max([], default=10) -> 10
 max(['Jul', 'John', 'Vicky'], key=len) -> Vicky, max(i for i in range(10)) # -> 9
 lst = [[1, 2, 3], [4, 5], [1, 3, 4, 5], [10, 20]],  max(lst, key=sum) -> [10, 20],  max(lst, key=len) -> [1, 3, 4, 5]
 max((i for i in range(10)), [10, 20]) # -> TypeError: '>' not supported between instances of 'list' and 'generator'
 max([i for i in range(10)], (10, 20)) # -> TypeError: '>' not supported between instances of 'tuple' and 'list'
 max([i for i in range(10)], [10, 20]) # -> [10, 20]
 max(10, 'a') # -> TypeError: '>' not supported between instances of 'str' and 'int', max(10, 'a', key=str) # -> a
________________________________________________________________________________________________________________________
 min(iterable, *, key=None), min(iterable, *, default, key=None), min(arg1, arg2, *args, key=None) - возвращает
 минимальное значение элемента из итерируемого объекта или наименьшее из двух или более переданных позиционных аргументов.
 x = ['4', '11', '6', '31']
 min(x) -> '4',  min(x, key=lambda i: int(i)) -> '4',  min([1,2,3,4], [3,4,5], key=sum) -> [1,2,3,4]
 min([]) -> ValueError: min() arg is an empty sequence, min([], default=0) -> 0
 lst = [5, 3, 1, 0, 9, 7]
 lst_num = list(enumerate(lst)) -> [(0, 5), (1, 3), (2, 1), (3, 0), (4, 9), (5, 7)]
 t_min = min(lst_num, key=lambda i : i[1]) -> (3, 0), t_min[0] -> 3
________________________________________________________________________________________________________________________
 class memoryview(object) - возвращает ссылку на буфер обмена памяти, в которой находится переданный в качестве
 аргумента объект object. Объект object должен поддерживать протокол буфера обмена.
 Протокол буфера обмена поддерживают встроенные объекты, такие как bytes, bytearray и некоторые типы расширений array.array
________________________________________________________________________________________________________________________
 next(iterator), next(iterator, default) - возвращает следующий элемент итератора, вызвав его метод __next__().Бросается
 исключение StopIteration, если значение по умолчанию default не задано. Возвращается значение default, если оно задано.

 def fruit_generate():
    # Создадим итератор при помощи генератора.
    for item in ['apple', 'banana', 'cherry']:
        yield item

 fruit = fruit_generate()

 print(next(fruit))  # apple
 print(next(fruit))  # banana
 print(next(fruit))  # cherry
 print(next(fruit))  # StopIteration

 fruit = iter(['apple', 'banana', 'cherry'])
 print(next(fruit, 'STOP'))  # apple
 print(next(fruit, 'STOP'))  # banana
 print(next(fruit, 'STOP'))  # cherry
 print(next(fruit, 'STOP'))  # STOP
________________________________________________________________________________________________________________________
 class object - возвращает новый безликий объект. Класс object() является базой для всех классов. В нем есть методы,
 общие для всех экземпляров классов Python. Kласс object - это экземпляр типа type. object не имеет словаря __dict__
 isinstance(object, object) -> True , isinstance(type, object) -> True

 Обратите внимание, что объект не имеет словаря __dict__
 поэтому нельзя назначить произвольные атрибуты экземпляру класса object().

 obj = object()
 print(obj)  # -> <object object at 0x000001D6411A4960>
 print('__dict__' in dir(obj))  # -> False
 object().__dict__  # -> AttributeError: 'object' object has no attribute '__dict__'. Did you mean: '__dir__'?

 from enum import Enum
 class Color(Enum):
     RED = object()
     GREEN = object()
     BLUE = object()

 Color.RED          # -> Color.RED
 Color.RED.value    # -> <object object at 0x000001360B224960>
 Color.GREEN        # -> Color.GREEN
 Color.GREEN.value  # -> <object object at 0x000001360B224930>
 Color.BLUE         # -> Color.BLUE
 Color.BLUE.value   # -> <object object at 0x000001360B224970>
________________________________________________________________________________________________________________________
 oct(x) - преобразует целое число в восьмеричную строку с префиксом 0o.  oct(8) -> '0o10', oct(-56) -> '-0o70'
________________________________________________________________________________________________________________________
 open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) - Открывает
 файл для чтения или записи при помощи файлового потока. Если файл не может быть открыт, бросается исключение OSError.
________________________________________________________________________________________________________________________
 ord(x) - для символа x вернет число, из таблицы символов Unicode(ASCII) представляющее его позицию.
 ord('a') возвращает целое число 97 . Обратная операция chr().   ord('A') -> 65,  chr(65) -> 'A'
________________________________________________________________________________________________________________________
 pow(base, exp, mod=None) - возвращает результат возведения числа base в степень exp, с опциональным делением по
 модулю mod. pow(base, exp) эквивалентно использованию оператора возведения в степень: base ** exp.
 pow(3, 2) -> 9,  pow(5, -3) -> 0.008,  pow(1.5, 3) -> 3.375, pow(5, 3, 4) -> 1, pow(5, 3, -2) -> -1
________________________________________________________________________________________________________________________
 print(*objects, sep=' ', end='\n', file=None, flush=False) - выводит объекты в текстовый поток, отделяя их друг от друга
 sep и заканчивая поток end. sep, end, file и flush, если они заданы, должны быть переданы в качестве аргументов ключевых слов.
 sep=' ' - строка, разделитель объектов. Значение по умолчанию - пробел ' '.
 end='\n' - строка, которой заканчивается поток. Значение по умолчанию '\n'.
 file=sys.stdout - объект, реализующий метод file.write(string). Значение по умолчанию sys.stdout.
 flush=False - если True поток будет сброшен в указанный файл file принудительно. Значение по умолчанию False
 Параметр flush=True в функции print() заставляет немедленно выводить данные на экран, игнорируя буферизацию.   <-----
 print(11, 12, 13, 14, sep=';') ->  11;12;13;14,  print('перенос \nс строки') -> перенос   с строки, print(10.) -> 10.0
________________________________________________________________________________________________________________________
 class property(fget=None, fset=None, fdel=None, doc=None) -  Вернуть атрибут свойства.
 fget=None - функция для получения значения атрибута
 fset=None - функция для установки значения атрибута
 fdel=None - функция для удаления значения атрибута
 doc=None  - строка, для строки документации атрибута

 class C:
    def __init__(self):
        self._x = None

    @property
    def x(self): # В декораторах 'setter' и 'deleter' нужно указывать имя метода-свойства
        return self._x

    @x.setter
    def x(self, value):
        self._x = value

    @x.deleter
    def x(self):
        del self._x
________________________________________________________________________________________________________________________
 class range(stop), class range(start, stop, step=1) - Класс range() (диапазон) генерирует арифметическую прогрессию
 целых чисел, с заданным шагом. По существу это отдельный неизменяемый тип данных в языке Python.
 list(range(3)) -> [0, 1, 2],  list(range(0, 10, 3)) -> [0, 3, 6, 9],  list(range(0, -5, -1)) -> [0, -1, -2, -3, -4]
________________________________________________________________________________________________________________________
 repr(object) - вернет строку, содержащую печатаемое формальное представление объекта. Для многих типов функция
 возвращает строку, которая при передаче в eval() может произвести объект с тем же значением, что и исходный.

 repr('Hello') -> "'Hello'",  repr([1, 2, 3]) -> '[1, 2, 3]',  repr(range(5)) -> 'range(0, 5)', eval(repr('He')) -> He

 class Person:
   def __init__(self, name, age):
      self.name = name
      self.age = age

   def __repr__(self):
      return f"Person('{self.name}', {self.age})"
________________________________________________________________________________________________________________________
 reversed(seq) - возвращает обратный итератор, то есть возвращает итератор, который перебирает элементы оригинала
 в обратном порядке. Не создает копию и не изменяет оригинал последовательности.
 Объект seq должен иметь метод __reversed__() или поддерживает протокол последовательности,
 это метод __len__() и метод __getitem__() с целочисленными аргументами, начинающимися с 0.
 reversed([1, 2, 3]) -> <list_reverseiterator object at 0x000001B9E22C4E80>, list(reversed([1, 2, 3])) -> [3, 2, 1]
 [i for i in reversed([1, 2, 3])] -> [3, 2, 1],                 НЕ Работает с generator/iterator  (Любой итератор)
________________________________________________________________________________________________________________________
 round(number, ndigits=None) -> вернет число, округленное до точности ndigits после десятичной точки. БАНКОВСКОЕ ОКРУГЛЕНИЕ
 Если аргумент ndigits опущен или None, то вернет ближайшее целое число.           округляются до ближайшего четного числа
 round(1.5) -> 2,  round(5.76543) -> 6, round(5.76543, 2) -> 5.77, round(5.76543, 3) -> 5.765, round(2.675, 2) -> 2.67
________________________________________________________________________________________________________________________
 class set, class set(iterable) - создает или преобразует переданный объект iterable, поддерживающий итерирование,
 в новое множество set. Если аргумент iterable не указан, будет создано пустое множество.   print(set())  # -> set()
 При преобразовании словаря dict в множество попадают только ключи.
 set(dict(apple='green', banana='yellow', cherry='red')) -> {'banana', 'cherry', 'apple'}
 set() -> set(), set(range(3)) -> {0, 1, 2}, set(['a', 'b', 'c']) -> {'b', 'a', 'c'}, set(('a', 'b', 'c')) -> 'c', 'a', 'b'}
________________________________________________________________________________________________________________________
 setattr(object, name, value) - Это аналог функции getattr(). Аргументами являются объект object, строка с именем name
 атрибута и произвольное значение value устанавливаемого атрибута.
 Для возвращения атрибута используется getattr().
 Для удаления атрибута используется delattr().
 Для проверки существования атрибута используется hasattr().

 class New:
   name = 'Chuck Norris'
   surname = 'Sasya'

 setattr(New, 'name', 'SuperSasya')  # установили новый атрибут
 delattr(New, 'surname')  # удалили атрибут
 hasattr(New, 'surname')  # False
 getattr(New, 'name')  # 'SuperSasya'
________________________________________________________________________________________________________________________
 class slice(stop), class slice(start, stop, step=None) ->  Шаблон среза, который можно применить к последовательности
 Каждый объект slice() в Python имеет метод .indices. Этот метод возвращает кортеж (start, end, step)
 my_slice = slice(None, None, 2) -> эквивалентно [::2], [1, 2, 3][slice(None, None, 2)] -> [1, 3]
 [1, 2, 3][slice(None, None, -1)] -> [3, 2, 1], my_slice = slice(None, None, -1) -> [1, 2, 3][my_slice] -> [3, 2, 1]
________________________________________________________________________________________________________________________
 sorted(iterable, /, *, key=None, reverse=False) - Вернет новый отсортированный список из элементов в iterable .
 Функция имеет два необязательных аргумента, которые должны быть указаны в качестве аргументов ключевых слов.
 Аргумент key принимает функцию, например key=str.lower. Переданная функция вычисляет результат для каждого элемента
 последовательности, который используется для сравнения элементов при сортировке. Значением по умолчанию является None,
 т.е. сравнивать элементы напрямую (как есть).
 Аргумент reverse=False имеет логическое значение. Если установлено значение True, то элементы списка сортируются
 в обратной последовательности (по убыванию).

 line = 'This is a test string from Andrew'
 x = sorted(line.split(), key=str.lower)
 print(x)
 # ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']

 class Student:
    def __init__(self, name, grade, age):
        self.name = name
        self.grade = grade
        self.age = age

    def __repr__(self):
        return repr((self.name, self.grade, self.age))

 student = [
     Student('john', 'A', 15),
     Student('jane', 'B', 12),
     Student('dave', 'B', 10),
     ]

 x = sorted(student, key=lambda student: student.age)
 print(x)
 # [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

 student = [
    ('john', 15, 4.1),
    ('jane', 12, 4.9),
    ('dave', 10, 3.9),
    ('kate', 11, 4.1),
    ]

 # По средней оценке
 x = sorted(student, key=lambda num: num[2])
 # По убыванию возраста
 y = sorted(x, key=lambda age: age[1], reverse=True)
 print(y)
 # [('john', 15, 4.1), ('jane', 12, 4.9), ('kate', 11, 4.1), ('dave', 10, 3.9)]

 А еще, для сортировок по нескольким ключам, удобнее использовать модуль operator.
 from operator import itemgetter

 x = sorted(student, key=itemgetter(2,1))
 print(x)
 # [('dave', 10, 3.9), ('kate', 11, 4.1), ('john', 15, 4.1), ('jane', 12, 4.9)]

________________________________________________________________________________________________________________________
 @staticmethod - декоратор staticmethod() преобразует метод класса в статический метод этого класса.
 Статический метод не получает неявный первый аргумент self класса.

 class C:
    @staticmethod
    def f(arg1, arg2, argN): ...

 Как и все декораторы, staticmethod() можно вызывать как обычную функцию и что-то делать с ее результатом.
 Это необходимо в некоторых случаях, когда вам нужна ссылка на функцию из тела класса, и вы хотите избежать
 автоматического преобразования в метод экземпляра. Для этих случаев используйте эту идиому

 def regular_function():
    ...

 class C:
    method = staticmethod(regular_function)

 Изменено в версии 3.10: Статические методы теперь наследуют атрибуты метода ( __module__, __name__, __qualname__ и ),
 имеют новый атрибут и теперь могут вызываться как обычные функции __doc__.__annotations____wrapped__
________________________________________________________________________________________________________________________
 class str(object=''), class str(object=b'', encoding='utf-8', errors='strict') - выполнит преобразование и
 вернет строковую версию объекта. Если объект не указан, класс str() возвращает пустую строку. В противном случае
 поведение str() зависит от того, задано ли кодировка encoding или значение errors обработчика ошибок.
 str(10) -> '10',  str(3.5) -> '3.5',  str(list(range(5))) -> '[0, 1, 2, 3, 4]'
________________________________________________________________________________________________________________________
 sum(iterable, /, start=0) - начинает суммирование элементов последовательности iterable с начального значения start,
 если оно указано, сложение происходит слева направо и в результате возвращает их сумму.
 sum([1, 2], start=1) -> 4,  sum([1, 2]) -> 3,  sum([1], start=1) -> 1, sum({1, 2}) -> 3, sum({1:2, 2:2}) -> 3
________________________________________________________________________________________________________________________
 class super, class super(type, object_or_type=None) - возвращает объект-посредник, который делегирует вызовы метода
 родительскому или родственному классу, указанного type типа. Это полезно для доступа к унаследованным методам, которые
 были переопределены в классе.
                                                                       Простой пример:
 class Computer():                                                     class A:
    def __init__(self, computer, ram, ssd):                                def some_method(self):
        self.computer = computer                                               print('some_method A')
        self.ram = ram                                                 class B(A):
        self.ssd = ssd                                                     def some_method(self):
                                                                               super().some_method()    <-----
 # Если создать дочерний класс `Laptop`, то будет доступ                       print('some_method B')
 # к свойству базового класса благодаря функции super().               x = B()
 class Laptop(Computer):                                               x.some_method()
     def __init__(self, computer, ram, ssd, model):
         super().__init__(computer, ram, ssd)                          # some_method A
         self.model = model                                            # some_method B


 lenovo = Laptop('lenovo', 2, 512, 'l420')

 print('This computer is:', lenovo.computer)
 print('This computer has ram of', lenovo.ram)
 print('This computer has ssd of', lenovo.ssd)
 print('This computer has this model:', lenovo.model)
 # Вывод
 # This computer is: lenovo
 # This computer has ram of 2
 # This computer has ssd of 512
 # This computer has this model: l420
________________________________________________________________________________________________________________________
 class tuple, class tuple(iterable) - создает новую неизменяемую последовательность - кортеж из итерируемого объекта,
 элементы которого идут в том же порядке, что и элементы переданного в качестве аргумента объекта.  tuple() -> ()

 tuple('Hello') -> ('H', 'e', 'l', 'l', 'o'),  tuple(range(6, 20, 2)) -> (6, 8, 10, 12, 14, 16, 18)

 x = {'a': 1, 'b': 3, 'c': 4}                             a_dict = {'a': 1, 'b': 3, 'c': 4}
 y = [(a, b) for a, b in x.items()]                       tuple(x)
 print(y) -> [('a', 1), ('b', 3), ('c', 4)]               ('a', 'b', 'c')
________________________________________________________________________________________________________________________
 class type(object),  class type(name, bases, dict, **kwds) - Возвращает тип объекта и является собственным метаклассом языка Python

 с одним аргументом object возвращает тип объекта. Возвращаемое значение - это как правило, тот же объект,
 что и возвращаемый object.__class__.  type() - тоже обьект

 # type - это тип всех типов, для которых не указан явно иной метакласс
 type(type)
 # <class 'type'>
 type(object)
 # <class 'type'>
 type(list)
 # <class 'type'>
 type(int)
 # <class 'type'>
 class Bar(object): pass
 type(Bar)
 # <class 'type'>

 Класс type() с тремя аргументами вернет объект нового типа. Это по сути динамическая форма инструкции class, ее еще называют метакласс.
 другими словами класс type(), вызванный с тремя аргументами на самом деле является метаклассом!
 Класс type() это метакласс, который Python внутренне использует для создания всех классов.
 Примеры создания и изменения классов "на лету" при помощи type():

 class Foo(object):
       bar = True
 print(Foo.bar)  # True

 Foo = type('Foo', (), {'bar':True})
 print(Foo.bar)  # True

 class X:
    a = 1
 print(X.a)  # 1

 X = type('X', (), dict(a=1))
 print(X.a) # 1
________________________________________________________________________________________________________________________
 vars(), vars(object) - вернет атрибут __dict__ - словарь пространства имен для модуля, класса, экземпляра или любого
 другого объекта с атрибутом __dict__.

 Такие объекты, как модули и экземпляры классов, имеют обновляемый __dict__ атрибут, однако другие объекты могут иметь
 ограничения для записи своих атрибутов dict, например классы, которые используют types.MappingProxyType для
 предотвращения прямого обновления словаря.

 Без аргумента vars() действует как встроенная функция locals(). Обратите внимание, что словарь переменных локальной
 области видимости полезен только для чтения, поскольку обновление словаря локальной области видимости игнорируются интерпретатором.

 # Можно использовать все встроенные функции
 print(vars(__builtins__)['max'](1, 2))                   # -> 2
 print(vars(__builtins__)['min'](['a', 'ab'], key=len))   # -> a
 print(vars(__builtins__)['sum']([1, 2]))                 # -> 3

 # Посмотреть все возможные атрибуты
 print(__builtins__.globals())         # -> {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__':...
 print(__builtins__.locals())          # -> {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__':...
 print(__builtins__.vars())            # -> {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__':...
________________________________________________________________________________________________________________________
 zip(*iterables, strict=False) -  создает итератор кортежей, который объединяет элементы каждой из переданных
 последовательностей *iterables.

 # Классный пример
 lst = ['Москва', 'Уфа', 'Тула', 'Самара', 'Омск', 'Воронеж', 'Владивосток', 'Лондон', 'Калининград', 'Севастополь']
 list(zip(*[iter(lst)]*3))
 # -> [('Москва', 'Уфа', 'Тула'), ('Самара', 'Омск', 'Воронеж'), ('Владивосток', 'Лондон', 'Калининград')]

 x = iter([1, 2, 3, 4, 5, 6, 7, 8, 9])
 print(*zip(x, x, x))  # -> (1, 2, 3) (4, 5, 6) (7, 8, 9)


 for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):
    print(item)

 (1, 'sugar')
 (2, 'spice')
 (3, 'everything nice')

 list(zip(range(3), ['fee', 'fi', 'fo', 'fum']))
 # [(0, 'fee'), (1, 'fi'), (2, 'fo')]

 list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True))
 # [('a', 1), ('b', 2), ('c', 3)]

 strict=True (доступен с версии Python 3.10), проверяет идентичность длин итераций, вызывая ошибку ValueError, если они не совпадают:
 list(zip(range(3), ['fee', 'fi', 'fo', 'fum'], strict=True))
 # Traceback (most recent call last):
 #   ...
 # ValueError: zip() argument 2 is longer than argument 1

 Распаковка списка кортежей на отдельные списки:
 x = [1, 2, 3]
 y = [4, 5, 6]
 # объединим два списка
 zipped = zip(x, y)
 list(zipped)
 # [(1, 4), (2, 5), (3, 6)]

 # распакуем полученный список кортежей
 x2, y2 = zip(*zipped)
 # сравниваем полученные списки с их исходными значениями
 list(x2) == x and list(y2) == y
 # True

 Создание словаря из двух списков:
 lst1 = [0, 1, 2, 3, 4, 5]
 lst2 = ['zero', 'one', 'two', 'three', 'four', 'five']
 # создаем словарь при помощи `dict()`
 dict(zip(lst1, lst2))
 # {0: 'zero', 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five'}

 # создаем словарь при помощи выражения генератора словаря, при этом меняем элементы списков местами
 d = {y: x for x, y in zip(lst1, lst2)}
 d
 # {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5}
________________________________________________________________________________________________________________________
 __import__(name, globals=None, locals=None, fromlist=(), level=0) - находит и импортирует модуль
 Это продвинутая функция, которая не нужна в повседневном программировании на Python, в отличие от importlib.import_module().
________________________________________________________________________________________________________________________







































"""