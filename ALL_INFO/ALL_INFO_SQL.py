"""

 Structured Query Language (SQL) — декларативный язык программирования, применяемый для создания, модификации и управления
 данными в реляционной базе данных, управляемой соответствующей системой управления базами данных.


 -- Проектирование базы данных (БД) --

 Проектирование БД - это процесс создания структуры базы данных для эффективного хранения, управления и обработки данных.

 Проектирование БД — это баланс между:

 - Нормализацией (минимизация дублирования) и производительностью (денормализация, индексы).
 - Гибкостью (под будущие изменения) и оптимизацией (под текущие запросы).


 Основные этапы проектирования БД:
 1) Анализ требований
 - Определение целей БД.
 - Выявление сущностей, их атрибутов и взаимосвязей.

 2) Концептуальная модель (ER-диаграмма)
 - Моделирование сущностей, атрибутов и связей между ними.
 - Пример:
   - Сущность "Пользователь" (атрибуты: id, имя, email).
   - Сущность "Заказ" (атрибуты: id, дата, сумма).
   - Связь: "Один ко многим" (1 пользователь → N заказов).

 3) Логическая модель
 - Преобразование ER-диаграммы в схему БД.
 - Определение таблиц, столбцов, первичных и внешних ключей.

 4) Нормализация
 - Устранение избыточности данных (обычно до 3НФ).
 - Дополнение: Иногда применяют денормализацию для ускорения запросов (например, в аналитических БД).

 5) Физическая модель
 - Реализация БД в конкретной СУБД (PostgreSQL, MySQL и др.).
 - Выбор типов данных, настройка индексов, партиционирование.
 - Дополнение:
   - Индексы ускоряют поиск, но замедляют вставку/обновление.
   - Важно учитывать безопасность (права доступа, шифрование).
   - Партиционирование (по диапазонам, спискам, хешу).
   - Репликация и шардирование для распределенных БД.
   - Оптимизация запросов через EXPLAIN ANALYZE в PostgreSQL.

 6) Тестирование и доработка
 - Проверка корректности данных и производительности.
 - Оптимизация запросов, индексов, структуры таблиц.

 7) Безопасность
 - SQL-инъекции и параметризованные запросы. - Экранирование


 Основные принципы проектирования БД:
 - Минимизация дублирования данных (нормализация).
 - Обеспечение целостности (первичные и внешние ключи).
 - Удобство запросов (индексы, структура таблиц).
 - Масштабируемость (гибкость для будущих изменений).


 Пример реализации в SQL

 -- Таблица "Пользователи"
 CREATE TABLE Users (
     id INT PRIMARY KEY,
     имя VARCHAR(100) NOT NULL,
     email VARCHAR(100) UNIQUE NOT NULL
 );

 -- Таблица "Заказы" (связь один-ко-многим)
 CREATE TABLE Orders (
     id INT PRIMARY KEY,
     user_id INT,
     дата DATE NOT NULL,
     сумма DECIMAL(10, 2) NOT NULL,
     FOREIGN KEY (user_id) REFERENCES Users(id)
 );

 -- Создание индекса для ускорения поиска по email
 CREATE INDEX idx_user_email ON Users(email);


 Итог!
 Правильное проектирование БД обеспечивает:
 - Эффективное хранение данных (минимум дублирования).
 - Быстрые запросы (индексы, нормализация/денормализация).
 - Надежность (целостность, безопасность).
 - Гибкость (масштабируемость под будущие изменения).

 -- END Проектирование базы данных (БД) --



 -- Какие есть ОПТИМИЗАЦИИ в SQL КРОМЕ индексов  --

 1. Партиционирование
 - Разделение таблицы на физические части (партиции) по ключу (например, по дате или диапазону значений).
 - Улучшает производительность при работе с большими таблицами, особенно при операциях чтения.

 2. Кэширование запросов
 - Некоторые СУБД (MySQL, PostgreSQL, Oracle) кэшируют результаты запросов.
   - В PostgreSQL кэш запросов (plan cache) работает автоматически, но нет встроенного кэша результатов.
 - Внешние кэши (Redis, Memcached) тоже помогают ускорить повторяющиеся запросы.

 3. Оптимизация JOIN
 - Правильный порядок таблиц (меньшие таблицы сначала, если нет фильтрации).
 - Использование INNER JOIN вместо OUTER JOIN, где возможно.
 - Применение HASH JOIN, MERGE JOIN или NESTED LOOPS в зависимости от данных.

 4. Денормализация
 - Сознательное дублирование данных для ускорения чтения.
 - Пример: хранение имени пользователя в заказе, чтобы не делать JOIN с users.

 5. Временные таблицы и CTE (Common Table Expressions)
 - Временные таблицы (CREATE TEMP TABLE) помогают разбивать сложные запросы.
 - CTE (WITH ... AS) улучшают читаемость и иногда оптимизируют выполнение.

 6. Оптимизация запросов
 - Избегание SELECT * – выбирать только нужные столбцы.
 - Замена LIKE '%text%' на полнотекстовый поиск (если возможно).
 - Минимизация подзапросов, замена их на JOIN или временные таблицы.
 - Использование EXISTS вместо IN для больших наборов данных.
 - Избегание NOT IN (лучше NOT EXISTS или LEFT JOIN ... WHERE NULL).
 - Использование UNION ALL вместо UNION, если дубликаты не нужны.

 - Оптимизация подзапросов:
 Замена коррелированных подзапросов на JOIN.

 Пример:

 -- Плохо (для каждой строки выполняется подзапрос)
 SELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE active = 1);

 -- Лучше
 SELECT orders.* FROM orders JOIN customers ON orders.customer_id = customers.id
 WHERE customers.active = 1;

 7. Настройка СУБД
 - Оптимизация размера буферного кэша (shared_buffers в PostgreSQL, innodb_buffer_pool_size в MySQL).
 - Настройка параллельного выполнения запросов (max_parallel_workers).
 - Оптимизация параметров сортировки и работы с временными таблицами.

 8. Материализованные представления
 - Предварительно рассчитанные данные, которые периодически обновляются.
 - Пример: CREATE MATERIALIZED VIEW ... REFRESH ... в PostgreSQL.

 9. Сжатие данных
 - Встроенное сжатие в СУБД (например, TABLESPACE в Oracle, COMPRESS в MySQL).
 - Уменьшает место на диске и ускоряет чтение (но может замедлить запись).

 10. Векторизация и пакетная обработка
 - Некоторые СУБД (ClickHouse, современные версии PostgreSQL) поддерживают векторизацию.
 - Пакетная вставка (INSERT ... VALUES (...), (...), ...) вместо одиночных запросов.

 Дополнительные методы:
 Шардинг                          - горизонтальное разделение данных между серверами.
 Оптимизация типов данных         - выбор подходящих типов (INT вместо VARCHAR для чисел).
 Использование частичных индексов - индексы только для нужных строк (WHERE condition).
 Оптимизация транзакций           - меньшие транзакции, правильный уровень изоляции.

 EXPLAIN ANALYZE - это команда в SQL, которая показывает план выполнения запроса и реальное время его работы
 EXPLAIN ANALYZE - главный инструмент для поиска и устранения «тормозов» в SQL.



 -- EXPLAIN ANALYZE - команда SQL для анализа запросов (в PostgreSQL, в MySQL - EXPLAIN FORMAT=JSON/TREE) --

 EXPLAIN ANALYZE — это команда SQL, которая показывает:

 1) Как выполняется запрос
  - Использует ли индекс (Index Scan) или сканирует всю таблицу (Seq Scan).
  - Где тратится больше всего времени (JOIN, сортировка и т.д.).

 2) Помогает оптимизировать
  - Если видите Seq Scan на большой таблице — возможно, нужен индекс.
  - Если Index Scan медленный — индекс может быть неэффективен.

 3) Показывает время и затраты
 - Сколько строк обработано (rows=...).
 - Сколько времени занял каждый этап.

 Пример:

 EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';
 - С индексом: Быстрый Index Scan (0.05 мс).
 - Без индекса: Медленный Seq Scan (0.2 мс + проверка всех строк).

 Когда использовать?
 - Для поиска и исправления медленных запросов.
 - Перед добавлением индексов.

 Итог: Инструмент для поиска и устранения "тормозов" в SQL.


 -- EXPLAIN vs EXPLAIN ANALYZE  в PostgreSQL --

 EXPLAIN         - показывает план выполнения запроса без его реального выполнения.
 EXPLAIN ANALYZE - выполняет запрос и показывает фактическое время выполнения, а также дополнительные метрики
 (например, количество строк, затраченное время).

 EXPLAIN
 - Только показывает план выполнения запроса, который оптимизатор PostgreSQL собирается использовать.
 - Не выполняет запрос на самом деле.
 - Полезен для предварительного анализа и оптимизации запросов без их реального выполнения.

 EXPLAIN ANALYZE
 Выполняет запрос и собирает статистику.
 Показывает:
 - План выполнения (как EXPLAIN).
 - Фактическое время выполнения каждого шага.
 - Количество обработанных строк.
 - Другие метрики (например, использование буферов, если добавить BUFFERS).
 - Полезен для точного анализа производительности, но изменяет данные (если запрос модифицирующий).

 Для INSERT/UPDATE/DELETE используйте EXPLAIN ANALYZE с осторожностью, так как он выполнит изменения!

 EXPLAIN         - только план.
 EXPLAIN ANALYZE - план + реальные данные выполнения.

 # Примеры

 -- Только план
 EXPLAIN SELECT * FROM users WHERE id = 1;

 -- План + фактические метрики выполнения
 EXPLAIN ANALYZE SELECT * FROM users WHERE id = 1;


 -- Планировщик в SQL --

 Планировщик в SQL (например, SQL Server Agent в MS SQL или pgAgent в PostgreSQL) — это инструмент для автоматического
 выполнения задач (резервное копирование, очистка данных, запуск скриптов и т. д.) по расписанию.

 Уточнения по СУБД:
 Microsoft SQL Server – SQL Server Agent (встроенный планировщик, поддерживает задания, оповещения, сложные сценарии).

 PostgreSQL – pgAgent (сторонний планировщик, требует отдельной установки) или cron (альтернатива через системные задачи).

 MySQL/MariaDB – Event Scheduler (встроенный механизм для периодических задач).

 Oracle – Oracle Scheduler (DBMS_SCHEDULER, мощный инструмент для сложных расписаний).

 Если нужно ещё короче:
 "Планировщик SQL — это сервис для автоматического выполнения задач в БД по расписанию."

 -- END Планировщик в SQL --


 При сравнении NULL с ЛЮБЫМ другим значением, включая 0, результат всегда будет NULL, а не TRUE или FALSE.   <-----

 В SQL значение NULL представляет собой отсутствие данных или неопределенное значение.

 При сравнении NULL с ЛЮБЫМ другим значением, включая 0, результат всегда будет NULL, а не TRUE или FALSE.
 Это значит, что NULL не может быть ни больше, ни меньше, ни равно чему-либо другому.

 Таким образом, в SQL можно сказать, что:

 0 > NULL: результат будет NULL (неопределено)
 0 < NULL: результат будет NULL (неопределено)
 0 = NULL: результат будет NULL (неопределено)
 Если вам нужно проверить, является ли значение NULL, вы можете использовать оператор IS NULL.


 Разница между UNION и UNION ALL заключается в том, что UNION удаляет дубликаты из результата,
 а UNION ALL сохраняет все строки, включая дубликаты.



 -- При JOIN в SQL, если для INT поля не найдено соответствие, результат зависит от типа соединения --

 - Для LEFT/RIGHT/FULL JOIN INT поле будет NULL, если соответствие не найдено.
 - Для INNER JOIN такие строки не попадут в результат.


 Примеры:

  -- Данные
 CREATE TABLE A(id INT);
 INSERT INTO A VALUES (1), (2);

 CREATE TABLE B(id INT, num INT);
 INSERT INTO B VALUES (1, 100);

 -- Запрос LEFT JOIN                                  -- Запрос INNER JOIN
 SELECT A.id, B.num                                   SELECT A.id, B.num
 FROM A                                               FROM A
 LEFT JOIN B ON A.id = B.id;                          JOIN B ON A.id = B.id;

 #  LEFT JOIN (NULL при отсутствии совпадений)        # INNER JOIN (только совпадения)
 Результат:                                           Результат:
 1 | 100                                              1 | 100 (id=2 не выведен)
 2 | NULL (нет совпадения → num=NULL)
 RIGHT JOIN и FULL JOIN (работают аналогично LEFT JOIN).

 # Разница одной строкой:

 INNER JOIN = только пересечение (как строгий фильтр).
 LEFT JOIN = все из левой таблицы + NULL справа при отсутствии совпадений.

 Аналогично работают RIGHT и FULL JOIN.

 # Более Краткий пример
 -- LEFT JOIN → NULL при отсутствии совпадений
 SELECT A.id, B.num FROM A LEFT JOIN B ON A.id = B.id;
 -- Результат: 1|100, 2|NULL

 -- INNER JOIN → только совпадения
 SELECT A.id, B.num FROM A JOIN B ON A.id = B.id;
 -- Результат: 1|100

 -- END При JOIN в SQL, если для INT поля не найдено соответствие, результат зависит от типа соединения --



 -- Self JOIN в PostgreSQL --

 -- Пример: найти сотрудников с одинаковой зарплатой
 SELECT
     a.id,
     a.name,
     a.salary,
     b.id as colleague_id,
     b.name as colleague_name
 FROM employees a
 JOIN employees b ON a.salary = b.salary AND a.id != b.id;


 Ключевые моменты:

 - Таблица соединяется сама с собой под разными алиасами (a, b).
 - Условие a.id != b.id исключает совпадение строки с самой собой.
 - Можно использовать LEFT JOIN, если нужно сохранить все строки из первой таблицы.

 Где использовать: иерархии (например, сотрудник → менеджер), поиск дубликатов, связи внутри одной таблицы.

 -- END Self JOIN в PostgreSQL --



 -- DEFAULT в SQL - значение по умолчанию для столбца --

 DEFAULT в SQL — значение по умолчанию для столбца, если данные не указаны явно.

 # Пример:                                                                # Минимальный пример:
 CREATE TABLE products (                                                  CREATE TABLE t (
    id INT PRIMARY KEY,                                                       id INT,
    price DECIMAL DEFAULT 0.00,  -- Цена по умолчанию 0                       flag BOOLEAN DEFAULT FALSE
    in_stock BOOLEAN DEFAULT TRUE  -- Наличие по умолчанию TRUE           );
);

 -- END DEFAULT в SQL - значение по умолчанию для столбца --



 Таблицы — это основа хранения данных в SQL, а представления — инструмент для извлечения конкретной информации.

 В SQL представление(VIEW) — это виртуальная таблица, основанная на SELECT операторе. CREATE VIEW НАЗВАНИЕ AS SELECT ...

 Примеры:
 CREATE VIEW top_rated_movies           CREATE VIEW NamesView
 AS                                     AS
 SELECT id,                             SELECT pl.vcName, count(*)
       title,                           FROM tbPeoples pl
       release_year,                    GROUP BY vcName
       genre,
       rating
 FROM movies
 WHERE rating = 9;


 Напишите запрос, который выводит информацию о версии MySQL сервера.
 SELECT VERSION();

 Напишите запрос, который выводит список баз данных на сервере
 SHOW DATABASES;

 Какие таблицы есть в  БД.
 SHOW TABLES;

 Выведите информацию о структуре таблицы statistics.
 USE information_schema;
 SHOW COLUMNS FROM statistics;

 - **DATABASE** — это более широкий контейнер с данными.
 - **SCHEMA** — это способ организации данных внутри базы данных.


 -- WHERE (ВХЕРЕ) vs HAVING в SQL --

 WHERE

 - Фильтрует строки до группировки (GROUP BY).
 - Работает с отдельными записями.
 - Нельзя использовать с агрегатными функциями (SUM, COUNT и т.д.).

 HAVING

 - Фильтрует результаты после группировки (GROUP BY).
 - Работает с группами.
 - Может использовать агрегатные функции (SUM, AVG и др.).


 Пример:
 - WHERE: фильтр до группировки (возраст > 30)
 SELECT department, COUNT(*)
 FROM employees
 WHERE age > 30
 GROUP BY department;

 - HAVING: фильтр после группировки (отделы с > 5 сотрудников)
 SELECT department, COUNT(*)
 FROM employees
 GROUP BY department
 HAVING COUNT(*) > 5;


 - Коротко:
 WHERE — фильтр строк, HAVING — фильтр групп.
 WHERE → до GROUP BY, HAVING → после.
 HAVING — для агрегатов, WHERE — нет.

 - Можно сделать ещё короче:

 WHERE  — фильтрует сырые строки (до группировки).
 HAVING — фильтрует агрегированные данные (после GROUP BY).


 Главное:
 WHERE  — для условий над полями.
 HAVING — для условий над группами (с COUNT, SUM и др.).

 -- WHERE (ВХЕРЕ) vs HAVING в SQL --



 --- Удаление в SQL ---

 -- TRUNCATE VS DELETE --

 TRUNCATE
 - Удаляет все строки таблицы быстро (не записывает в журнал удаление каждой строки).
 - Нельзя использовать с WHERE (удаляет всё).
 - Сбрасывает счетчик автоинкремента (если есть).
 - Нельзя откатить (ROLLBACK в некоторых СУБД).

 DELETE
 - Удаляет строки медленнее (записывает каждое удаление в журнал).
 - Можно использовать с WHERE (удаление выборочно).
 - Не сбрасывает автоинкремент.
 - Можно откатить (ROLLBACK).

 Короче:
 TRUNCATE — быстрое очищение всей таблицы.
 DELETE   — гибкое удаление строк с возможностью отката.

 Когда что использовать?
 TRUNCATE — когда нужно быстро очистить всю таблицу без возможности отката.
 DELETE   — когда нужно выборочно удалять строки или если нужна возможность отката.

 Пример
 -- TRUNCATE: быстрое удаление всех данных
 TRUNCATE TABLE employees;

 -- DELETE: удаление с условием + можно откатить
 DELETE FROM employees WHERE department = 'HR';


 TRUNCATE

 Работает быстрее, потому что это DDL-операция (Data Definition Language), а не DML (Data Manipulation Language).
 Освобождает место на диске (в отличие от DELETE, который может оставлять его для отката).
 В некоторых СУБД (например, PostgreSQL) TRUNCATE можно откатить, если выполнен внутри транзакции (BEGIN; TRUNCATE ...; ROLLBACK;).
 Требует более высоких привилегий (обычно DROP на таблицу).

 DELETE

 Можно использовать с RETURNING (в PostgreSQL) для получения удаленных данных.
 Активирует триггеры ON DELETE (TRUNCATE — нет).

 # ПРИМЕРЫ SQL
 -- 1. Очистка всей таблицы
 TRUNCATE TABLE users;        -- Быстро, без отката (в большинстве СУБД)
 DELETE FROM users;           -- Медленнее, но можно откатить

 -- 2. Удаление с условием (только DELETE)
 DELETE FROM orders WHERE created_at < '2020-01-01';

 -- 3. Автоинкремент
 TRUNCATE TABLE products;     -- Счётчик сбросится (начнёт с 1)
 DELETE FROM products;        -- Счётчик сохраняется (продолжит с последнего id)

 -- 4. Транзакции (PostgreSQL)
 BEGIN; TRUNCATE TABLE logs; ROLLBACK;  -- Откат возможен только в транзакции
 BEGIN; DELETE FROM logs; ROLLBACK;     -- DELETE всегда можно откатить

 -- 5. Возврат удалённых данных (PostgreSQL)
 DELETE FROM employees
 WHERE salary > 100000
 RETURNING id, name;  -- TRUNCATE так не умеет

 -- 6. Триггеры
 DELETE FROM accounts;    -- Вызовет триггеры ON DELETE
 TRUNCATE TABLE accounts; -- Триггеры НЕ сработают




 -- DROP TABLE vs DROP SCHEMA --

 DROP TABLE  — уничтожает таблицу (структура + данные).     Нужно удалить таблицу
 DROP SCHEMA — удаляет всю схему (таблицы, функции и др.).  Нужно удалить всю базу/схему


 -- DROP TABLE — удаляет таблицу и все её данные.
 DROP TABLE employees;  -- Таблица `employees` удалена полностью

 -- DROP SCHEMA — удаляет схему (пространство с таблицами, представлениями и др. объектами).
 DROP SCHEMA hr CASCADE;  -- Удаляет схему `hr` и все её объекты


 DROP TABLE

 - Можно добавить CASCADE, чтобы автоматически удалить зависимости (например, внешние ключи).
 - В некоторых СУБД (MySQL) есть DROP TABLE IF EXISTS, чтобы избежать ошибки, если таблицы нет.

 DROP SCHEMA

 - Без CASCADE выдаст ошибку, если в схеме есть объекты.
 - В PostgreSQL и MySQL можно использовать DROP SCHEMA IF EXISTS.



 -- При удалении в SQL строк НЕ стало меньше --

 При удалении в SQL строк не стало меньше — возможно, данные помечены как удалённые, но физически ещё хранятся
 (например, из-за транзакций или MVCC в PostgreSQL). MVCC = версионность строк для изоляции транзакций без блокировок.
 MVCC (Multi-Version Concurrency Control) - это механизм в СУБД для работы с данными без блокировок.

 Time to Live (TTL) — срок жизни данных, после которого они автоматически удаляются.

 Вакуум (VACUUM) в SQL — процесс очистки "мёртвых" строк (удалённых или устаревших) и освобождения места (особенно в PostgreSQL).

 Кратко:
 Удалённые строки могут временно оставаться в таблице (MVCC).
 TTL — автоматическое удаление по времени.
 VACUUM — очистка мусора в БД.


 - Удаление строк в SQL
 Да, при обычном DELETE строки могут оставаться в таблице физически (особенно в PostgreSQL из-за MVCC).
 Они помечаются как "мёртвые", но не удаляются сразу.

 - TTL (Time To Live)
 Это верно, но TTL — это не стандартная SQL-функция. Он есть в некоторых СУБД (например, в ClickHouse, Redis),
 но в PostgreSQL его нет "из коробки". Аналог можно реализовать вручную (например, через задания cron или триггеры).

 - VACUUM в PostgreSQL
 Абсолютно верно. VACUUM (особенно VACUUM FULL) освобождает место, занимаемое "мёртвыми" строками. Автовакуум
 (autovacuum) делает это автоматически.

 - Дополнительно
 В других СУБД (например, MySQL InnoDB) есть схожие механизмы (например, очистка через механизм undo-логов),
 но там нет команды VACUUM.




 -- Constraint (ограничение) в SQL --

 Constraint (ограничение) в SQL — это правило, которое ограничивает данные в таблице для сохранения их целостности.

 Основные типы:
 - PRIMARY KEY — уникальный идентификатор (не NULL).
 - FOREIGN KEY — связь с другой таблицей.
 - UNIQUE — все значения в столбце уникальны.
 - NOT NULL — запрет на пустые значения.
 - CHECK — проверка условия (например, age > 0).

 Пример:
 CREATE TABLE users (
     id INT PRIMARY KEY,
     email VARCHAR(255) UNIQUE NOT NULL,
     age INT CHECK (age >= 18)
 );
 Зачем: чтобы данные были корректными и непротиворечивыми.

 Какие CONSTRAINT создают индексы автоматически?
 - PRIMARY KEY
 - UNIQUE

 -- END Constraint (ограничение) в SQL --


 -- Deadlock в SQL --

 Deadlock в SQL — это ситуация, когда две или более транзакции блокируют друг друга, бесконечно ожидая освобождения ресурсов.
 Deadlock в SQL — взаимоблокировка транзакций, когда каждая ждёт ресурс, занятый другой.

 Проще:
- Транзакция A ждёт данные, которые заблокировала транзакция B.
- Транзакция B ждёт данные, которые заблокировала транзакция A.
- Результат: взаимный клин, обе транзакции «зависают».

 Как решается:
 - СУБД автоматически обнаруживает deadlock и аварийно завершает одну из транзакций (жертва).
 - Приложение должно повторить отменённую транзакцию.

 Пример:
 - Транзакция 1
 BEGIN;
 UPDATE accounts SET balance = balance - 100 WHERE id = 1; -- Блокирует запись 1
 UPDATE accounts SET balance = balance + 100 WHERE id = 2; -- Ждёт, пока транзакция 2 освободит запись 2

 - Транзакция 2 (параллельно)
 BEGIN;
 UPDATE accounts SET balance = balance - 50 WHERE id = 2; -- Блокирует запись 2
 UPDATE accounts SET balance = balance + 50 WHERE id = 1; -- Ждёт, пока транзакция 1 освободит запись 1
 -- DEADLOCK! СУБД убивает одну из транзакций.

 Профилактика Deadlock:
 - Запросы в одинаковом порядке (например, всегда id=1 → id=2).
 - Короткие транзакции.
 - Использование NOWAIT или таймаутов.

 -- END Deadlock в SQL --


 -- Блокировки (Locks) vs Deadlock в SQL --

 Блокировки (Locks) - Механизм контроля доступа к данным при параллельных транзакциях.

 Типы:

 - Shared (S) – чтение (много транзакций).
 - Exclusive (X) – запись (только одна).
 - Update (U) – подготовка к изменению.
 - Intent – намерение заблокировать данные.

 Deadlock - Взаимная блокировка: две транзакции ждут ресурсы друг друга, создавая тупик.

 Пример:

 Транзакция A блокирует строку 1, B – строку 2.
 A хочет строку 2, B – строку 1.
 Обе зависают.


 -- Уровни изоляции в SQL --

 Уровни изоляции в SQL определяют, насколько транзакции "видят" изменения друг друга,
 балансируя между согласованностью данных и производительностью

 Уровни изоляции контролируют видимость изменений между параллельными транзакциями.

 Уровни изоляции в SQL определяют, как транзакции взаимодействуют с параллельными транзакциями,
 предотвращая проблемы (грязное чтение, неповторяемое чтение, фантомы).

 4 уровня изоляции (от низкого к высокому):

 - Read Uncommitted – Видны даже незафиксированные изменения других транзакций (грязное чтение).
 - Read Committed – Только зафиксированные данные (стандарт в многих СУБД).
 - Repeatable Read – Гарантирует, что прочитанные данные не изменятся в рамках транзакции.
 - Serializable – Полная изоляция, как если бы транзакции выполнялись строго по очереди.

 Чем выше уровень, тем строже изоляция, но ниже производительность.
 чем выше уровень, тем больше накладных расходов (блокировки, проверки конфликтов), но в современных СУБД
 (например, PostgreSQL) даже Serializable может работать достаточно быстро благодаря оптимизациям.

 -- END Уровни изоляции в SQL --


 -- Что такое ИНДЕКСЫ в SQL и как их использовать --

 По сути, индекс — это сбалансированное двоичное дерево поиска. Каждая строка в таблице соответствует узлу в дереве.

 Производительность: Проблема в том, что, когда новая запись вставляется в таблицу или удаляется из нее, приходится
 обновлять все индексы, чтобы отразить это изменение. Если индексов много, то обновление, вставка или удаление строк
 могут стать в вычислительном плане дорогостоящими операциями (ВСПОМНИМ ПРО БАЛАНСИРОВКУ ДЕРЕВА).

 Более того, индексы занимают ограниченное дисковое пространство.

 - Ответ 1:

 Если в кратце, то индекс, это поле по которому оптимизирован(ускорен) поиск.                            <-----

 Поскольку индекс занимает место, то индексировать нужно только те поля, по которым происходит выборка.  <-----

 Допустим есть таблица.

 CREATE TABLE MyGuests (
     id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,
     firstname VARCHAR(30) NOT NULL,
     lastname VARCHAR(30) NOT NULL,
     email VARCHAR(50),
     reg_date TIMESTAMP
 )

 id - уже индекс

 Допустим вам нужен поиск по имени (firstname).

 SELECT * FROM MyGuests WHERE firstname = "Вася"

 тогда есть смысл добавить индекс по данному полю.

 CREATE INDEX firstname_index ON MyGuests (firstname) USING BTREE;    # Создание Индекса

 Будет созданна "карта" которая позволет легко находить записи в оригинальном списке.


 - Ответ 2:

 Вкратце, индексы создаются для повышения производительности поиска данных. Таблицы могут иметь огромное количество строк,
 которые хранятся в произвольном порядке. Без индекса поиск нужных строк идёт по порядку (последовательно), что на
 больших объемах данных отнимает много времени.

 Индекс - обычно один или несколько столбцов таблицы и указателей на соответствующие строки таблицы, позволяет искать
 строки, удовлетворяющие критерию поиска. Ускорение работы с использованием индексов достигается в первую очередь за
 счёт того, что индекс имеет структуру, оптимизированную под поиск — например, в MySQL b-дерева. Индекс лучше
 использовать на тех столбцах таблицы, на которые вы чаще всего будете накладывать условия через where column_name = ...

 Индекс создаётся по правилу:

 create index название_индекса
 on название_таблицы (название_столбца)

 Например, у вас таблица называется test, где хранятся данные по городам России с улицами вида Город, Улица, Дом.Понятно,
 что строк в таблице при таком раскладе будет много. Если вы часто делаете выборку по определенному городу, например:

 select *
 from test
 where city = 'Омск'

 то, чтобы этот запрос отработал быстрее обычного, следует добавить индекс по вышеуказанному правилу:

 create index city_index
 on test (city)

 Тогда тот же самый запрос

 select *
 from test
 where city = 'Омск'

 отработает гораздо быстрее, если столбец city будет проиндексирован.


 Внешний ключ - это столбец для соединения с другими таблицами.
 Индекс - столбец, по которому можно задать условие и тогда запрос отработает гораздо быстрее.


 -- Ответ 3:
 На пальцах можно объяснить так:

 Когда Вы создаёте таблицу, добавляете в неё данные, то таблица разрастается и она выглядит как просто последовательный
 список, упорядоченный по тому как в неё данные добавлялись.

 Когда данных мало, список маленький и все запросы к ней выполняются, почти, незаметно. Но когда количество записей в
 таблице начинает переваливать за миллион (в разных случаях по разному, но как пример миллион), то у Вас поиск уже идёт
 не так быстро и с добавлением всё новых и новых записей - ещё медленнее.

 Это связано с тем, что когда Вы ищите какую-то запись, то просматриваются все записи, пока не дойдут до нужной.

 Когда Вам это окончательно надоедает и Вы хотите что-нибудь сделать, то к Вам на помощь приходят индексы.

 Индекс создаётся по какому-то определённому полю (можно по нескольким) по которому, обычно, выполняется поиск.
 Когда Вы создаёте индекс, то MySql (и любая другая БД) обходит все записи в таблице и строит дерево
 (скорее всего B-дерево или разновидность), в котором ключами выступает выбранное поле, а содержимым ссылки на записи в таблице.

 И когда Вы делаете очередной свой select запрос по таблице, по полю для которого создали индекс MySql
 (и любая другая БД) знает что у неё есть индекс, по которому пройтись будет быстрее, нежели перебирать все записи и
 Ваш запрос будет направлен этому индексу и записи, удовлетворяющие условию, будут найдены гораздо быстрее, так как
 поиск по построенному дереву будет гораздо быстрее, нежели простой перебор всех записей.

 B-Tree индекс дает скорость выборки порядка O(log n): Логарифмическая сложность
 hash в среднем обеспечивают скорость выборки O(1):  Константная сложность.   если происходит множество коллизий  линейную O(n).

 Таким образом:
- B-Tree обеспечивает логарифмическую сложность O(log n) при поиске.
- Хэш-индексы в среднем обеспечивают постоянную сложность O(1) для поиска, но могут достигать до O(n) в худшем случае при наличии коллизий.

 Важно также отметить, что хэш-индексы НЕ поддерживают диапазонный поиск, в отличие от B-Tree.

 В реальной жизни hash и B-Tree применяются совместно, то есть для вычисления значений B-Tree индекса все равно применяются хэши.

 ### Сравнение   B-Tree vs Hash:

 - **Производительность**:
  B-Tree лучше для операций, требующих диапазонного поиска, тогда как
  хэш-индексы оптимальны для точных совпадений.

 - **Структурные особенности**:
  B-Tree — это сбалансированная структура, которая остается упорядоченной, в то время как хэш-индексы НЕ упорядочены.

 - **Гибкость**:
  B-Tree более универсален и подходит для разнообразных типов запросов, в то время как хэш-индексы более узкоспециализированы.

 В зависимости от конкретных задач и типов запросов, СУБД может использовать один или оба типа индексов.


  -- Вывод: Когда что использовать? --

 | Критерий	           | Без индекса	    | С индексом            |
 |---------------------|--------------------|-----------|-----------|
 | Скорость	           | Медленно (O(n))	| Быстро (O(log n))     |
 | Подходит для	       | Маленькие таблицы	| Большие таблицы       |
 | Поддержка операций  | Любые условия	    | Только индексируемые  |
 | Нагрузка на БД	   | Высокая	        | Низкая                |

 Рекомендация:

 - Всегда добавляйте индексы на часто используемые столбцы (WHERE, JOIN, ORDER BY).
 - Не индексируйте редко используемые столбцы или маленькие таблицы — это тратит ресурсы.
 - Индексы занимают место и замедляют вставку/обновление.
 - Проверяйте ПЛАН ЗАПРОСА (EXPLAIN ANALYZE), чтобы убедиться, что индекс используется.

  EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';
  # Вывод должен содержать Index Scan (если индекс есть) или Seq Scan (если нет).


 -- ПОЧЕМУ ИНДЕКСЫ замедляют операции вставки (INSERT) и обновления (UPDATE) --

 Индексы замедляют INSERT и UPDATE в PostgreSQL, потому что:

 - INSERT - при добавлении новой записи нужно обновлять все индексы таблицы.
 - UPDATE - если изменяются индексируемые поля, PostgreSQL должен пересчитать соответствующие индексы.

 Чем больше индексов, тем больше накладных расходов на их поддержку.

 - Для INSERT - каждая новая запись требует добавления соответствующих записей во все индексы таблицы.
 - Для UPDATE - если меняется значение в индексируемом поле, PostgreSQL должен удалить старую запись из индекса и добавить новую.

 Чем больше индексов -> тем больше операций записи -> тем выше нагрузка.


 -- Индексы в PostgreSQL --

 1. По умолчанию - B-tree
 CREATE INDEX idx_name ON table(column);  -- B-tree (автоматически)

 Применение B-tree:
 - Сравнения: =, >, <, BETWEEN, IN
 - Сортировка: ORDER BY
 - Поиск по префиксу: LIKE 'prefix%' (но не LIKE '%abc') (Уточнение: LIKE '%suffix' НЕ использует B-tree индекс)

 Сложность:
 - O(log n) для всех операций (поиск/вставка/удаление)

 2. Специальные типы индексов (требуют USING):

 | Тип    | Оптимальное применение        | Сложность | Ключевые ограничения            |
 |--------|-------------------------------|-----------|---------------------------------|
 | Hash   | Точные совпадения (=)         | O(1)      | Не поддерживает сортировку, >/< |
 | GIN    | JSONB, массивы, полнотекст    | O(log n)  | Больше места, чем B-tree        |
 | GiST   | Геоданные, сложные типы       | Зависит   | Медленнее B-tree для простых запросов |
 | BRIN   | Упорядоченные большие таблицы | O(1)      | Менее точен, чем B-tree         |

 Примеры создания:
 CREATE INDEX idx_hash ON table USING hash(column);  -- Для быстрого =
 CREATE INDEX idx_gin ON table USING gin(jsonb_column);  -- Для JSONB

 Итоговые рекомендации:
 1. B-tree - стандартный выбор (покрывает 90% случаев)
 2. GIN - для JSONB/массивов (индексирует элементы внутри)
 3. BRIN - для временных рядов (где данные упорядочены по времени)
 4. Hash - только для узких случаев (поиск по =)
 5. GiST - для геоданных и специализированных расширений


 -- Можно ли много индексов? МНОЖЕСТВЕННЫЕ ИНДЕКСЫ в SQL --

 Пример создания нескольких индексов:

 CREATE INDEX idx_customer_name ON customers(name);
 CREATE INDEX idx_order_date ON orders(order_date);
 CREATE INDEX idx_product_category ON products(category_id, price);


 Да, можно создавать много индексов в SQL, но с оговорками:

 Плюсы множественных индексов:

 - Ускоряют поиск и сортировку по разным полям
 - Оптимизируют JOIN-операции
 - Улучшают производительность сложных запросов

 Минусы:

 - Замедляют INSERT/UPDATE/DELETE (каждое изменение данных требует обновления индексов)
 - Занимают дополнительное место на диске
 - Могут избыточно дублировать друг друга

 Рекомендации:

 - Создавайте индексы только для часто используемых в WHERE/JOIN/ORDER BY полей
 - Комбинируйте поля в составных индексах вместо создания отдельных
 - Избегайте индексов для редко используемых запросов
 - Удаляйте неиспользуемые индексы


  -- Кластерные индексы vs Обычные индексы --

 - Кластерные индексы лучше подходят — для операций с диапазонами
 - НЕкластерные индексы              — для выборок по конкретным значениям.


 | Аспект                 | Кластерные индексы                           | Некластерные индексы
 |------------------------|----------------------------------------------|------------------------------------------------
 | **Структура**          | Определяет физический порядок хранения строк.| Создает отдельную структуру с указателями на строки.
 | **Количество**         | Только один на таблицу.                      | Много на таблицу.
 | **Производительность** | Быстрый для диапазонных запросов.            | Быстрый для точных запросов.
 | **Обновления**         | Более затратные при изменениях данных.       | Менее затратные операции при изменениях.

  Кластерные индексы играют важную роль в оптимизации производительности базы данных за счет упорядочивания данных.

 -- END Что такое ИНДЕКСЫ в SQL и как их использовать --



 -- Обычный индекс (INDEX) VS  Уникальный индекс (UNIQUE INDEX) --

 Индексы в SQL — это специальные структуры данных для ускорения поиска и сортировки в таблицах.

 1. Обычный индекс (INDEX)
 - Ускоряет поиск по столбцу.
 - Допускает дубликаты и NULL.

 Пример:
 CREATE INDEX idx_name ON users(name);  -- Ускоряет поиск по имени

 2. Уникальный индекс (UNIQUE INDEX)
 Запрещает дубликаты значений (как PRIMARY KEY, но может содержать NULL).


 Пример:

 CREATE UNIQUE INDEX idx_email ON users(email);  -- email должен быть уникальным

 Разница между   INDEX и UNIQUE INDEX


 | Характеристика	  | INDEX          | UNIQUE INDEX
 |--------------------|----------------|--------------------------------------|
 | Дубликаты          | Разрешены      | Запрещены                            |
 | NULL-значения      | Разрешены      | Один NULL обычно разрешён*           |
 | Скорость поиска    | Ускоряет       | Ускоряет + контролирует уникальность |


 *Зависит от СУБД: в PostgreSQL несколько NULL разрешены, в MySQL — один, если столбец не NOT NULL.

 Когда использовать?
 - INDEX — для часто фильтруемых столбцов (поиск по имени).
 - UNIQUE INDEX — для столбцов, где важна уникальность (email, телефон).


 Примеры запросов:

 - Создание индекса
 CREATE INDEX idx_age ON users(age);

 - Создание уникального индекса
 CREATE UNIQUE INDEX idx_phone ON users(phone);

 - Удаление индекса
 DROP INDEX idx_name ON users;

 Важно:
 - Индексы ускоряют SELECT, но замедляют INSERT/UPDATE/DELETE (т.к. нужно обновлять индекс).
 - Составные индексы (по нескольким столбцам) работают только для условий, где используются первые столбцы индекса.

 Коротко:
 - INDEX        — просто ускоритель.
 - UNIQUE INDEX — ускоритель + защита от дублей.

 Супер-кратко:
 - INDEX        — ускоряет поиск, разрешает дубли и NULL.
 - UNIQUE INDEX — ускоряет + запрещает дубли (но обычно разрешает несколько NULL).

 -- END Обычный индекс (INDEX) VS  Уникальный индекс (UNIQUE INDEX) --



 -- Что такое Транзакции в SQL Атомарное действие --

 Транзакция, если по-простому - это совокупность неких действий, причем такая, что либо все эти действия
 выполняются успешно, либо ни одно не выполняется вообще.

 Соответственно, транзакция в sql - это последовательность операторов, которая либо выполняется целиком, либо целиком
 же откатывается. (почитайте про ключевые слова TRANSACTION, COMMIT, ROLLBACK)

 TCL (Transaction Control Language)
 BEGIN TRANSACTION    — начало транзакции.
 COMMIT TRANSACTION   — изменение команд транзакции.
 ROLLBACK TRANSACTION — отказ в транзакции.
 SAVE TRANSACTION     — формирование промежуточной точки сохранения внутри

 Транзакции в SQL — это набор операций, которые выполняются как единое целое. Они обеспечивают атомарность,
 консистентность, изолированность и долговечность (ACID-принципы). Это значит, что либо все операции в транзакции
 выполняются успешно, либо, в случае ошибки, все изменения отменяются.

 ### Пример транзакции:

 Предположим, у нас есть две таблицы: `Accounts` (для учета балансов пользователей) и `Transactions` (для учета сделанных транзакций).

 #### 1. Создание таблиц

 CREATE TABLE Accounts (
     AccountID INT PRIMARY KEY,
     Balance DECIMAL(10, 2)
 );

 CREATE TABLE Transactions (
     TransactionID INT PRIMARY KEY AUTO_INCREMENT,
     FromAccount INT,
     ToAccount INT,
     Amount DECIMAL(10, 2),
     TransactionDate DATETIME DEFAULT CURRENT_TIMESTAMP
 );


 #### 2. Пример транзакции

 Предположим, мы хотим перевести 100 единиц денег от одного аккаунта к другому:

 BEGIN;

 UPDATE Accounts
 SET Balance = Balance - 100
 WHERE AccountID = 1;

 UPDATE Accounts
 SET Balance = Balance + 100
 WHERE AccountID = 2;

 INSERT INTO Transactions (FromAccount, ToAccount, Amount)
 VALUES (1, 2, 100);

 COMMIT;


 ### Объяснение:

 1. **BEGIN**  - Начинает транзакцию.
 2. **UPDATE** - Первое обновление уменьшает баланс первого аккаунта.
 3. **UPDATE** - Второе обновление увеличивает баланс второго аккаунта.
 4. **INSERT** - Записывает информацию о транзакции в таблицу `Transactions`.
 5. **COMMIT** - Подтверждает все изменения, сделанные в рамках транзакции.

 Если на каком-то этапе возникает ошибка (например, недостаточно средств на первом аккаунте), можно выполнить `ROLLBACK`,
 чтобы отменить все изменения, сделанные в транзакции.

 -- END Что такое Транзакции в SQL Атомарное действие --


 -- Грязные операции чтения (dirty reads) в транзакциях --

 Грязные операции чтения (dirty reads) в транзакциях - это чтение незафиксированных изменений из параллельной транзакции,
 которая может быть откачена.

 Кратко:
 - Чтение незавершённых данных.
 - Возникает при низком уровне изоляции (например, READ UNCOMMITTED).
 - Может привести к некорректным результатам.

 Пример:

 -- Транзакция 1 (не завершена)
 UPDATE users SET balance = 100 WHERE id = 1;

 -- Транзакция 2 (читает незафиксированные данные)
 SELECT balance FROM users WHERE id = 1; -- Вернёт 100, даже если Транзакция 1 откатится.

 Итог: Опасны, так как используют потенциально невалидные данные.



 -- ACID-принципы --
 ACID — это набор свойств, которые гарантируют надежность транзакций в системах управления базами данных (СУБД).

 ACID расшифровывается как:

 1. **Atomicity (Атомарность)**: Транзакция выполняется полностью или не выполняется вообще. Частичные изменения не допустимы.

 2. **Consistency (Согласованность)**: Транзакция переводит базу данных из одного согласованного состояния в другое.
    Это означает, что все бизнес-правила и ограничения базы данных должны соблюдаться. Ограничения (например, UNIQUE, FOREIGN KEY)

 3. **Isolation (Изолированность)**: Одновременно выполняющиеся транзакции не влияют друг на друга.
    Результаты транзакции не доступны другим до её завершения. Уровни изоляции определяют, насколько строго транзакции изолированы.

 4. **Durability (Надежность/Долговечность)**: После завершения транзакции её изменения сохраняются в базе данных, даже в случае сбоя системы.

 Эти свойства помогают обеспечить надежность и целостность данных в реляционных базах данных.


 # КОРОТКО:
 ACID — свойства надежных транзакций в БД:

 Атомарность — либо всё, либо ничего.
 Пример: Перевод денег: если списание прошло, а зачисление нет — операция отменится.

 Согласованность — данные всегда корректны.
 Пример: Невозможно записать отрицательный баланс, если есть ограничение balance >= 0.

 Изолированность — транзакции не мешают друг другу.
 Пример: Пока один пользователь не завершит редактирование записи, другой не увидит её изменения.

 Долговечность — изменения сохраняются даже при сбое.
 Пример: После подтверждения платежа он останется в БД, даже если сервер упадёт.

 Короче: «Либо всё, либо ничего; только по правилам; без помех; навсегда».    <-----    <-----


 # Хорошее определение
 Atomicity (атомарность)       - все операции в транзакции выполняются или ни одна.
 Consistency (согласованность) - данные остаются валидными после транзакции.
 Isolation (изолированность)   - параллельные транзакции не мешают друг другу.
 Durability (долговечность)    - после commit изменения сохраняются даже при сбое.


 Какие уровни изоляции транзакций вы знаете?

 Read Uncommitted - возможны "грязные" чтения.
 Read Committed   - только committed данные (стандарт в PostgreSQL).
 Repeatable Read  - защита от "неповторяемого чтения".
 Serializable     - полная изоляция (как последовательное выполнение).


  -- CAP теорема --
 CAP теорема (или теорема CAP) — это концепция, которая описывает баланс между тремя важными свойствами распределённых
  вычислений в системах хранения данных:

 1. **Consistency (Согласованность)**: Все узлы системы видят одни и те же данные в одно и то же время. Это значит,
  что после успешного завершения операции все пользователи будут видеть обновленные данные.

 2. **Availability (Доступность)**: Каждый запрос к системе получает ответ, даже если некоторые узлы недоступны.
  Система всегда отвечает, но не обязательно корректно.

 3. **Partition Tolerance (Устойчивость к разделению)**: Система продолжает функционировать даже в случае сетевых
  разделений, когда узлы не могут обмениваться данными.

 Согласно теореме CAP, в любой распределенной системе можно одновременно гарантировать только два из трёх свойств:

 - Если вы стремитесь к **согласованности** и **доступности**, у вас может возникнуть проблема при сетевом разделении (Partition).
 - Если вы стремитесь к **доступности** и **устойчивости к разделению**, вы можете потерять **согласованность**.
 - Если вы пытаетесь обеспечить **согласованность** и **устойчивость к разделению**, вы можете столкнуться с проблемами
   в **доступности**.

 Таким образом, теорема CAP помогает разработчикам и архитекторам систем понимать компромиссы, которые необходимо
 учитывать при проектировании распределенных систем.



 -- В ClickHouse НЕТ ACID И ТРАНЗАКЦИЙ ??? --

 В ClickHouse действительно нет полноценной поддержки ACID (Atomicity, Consistency, Isolation, Durability)
 и классических транзакций, как в реляционных СУБД (PostgreSQL, MySQL и т. д.).

 В ClickHouse нет полноценной поддержки ACID и транзакций в классическом понимании (как в PostgreSQL или Oracle).

 Коротко:

 Нет транзакций — нельзя откатить группу запросов.
 Нет атомарности на уровне запросов, изменяющих данные (кроме вставок в одну партицию).
 Изоляция ограничена (данные видны сразу после вставки).


 Когда ClickHouse подходит, а когда нет?
 Подходит:

 Аналитика, логгирование, big data (быстрое чтение, агрегация).
 Данные, которые можно пересчитать или где возможна консистентность в конечном счёте.

 Не подходит:

 Традиционные OLTP (банковские транзакции, инвентаризация).
 Системы, требующие строгой согласованности и изоляции.

 Альтернативы для ACID в ClickHouse

 Использовать PostgreSQL + ClickHouse (PostgreSQL для транзакций, ClickHouse для аналитики).
 ClickHouse + Kafka (буферизация и обработка событий).

 ClickHouse не ACID-совместим в классическом смысле, но предоставляет некоторые гарантии атомарности и durability
 в рамках своей архитектуры. Если нужны транзакции — лучше выбрать другую СУБД или комбинировать решения.


 Пример для альтернатив:
 -- В PostgreSQL (OLTP):
 BEGIN;
   UPDATE accounts SET balance = balance - 100 WHERE user_id = 1;
   INSERT INTO transactions VALUES (1, -100, now());
 COMMIT;

 -- В ClickHouse (аналитика):
 INSERT INTO analytics.events (event_date, user_id, action)
 VALUES ('2023-10-01', 42, 'click'); -- Атомарно, но без отката

 -- END В ClickHouse НЕТ ACID И ТРАНЗАКЦИЙ ??? --



 -- Many-to-Many НЕТ в PostgreSQL ??? --

 Реализуется через ПРОМЕЖУТОЧНУЮ ТАБЛИЦУ (junction/associative table), которая содержит внешние ключи на обе связанные таблицы.

 M2M в PostgreSQL ЕСТЬ, но требует явного создания связующей таблицы.
 PostgreSQL (как и другие SQL-СУБД) поддерживает M2M через промежуточные таблицы.
 Возможно, путаница с NoSQL БД (например, MongoDB), где M2M реализуется иначе (вложенными массивами).


 Many-to-Many (M2M) в PostgreSQL
 Как работает:

 - Связь между двумя таблицами через промежуточную таблицу (junction table).
 - Например: Студенты ↔ Курсы (студент может быть на многих курсах, курс может иметь многих студентов).
 - Промежуточная таблица содержит внешние ключи (FK) на обе таблицы.

 M2M существует, но реализуется через промежуточную таблицу (junction/associative table).
 Эта таблица содержит внешние ключи (FK) на обе связанные таблицы.
 Это стандартный подход в реляционных БД (PostgreSQL, MySQL, SQL Server и др.).


 # Пример: Студенты и Курсы

 -- Основные таблицы
 CREATE TABLE students (
     student_id SERIAL PRIMARY KEY,
     name TEXT
 );

 CREATE TABLE courses (
     course_id SERIAL PRIMARY KEY,
     title TEXT
 );

 -- Промежуточная таблица для M2M
 CREATE TABLE student_courses (
     student_id INT REFERENCES students(student_id),
     course_id INT REFERENCES courses(course_id),
     PRIMARY KEY (student_id, course_id)  -- Составной первичный ключ
 );

 -- END Many-to-Many нет в PostgreSQL ??? --



 -- COALESCE    COALESCE(value1, value2, ..., valueN) --

 COALESCE — это функция в SQL, которая возвращает первый ненулевой аргумент из списка.
 Если все аргументы равны NULL, функция вернет NULL.

 # Пример
 Предположим, у нас есть таблица `employees`:

 | id | name    | bonus  |
 |----|---------|--------|
 | 1  | Alice   | NULL   |
 | 2  | Bob     | 500    |
 | 3  | Charlie | NULL   |

 **Запрос с использованием `COALESCE`:**
 SELECT name, COALESCE(bonus, 1000) AS effective_bonus
 FROM employees;

 **Результат

 | name    | effective_bonus  |
 |---------|------------------|
 | Alice   | 1000             |
 | Bob     | 500              |
 | Charlie | 1000             |

 ### Объяснение:
 В этом примере `COALESCE(bonus, 1000)` возвращает значение `bonus`, если оно ненулевое; если `bonus` — это `NULL`, то
 возвращается значение `1000`. Таким образом, `effective_bonus` для `Alice` и `Charlie` будет `1000`, а для `Bob` — `500`



 Виртуальная таблица(Вьюха) - не имеет физического табличного представления в базе данных. Ее данные формируются в момент
 выполнения запроса на основе других реальных таблиц базы данных.

 Виртуальная таблица - Таблица созданная на основе источника посредством выполнения запроса.
 Итак, вьюшка – это просто запрос на языке SQL, который выбирает данные, а в базе данных она выглядит как таблица
 и работа с ней происходит также.

 Чем View отличается от таблицы?
 View — виртуальная (логическая) таблица, представляющая собой поименованный запрос (синоним к запросу), который будет
 подставлен как подзапрос при использовании представления. В отличие от обычных таблиц реляционных баз данных,
 представление не является самостоятельной частью набора данных, хранящегося в базе.

 Таблица содержит данные, Представление(View) — это просто оператор SELECT, который был сохранен в базе данных

 Таблица — это сущность базы данных, которая хранит данные в виде строк и столбцов.
 Представление — это виртуальная таблица, используемая для просмотра или манипулирования некоторыми частями таблицы .

 Представление(View) является результатом SQL-запроса и представляет собой виртуальную таблицу, тогда как таблица состоит из
 строк и столбцов, которые хранят информацию о любом объекте и используются для извлечения этих данных по мере необходимости.



 --- Разница между Joins Сравнение Joins ---

 В SQL существует несколько типов соединений (joins), которые позволяют объединять данные из разных таблиц.
 Вот краткое описание основных типов соединений и их разница:

 1. **INNER JOIN**:
 - Возвращает только те строки, которые имеют совпадения в обеих таблицах.
 - Например, если в таблицах A и B есть совпадающие значения, то только они будут включены в результат.

 2. **LEFT JOIN (или LEFT OUTER JOIN)**:
 - Возвращает все строки из левой таблицы и совпадающие строки из правой таблицы.
 - Если совпадений нет, в результатах будут NULL-значения для правой таблицы.

 3. **RIGHT JOIN (или RIGHT OUTER JOIN)**:
 - Возвращает все строки из правой таблицы и совпадающие строки из левой таблицы.
 - Если совпадений нет, в результатах будут NULL-значения для левой таблицы.

 4. **FULL JOIN (или FULL OUTER JOIN)**:
 - Возвращает все строки из обеих таблиц.
 - Если для какой-то строки нет совпадений, в соответствующих местах будут NULL-значения.

 5. **CROSS JOIN**:
 - Возвращает декартово произведение строк двух таблиц, т.е. все возможные сочетания строк из обеих таблиц.

 6. **SELF JOIN**:
 - Это соединение таблицы самой с собой. Используется для сравнения строк в одной таблице.



 Оконные функции SQL:
 Оконная функция вычисляет значение по набору данных, связанных с текущей строкой, то есть данные из одной группы,
 если используется Partition by.


 `PARTITION BY` в SQL — это предложение, используемое в оконных функциях для разделения набора строк на более мелкие
 подгруппы (партиции) перед применением функции.

 Оконные функции в SQL — это функции, которые позволяют выполнять вычисления по наборам строк, связанным с текущей
 строкой, не сводя их в одну строку, как это делает, например, агрегатная функция. Они "окружают" строки и позволяют
 выполнять аналитику, сохраняя при этом все строки в результирующем наборе. Оконные функции особенно полезны для
 вычисления скользящих средних, рангов, сумм и т.д.


 Пример:
 SELECT
     id,
     amount,
     sale_date,
     SUM(amount) OVER (ORDER BY sale_date) AS cumulative_sum
 FROM
     sales;

 ### Объяснение:

 - `SUM(amount)`: Это оконная функция, которая вычисляет сумму по столбцу `amount`.
 - `OVER (ORDER BY sale_date)`: Это определяет "окно" для функции, указывая, что суммы должны быть рассчитаны в порядке дат.


 -- RANK, DENSE_RANK и ROW_NUMBER  оконные функции --

 RANK, DENSE_RANK и ROW_NUMBER — это оконные функции в SQL для нумерации строк в результате запроса
 Все они работают с OVER (ORDER BY ...) и могут включать PARTITION BY для группировки.
 Эти функции могут быть медленными на больших таблицах, особенно с PARTITION BY.

 Пример RANK, DENSE_RANK и ROW_NUMBER:

 SELECT
    name,
    RANK() OVER (ORDER BY score DESC) AS rank,
    DENSE_RANK() OVER (ORDER BY score DESC) AS dense_rank,
    ROW_NUMBER() OVER (ORDER BY score DESC) AS row_num
 FROM students;


 # Сравнение в таблице для наглядности

 | Функция    | Поведение при равенстве | Нумерация (пример: 100, 90, 90, 80) |
 |------------|-------------------------|-------------------------------------|
 | RANK       | Пропускает номер        | 1, 2, 2, 4                          |
 | DENSE_RANK | Не пропускает           | 1, 2, 2, 3                          |
 | ROW_NUMBER | Всегда уникальная       | 1, 2, 3, 4                          |



 RANK в SQL — это оконная функция, которая назначает ранг каждой строке в результате запроса с возможностью пропусков.

 Как работает:
 Присваивает номер позиции (1, 2, 3...) в зависимости от сортировки.

 Если значения одинаковые — даёт им одинаковый ранг, пропуская следующие номера.

 Пример 1:                                          Пример с PARTITION BY
                                                    -- Ранжирование по отделам
 SELECT                                             SELECT
     name,                                              department,
     score,                                             name,
     RANK() OVER (ORDER BY score DESC) AS rank          salary,
 FROM students;                                         RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_rank
                                                    FROM employees;
 Результат Пример 1:

 | name  | score | rank |
 |-------|-------|------|
 | Иван  | 100   | 1    |
 | Мария | 90    | 2    |
 | Алекс | 90    | 2    |  -- Пропуск 3
 | Петр  | 80    | 4    |

 Отличия от других функций:

 DENSE_RANK — без пропусков (в примере выше Алекс получил бы 3).
 ROW_NUMBER — всегда уникальные номера (даже при одинаковых значениях).

 Примечание:
 - "NULL-значения считаются равными друг другу"

 Где использовать: рейтинги, топ-N запросы, аналитика.

 -- END RANK, DENSE_RANK и ROW_NUMBER  оконные функции --



 DDL (Data Definition Language)
 CREATE  — создание нового объекта в существующей базе.
 ALTER   — изменение существующего объекта.
 DROP    — удаление объекта из базы.

 DML (Data Manipulation Language)
 SELECT — позволяет выбрать данные в соответствии с необходимым условием.
 INSERT — осуществляют добавление новых данных.
 UPDATE — производит замену существующих данных.
 DELETE — удаление информации.

 DCL (Data Control Language)
 GRANT  — предоставляет доступ к объекту.
 REVOKE — аннулирует выданное ранее разрешение на доступ.
 DENY   — запрет, который прекращает действие разрешения.

 TCL (Transaction Control Language)
 BEGIN TRANSACTION    — начало транзакции.
 COMMIT TRANSACTION   — изменение команд транзакции.
 ROLLBACK TRANSACTION — отказ в транзакции.
 SAVE TRANSACTION     — формирование промежуточной точки сохранения внутри

 Операторы сравнения SQL:    = , != <>, >, <, >=, <=, !<, !>

 Логические операторы:
 ALL	    TRUE, если все сравнения в наборе равны TRUE.
 ANY	    TRUE, если любое из сравнений в наборе равно TRUE.
 AND	    TRUE, если оба выражения типа Boolean равны TRUE.
 BETWEEN	TRUE, если операнд принадлежит указанному диапазону.
 EXISTS	    TRUE, если вложенный запрос возвращает как минимум одну строку.
 IN	        TRUE, если операнд содержится в заданном списке выражений.
 LIKE	    TRUE, если оператор удовлетворяет шаблону.
 NOT    	Меняет значение оператора типа Boolean на противоположное.
 OR	        TRUE, если одно из выражений типа Boolean равно TRUE.
 IS NULL    позволяет проверить значение поля на NULL.
 UNIQUE     позволяет проверить уникальность каждой строки.

 SOME	    TRUE, если некоторые из сравнений в наборе равны TRUE.   Ключевые слова SOME и ANY эквивалентны.


 # Как начать работу с SQL
 SELECT    — выбор данных.
 FROM      — источник информации, откуда брать данные.
 JOIN      — добавление таблиц.
 WHERE     — при каком условии.
 GROUP BY  — сформируй группу данных по заданному признаку.
 ORDER BY  — сортировка данных по нужному признаку.
 LIMIT     — количество результатов.
 ;         — конец предложения


 Чтобы в Pycharm Создать SQL file: Создает текстовый файл с расширением .sql или .SQL

 Как закомментировать код в SQL?  Ставим -- перед
 select * from book
 -- where amount = 3 and price >= 500

 Как в СЕРЕДИНЕ закомментировать код в SQL?  Оборачиваем в /* */
 select * from book
 where amount = 3 /* and price >= 500 */


 Проверка на bool   Как в Python  print('1' if True else '0')  # -> 1

 # Тоже самое
 SELECT * FROM students WHERE IsActive;
 SELECT * FROM students WHERE isActive = 1;
 SELECT * FROM students WHERE not not IsActive;
 select * from students where students.isActive = 1
 Select * FROM students WHERE IsActive == 1;
 Select * FROM students WHERE isActive <> 0;

 WITH позволяет дать блоку подзапроса имя/псевдоним, на которое можно ссылаться в нескольких местах основного SQL-запроса.
 Имя, присвоенное подзапросу, обрабатывается так, как если бы оно было встроенным представлением или таблицей.
 SQL оператор WITH по сути является заменой обычному подзапросу.

 Cинтаксис Oracle PL/SQL WITH с одним подзапросом:
 WITH query_name AS (SELECT expressions FROM table_A)

 SELECT column_list

   FROM query_name [,table_name]

 [WHERE conditions]


 Что такое обобщенное табличное выражение?
 это простой способ разбить сложный запрос T-SQL на несколько запросов, что придаёт больше гибкости и управляемости.
 CTE во многом очень похожи на представления.

 CTE (Common Table Expression) в SQL — это временный результат, который можно использовать внутри оператора
 `SELECT`, `INSERT`, `UPDATE` или `DELETE`. CTE позволяет структурировать сложные запросы и повышать их читаемость.
 CTE объявляется с помощью оператора `WITH`, за которым следует определение имени CTE и его запроса.

 Пример использования CTE:

 WITH SalesCTE AS (
     SELECT ProductID, SUM(Quantity) AS TotalSales
     FROM Sales
     GROUP BY ProductID
 )
 SELECT *
 FROM SalesCTE
 WHERE TotalSales > 100;

 В этом примере CTE `SalesCTE` вычисляет общие продажи по продуктам, которые затем могут быть использованы в основном запросе.


 # Регулярки в SQL

 SELECT ... WHERE title REGEXP BINARY '^(An?|The) +'; -- MySQL

 SELECT ... WHERE REGEXP_LIKE(title, '^(An?|The) +', 'c'); -- Oracle

 SELECT ... WHERE title ~ '^(An?|The) +'; -- PostgreSQL

 SELECT ... WHERE title REGEXP '^(An?|The) +'; -- SQLite


 Создание таблицы book со столбцами определенного типа данных

 CREATE TABLE book(
    book_id INT PRIMARY KEY AUTO_INCREMENT,    # id  pk primary key
    title VARCHAR(50),                         # str
    author VARCHAR(30),                        # str
    price DECIMAL(8, 2),                       # decimal
    amount INT                                 # int
);

 # Вставка записи в таблицу
 INSERT INTO book (book_id,	title,	author,	price,	amount)             # Столбцы
 VALUES
    ('1', 'Мастер и Маргарита','Булгаков М.А.','670.99', '3');          # Значения

 +---------+--------------------+---------------+--------+--------+
 | book_id | title              | author        | price  | amount |
 +---------+--------------------+---------------+--------+--------+
 | 1       | Мастер и Маргарита | Булгаков М.А. | 670.99 | 3      |
 +---------+--------------------+---------------+--------+--------+


 # Занесите три последние записи в таблицу book,  первая запись уже добавлена на предыдущем шаге:

 INSERT INTO book (title, author, price, amount)
 VALUES
     ('Белая гвардия', 'Булгаков М.А.', 540.50 , 5),
     ('Идиот', 'Достоевский Ф.М.', 460, 10),
     ('Братья Карамазовы', 'Достоевский Ф.М.', 799.01, 2),
     ('Стихотворения и поэмы', 'Есенин С.А.', 650.00, 15);


 # Исходная таблица
 +---------+-----------------------+------------------+--------+--------+
 | book_id | title                 | author           | price  | amount |
 +---------+-----------------------+------------------+--------+--------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
 | 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
 +---------+-----------------------+------------------+--------+--------+


 # Мы выбираем столбцы title, author, amount из Таблицы book
 SELECT title, author, amount  FROM book

 # Тоже самое
 SELECT (title), (author), (amount)  FROM book

 # Выбрать все поля из Таблицы book
 SELECT * FROM book

 +-----------------------+------------------+--------+
 | title                 | author           | amount |
 +-----------------------+------------------+--------+
 | Мастер и Маргарита    | Булгаков М.А.    | 3      |
 | Белая гвардия         | Булгаков М.А.    | 5      |
 | Идиот                 | Достоевский Ф.М. | 10     |
 | Братья Карамазовы     | Достоевский Ф.М. | 2      |
 | Стихотворения и поэмы | Есенин С.А.      | 15     |
 +-----------------------+------------------+--------+

 # Оператор WITH - Псевдоним
 WITH NEW_NAME AS (SELECT author , title, price FROM book)
    SELECT * from NEW_NAME

 +------------------+-----------------------+--------+
 | author           | title                 | price  |
 +------------------+-----------------------+--------+
 | Булгаков М.А.    | Мастер и Маргарита    | 670.99 |
 | Булгаков М.А.    | Белая гвардия         | 540.50 |
 | Достоевский Ф.М. | Идиот                 | 460.00 |
 | Достоевский Ф.М. | Братья Карамазовы     | 799.01 |
 | Есенин С.А.      | Стихотворения и поэмы | 650.00 |
 +------------------+-----------------------+--------+


 # Просто дать любое название
 SELECT 'Привет, мир!' AS result, title from book

 +--------------+-----------------------+
 | result       | title                 |
 +--------------+-----------------------+
 | Привет, мир! | Мастер и Маргарита    |
 | Привет, мир! | Белая гвардия         |
 | Привет, мир! | Идиот                 |
 | Привет, мир! | Братья Карамазовы     |
 | Привет, мир! | Игрок                 |
 | Привет, мир! | Стихотворения и поэмы |
 +--------------+-----------------------+



 # AS дать название
 # if author=='Булгаков М.А.' то выводим 100 if author=='Есенин С.А.' то выводим 200 else price
 SELECT author, title,
      IF(author='Булгаков М.А.', 100, IF(author='Есенин С.А.', 200, price)) AS new_price  FROM book

 +------------------+-----------------------+-----------+
 | author           | title                 | new_price |
 +------------------+-----------------------+-----------+
 | Булгаков М.А.    | Мастер и Маргарита    | 100       |
 | Булгаков М.А.    | Белая гвардия         | 100       |
 | Достоевский Ф.М. | Идиот                 | 460.00    |
 | Достоевский Ф.М. | Братья Карамазовы     | 799.01    |
 | Есенин С.А.      | Стихотворения и поэмы | 200       |
 +------------------+-----------------------+-----------+


 # Округление с условиями
 SELECT author, title,
     ROUND(IF(author='Булгаков М.А.', price+price*0.10, IF(author='Есенин С.А.', price+price*0.05, price)), 2)
      AS new_price  FROM book

 # Тоже самое
 select author, title,
 round(case author
     when "Булгаков М.А." then price * 1.1
     when "Есенин С.А." then price * 1.05
     else price end, 2) as new_price
 from book

 +------------------+-----------------------+-----------+
 | author           | title                 | new_price |
 +------------------+-----------------------+-----------+
 | Булгаков М.А.    | Мастер и Маргарита    | 738.09    |
 | Булгаков М.А.    | Белая гвардия         | 594.55    |
 | Достоевский Ф.М. | Идиот                 | 460.00    |
 | Достоевский Ф.М. | Братья Карамазовы     | 799.01    |
 | Есенин С.А.      | Стихотворения и поэмы | 682.50    |
 +------------------+-----------------------+-----------+


 # Вывести автора, название  и цены тех книг, количество которых меньше 10.
 SELECT author, title, price FROM book
     where amount < 10

 +------------------+--------------------+--------+
 | author           | title              | price  |
 +------------------+--------------------+--------+
 | Булгаков М.А.    | Мастер и Маргарита | 670.99 |
 | Булгаков М.А.    | Белая гвардия      | 540.50 |
 | Достоевский Ф.М. | Братья Карамазовы  | 799.01 |
 +------------------+--------------------+--------+


 # Вывести название, автора,  цену  и количество всех книг, цена которых меньше 500 или больше 600, а стоимость всех
 экземпляров этих книг больше или равна 5000.
 select title, author, price, amount from book
     where (author < 500 or author > 600) and price * amount >= 5000

 # Тоже самое
 select title, author, price, amount from book
     where (author < 500 || author > 600) && price * amount >= 5000

 +-----------------------+-------------+--------+--------+
 | title                 | author      | price  | amount |
 +-----------------------+-------------+--------+--------+
 | Стихотворения и поэмы | Есенин С.А. | 650.00 | 15     |
 +-----------------------+-------------+--------+--------+


 # Выбрать названия и количества тех книг, количество которых от 5 до 14 включительно.

 # Тоже самое                           # Тоже самое
 SELECT title, amount                   SELECT title, amount
 FROM book                              FROM book
 WHERE amount BETWEEN 5 AND 14;         WHERE amount >= 5 AND amount <=14;

 +---------------+--------+
 | title         | amount |
 +---------------+--------+
 | Белая гвардия | 5      |
 | Идиот         | 10     |
 +---------------+--------+


 # Вывести название и авторов тех книг, цены которых принадлежат интервалу от 540.50 до 800 (включая границы),
 а количество или 2, или 3, или 5, или 7 .

 # BETWEEN в диапазоне аналог range включая его границы
 select title, author from book
     where price between 540.50 and 800 and amount in (2, 3, 5, 7)

  # IN и BETWEEN выполняются раньше and, поэтому скобки писать не обязательно
 select title, author from book
    where price (between 540.50 and 800) and (amount in (2, 3, 5, 7));

 +--------------------+------------------+
 | title              | author           |
 +--------------------+------------------+
 | Мастер и Маргарита | Булгаков М.А.    |
 | Белая гвардия      | Булгаков М.А.    |
 | Братья Карамазовы  | Достоевский Ф.М. |
 +--------------------+------------------+


 # Вывести  автора и название  книг, количество которых принадлежит интервалу от 2 до 14 (включая границы). Информацию
 отсортировать сначала по авторам (в обратном алфавитном порядке), а затем по названиям книг (по алфавиту).

 # ASC - (по возрастанию),  DESC - (по убыванию)
 select author, title from book
    where amount between 2 and 14
    ORDER BY author DESC, title asc;

 +------------------+--------------------+
 | author           | title              |
 +------------------+--------------------+
 | Достоевский Ф.М. | Братья Карамазовы  |
 | Достоевский Ф.М. | Идиот              |
 | Булгаков М.А.    | Белая гвардия      |
 | Булгаков М.А.    | Мастер и Маргарита |
 +------------------+--------------------+
________________________________________________________________________________________________________________________


 # Исходная таблица
 +---------+-----------------------+------------------+--------+--------+
 | book_id | title                 | author           | price  | amount |
 +---------+-----------------------+------------------+--------+--------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
 | 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
 | 6       |                       | Иванов С.С.      | 50.00  | 10     |
 | 7       | Дети полуночи         | Рушди Салман     | 950.00 | 5      |
 | 8       | Лирика                | Гумилев Н.С.     | 460.00 | 10     |
 | 9       | Поэмы                 | Бехтерев С.С.    | 460.00 | 10     |
 | 10      | Капитанская дочка     | Пушкин А.С.      | 520.50 | 7      |
 +---------+-----------------------+------------------+--------+--------+


 # Вывести название и автора тех книг, название которых состоит из двух и более слов, а инициалы автора содержат букву
 «С». Считать, что в названии слова отделяются друг от друга пробелами и не содержат знаков препинания, между фамилией
 автора и инициалами обязателен пробел, инициалы записываются без пробела в формате: буква, точка, буква, точка.
 Информацию отсортировать по названию книги в алфавитном порядке.

 LIKE 'a%'     Находит любые значения, которые начинаются с "a"
 LIKE '%a'     Находит любые значения, которые заканчиваются на "a"
 LIKE '%or%'   Находит любые значения, которые имеют "or" в любой позиции
 LIKE '_r%'    Находит любые значения, имеющие букву "r" во второй позиции
 LIKE 'a__%'   Находит любые значения, начинающиеся с буквы "a" и имеющие длину не менее 3 символов
 LIKE 'a%o'    Находит любые значения, которые начинаются с "a" и заканчиваются "о"


 select title, author from book
   WHERE title like '% %' and title not like ' %' and (author like '%______ С___' or author like '%______ __С_')
   # Тоже самое но с REGEXP
   WHERE title REGEXP '(.+ .+)+' and  author REGEXP '(.+ С.А.)|(.+ А.С.)'


 # _ В like значит 1 любой символ

 +-----------------------+-------------+
 | title                 | author      |
 +-----------------------+-------------+
 | Капитанская дочка     | Пушкин А.С. |
 | Стихотворения и поэмы | Есенин С.А. |
 +-----------------------+-------------+
________________________________________________________________________________________________________________________


 # Исходная таблица
 +---------+-----------------------+------------------+--------+--------+
 | book_id | title                 | author           | price  | amount |
 +---------+-----------------------+------------------+--------+--------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 3      |
 | 5       | Игрок                 | Достоевский Ф.М. | 480.50 | 10     |
 | 6       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
 +---------+-----------------------+------------------+--------+--------+


 # Выбор уникальных элементов столбца  DISTINCT                                                                 <-----
 На самом деле это тяжёлая операция - группировка и сортировку в себя включает, на маленьких объёмах это незаметно,
 а вот на больших его лучше не использовать

 # Отобрать различные (уникальные) элементы столбца amount таблицы book.

 select distinct amount from book
 select distinct(amount) from book   # Обернуть в скобки тоже можно

 +--------+
 | amount |
 +--------+
 | 3      |
 | 5      |
 | 10     |
 | 15     |
 +--------+


 # Тоже самое но установить LIMIT

 select distinct amount from book
 limit 1

 +--------+
 | amount |
 +--------+
 | 3      |
 +--------+


 # Выборка данных, групповые функции SUM и COUNT   в GROUP BY попадает столбец без функции
 Важно! В разделе GROUP BY нужно перечислять все НЕАГРЕГИРОВАННЫЕ столбцы (к которым не применяются групповые функции) из SELECT.

 SELECT author, sum(amount), count(amount)
 FROM book
 GROUP BY author;

 +------------------+-------------+---------------+
 | author           | sum(amount) | count(amount) |
 +------------------+-------------+---------------+
 | Булгаков М.А.    | 8           | 2             |
 | Достоевский Ф.М. | 23          | 3             |
 | Есенин С.А.      | 15          | 1             |
 +------------------+-------------+---------------+


 select author as Автор, count(author) as Различных_книг, sum(amount) as Количество_экземпляров from book
     GROUP BY Автор

 +------------------+----------------+------------------------+
 | Автор            | Различных_книг | Количество_экземпляров |
 +------------------+----------------+------------------------+
 | Булгаков М.А.    | 2              | 8                      |
 | Достоевский Ф.М. | 3              | 23                     |
 | Есенин С.А.      | 1              | 15                     |
 +------------------+----------------+------------------------+


 # посчитать уникальные наименования
 SELECT
     author,
     COUNT(DISTINCT title)
 FROM book
 GROUP BY author;

 +------------------+-----------------------+
 | author           | COUNT(DISTINCT title) |
 +------------------+-----------------------+
 | Булгаков М.А.    | 2                     |
 | Достоевский Ф.М. | 3                     |
 | Есенин С.А.      | 1                     |
 +------------------+-----------------------+


 # Выборка данных, групповые функции MIN, MAX и AVG

 SELECT author, MIN(price) AS Минимальная_цена, MAX(price) AS Максимальная_цена, AVG(price) AS Средняя_цена
 FROM book
 GROUP BY author;

 +------------------+------------------+-------------------+--------------+
 | author           | Минимальная_цена | Максимальная_цена | Средняя_цена |
 +------------------+------------------+-------------------+--------------+
 | Булгаков М.А.    | 540.50           | 670.99            | 605.745000   |
 | Достоевский Ф.М. | 460.00           | 799.01            | 579.836667   |
 | Есенин С.А.      | 650.00           | 650.00            | 650.000000   |
 +------------------+------------------+-------------------+--------------+


 # Выборка данных c вычислением, групповые функции
 SELECT MIN(price) AS Минимальная_цена, MAX(price) AS Максимальная_цена, ROUND(AVG(price), 2) AS Средняя_цена
 FROM book

 +------------------+-------------------+--------------+
 | Минимальная_цена | Максимальная_цена | Средняя_цена |
 +------------------+-------------------+--------------+
 | 460.00           | 799.01            | 600.17       |
 +------------------+-------------------+--------------+


 # Вычислить среднюю цену и суммарную стоимость тех книг, количество экземпляров которых принадлежит интервалу
 от 5 до 14, включительно. Столбцы назвать Средняя_цена и Стоимость, значения округлить до 2-х знаков после запятой.

 SELECT
     ROUND(AVG(price), 2) as Средняя_цена,
     ROUND(SUM(price * amount), 2) as Стоимость     # Внимание на запятую она тут не нужна
 FROM book
 where amount BETWEEN 5 AND 14

 +--------------+-----------+
 | Средняя_цена | Стоимость |
 +--------------+-----------+
 | 493.67       | 12107.50  |
 +--------------+-----------+


 # Пример
 SELECT author,
     MIN(price) AS Минимальная_цена,
     MAX(price) AS Максимальная_цена               # Внимание на запятую она тут не нужна
 FROM book
 GROUP BY author
 HAVING SUM(price * amount) > 5000;

 +------------------+------------------+-------------------+
 | author           | Минимальная_цена | Максимальная_цена |
 +------------------+------------------+-------------------+
 | Достоевский Ф.М. | 460.00           | 799.01            |
 | Есенин С.А.      | 650.00           | 650.00            |
 +------------------+------------------+-------------------+


 # Посчитать стоимость всех экземпляров каждого автора без учета книг «Идиот» и «Белая гвардия».
 В результат включить только тех авторов, у которых суммарная стоимость книг (без учета книг «Идиот» и «Белая гвардия»)
 более 5000 руб. Вычисляемый столбец назвать Стоимость. Результат отсортировать по убыванию стоимости.

 <>  то же самое что и !=

 # Тоже самое                                              # Тоже самое
 SELECT author,                                            SELECT author,
     SUM(price*amount) AS Стоимость                            SUM(price*amount) AS Стоимость
 FROM book                                                 FROM book
 WHERE title != 'Идиот' and title != 'Белая гвардия'       WHERE title <> 'Идиот' and title <> 'Белая гвардия'
 GROUP BY author                                           GROUP BY author
 HAVING SUM(price*amount) > 5000                           HAVING Стоимость > 5000
 order by Стоимость desc                                   order by Стоимость desc

 # Тоже самое Но лучше конечно not in
 select author, sum(price*amount) as Стоимость
 from book
 where title not in ('Идиот', 'Белая гвардия')
 group by author
 having Стоимость > 5000
 order by Стоимость desc

 +------------------+-----------+
 | author           | Стоимость |
 +------------------+-----------+
 | Есенин С.А.      | 9750.00   |
 | Достоевский Ф.М. | 7202.03   |
 +------------------+-----------+


 # Вложенный запрос, возвращающий одно значение

 SELECT title, author, price, amount
 FROM book
 WHERE price = (
          SELECT MIN(price)
          FROM book
       );                                               # ; Означает конец выражения

 +-------+------------------+--------+--------+
 | title | author           | price  | amount |
 +-------+------------------+--------+--------+
 | Идиот | Достоевский Ф.М. | 460.00 | 10     |
 +-------+------------------+--------+--------+


 # Вывести информацию (автора, название и цену) о  книгах, цены которых меньше или равны средней цене книг на складе.
 Информацию вывести в отсортированном по убыванию цены виде. Среднее вычислить как среднее по цене книги.

 SELECT author, title, price
 FROM book
 WHERE price <= (
          SELECT avg(price)
          FROM book
       )
 order by price desc

 +------------------+---------------+--------+
 | author           | title         | price  |
 +------------------+---------------+--------+
 | Булгаков М.А.    | Белая гвардия | 540.50 |
 | Достоевский Ф.М. | Игрок         | 480.50 |
 | Достоевский Ф.М. | Идиот         | 460.00 |
 +------------------+---------------+--------+


 # Использование вложенного запроса в выражении

 # То есть нужно вывести и те книги, количество экземпляров которых меньше среднего на 3, или больше среднего на 3.
 SELECT title, author, amount
 FROM book
 WHERE ABS(amount - (SELECT AVG(amount) FROM book)) > 3;

 +-----------------------+------------------+--------+
 | title                 | author           | amount |
 +-----------------------+------------------+--------+
 | Мастер и Маргарита    | Булгаков М.А.    | 3      |
 | Братья Карамазовы     | Достоевский Ф.М. | 3      |
 | Стихотворения и поэмы | Есенин С.А.      | 15     |
 +-----------------------+------------------+--------+


 # Вывести информацию (автора, название и цену) о тех книгах, цены которых превышают минимальную цену книги на складе
 не более чем на 150 рублей в отсортированном по возрастанию цены виде.

 SELECT author, title, price
 FROM book
 WHERE (price - (SELECT min(price) FROM book)) <= 150
 order by price

 +------------------+----------------+--------+
 | author           | title          | price  |
 +------------------+----------------+--------+
 | Достоевский Ф.М. | Идиот          | 460.00 |
 | Достоевский Ф.М. | Игрок          | 480.50 |
 | Булгаков М.А.    | Белая гвардия  | 540.50 |
 | Пушкин А.С.      | Евгений Онегин | 610.00 |
 +------------------+----------------+--------+


 # Вывести информацию (автора, книгу и количество) о тех книгах, количество экземпляров которых в таблице book не дублируется.
 SELECT author, title, amount
 FROM book
 WHERE amount NOT IN (
         SELECT amount
         FROM book
         GROUP BY amount
         HAVING COUNT(amount) != 1
       )

 +---------------+-----------------------+--------+
 | author        | title                 | amount |
 +---------------+-----------------------+--------+
 | Булгаков М.А. | Белая гвардия         | 5      |
 | Есенин С.А.   | Стихотворения и поэмы | 15     |
 +---------------+-----------------------+--------+


 # Вложенный запрос, операторы ANY и ALL

 SELECT title, author, amount, price
 FROM book
 WHERE amount < ALL (
         SELECT AVG(amount)
         FROM book
         GROUP BY author
       );

 +--------------------+------------------+--------+--------+
 | title              | author           | amount | price  |
 +--------------------+------------------+--------+--------+
 | Мастер и Маргарита | Булгаков М.А.    | 3      | 670.99 |
 | Братья Карамазовы  | Достоевский Ф.М. | 3      | 799.01 |
 +--------------------+------------------+--------+--------+
________________________________________________________________________________________________________________________

 # Таблица book
 +---------+-----------------------+------------------+--------+--------+
 | book_id | title                 | author           | price  | amount |
 +---------+-----------------------+------------------+--------+--------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
 | 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
 +---------+-----------------------+------------------+--------+--------+

  # Таблица supply
 +-----------+----------------+------------------+--------+--------+
 | supply_id | title          | author           | price  | amount |
 +-----------+----------------+------------------+--------+--------+
 | 1         | Лирика         | Пастернак Б.Л.   | 518.99 | 2      |
 | 2         | Черный человек | Есенин С.А.      | 570.20 | 6      |
 | 3         | Белая гвардия  | Булгаков М.А.    | 540.50 | 7      |
 | 4         | Идиот          | Достоевский Ф.М. | 360.80 | 3      |
 +-----------+----------------+------------------+--------+--------+

 # Занести из таблицы supply в таблицу book только те книги, авторов которых нет в  book.


 INSERT INTO book (title, author, price, amount)
 SELECT title, author, price, amount
 FROM supply
 WHERE author NOT IN (SELECT DISTINCT author
         FROM book);

 SELECT * FROM book;

 +---------+-----------------------+------------------+--------+--------+
 | book_id | title                 | author           | price  | amount |
 +---------+-----------------------+------------------+--------+--------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
 | 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
 | 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
 +---------+-----------------------+------------------+--------+--------+


 # Обновить Таблицу Заменить значения одного столбца
 UPDATE book
 SET amount = 19;

 select * from book

 +---------+-----------------------+------------------+--------+--------+
 | book_id | title                 | author           | price  | amount |
 +---------+-----------------------+------------------+--------+--------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 19     |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 19     |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 19     |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 19     |
 | 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 19     |
 +---------+-----------------------+------------------+--------+--------+


 # Добавить КОЛОНКУ в запросе SQL   ALTER - Может много чего
 ALTER TABLE book
 ADD Address VARCHAR(50) NOT NULL DEFAULT 'Неизвестно';

 SELECT * FROM book;

 +---------+-----------------------+------------------+--------+--------+------------+
 | book_id | title                 | author           | price  | amount | Address    |
 +---------+-----------------------+------------------+--------+--------+------------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      | Неизвестно |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      | Неизвестно |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     | Неизвестно |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      | Неизвестно |
 | 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     | Неизвестно |
 +---------+-----------------------+------------------+--------+--------+------------+


 # Обновить Таблицу
 UPDATE fine tv
 SET tv.sum_fine = (
     SELECT v.sum_fine
     FROM traffic_violation v
     WHERE v.violation = tv.violation
 )
 WHERE tv.sum_fine IS NULL;



 С помощью выражения ON DELETE можно установить действия, которые выполняются для записей подчиненной таблицы
 при удалении связанной строки из главной таблицы. При удалении можно установить следующие опции:

 - CASCADE: автоматически удаляет строки из зависимой таблицы при удалении  связанных строк в главной таблице.
 - SET NULL: при удалении  связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL.
 (В этом случае столбец внешнего ключа должен поддерживать установку NULL).
 - SET DEFAULT похоже на SET NULL за тем исключением, что значение  внешнего ключа устанавливается не в NULL,
 а в значение по умолчанию для данного столбца.
 - RESTRICT: отклоняет удаление строк в главной таблице при наличии связанных строк в зависимой таблице.

 Важно! Если для столбца установлена опция SET NULL, то при его описании нельзя задать ограничение на пустое значение.

 # Создание таблицы с внешними ключами  FOREIGN KEY
 CREATE TABLE book (
     book_id INT PRIMARY KEY AUTO_INCREMENT,
     title VARCHAR(50),
     author_id INT NOT NULL,
     genre_id INT,
     price DECIMAL(8,2),
     amount INT,
     FOREIGN KEY (author_id)  REFERENCES author (author_id) ON DELETE CASCADE,
     FOREIGN KEY (genre_id) REFERENCES genre (genre_id) ON DELETE SET NULL
     );





 --- JOINS ---
 В pandas это - pandas.DataFrame.join   pandas.DataFrame.merge

 <join_type> ::=
    [ { INNER | { { LEFT | RIGHT | FULL } [ OUTER ] } } [ <join_hint> ] ]       # [] - НЕобязательное
    JOIN

 Ключевое слово OUTER отмечено как необязательное (заключено в квадратные скобки). В этом конкретном случае OUTER
 не имеет значения, указываете вы его или нет. Обратите внимание, что хотя другие элементы предложения join также
 отмечены как необязательные, их исключение будет иметь значение.

 Например, вся часть type в JOIN предложении является необязательной, в этом случае по умолчанию будет, INNER
 если вы просто укажете JOIN. Другими словами, это допустимо:

 SELECT *
 FROM A JOIN B ON A.X = B.Y

 Вот список эквивалентных синтаксисов:
 A LEFT JOIN B            A LEFT OUTER JOIN B
 A RIGHT JOIN B           A RIGHT OUTER JOIN B
 A FULL JOIN B            A FULL OUTER JOIN B
 A INNER JOIN B           A JOIN B


 На верхнем уровне в основном существуют 3 типа соединений:

 1.INNER JOIN извлекает данные, если они присутствуют в обеих таблицах.

 2.OUTER JOINs бывают 3 типов:
    1.LEFT OUTER JOIN  - извлекает данные, если они присутствуют в левой таблице.
    2.RIGHT OUTER JOIN - извлекает данные, если они присутствуют в нужной таблице.
    3.FULL OUTER JOIN  - извлекает данные, если они присутствуют в любой из двух таблиц.
 3. CROSS JOIN, как следует из названия, делает n раз m пар, которые соединяют все со всем. Это похоже на то, как мы
 просто перечисляем таблицы для соединения (в предложении FROM оператора SELECT), используя запятые для их разделения.

 Следует отметить следующее:
 - Если вы просто упомянули JOIN, то по умолчанию это INNER JOIN.
 - Соединение OUTER должно быть LEFT| RIGHT| FULL; вы не можете просто сказать OUTER JOIN.
 - Вы можете опустить OUTER ключевое слово и просто сказать LEFT JOIN или RIGHT JOIN или FULL JOIN.  <-----



  --- Pandas vs SQL ---

 -- INNER JOIN --

 SELECT *                     # Pandas
 FROM df1                     pd.merge(df1, df2, on="key")
 INNER JOIN df2
   ON df1.key = df2.key;


 merge() также предлагает параметры для случаев, когда вы хотите объединить столбец одного DataFrame с индексом другого DataFrame.
 indexed_df2 = df2.set_index("key")
 pd.merge(df1, indexed_df2, left_on="key", right_index=True)


 -- LEFT OUTER JOIN --

 SELECT *                      # Pandas
 FROM df1                      pd.merge(df1, df2, on="key", how="left")
 LEFT OUTER JOIN df2
   ON df1.key = df2.key;


 -- RIGHT JOIN --

 SELECT *                      # Pandas
 FROM df1                      pd.merge(df1, df2, on="key", how="right")
 RIGHT OUTER JOIN df2
   ON df1.key = df2.key;


 -- FULL JOIN --

 SELECT *                       # Pandas
 FROM df1                       pd.merge(df1, df2, on="key", how="outer")
 FULL OUTER JOIN df2
   ON df1.key = df2.key;





 # Соединение INNER JOIN  можно использовать просто JOIN   разницы никакой!!!
 Оператор внутреннего соединения INNER JOIN соединяет две таблицы. Порядок таблиц для оператора неважен,
 поскольку оператор является симметричным.


 # Исходные таблицы
 Таблица genre:
 +----------+-------------+
 | genre_id | name_genre  |
 +----------+-------------+
 | 1        | Роман       |
 | 2        | Поэзия      |
 | 3        | Приключения |
 +----------+-------------+

 Таблица author:
 +-----------+------------------+
 | author_id | name_author      |
 +-----------+------------------+
 | 1         | Булгаков М.А.    |
 | 2         | Достоевский Ф.М. |
 | 3         | Есенин С.А.      |
 | 4         | Пастернак Б.Л.   |
 | 5         | Лермонтов М.Ю.   |
 +-----------+------------------+

 Таблица book:
 +---------+-----------------------+-----------+----------+--------+--------+
 | book_id | title                 | author_id | genre_id | price  | amount |
 +---------+-----------------------+-----------+----------+--------+--------+
 | 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
 | 2       | Белая гвардия         | 1         | 1        | 540.50 | 5      |
 | 3       | Идиот                 | 2         | 1        | 460.00 | 10     |
 | 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
 | 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
 | 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
 | 7       | Черный человек        | 3         | 2        | 570.20 | 6      |
 | 8       | Лирика                | 4         | 2        | 518.99 | 2      |
 +---------+-----------------------+-----------+----------+--------+--------+

 # Вывести название, жанр и цену тех книг, количество которых больше 8, в отсортированном по убыванию цены виде.


 SELECT title, name_genre, price             SELECT title, name_genre, price
 FROM genre INNER JOIN book                  FROM genre g JOIN book b
      ON genre.genre_id = book.genre_id      ON g.genre_id = b.genre_id AND b.amount > 8
 WHERE amount > 8                            ORDER BY price DESC;
 ORDER BY price DESC;


 # Можно использовать  USING    book.genre_id = genre.genre_id на USING(genre_id) - записи эквивалентны

 SELECT title, name_genre, price from book
 JOIN genre USING(genre_id)
 WHERE amount > 8
 ORDER BY price DESC;

 # Моё решение
 select title, name_genre, price from book
 join genre on book.genre_id = genre.genre_id
 where amount > 8
 order by price desc



 # Внешнее соединение LEFT и RIGHT OUTER JOIN
 Оператор внешнего соединения LEFT OUTER JOIN  (можно использовать LEFT JOIN) соединяет две таблицы.
 Порядок таблиц для оператора важен, поскольку оператор не является симметричным.


 # Вывести все жанры, которые не представлены в книгах на складе.

 SELECT DISTINCT name_genre
 FROM genre LEFT JOIN book
      on genre.genre_id = book.genre_id
 WHERE title is NUll;


 # Вывести (жанр, книга, автор), относящихся к жанру, включающему слово «роман» в отсортированном по названиям книг виде.

 select name_genre, title, name_author from book      select name_genre, title, name_author from book
 JOIN genre ON book.genre_id = genre.genre_id         JOIN genre ON book.genre_id = genre.genre_id
 JOIN author ON book.author_id = author.author_id     JOIN author ON book.author_id = author.author_id
 where name_genre like '%Роман%'                      WHERE book.genre_id=1
 order by title                                       order by title


 # Лучше решения!!!
                                               # LIKE регистроНЕзависимый, всю эту конструкцию можно заменить одним WHERE LIKE '%роман%'
 SELECT name_genre, title, name_author         SELECT name_genre, title, name_author
  FROM genre g                                 FROM genre g
       INNER JOIN book b                           INNER JOIN book b ON g.genre_id=b.genre_id
       ON g.genre_id = b.genre_id                  INNER JOIN author a ON a.author_id=b.author_id
          AND g.name_genre LIKE '%_оман%'      WHERE LOWER(name_genre) RLIKE '[[:<:]]роман[[:>:]]'
       INNER JOIN author USING(author_id)      ORDER BY title
 ORDER BY title;



 # Выберите из таблицы game_events только те события, которые произошли 15 января 2021 года или позднее.
 # В выводе получите только один столбец - уникальные названия этих событий.

 select distinct event_name from game_events
 where event_date >= '2021-01-15'


 # *Агрегирующие функции (иногда их ещё называют агрегатными) обрабатывают набор строк для подсчета и возвращают одно
 # обобщенное значение: SUM, MAX, MIN, COUNT, AVG

 COUNT(*) —  подсчитывает  все записи, относящиеся к группе, в том числе и со значением NULL;
 COUNT(имя_столбца) — возвращает количество записей конкретного столбца (только NOT NULL), относящихся к группе.

 # Такой запрос всегда вернет только одно значение – количество строк в таблице, которая указана во FROM.

 SELECT COUNT(*)
 FROM game_events


 # как посчитать количество уникальных пользователей за каждый день.

 SELECT event_date, COUNT(DISTINCT user_id)
 FROM game_events
 GROUP BY event_date


 # Найти дату первого и последнего игрового события для каждого игрока.

 select user_id, min(event_date), max(event_date) from game_events
 group by user_id









 # Пример!!!
 # Исходная таблица
 +---------+-----------------------+------------------+--------+--------+
 | book_id | title                 | author           | price  | amount |
 +---------+-----------------------+------------------+--------+--------+
 | 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
 | 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
 | 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
 | 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 3      |
 | 5       | Игрок                 | Достоевский Ф.М. | 480.50 | 10     |
 | 6       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
 +---------+-----------------------+------------------+--------+--------+

 # В GROUP BY можно использовать без функций
 SELECT author
 FROM book
 GROUP BY author;

 +------------------+
 | author           |
 +------------------+
 | Булгаков М.А.    |
 | Достоевский Ф.М. |
 | Есенин С.А.      |
 +------------------+


 # Разные способы !!!                                       # Тоже самое В GROUP BY можно использовать все столбцы
 SELECT author, title, count(price), max(amount) as maxx    SELECT author, title, count(price), max(amount) as maxx
 FROM book                                                  FROM book
 GROUP BY author, title;                                    GROUP BY author, title, price, amount;

 +------------------+-----------------------+--------------+------+
 | author           | title                 | count(price) | maxx |
 +------------------+-----------------------+--------------+------+
 | Булгаков М.А.    | Мастер и Маргарита    | 1            | 3    |
 | Булгаков М.А.    | Белая гвардия         | 1            | 5    |
 | Достоевский Ф.М. | Идиот                 | 1            | 10   |
 | Достоевский Ф.М. | Братья Карамазовы     | 1            | 3    |
 | Достоевский Ф.М. | Игрок                 | 1            | 10   |
 | Есенин С.А.      | Стихотворения и поэмы | 1            | 15   |
 +------------------+-----------------------+--------------+------+


 # Вернуть чётное число в таблице или нет!     PostgreSQL 13.0
 SELECT number,
 CASE WHEN (number % 2) = 0 THEN 'Even'
 ELSE 'Odd' END AS is_even
 FROM numbers;

 # Выбор всех студентов у которых tuition_received==False      # В SQL так же работает оператор not как и в Python
 select * from students
 where not tuition_received















































































































































































































































































































































































"""